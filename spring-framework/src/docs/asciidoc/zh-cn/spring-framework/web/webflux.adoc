[[webflux]]
= Spring WebFlux
:doc-spring-security: {doc-root}/spring-security/site/docs/current/reference

Spring 框架中包含的原始 Web 框架 Spring Web MVC 是专门为 Servlet API 和 Servlet 容器而构建的。 reactive-stack Web 框架 Spring WebFlux 在更高版本5.0中添加。
它是完全非阻塞的，支持 https://www.reactive-streams.org/[Reactive Streams] 背压，并在 Netty，Undertow 和 Servlet 3.1+ 容器等服务器上运行。

这两个 Web 框架的模块(https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc[spring-webmvc] 和
https://github.com/spring-projects/spring-framework/tree/master/spring-webflux[spring-webflux])，都在 Spring Framework 中。 每个模块都是可选的。
两种框架可以任选一个，也可以并存使用。例如，带有响应式 `WebClient` 的 Spring MVC 控制器。


[[webflux-new-framework]]
== 概述

为什么创建Spring WebFlux?

部分原因是我们需要使用较少的线程和硬件资源来处理高并发非阻塞I/O请求。 Servlet 3.1 确实提供了用于非阻塞 I/O 的 API。但是，使用它会导致 Servlet API 的其余部分偏离，在这些 API 中，(`Filter`, `Servlet`) 是同步的 ，(`getParameter`,
`getPart`) 是阻塞的。这是促使新的通用API成为所有非阻塞运行时的基础的动机，更重要的原因是一些服务框架 比如Netty 已经完美实现了异步和non-blocking服务开发方式。

另一个原因是函数式编程。除了在Java5 提供的注解编程外（例如带注解的 REST 控制器或单元测试），Java 8 提供 lambda 函数编程 API。这对于非阻塞的应用程序和延续样式的 API（如由 `CompletableFuture` 和 http://reactivex.io/[ReactiveX] 流行的API）是有利的，
这些 API 允许以声明方式构成异步逻辑。在编程模型级别，Java 8 使 Spring WebFlux 能够与带注解的控制器一起提供功能性的 Web 端点。


[[webflux-why-reactive]]
=== 定义 "`Reactive`"

我们谈到了 "`non-blocking`" 和 "`functional`" ，但是 reactive 意味着什么？

术语  "`reactive,`"  是基于事件响应的编程模型，事件包括 网络I/O事件、页面的鼠标点击事件等等。也就是说非阻塞编程就是Reactive，因为相对阻塞式编程而言，非阻塞编程以响应事件的通知为主，这些事件通知包括系统操作的状态变化和数据的状态变化。

我们 Spring 研发组考虑到一个非常重要的机制，那就是在non-blocking情况下的限流控制（又称 背压）问题。在同步调用情况下，阻塞调用是背压的自然形式，迫使调用者等待。在非阻塞代码中，去控制响应事件的速率就变得非常重要，这样快速的生产者就不会淹没其目的地。

Reactive Streams 是一个 https://github.com/reactive-streams/reactive-streams-jvm/blob/master/README.md#specification[small spec]（在Java 9 中也 https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html[adopted]），
它定义了带有响应式的异步组件之间的交互。例如，数据存储库（充当 https://www.reactive-streams.org/reactive-streams-1.0.1-javadoc/org/reactivestreams/Publisher.html[Publisher]）可以生成 HTTP 服务器（充当 https://www.reactive-streams.org/reactive-streams-1.0.1-javadoc/org/reactivestreams/Subscriber.html[Subscriber]）然后可以写入响应的数据。响应式流的主要目的是让订阅者控制发布者生成数据的速度或速度。

NOTE: *常见问题: 如果 publisher 太快怎么办?* +
Reactive Streams 的目的仅仅是建立机制和边界.
如果 publisher 无法放慢速度，那就让它 buffer缓存，丢弃消息 甚至失败。

[[webflux-reactive-api]]
=== Reactive API

Reactive Streams 对于交互设计中扮演着一个非常重要的角色。但是由于它太底层了，对于编写应用层API没有太大作用。编写一个应用需要更高级的，功能更丰富，且具有函数编程特性的API。这与 Java 8 Stream API 相似，但不仅适用于集合。这就是 reactive 库的作用。

https://github.com/reactor/reactor[Reactor] 是 Spring WebFlux 的首选 reactive 库。它提供了 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[`Mono`] 和 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[`Flux`] API 类型，
`ReactiveX` http://reactivex.io/documentation/operators.html[vocabulary of operators] 提供了非常丰富的操作API 来处理 0..1 (`Mono`) 和 0..N (`Flux`)  的数据序列。 Reactor 是 Reactive Streams 库，因此，它的所有运算符都支持无阻塞背压。 Reactor 非常注重服务器端 Java。它是与 Spring 紧密合作开发的。

WebFlux 需要 Reactor 作为核心依赖，同时又可以与其他符合 Reactive Streams 规范的代码库结合使用。通常，WebFlux API 接受普通的 Publisher 作为输入，在内部将其适应于 Reactor 类型，使用它，然后返回 Flux 或 Mono 作为输出。
因此，您可以将任何 `Publisher` 作为输入传递，并且可以对输出应用操作，但是您需要调整输出以与其他 reactive 库一起使用。只要可行（例如，带注解的控制器），WebFlux 就会透明地适应 RxJava 或其他反应式库的使用。有关更多详细信息，请参见 <<webflux-reactive-libraries>> 。

NOTE: 除了 Reactive API 外，WebFlux 还可以与 Kotlin 中的 <<languages.adoc#coroutines, Coroutines>> API 一起使用，从而提供了更强的编程风格。

[[webflux-programming-models]]
=== 编程模型

`spring-web` 模块包含 Spring WebFlux reactive 基础，包括 HTTP 抽象，用于支持的服务器的 Reactive Streams <<webflux-httphandler, adapters>>，<<webflux-codecs, codecs>>，以及与 Servlet API 相似但具有非阻塞的核心 <<webflux-web-handler-api>> 。

在此基础上，Spring WebFlux 提供了两种编程模型的选择：

* <<webflux-controller>>: 与 Spring MVC 一致，并且使用和 `spring-web` 模块的相同注解。 Spring MVC 和 WebFlux 控制器都支持 响应式（Reactor 和 RxJava）返回类型，因此，区分它们并不容易。
一个显着的区别是 WebFlux 还支持响应式 `@RequestBody` 参数。
* <<webflux-fn>>: 基于 Lambda 的轻量级功能编程模型。 你可将函数式编程看做是一个小的代码库，或者是可以路由和处理请求的一组应用套件。这与基于注解的编程最大的区别是应用程序从头到尾负责请求处理，而不通过注解来声明调用方法。

[[webflux-framework-choice]]
=== 适用性

Spring MVC 或 WebFlux?

这是个很平常的问题，但却还是有歧义的。实际上，两者可以相互辅助来解决更大范围的问题。 两者的设计旨在实现彼此的连续性和一致性，你可以同时使用两个框架的功能，每个框架来处理自己擅长的问题，这对双方都是有益的。下图展示了两者之间的关系，并列出了两者共同点和差异。

image::images/spring-mvc-and-webflux-venn.png[]

我们建议您考虑以下几点：

* 如果您有运行正常的 Spring MVC 应用程序，则无需更改。 命令式编程是编写，理解和调试代码的最简单方法。因为从历史上看，大多数代码库都是阻塞的，你可以选择更多的库，结合到现有的框架中。
* 如果你已经有一个非阻塞的 web 技术栈，那么你可以考虑使用 Spring WebFlux 作为替代方案，它可以提供同样的功能，同时 Spring WebFlux 提供了多种服务端容器支持（Netty，Tomcat，Jetty，Undertow 和 Servlet 3.1+容器），注解和函数式编程，以及与其他 Reactor 代码库的集成（Reactor, RxJava 等等）
* 如果您对与 Java 8 lambda 或 Kotlin 提供的轻量级函数式编程比较感兴趣，你可以考虑使用 Spring WebFlux 。也可以使用 Spring WebFlux 作为 web 服务的站点。 对于要求较低复杂性的较小应用程序或微服务（可以受益于更高的透明度和控制）而言，这也是一个不错的选择。
* 在微服务架构中，您可以混合使用带有 Spring MVC 或 Spring WebFlux 控制器或带有 Spring WebFlux 功能端点的应用程序。 在两个框架中都支持相同的基于注释的编程模型，这使得重用知识变得更加容易，同时还为正确的工作选择了正确的工具。
* 评估应用程序技术上扩展性的一个简单方法是检查它的依赖那些组件，如果您要使用阻塞性 api (JPA、JDBC)或网络api，那么 Spring MVC 至少是系统架构上的最佳选择。从技术上讲，同时在单独的线程上使用 Reactor 和 RxJava 是可行的，但是你无法最大的利用非阻塞技术栈的优点。
* 如果你已经有了一个 Spring MVC 应用程序，同时又需要远程调用其他的服务，这时可以尝试事件响应式客户端 `WebClient`。 通过 `WebClient` , 您可以直接从 Spring MVC 控制器方法返回响应式返回结果（Reactor，RxJava 或 <<webflux-reactive-libraries, or other>>）。 并且每次远程调用的延迟或调用之间的相互依赖性越大，得到的好处就越大。 Spring MVC控制器也可以通过WebClient调用其他支持事件响应的功能组件。
* 如果您有庞大的团队，还要用Spring WebFlux技术栈，就必须要权衡陡峭的学习曲线和收益了。一个切实可行的方式就是使用Spring WebFlux部分技术栈 比如WebClient，除此外，可以从小的地方着手使用Spring WebFlux。我们认为对于绝大部分的应用程序，转变到基于事件响应式编程是不必要的。如果你还不确定使用响应式编程有哪些好处，可以首先了解下非阻塞 I/O 的工作原理及其效果（例如，单线程 Node.js 的并发性）。

[[webflux-server-choice]]
=== Servers

Tomcat，Jetty，Servlet 3.1+ 容器以及无服务器运行时（例如 Netty 和 Undertow）都支持 Spring WebFlux。 所有服务器都适应于底层 <<webflux-httphandler, 公共的 API>>，因此可以跨服务器支持更高级别的<<webflux-programming-models, programming models>>。

Spring WebFlux 并没有提供内嵌的停止或者启动的服务的功能组件。 但是，从 Spring 配置和 <<webflux-config, WebFlux 基础结构>> <<webflux-web-handler-api, assemble>> 应用程序并用几行代码 <<webflux-httphandler, run it>>它很容易。

Spring Boot 具有一个 WebFlux starter 组件，可以自动执行这些步骤。默认使用 Netty，但是通过更改 Maven 或 Gradle 依赖，可以轻松切换到 Tomcat，Jetty 或 Undertow。 Spring Boot 默认为 Netty，因为它更广泛地用于异步和非阻塞编程，同时并允许客户端和服务器共享接入层代码。

Tomcat 和 Jetty 可以与 Spring MVC 和 WebFlux 一起使用。 但是请记住，它们的使用方式非常不同。 Spring MVC 依靠 Servlet 阻塞 I/O，并允许应用程序在需要时直接使用 Servlet API。 Spring WebFlux 依赖于 Servlet 3. 1非阻塞I/O，并在底层适配器后面使用 Servlet API，并且不公开供直接使用。

对于 Undertow，Spring WebFlux 直接使用 Undertow API，而无需使用 Servlet API。

[[webflux-performance]]
=== 性能

性能具有许多特征和意义。基于响应的非阻塞编程并不意味着应用程序一定会运行得更快，在某些情况下，他们是高性能的，例如，使用 `WebClient` 并行执行远程调用。总的来说，以非阻塞的方式实现应用需要更多的工作，并且有可能会稍微增加请求的处理时间。

响应式非阻塞编程的预期好处是能够使用少量固定数量的线程和更少的内存进行伸缩。这使得应用程序在高负载下以更可预测的方式进行伸缩。你需要在有一些延迟的情况下来观察它的好处，(包括慢速和不可预测的网络I/O混合)。这时响应式非阻塞编程会开始显示其优势，依照不通的情况，其最终结果的差异可能是巨大的。

[[webflux-concurrency-model]]
=== 并发模型

Spring MVC 和 Spring WebFlux 都支持带注释的控制器，但是在并发模型和阻塞线程的假定设置上，有一个关键的区别。

在 Spring MVC（通常是 servlet 应用程序）中，假定应用程序可以阻塞当前线程（例如，用于远程调用），因此servlet容器会使用一个大的线程池来应对请求处理过程中可能出现的阻塞问题。

在 Spring WebFlux（通常是非阻塞服务器）中，假定应用程序不阻塞，因此，非阻塞服务器使用一个小的、固定大小的线程池(event loop workers)来处理请求。

TIP: "`可扩展`" 和 "`少量线程`" 可能听起来是矛盾的，但是由于不会阻塞当前线程(而是依赖回调)意味着你不需要额外的线程来预防阻塞的情况出现。

.Invoking a Blocking API（阻塞式API）
如果确实需要使用阻塞怎么办？ Reactor 和 RxJava 都提供了 `publishOn` 操作函数来控制线程的执行。这意味着在这种编程模型上开了一个口子。但是要记住，阻塞 api 并不适合这种并发模型。

.Mutable State（可变状态）
在 Reactor 和 RxJava 中，您可以通过操作符声明逻辑，并且在运行时提供一个响应式管道，数据在管道中可以在不同的阶段按都顺序进行处理。这样做的一个好处是，它使应用程序不必关心数据状态的变化，因为管道中的应用程序代码永远不会被其他应用程序并发调用。

.Threading Model（线程模型）
您期望在运行 Spring WebFlux 的服务器上看到哪些线程？

* 在“普通的”Spring WebFlux服务器上(例如，没有数据访问，也没有其他可选的依赖项)，你可以设置一个线程用于服务器端接收请求，设置几个线程用于处理请求,通常处理请求的线程数与 CPU 内核的数量一样多。但是，Servlet 容器可以设置更多的线程(例如，Tomcat 上的 10 个线程)，以支持阻塞式 I/O 的 servlet 和非阻塞式 I/O 的 Servlet 3.1。
* 响应式的WebClient采用 `event-loop` 方式。因此，你可以看到与之相关的少量固定数量的处理线程(例如， Netty连接器中的 `reactor-http-nio`)。。 但是，如果客户端和服务器都使用 Reactor Netty，则默认情况下，这两个共享 `event-loop` 资源。
* Reactor 和 RxJava 都提供抽象线程池，称为调度器，以与 `publishOn`  运算符配合使用，该运算符用于将处理切换到其他线程池。
调度器都有一种特定的并发策略-例如， "`parallel`"（针对有限线程数量的cpu密集型程序）或  "`elastic`"（针对大量线程的 I/O 密集型程序）。 如果您看到这样的线程，这意味着某些代码正在使用特定的线程池调度器策略。
* 允许数据访问库和其他第三方依赖包也可以创建和使用它们自己的线程。

.配置
Spring框架不支持启动和停止 <<webflux-server-choice, servers>> 的支持。 要为服务端配置线程模型，需要使用特定于服务端的配置功能，如果使用 Spring Boot，请检查每个服务器的 Spring Boot 配置选项。 您可以直接 <<web-reactive.adoc#webflux-client-builder, configure>> `WebClient`。 对于所有其他库，请参阅其各自的文档。


[[webflux-reactive-spring-web]]
== Reactive Core

`spring-web` spring-web模块包含以下对响应式web应用程序的基本支持。

* 在服务端请求处理过程中，提供了两个层次的支持，
** <<webflux-httphandler, HttpHandler>>: 提供了用于非阻塞 I/O 和响应式流背压机制的处理机制。以及用于响应式 Netty、Undertow、Tomcat、Jetty 和任何 Servlet 3.1+ 容器的适配器。
** <<webflux-web-handler-api>>: 用于处理请求的高级通用web API，使用这个API可以构建具体的编程模型，如带注释的控制器和功能入口。
* 对于客户端，有一个基本的 `ClientHttpConnector` 来执行带有非阻塞 I/O 和响应式流背压机制的 HTTP 请求，以及用于https://github.com/reactor/reactor-netty[Reactor Netty] 和 https://github.com/jetty-project/jetty-reactive-httpclient[Jetty HttpClient] 的API。
在实际的应用开发过程中，我们使用的更高层级的  <<web-reactive.adoc#webflux-client, WebClient>> 就是构建在这个基本的 `ClientHttpConnector` 之上。
* 对于客户端和服务器， <<webflux-codecs, codecs>> 用于序列化和反序列化 HTTP 请求和响应内容。

[[webflux-httphandler]]
=== `HttpHandler`

{api-spring-framework}/http/server/reactive/HttpHandler.html[HttpHandler] 是一个简单的契约或者编程规范，它是被故意设计成最小化的,且只有一个方法来处理请求和响应。其主要的、也是唯一的目的是对不同的HTTP服务器 api 进行最小的抽象。

下表描述了它支持的服务器api:

[cols="1,2,2", options="header"]
|===
| Server name | Server API used | Reactive Streams support

| Netty
| Netty API
| https://github.com/reactor/reactor-netty[Reactor Netty]

| Undertow
| Undertow API
| spring-web: Undertow to Reactive Streams bridge

| Tomcat
| Servlet 3.1 non-blocking I/O; Tomcat API to read and write ByteBuffers vs byte[]
| spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge

| Jetty
| Servlet 3.1 non-blocking I/O; Jetty API to write ByteBuffers vs byte[]
| spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge

| Servlet 3.1 container
| Servlet 3.1 non-blocking I/O
| spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge
|===

下表描述了不同服务端容器的程序依赖 (也参见 https://github.com/spring-projects/spring-framework/wiki/What%27s-New-in-the-Spring-Framework[支持的版本]):

|===
|Server name|Group id|Artifact name

|Reactor Netty
|io.projectreactor.netty
|reactor-netty

|Undertow
|io.undertow
|undertow-core

|Tomcat
|org.apache.tomcat.embed
|tomcat-embed-core

|Jetty
|org.eclipse.jetty
|jetty-server, jetty-servlet
|===

下面的代码片段显示如何在不同的服务端容器中使用 `HttpHandler` 适配器

*Reactor Netty*
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	HttpHandler handler = ...
	ReactorHttpHandlerAdapter adapter = new ReactorHttpHandlerAdapter(handler);
	HttpServer.create().host(host).port(port).handle(adapter).bind().block();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val handler: HttpHandler = ...
	val adapter = ReactorHttpHandlerAdapter(handler)
	HttpServer.create().host(host).port(port).handle(adapter).bind().block()
----

*Undertow*
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	HttpHandler handler = ...
	UndertowHttpHandlerAdapter adapter = new UndertowHttpHandlerAdapter(handler);
	Undertow server = Undertow.builder().addHttpListener(port, host).setHandler(adapter).build();
	server.start();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val handler: HttpHandler = ...
	val adapter = UndertowHttpHandlerAdapter(handler)
	val server = Undertow.builder().addHttpListener(port, host).setHandler(adapter).build()
	server.start()
----

*Tomcat*
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	HttpHandler handler = ...
	Servlet servlet = new TomcatHttpHandlerAdapter(handler);

	Tomcat server = new Tomcat();
	File base = new File(System.getProperty("java.io.tmpdir"));
	Context rootContext = server.addContext("", base.getAbsolutePath());
	Tomcat.addServlet(rootContext, "main", servlet);
	rootContext.addServletMappingDecoded("/", "main");
	server.setHost(host);
	server.setPort(port);
	server.start();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val handler: HttpHandler = ...
	val servlet = TomcatHttpHandlerAdapter(handler)

	val server = Tomcat()
	val base = File(System.getProperty("java.io.tmpdir"))
	val rootContext = server.addContext("", base.absolutePath)
	Tomcat.addServlet(rootContext, "main", servlet)
	rootContext.addServletMappingDecoded("/", "main")
	server.host = host
	server.setPort(port)
	server.start()
----

*Jetty*

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	HttpHandler handler = ...
	Servlet servlet = new JettyHttpHandlerAdapter(handler);

	Server server = new Server();
	ServletContextHandler contextHandler = new ServletContextHandler(server, "");
	contextHandler.addServlet(new ServletHolder(servlet), "/");
	contextHandler.start();

	ServerConnector connector = new ServerConnector(server);
	connector.setHost(host);
	connector.setPort(port);
	server.addConnector(connector);
	server.start();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val handler: HttpHandler = ...
	val servlet = JettyHttpHandlerAdapter(handler)

	val server = Server()
	val contextHandler = ServletContextHandler(server, "")
	contextHandler.addServlet(ServletHolder(servlet), "/")
	contextHandler.start();

	val connector = ServerConnector(server)
	connector.host = host
	connector.port = port
	server.addConnector(connector)
	server.start()
----

*Servlet 3.1+ Container*

要将其作为 WAR 部署到任何 Servlet 3.1+ 容器中，您可以扩展 WAR 并将其包括在 {api-spring-framework}/web/server/adapter/AbstractReactiveWebInitializer.html[`AbstractReactiveWebInitializer`] 中。 该类使用 `ServletHttpHandlerAdapter` 包装 `HttpHandler` 并将其注册为 Servlet。

[[webflux-web-handler-api]]
=== `WebHandler` API

`org.springframework.web.server` 包建立在 <<webflux-httphandler>> 契约的基础上，为多个 {api-spring-framework}/web/server/WebExceptionHandler.html[`WebExceptionHandler`] ，
多个 {api-spring-framework}/web/server/WebFilter.html[`WebFilter`] ，和单个 {api-spring-framework}/web/server/WebHandler.html[`WebHandler`] 组件链等处理请求提供通用的 Web API。
通过简单地指向<<webflux-web-handler-api-special-beans, 自动检测>>组件的 Spring `ApplicationContext` 和/或 通过向构建器注册组件，可以将该链与 `WebHttpHandlerBuilder` 放在一起。

尽管 `HttpHandler` 的目标很简单，即抽象化不同 HTTP 服务器的使用，但 `WebHandler` API 的目的是提供 Web 应用程序中常用的更广泛的功能集，例如：

* User session with attributes.
* Request attributes.
* 解析请求中的 `Locale` 或 `Principal`.
* 访问已解析和缓存的表单数据。.
* multipart data 数据的抽象.
* 更多..

[[webflux-web-handler-api-special-beans]]
==== 特殊的 bean 类型

下表列出了 `WebHttpHandlerBuilder` 可以在 Spring `ApplicationContext` 中自动检测的组件，或可以直接向其注册的组件：

[cols="2,2,1,3", options="header"]
|===
| Bean name | Bean type | Count | Description

| <any>
| `WebExceptionHandler`
| 0..N
| Provide handling for exceptions from the chain of `WebFilter` instances and the target
  `WebHandler`. For more details, see <<webflux-exception-handler>>.

| <any>
| `WebFilter`
| 0..N
| Apply interception style logic to before and after the rest of the filter chain and
  the target `WebHandler`. For more details, see <<webflux-filters>>.

| `webHandler`
| `WebHandler`
| 1
| The handler for the request.

| `webSessionManager`
| `WebSessionManager`
| 0..1
| The manager for `WebSession` instances exposed through a method on `ServerWebExchange`.
  `DefaultWebSessionManager` by default.

| `serverCodecConfigurer`
| `ServerCodecConfigurer`
| 0..1
| For access to `HttpMessageReader` instances for parsing form data and multipart data that is then
  exposed through methods on `ServerWebExchange`. `ServerCodecConfigurer.create()` by default.

| `localeContextResolver`
| `LocaleContextResolver`
| 0..1
| The resolver for `LocaleContext` exposed through a method on `ServerWebExchange`.
  `AcceptHeaderLocaleContextResolver` by default.

| `forwardedHeaderTransformer`
| `ForwardedHeaderTransformer`
| 0..1
| For processing forwarded type headers, either by extracting and removing them or by removing them only.
  Not used by default.
|===


[[webflux-form-data]]
==== 表单数据

`ServerWebExchange` 使用以下方法访问表单数据:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	Mono<MultiValueMap<String, String>> getFormData();
----
[source,Kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	suspend fun getFormData(): MultiValueMap<String, String>
----

`DefaultServerWebExchange` 使用配置的 `HttpMessageReader` 将表单数据(`application/x-www-form-urlencoded`)解析为 `MultiValueMap`。 默认情况下，`FormHttpMessageReader` 配置为由 `ServerCodecConfigurer` Bean使用（请参阅 <<webflux-web-handler-api, Web Handler API>>）。

[[webflux-multipart]]
==== Multipart Data
[.small]#<<web.adoc#mvc-multipart, Web MVC>>#

`ServerWebExchange` 使用以下方法访问 multipart data:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	Mono<MultiValueMap<String, Part>> getMultipartData();
----
[source,Kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	suspend fun getMultipartData(): MultiValueMap<String, Part>
----

`DefaultServerWebExchange` 使用配置的 `HttpMessageReader<MultiValueMap<String, Part>>` 将 `multipart/form-data` 内容解析为 `MultiValueMap`. 现在,https://github.com/synchronoss/nio-multipart[Synchronoss NIO Multipart]
是唯一受支持的第三方库，并且是我们知道的用于非阻塞解析多部分请求的唯一库。 通过 `ServerCodecConfigurer` Bean启用它（请参阅 <<webflux-web-handler-api, Web Handler API>>）。

要以流方式解析多部分数据，可以使用从 `HttpMessageReader<Part>` 返回的  `Flux<Part>`。 例如，在带注释的控制器中，使用 `@RequestPart` 意味着按名称对各个部分进行类似于 Map 的访问，因此需要完全解析多部分数据。
相反，您可以使用 `@RequestBody` 将内容解码为  `Flux<Part>` 而不收集到 `MultiValueMap`。

[[webflux-forwarded-headers]]
==== Forwarded Headers
[.small]#<<web.adoc#filters-forwarded-headers, Web MVC>>#

当请求通过代理（例如负载均衡）进行处理时，主机，端口和 scheme 可能会更改，从客户端的角度来看，要创建指向正确的主机，端口和 scheme 的 url 是一个挑战。

https://tools.ietf.org/html/rfc7239[RFC 7239] 定义了 `Forwarded` HTTP header ,代理可以使用原始请求的信息。 还有其他非标准标头，包括`X-Forwarded-Host`, `X-Forwarded-Port`,
`X-Forwarded-Proto`, `X-Forwarded-Ssl`, 和 `X-Forwarded-Prefix`.

`ForwardedHeaderTransformer` 是一个组件，可根据转发的标头修改请求的主机，端口和 scheme，然后删除这些标头。 您可以将其声明为名称为 `forwardedHeaderTransformer` 的 Bean，并对其进行<<webflux-web-handler-api-special-beans, 检测>> 和使用。

对于转发的标头，存在安全方面的考虑，因为应用程序无法知道标头是由代理添加的，还是由恶意客户端添加的。 这就是为什么应配置信任边界处的代理以删除来自外部的不受信任的转发流量的原因。
您还可以使用 `removeOnly=true` 配置 `ForwardedHeaderTransformer`，在这种情况下，它将删除但不使用标头。

NOTE: 在5.1中，`ForwardedHeaderFilter` 被 `ForwardedHeaderTransformer` 弃用并取代，因此可以在创建交换之前更早地处理转发的标头。 如果仍然配置了过滤器，则将其从过滤器列表中删除，而改用 `ForwardedHeaderTransformer`。

[[webflux-filters]]
=== Filters
[.small]#<<web.adoc#filters, Web MVC>>#

在 <<webflux-web-handler-api>> 中，您可以使用 WebFilter 在其余的过滤器处理链和目标 `WebHandler` 之前和之后应用拦截器样式的逻辑。 使用  <<webflux-config>> 时，注册 WebFilter 就像将其声明为 Spring bean 一样简单，并且（可选）通过在bean声明上使用 `@Order` 或实现 `Ordered` 接口来表达优先级。

[[webflux-filters-cors]]
==== CORS
[.small]#<<web.adoc#filters-cors, Web MVC>>#

Spring WebFlux 通过控制器上的注释为 CORS 配置提供了细粒度的支持。 但是，当您将其与 Spring Security 结合使用时，我们建议您依赖内置的 `CorsFilter`，因为它必须在 Spring Security 的过滤器链之前。

有关更多详细信息，请参见  <<webflux-cors>> 和 <<webflux-cors.adoc#webflux-cors-webfilter>>  上的部分。

[[webflux-exception-handler]]
=== Exceptions
[.small]#<<web.adoc#mvc-ann-customer-servlet-container-error-page, Web MVC>>#

在 <<webflux-web-handler-api>> 中，可以使用 `WebExceptionHandler` 来处理 `WebFilter` 实例链和目标 `WebHandler` 链中的异常。 使用 <<webflux-config>>时，注册 `WebExceptionHandler` 就像将其声明为Spring bean一样简单，并且（可选）通过在bean声明上使用 `@Order` 或实现 `Ordered` 接口来表达优先级。

下表描述了可用的 `WebExceptionHandler` 实现：

[cols="1,2", options="header"]
|===
| Exception Handler | Description

| `ResponseStatusExceptionHandler`
| Provides handling for exceptions of type
  {api-spring-framework}/web/server/ResponseStatusException.html[`ResponseStatusException`]
  by setting the response to the HTTP status code of the exception.

| `WebFluxResponseStatusExceptionHandler`
| Extension of `ResponseStatusExceptionHandler` that can also determine the HTTP status
  code of a `@ResponseStatus` annotation on any exception.

  This handler is declared in the <<webflux-config>>.

|===



[[webflux-codecs]]
=== Codecs(编解码器)
[.small]#<<integration.adoc#rest-message-conversion, Web MVC>>#

`spring-web` 和 `spring-core` 模块支持通过具有 Reactive Streams 背压的非阻塞I/O，可以将字节内容与更高级别的对象之间的字节序列进行序列化和反序列化。 以下介绍了此支持：

* {api-spring-framework}/core/codec/Encoder.html[`Encoder`] 和
{api-spring-framework}/core/codec/Decoder.html[`Decoder`] 用于独立于HTTP编码和解码内容。
* {api-spring-framework}/http/codec/HttpMessageReader.html[`HttpMessageReader`] 和
{api-spring-framework}/http/codec/HttpMessageWriter.html[`HttpMessageWriter`] 是对HTTP消息内容进行编码和解码。
* 可以使用 `EncoderHttpMessageWriter` 包装 `Encoder` ，使它能在 Web 应用程序中使用。同样，可以使用 `DecoderHttpMessageReader` 来包装 `Decoder`。
* {api-spring-framework}/core/io/buffer/DataBuffer.html[`DataBuffer`] 抽象了不同的字节缓冲区表示形式 (例如 Netty `ByteBuf`, `java.nio.ByteBuffer`, 等.) 请参见 <<core#databuffers,Data Buffers and Codecs>> 部分中的数据缓冲区和编解码器。

`spring-core` 模块提供 `byte[]`, `ByteBuffer`, `DataBuffer`, `Resource` 和 `String` 编码器和解码器实现。 `spring-web` 模块提供了 Jackson JSON，Jackson Smile，JAXB2，Protocol Buffers 和其他编码器和解码器，
以及仅用于 Web 的 HTTP 消息读取器和写入器实现，用于表单数据，多部分内容，服务器发送事件等。

`ClientCodecConfigurer` 和 `ServerCodecConfigurer` 通常用于配置和自定义编解码器。 请参阅有关 <<webflux-config-message-codecs>> 的部分。

[[webflux-codecs-jackson]]
==== Jackson JSON

Jackson 支持 JSON 和二进制JSON(https://github.com/FasterXML/smile-format-specification[Smile]) 。

`Jackson2Decoder` 的工作方式如下：

* Jackson 以异步, 非阻塞的形式解析，将字节块流聚合到 `TokenBuffer` 的每个块中，每个代表 JSON 对象。
* 每个 `TokenBuffer` 都传递给 Jackson `ObjectMapper` 以创建更高级别的对象。
* 当解码为一个简单的 publisher (例如 `Mono`) 时, 有一个 `TokenBuffer`.
* 当解码为多个 publisher (例如 `Flux`), 一旦为完整格式的对象接收到足够的字节，每个 `TokenBuffer` 就会传递给 `ObjectMapper`。 输入内容可以是 JSON 数组，如果内容类型为 "application/stream+json"，也可以是 https://en.wikipedia.org/wiki/JSON_streaming[line-delimited JSON]。

`Jackson2Encoder` 的工作方式如下:

* 对于单个 publisher (例如 `Mono`), 只需通过 `ObjectMapper` 对其进行序列化即可。
* 对于具有 "application/json" 的多个 publisher, 默认情况下使用 `Flux#collectToList()` 将值收集起来，然后序列化结果集合。
* 对于具有流媒体类型 `application/stream+json` 或 `application/stream+x-jackson-smile` 的多个 publisher, 请使用 https://en.wikipedia.org/wiki/JSON_streaming[line-delimited JSON] 格式分别对每个值进行编码，写入和刷新。
* 对于SSE 将为每个事件调用 `Jackson2Encoder` 并刷新输出以确保交付没有延迟。

[NOTE]
====
默认情况下，`Jackson2Encoder` 和 `Jackson2Decoder` 都不支持 `String` 类型的元素。 相反，假设需要表示一个字符串或字符串序列，则由 `CharSequenceEncoder` 序列化 JSON 内容。
如果您需要从 `Flux<String>` 呈现JSON数组，请使用 `Flux#collectToList()` 并对 `Mono<List<String>>` 进行编码。
====

[[webflux-codecs-forms]]
==== 表单数据

`FormHttpMessageReader` 和 `FormHttpMessageWriter` 支持对 "application/x-www-form-urlencoded" 内容进行解码和编码。.

服务器端经常需要从多个位置访问表单内容，`ServerWebExchange` 提供了 `getFormData()` 方法，该方法通过 `FormHttpMessageReader` 解析内容，然后缓存结果以进行重复访问。 请参阅 <<webflux-web-handler-api>> 部分中的 <<webflux-form-data>> 。

一旦使用 `getFormData()`，就无法再从请求正文中读取原始内容。 因此，应用程序应始终通过 `ServerWebExchange` 来访问缓存的表单数据，而不是从原始请求正文中进行读取。

[[webflux-codecs-multipart]]
==== Multipart

`MultipartHttpMessageReader` 和 `MultipartHttpMessageWriter` 支持对 "multipart/form-data" 内容进行解码和编码。 反过来，`MultipartHttpMessageReader` 委托 `HttpMessageReader` 进行实际解析为 `Flux<Part>` 然后将这些内容简单地收集到 `MultiValueMap`.
目前，https://github.com/synchronoss/nio-multipart[Synchronoss NIO Multipart] 用于实际解析。

服务器端经常需要从多个位置访问表单内容，`ServerWebExchange` 提供了 `getMultipartData()` 方法，该方法通过 `MultipartHttpMessageReader` 解析内容，然后缓存结果以进行重复访问。 请参阅 <<webflux-web-handler-api>> 部分中的 <<webflux-multipart>>。

一旦使用 `getMultipartData()` ，就无法再从请求正文中读取原始原始内容。 因此，应用程序必须始终使用 `getMultipartData()` 来重复访问，否则必须依赖 `SynchronossPartHttpMessageReader` 来一次性访问 `Flux<Part>`

[[webflux-codecs-limits]]
==== 限制

可以通过 `Decoder` 和 `HttpMessageReader` 的实现来对 部分 buffer 或 全部的输入流进行配置，比如，可以限制内存中缓冲的最大字节数。在某些情况下，由于输入被汇总并表示为单个对象而发生缓冲，
例如，具有 `@RequestBody byte[]`,
`x-www-form-urlencoded` 数据的控制器方法，等等。 在分割输入流（例如，定界文本，JSON对象流等）时，流处理也会发生缓冲。 对于那些流情况，该限制适用于与流中一个对象关联的字节数。

要配置缓冲区大小，您可以检查给定的 `Decoder` 或 `HttpMessageReader` 是否暴露了 `maxInMemorySize` 属性，如果这样，则 Javadoc 将具有有关默认值的详细信息。 在 WebFlux 中，`ServerCodecConfigurer` 通过默认编码解码器的 `maxInMemorySize` 属性，
提供了一个设置所有编码解码器的 <<webflux-config-message-codecs,single place>>。 在客户端，可以在  <<web-reactive.adoc#webflux-client-builder-maxinmemorysize, WebClient.Builder>> 中更改限制。

对于 <<webflux-codecs-multipart,Multipart parsing>>，`maxInMemorySize` 属性限制了非文件部分的大小。 对于文件部件，它确定将部件写入磁盘的阈值。 对于写入磁盘的文件部件，还有一个额外的 `maxDiskUsagePerPart` 属性可限制每个部件的磁盘空间量。
还有一个maxParts属性，用于限制多部分请求中的部分总数。 要在 `WebFlux` 中配置所有3个，您需要向 `ServerCodecConfigurer` 提供一个预先配置的 `MultipartHttpMessageReader` 实例。

[[webflux-codecs-streaming]]
==== Streaming
[.small]#<<web.adoc#mvc-ann-async-http-streaming, Web MVC>>#

在流式传输到 HTTP 响应(例如 `text/event-stream`，`application/stream+json`) 时，定期发送数据很重要，这样才能尽快（而不是稍后）可靠地检测到断开连接的客户端。 这样的发送可以是仅注释的空 SSE 事件，也可以是有效用作心跳的任何其他“无操作”数据。

[[webflux-codecs-buffers]]
==== `DataBuffer`

`DataBuffer` 是 WebFlux 中字节缓冲区的表示形式。 该部分参考的 Spring Core 中 <<core#databuffers, Data Buffers and Codecs>> 部分。
要理解的关键点是，在诸如 Netty 之类的某些服务器上，字节缓冲区是池化的，并且对引用计数进行计数，并且在使用时必须将其释放，以避免内存泄漏。

WebFlux 应用程序通常不需要关心此类问题，除非它们直接使用或产生数据缓冲区，而不是依赖于编解码器与更高级别的对象之间进行转换，或者除非它们选择创建自定义编解码器。 对于这种情况，请查看<<core#databuffers, Data Buffers and Codecs>>中的信息，尤其是有关<<core#databuffers-using, Using DataBuffer>>的部分。

[[webflux-logging]]
=== Logging
[.small]#<<web.adoc#mvc-logging, Web MVC>>#

Spring WebFlux 中的 DEBUG 级别日志记录意图提供一个紧密的，最小化的并且对用户友好的。 它侧重于一遍又一遍有用的高价值信息，而其他信息则仅在调试特定问题时才有用。

TRACE 级别的日志记录通常遵循与 DEBUG 相同的原理（例如，也不应成为 firehose），但可用于调试任何问题。 另外，某些日志消息在 TRACE vs DEBUG 上可能显示不同级别的详细信息。

良好的日志记录来自使用日志的经验。 如果您发现任何不符合既定目标的东西，请告诉我们。

[[webflux-logging-id]]
==== Log Id

在 WebFlux中，单个请求可以在多个线程上执行，并且线程 ID 对于关联属于特定请求的日志消息没有用。 这就是为什么默认情况下 WebFlux 日志消息以特定于请求的ID为前缀的原因。

在服务器端，日志 ID 存储在 `ServerWebExchange` 属性 ({api-spring-framework}/web/server/ServerWebExchange.html#LOG_ID_ATTRIBUTE[`LOG_ID_ATTRIBUTE`]),中，而可从 `ServerWebExchange#getLogPrefix()` 获得基于该ID的全格式前缀。 在 WebClient 端，日志 ID 存储在 `ClientRequest` 属性 ({api-spring-framework}/web/reactive/function/client/ClientRequest.html#LOG_ID_ATTRIBUTE[`LOG_ID_ATTRIBUTE`]) 中，而完全格式的前缀可从 `ClientRequest#logPrefix()` 获得。

[[webflux-logging-sensitive-data]]
==== 敏感数据
[.small]#<<web.adoc#mvc-logging-sensitive-data, Web MVC>>#

`DEBUG` 和 `TRACE`  日志记录可以记录敏感信息。 这就是默认情况下屏蔽表单参数和标题的原因，并且必须显式启用它们的完整日志记录。

下面的示例说明如何针对服务器端请求执行此操作：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	class MyConfig implements WebFluxConfigurer {

		@Override
		public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
			configurer.defaultCodecs().enableLoggingRequestDetails(true);
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebFlux
	class MyConfig : WebFluxConfigurer {

		override fun configureHttpMessageCodecs(configurer: ServerCodecConfigurer) {
			configurer.defaultCodecs().enableLoggingRequestDetails(true)
		}
	}
----

下面的示例说明如何针对客户端请求执行此操作：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	Consumer<ClientCodecConfigurer> consumer = configurer ->
			configurer.defaultCodecs().enableLoggingRequestDetails(true);

	WebClient webClient = WebClient.builder()
			.exchangeStrategies(strategies -> strategies.codecs(consumer))
			.build();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val consumer: (ClientCodecConfigurer) -> Unit  = { configurer -> configurer.defaultCodecs().enableLoggingRequestDetails(true) }

	val webClient = WebClient.builder()
			.exchangeStrategies({ strategies -> strategies.codecs(consumer) })
			.build()
----

[[webflux-codecs-custom]]
==== Custom codecs

应用程序可以注册自定义编解码器以支持其他媒体类型，也可以注册默认编解码器不支持的特定行为。

开发人员表达的某些配置选项在默认编解码器上强制执行。 自定义编解码器可能希望有机会与这些首选项保持一致，例如 <<webflux-codecs-limits, 强制执行缓冲限制>>或<<webflux-logging-sensitive-data, 记录敏感数据>>。

下面的示例说明如何针对客户端请求执行此操作：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	WebClient webClient = WebClient.builder()
			.codecs(configurer -> {
					CustomDecoder decoder = new CustomDecoder();
                    configurer.customCodecs().registerWithDefaultConfig(decoder);
			})
			.build();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val webClient = WebClient.builder()
			.codecs({ configurer ->
					val decoder = CustomDecoder()
            		configurer.customCodecs().registerWithDefaultConfig(decoder)
			 })
			.build()
----

[[webflux-dispatcher-handler]]
== `DispatcherHandler`
[.small]#<<web.adoc#mvc-servlet, Web MVC>>#

Spring WebFlux, similarly to Spring MVC, is designed around the front controller pattern,
where a central `WebHandler`, the `DispatcherHandler`, provides a shared algorithm for
request processing, while actual work is performed by configurable, delegate components.
This model is flexible and supports diverse workflows.

`DispatcherHandler` discovers the delegate components it needs from Spring configuration.
It is also designed to be a Spring bean itself and implements `ApplicationContextAware`
for access to the context in which it runs. If `DispatcherHandler` is declared with a bean
name of `webHandler`, it is, in turn, discovered by
{api-spring-framework}/web/server/adapter/WebHttpHandlerBuilder.html[`WebHttpHandlerBuilder`],
which puts together a request-processing chain, as described in <<webflux-web-handler-api>>.

Spring configuration in a WebFlux application typically contains:

* `DispatcherHandler` with the bean name, `webHandler`
* `WebFilter` and `WebExceptionHandler` beans
* <<webflux-special-bean-types,`DispatcherHandler` special beans>>
* Others

The configuration is given to `WebHttpHandlerBuilder` to build the processing chain,
as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	ApplicationContext context = ...
	HttpHandler handler = WebHttpHandlerBuilder.applicationContext(context).build();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val context: ApplicationContext = ...
	val handler = WebHttpHandlerBuilder.applicationContext(context).build()
----

The resulting `HttpHandler` is ready for use with a <<webflux-httphandler, server adapter>>.



[[webflux-special-bean-types]]
=== Special Bean Types
[.small]#<<web.adoc#mvc-servlet-special-bean-types, Web MVC>>#

The `DispatcherHandler` delegates to special beans to process requests and render the
appropriate responses. By "`special beans,`" we mean Spring-managed `Object` instances that
implement WebFlux framework contracts. Those usually come with built-in contracts, but
you can customize their properties, extend them, or replace them.

The following table lists the special beans detected by the `DispatcherHandler`. Note that
there are also some other beans detected at a lower level (see
<<webflux-web-handler-api-special-beans>> in the Web Handler API).

[[webflux-special-beans-table]]
[cols="1,2", options="header"]
|===
| Bean type | Explanation

| `HandlerMapping`
| Map a request to a handler. The mapping is based on some criteria, the details of
  which vary by `HandlerMapping` implementation -- annotated controllers, simple
  URL pattern mappings, and others.

  The main `HandlerMapping` implementations are `RequestMappingHandlerMapping` for
  `@RequestMapping` annotated methods, `RouterFunctionMapping` for functional endpoint
  routes, and `SimpleUrlHandlerMapping` for explicit registrations of URI path patterns
  and `WebHandler` instances.

| `HandlerAdapter`
| Help the `DispatcherHandler` to invoke a handler mapped to a request regardless of
  how the handler is actually invoked. For example, invoking an annotated controller
  requires resolving annotations. The main purpose of a `HandlerAdapter` is to shield the
  `DispatcherHandler` from such details.

| `HandlerResultHandler`
| Process the result from the handler invocation and finalize the response.
  See <<webflux-resulthandling>>.

|===



[[webflux-framework-config]]
=== WebFlux Config
[.small]#<<web.adoc#mvc-servlet-config, Web MVC>>#

Applications can declare the infrastructure beans (listed under
<<webflux-web-handler-api-special-beans, Web Handler API>> and
<<webflux-special-bean-types, `DispatcherHandler`>>) that are required to process requests.
However, in most cases, the <<webflux-config>> is the best starting point. It declares the
required beans and provides a higher-level configuration callback API to customize it.

NOTE: Spring Boot relies on the WebFlux config to configure Spring WebFlux and also provides
many extra convenient options.



[[webflux-dispatcher-handler-sequence]]
=== Processing
[.small]#<<web.adoc#mvc-servlet-sequence, Web MVC>>#

`DispatcherHandler` processes requests as follows:

* Each `HandlerMapping` is asked to find a matching handler, and the first match is used.
* If a handler is found, it is executed through an appropriate `HandlerAdapter`, which
exposes the return value from the execution as `HandlerResult`.
* The `HandlerResult` is given to an appropriate `HandlerResultHandler` to complete
processing by writing to the response directly or by using a view to render.



[[webflux-resulthandling]]
=== Result Handling

The return value from the invocation of a handler, through a `HandlerAdapter`, is wrapped
as a `HandlerResult`, along with some additional context, and passed to the first
`HandlerResultHandler` that claims support for it. The following table shows the available
`HandlerResultHandler` implementations, all of which are declared in the <<webflux-config>>:

[cols="1,2,1", options="header"]
|===
| Result Handler Type | Return Values | Default Order

| `ResponseEntityResultHandler`
| `ResponseEntity`, typically from `@Controller` instances.
| 0

| `ServerResponseResultHandler`
| `ServerResponse`, typically from functional endpoints.
| 0

| `ResponseBodyResultHandler`
| Handle return values from `@ResponseBody` methods or `@RestController` classes.
| 100

| `ViewResolutionResultHandler`
| `CharSequence`, {api-spring-framework}/web/reactive/result/view/View.html[`View`],
  {api-spring-framework}/ui/Model.html[Model], `Map`,
  {api-spring-framework}/web/reactive/result/view/Rendering.html[Rendering],
  or any other `Object` is treated as a model attribute.

  See also <<webflux-viewresolution>>.
| `Integer.MAX_VALUE`

|===



[[webflux-dispatcher-exceptions]]
=== Exceptions
[.small]#<<web.adoc#mvc-exceptionhandlers, Web MVC>>#

The `HandlerResult` returned from a `HandlerAdapter` can expose a function for error
handling based on some handler-specific mechanism. This error function is called if:

* The handler (for example, `@Controller`) invocation fails.
* The handling of the handler return value through a `HandlerResultHandler` fails.

The error function can change the response (for example, to an error status), as long as an error
signal occurs before the reactive type returned from the handler produces any data items.

This is how `@ExceptionHandler` methods in `@Controller` classes are supported.
By contrast, support for the same in Spring MVC is built on a `HandlerExceptionResolver`.
This generally should not matter. However, keep in mind that, in WebFlux, you cannot use a
`@ControllerAdvice` to handle exceptions that occur before a handler is chosen.

See also <<webflux-ann-controller-exceptions>> in the "`Annotated Controller`" section or
<<webflux-exception-handler>> in the WebHandler API section.



[[webflux-viewresolution]]
=== View Resolution
[.small]#<<web.adoc#mvc-viewresolver, Web MVC>>#

View resolution enables rendering to a browser with an HTML template and a model without
tying you to a specific view technology. In Spring WebFlux, view resolution is
supported through a dedicated <<webflux-resulthandling, HandlerResultHandler>> that uses
  `ViewResolver` instances to map a String (representing a logical view name) to a `View`
instance. The `View` is then used to render the response.


[[webflux-viewresolution-handling]]
==== Handling
[.small]#<<web.adoc#mvc-handling, Web MVC>>#

The `HandlerResult` passed into `ViewResolutionResultHandler` contains the return value
from the handler and the model that contains attributes added during request
handling. The return value is processed as one of the following:

* `String`, `CharSequence`: A logical view name to be resolved to a `View` through
the list of configured `ViewResolver` implementations.
* `void`: Select a default view name based on the request path, minus the leading and
trailing slash, and resolve it to a `View`. The same also happens when a view name
was not provided (for example, model attribute was returned) or an async return value
(for example, `Mono` completed empty).
* {api-spring-framework}/web/reactive/result/view/Rendering.html[Rendering]: API for
view resolution scenarios. Explore the options in your IDE with code completion.
* `Model`, `Map`: Extra model attributes to be added to the model for the request.
* Any other: Any other return value (except for simple types, as determined by
{api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty])
is treated as a model attribute to be added to the model. The attribute name is derived
from the class name by using {api-spring-framework}/core/Conventions.html[conventions],
unless a handler method `@ModelAttribute` annotation is present.

The model can contain asynchronous, reactive types (for example, from Reactor or RxJava). Prior
to rendering, `AbstractView` resolves such model attributes into concrete values
and updates the model. Single-value reactive types are resolved to a single
value or no value (if empty), while multi-value reactive types (for example, `Flux<T>`) are
collected and resolved to `List<T>`.

To configure view resolution is as simple as adding a `ViewResolutionResultHandler` bean
to your Spring configuration. <<webflux-config-view-resolvers, WebFlux Config>> provides a
dedicated configuration API for view resolution.

See <<webflux-view>> for more on the view technologies integrated with Spring WebFlux.


[[webflux-redirecting-redirect-prefix]]
==== Redirecting
[.small]#<<web.adoc#mvc-redirecting-redirect-prefix, Web MVC>>#

The special `redirect:` prefix in a view name lets you perform a redirect. The
`UrlBasedViewResolver` (and sub-classes) recognize this as an instruction that a
redirect is needed. The rest of the view name is the redirect URL.

The net effect is the same as if the controller had returned a `RedirectView` or
`Rendering.redirectTo("abc").build()`, but now the controller itself can
operate in terms of logical view names. A view name such as
`redirect:/some/resource` is relative to the current application, while a view name such as
`redirect:https://example.com/arbitrary/path` redirects to an absolute URL.


[[webflux-multiple-representations]]
==== Content Negotiation
[.small]#<<web.adoc#mvc-multiple-representations, Web MVC>>#

`ViewResolutionResultHandler` supports content negotiation. It compares the request
media types with the media types supported by each selected `View`. The first `View`
that supports the requested media type(s) is used.

In order to support media types such as JSON and XML, Spring WebFlux provides
`HttpMessageWriterView`, which is a special `View` that renders through an
<<webflux-codecs, HttpMessageWriter>>. Typically, you would configure these as default
views through the <<webflux-config-view-resolvers, WebFlux Configuration>>. Default views are
always selected and used if they match the requested media type.




[[webflux-controller]]
== Annotated Controllers
[.small]#<<web.adoc#mvc-controller, Web MVC>>#

Spring WebFlux provides an annotation-based programming model, where `@Controller` and
`@RestController` components use annotations to express request mappings, request input,
handle exceptions, and more. Annotated controllers have flexible method signatures and
do not have to extend base classes nor implement specific interfaces.

The following listing shows a basic example:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RestController
	public class HelloController {

		@GetMapping("/hello")
		public String handle() {
			return "Hello WebFlux";
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RestController
	class HelloController {

		@GetMapping("/hello")
		fun handle() = "Hello WebFlux"
	}
----

In the preceding example, the method returns a `String` to be written to the response body.



[[webflux-ann-controller]]
=== `@Controller`
[.small]#<<web.adoc#mvc-ann-controller, Web MVC>>#

You can define controller beans by using a standard Spring bean definition.
The `@Controller` stereotype allows for auto-detection and is aligned with Spring general support
for detecting `@Component` classes in the classpath and auto-registering bean definitions
for them. It also acts as a stereotype for the annotated class, indicating its role as
a web component.

To enable auto-detection of such `@Controller` beans, you can add component scanning to
your Java configuration, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@ComponentScan("org.example.web") // <1>
	public class WebConfig {

		// ...
	}
----
<1> Scan the `org.example.web` package.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@ComponentScan("org.example.web") // <1>
	class WebConfig {

		// ...
	}
----
<1> Scan the `org.example.web` package.

`@RestController` is a <<core.adoc#beans-meta-annotations, composed annotation>> that is
itself meta-annotated with `@Controller` and `@ResponseBody`, indicating a controller whose
every method inherits the type-level `@ResponseBody` annotation and, therefore, writes
directly to the response body versus view resolution and rendering with an HTML template.



[[webflux-ann-requestmapping]]
=== Request Mapping
[.small]#<<web.adoc#mvc-ann-requestmapping, Web MVC>>#

The `@RequestMapping` annotation is used to map requests to controllers methods. It has
various attributes to match by URL, HTTP method, request parameters, headers, and media
types. You can use it at the class level to express shared mappings or at the method level
to narrow down to a specific endpoint mapping.

There are also HTTP method specific shortcut variants of `@RequestMapping`:

* `@GetMapping`
* `@PostMapping`
* `@PutMapping`
* `@DeleteMapping`
* `@PatchMapping`

The preceding annotations are <<webflux-ann-requestmapping-composed>> that are provided
because, arguably, most controller methods should be mapped to a specific HTTP method versus
using `@RequestMapping`, which, by default, matches to all HTTP methods. At the same time, a
`@RequestMapping` is still needed at the class level to express shared mappings.

The following example uses type and method level mappings:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RestController
	@RequestMapping("/persons")
	class PersonController {

		@GetMapping("/{id}")
		public Person getPerson(@PathVariable Long id) {
			// ...
		}

		@PostMapping
		@ResponseStatus(HttpStatus.CREATED)
		public void add(@RequestBody Person person) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RestController
	@RequestMapping("/persons")
	class PersonController {

		@GetMapping("/{id}")
		fun getPerson(@PathVariable id: Long): Person {
			// ...
		}

		@PostMapping
		@ResponseStatus(HttpStatus.CREATED)
		fun add(@RequestBody person: Person) {
			// ...
		}
	}
----


[[webflux-ann-requestmapping-uri-templates]]
==== URI Patterns
[.small]#<<web.adoc#mvc-ann-requestmapping-uri-templates, Web MVC>>#

You can map requests by using glob patterns and wildcards:

* `?` matches one character
* `*` matches zero or more characters within a path segment
* `**` match zero or more path segments

You can also declare URI variables and access their values with `@PathVariable`,
as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/owners/{ownerId}/pets/{petId}")
	public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/owners/{ownerId}/pets/{petId}")
	fun findPet(@PathVariable ownerId: Long, @PathVariable petId: Long): Pet {
		// ...
	}
----

You can declare URI variables at the class and method levels, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	@RequestMapping("/owners/{ownerId}") // <1>
	public class OwnerController {

		@GetMapping("/pets/{petId}") // <2>
		public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
			// ...
		}
	}
----
<1> Class-level URI mapping.
<2> Method-level URI mapping.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	@RequestMapping("/owners/{ownerId}") // <1>
	class OwnerController {

		@GetMapping("/pets/{petId}") // <2>
		fun findPet(@PathVariable ownerId: Long, @PathVariable petId: Long): Pet {
			// ...
		}
	}
----
<1> Class-level URI mapping.
<2> Method-level URI mapping.


URI variables are automatically converted to the appropriate type or a `TypeMismatchException`
is raised. Simple types (`int`, `long`, `Date`, and so on) are supported by default and you can
register support for any other data type.
See <<webflux-ann-typeconversion>> and <<webflux-ann-initbinder>>.

URI variables can be named explicitly (for example, `@PathVariable("customId")`), but you can
leave that detail out if the names are the same and you compile your code with debugging
information or with the `-parameters` compiler flag on Java 8.

The syntax `{*varName}` declares a URI variable that matches zero or more remaining
path segments. For example `/resources/{*path}` matches all files `/resources/` and the
`"path"` variable captures the complete relative path.

The syntax `{varName:regex}` declares a URI variable with a regular expression that has the
syntax: `{varName:regex}`. For example, given a URL of `/spring-web-3.0.5 .jar`, the following method
extracts the name, version, and file extension:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}")
	public void handle(@PathVariable String version, @PathVariable String ext) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}")
	fun handle(@PathVariable version: String, @PathVariable ext: String) {
		// ...
	}
----

URI path patterns can also have embedded `${...}` placeholders that are resolved on startup
through `PropertyPlaceHolderConfigurer` against local, system, environment, and other property
sources. You ca use this to, for example, parameterize a base URL based on some external
configuration.

NOTE: Spring WebFlux uses `PathPattern` and the `PathPatternParser` for URI path matching support.
Both classes are located in `spring-web` and are expressly designed for use with HTTP URL
paths in web applications where a large number of URI path patterns are matched at runtime.

Spring WebFlux does not support suffix pattern matching -- unlike Spring MVC, where a
mapping such as `/person` also matches to `/person.{asterisk}`. For URL-based content
negotiation, if needed, we recommend using a query parameter, which is simpler, more
explicit, and less vulnerable to URL path based exploits.


[[webflux-ann-requestmapping-pattern-comparison]]
==== Pattern Comparison
[.small]#<<web.adoc#mvc-ann-requestmapping-pattern-comparison, Web MVC>>#

When multiple patterns match a URL, they must be compared to find the best match. This is done
with `PathPattern.SPECIFICITY_COMPARATOR`, which looks for patterns that are more specific.

For every pattern, a score is computed, based on the number of URI variables and wildcards,
where a URI variable scores lower than a wildcard. A pattern with a lower total score
wins. If two patterns have the same score, the longer is chosen.

Catch-all patterns (for example, `**`, `{*varName}`) are excluded from the scoring and are always
sorted last instead. If two patterns are both catch-all, the longer is chosen.


[[webflux-ann-requestmapping-consumes]]
==== Consumable Media Types
[.small]#<<web.adoc#mvc-ann-requestmapping-consumes, Web MVC>>#

You can narrow the request mapping based on the `Content-Type` of the request,
as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping(path = "/pets", consumes = "application/json")
	public void addPet(@RequestBody Pet pet) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/pets", consumes = ["application/json"])
	fun addPet(@RequestBody pet: Pet) {
		// ...
	}
----

The consumes attribute also supports negation expressions -- for example, `!text/plain` means any
content type other than `text/plain`.

You can declare a shared `consumes` attribute at the class level. Unlike most other request
mapping attributes, however, when used at the class level, a method-level `consumes` attribute
overrides rather than extends the class-level declaration.

TIP: `MediaType` provides constants for commonly used media types -- for example,
`APPLICATION_JSON_VALUE` and `APPLICATION_XML_VALUE`.


[[webflux-ann-requestmapping-produces]]
==== Producible Media Types
[.small]#<<web.adoc#mvc-ann-requestmapping-produces, Web MVC>>#

You can narrow the request mapping based on the `Accept` request header and the list of
content types that a controller method produces, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping(path = "/pets/{petId}", produces = "application/json")
	@ResponseBody
	public Pet getPet(@PathVariable String petId) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/pets/{petId}", produces = ["application/json"])
	@ResponseBody
	fun getPet(@PathVariable String petId): Pet {
		// ...
	}
----

The media type can specify a character set. Negated expressions are supported -- for example,
`!text/plain` means any content type other than `text/plain`.

You can declare a shared `produces` attribute at the class level. Unlike most other request
mapping attributes, however, when used at the class level, a method-level `produces` attribute
overrides rather than extend the class level declaration.

TIP: `MediaType` provides constants for commonly used media types -- e.g.
`APPLICATION_JSON_VALUE`, `APPLICATION_XML_VALUE`.


[[webflux-ann-requestmapping-params-and-headers]]
==== Parameters and Headers
[.small]#<<web.adoc#mvc-ann-requestmapping-params-and-headers, Web MVC>>#

You can narrow request mappings based on query parameter conditions. You can test for the
presence of a query parameter (`myParam`), for its absence (`!myParam`), or for a
specific value (`myParam=myValue`). The following examples tests for a parameter with a value:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping(path = "/pets/{petId}", params = "myParam=myValue") // <1>
	public void findPet(@PathVariable String petId) {
		// ...
	}
----
<1> Check that `myParam` equals `myValue`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/pets/{petId}", params = ["myParam=myValue"]) // <1>
	fun findPet(@PathVariable petId: String) {
		// ...
	}
----
<1> Check that `myParam` equals `myValue`.

You can also use the same with request header conditions, as the follwing example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping(path = "/pets", headers = "myHeader=myValue") // <1>
	public void findPet(@PathVariable String petId) {
		// ...
	}
----
<1> Check that `myHeader` equals `myValue`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/pets", headers = ["myHeader=myValue"]) // <1>
	fun findPet(@PathVariable petId: String) {
		// ...
	}
----
<1> Check that `myHeader` equals `myValue`.



[[webflux-ann-requestmapping-head-options]]
==== HTTP HEAD, OPTIONS
[.small]#<<web.adoc#mvc-ann-requestmapping-head-options, Web MVC>>#

`@GetMapping` and `@RequestMapping(method=HttpMethod.GET)` support HTTP HEAD
transparently for request mapping purposes. Controller methods need not change.
A response wrapper, applied in the `HttpHandler` server adapter, ensures a `Content-Length`
header is set to the number of bytes written without actually writing to the response.

By default, HTTP OPTIONS is handled by setting the `Allow` response header to the list of HTTP
methods listed in all `@RequestMapping` methods with matching URL patterns.

For a `@RequestMapping` without HTTP method declarations, the `Allow` header is set to
`GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS`. Controller methods should always declare the
supported HTTP methods (for example, by using the HTTP method specific variants --
`@GetMapping`, `@PostMapping`, and others).

You can explicitly map a `@RequestMapping` method to HTTP HEAD and HTTP OPTIONS, but that
is not necessary in the common case.


[[webflux-ann-requestmapping-composed]]
==== Custom Annotations
[.small]#<<web.adoc#mvc-ann-requestmapping-composed, Web MVC>>#

Spring WebFlux supports the use of <<core.adoc#beans-meta-annotations, composed annotations>>
for request mapping. Those are annotations that are themselves meta-annotated with
`@RequestMapping` and composed to redeclare a subset (or all) of the `@RequestMapping`
attributes with a narrower, more specific purpose.

`@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping`, and `@PatchMapping` are
examples of composed annotations. They are provided, because, arguably, most
controller methods should be mapped to a specific HTTP method versus using `@RequestMapping`,
which, by default, matches to all HTTP methods. If you need an example of composed
annotations, look at how those are declared.

Spring WebFlux also supports custom request mapping attributes with custom request matching
logic. This is a more advanced option that requires sub-classing
`RequestMappingHandlerMapping` and overriding the `getCustomMethodCondition` method, where
you can check the custom attribute and return your own `RequestCondition`.


[[webflux-ann-requestmapping-registration]]
==== Explicit Registrations
[.small]#<<web.adoc#mvc-ann-requestmapping-registration, Web MVC>>#

You can programmatically register Handler methods, which can be used for dynamic
registrations or for advanced cases, such as different instances of the same handler
under different URLs. The following example shows how to do so:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class MyConfig {

		@Autowired
		public void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler) // <1>
				throws NoSuchMethodException {

			RequestMappingInfo info = RequestMappingInfo
					.paths("/user/{id}").methods(RequestMethod.GET).build(); // <2>

			Method method = UserHandler.class.getMethod("getUser", Long.class); // <3>

			mapping.registerMapping(info, handler, method); // <4>
		}

	}
----
<1> Inject target handlers and the handler mapping for controllers.
<2> Prepare the request mapping metadata.
<3> Get the handler method.
<4> Add the registration.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class MyConfig {

		@Autowired
		fun setHandlerMapping(mapping: RequestMappingHandlerMapping, handler: UserHandler) { // <1>

			val info = RequestMappingInfo.paths("/user/{id}").methods(RequestMethod.GET).build() // <2>

			val method = UserHandler::class.java.getMethod("getUser", Long::class.java) // <3>

			mapping.registerMapping(info, handler, method) // <4>
		}
	}
----
<1> Inject target handlers and the handler mapping for controllers.
<2> Prepare the request mapping metadata.
<3> Get the handler method.
<4> Add the registration.



[[webflux-ann-methods]]
=== Handler Methods
[.small]#<<web.adoc#mvc-ann-methods, Web MVC>>#

`@RequestMapping` handler methods have a flexible signature and can choose from a range of
supported controller method arguments and return values.


[[webflux-ann-arguments]]
==== Method Arguments
[.small]#<<web.adoc#mvc-ann-arguments, Web MVC>>#

The following table shows the supported controller method arguments.

Reactive types (Reactor, RxJava, <<webflux-reactive-libraries, or other>>) are
supported on arguments that require blocking I/O (for example, reading the request body) to
be resolved. This is marked in the Description column. Reactive types are not expected
on arguments that do not require blocking.

JDK 1.8's `java.util.Optional` is supported as a method argument in combination with
annotations that have a `required` attribute (for example, `@RequestParam`, `@RequestHeader`,
and others) and is equivalent to `required=false`.

[cols="1,2", options="header"]
|===
| Controller method argument | Description

| `ServerWebExchange`
| Access to the full `ServerWebExchange` -- container for the HTTP request and response,
  request and session attributes, `checkNotModified` methods, and others.

| `ServerHttpRequest`, `ServerHttpResponse`
| Access to the HTTP request or response.

| `WebSession`
| Access to the session. This does not force the start of a new session unless attributes
  are added. Supports reactive types.

| `java.security.Principal`
| The currently authenticated user -- possibly a specific `Principal` implementation class if known.
  Supports reactive types.

| `org.springframework.http.HttpMethod`
| The HTTP method of the request.

| `java.util.Locale`
| The current request locale, determined by the most specific `LocaleResolver` available -- in
  effect, the configured `LocaleResolver`/`LocaleContextResolver`.

| `java.util.TimeZone` + `java.time.ZoneId`
| The time zone associated with the current request, as determined by a `LocaleContextResolver`.

| `@PathVariable`
| For access to URI template variables. See <<webflux-ann-requestmapping-uri-templates>>.

| `@MatrixVariable`
| For access to name-value pairs in URI path segments. See <<webflux-ann-matrix-variables>>.

| `@RequestParam`
| For access to Servlet request parameters. Parameter values are converted to the declared
  method argument type. See <<webflux-ann-requestparam>>.

  Note that use of `@RequestParam` is optional -- for example, to set its attributes.
  See "`Any other argument`" later in this table.

| `@RequestHeader`
| For access to request headers. Header values are converted to the declared method argument
  type. See <<webflux-ann-requestheader>>.

| `@CookieValue`
| For access to cookies. Cookie values are converted to the declared method argument type.
  See <<webflux-ann-cookievalue>>.

| `@RequestBody`
| For access to the HTTP request body. Body content is converted to the declared method
  argument type by using `HttpMessageReader` instances. Supports reactive types.
  See <<webflux-ann-requestbody>>.

| `HttpEntity<B>`
| For access to request headers and body. The body is converted with `HttpMessageReader` instances.
  Supports reactive types. See <<webflux-ann-httpentity>>.

| `@RequestPart`
| For access to a part in  a `multipart/form-data` request. Supports reactive types.
  See <<webflux-multipart-forms>> and <<webflux-multipart>>.

| `java.util.Map`, `org.springframework.ui.Model`, and `org.springframework.ui.ModelMap`.
| For access to the model that is used in HTML controllers and is exposed to templates as
  part of view rendering.

| `@ModelAttribute`
| For access to an existing attribute in the model (instantiated if not present) with
  data binding and validation applied. See <<webflux-ann-modelattrib-method-args>> as well
  as <<webflux-ann-modelattrib-methods>> and <<webflux-ann-initbinder>>.

  Note that use of `@ModelAttribute` is optional -- for example, to set its attributes.
  See "`Any other argument`" later in this table.

| `Errors`, `BindingResult`
| For access to errors from validation and data binding for a command object, i.e. a
  `@ModelAttribute` argument. An `Errors`, or `BindingResult` argument must be declared
  immediately after the validated method argument.

| `SessionStatus` + class-level `@SessionAttributes`
| For marking form processing complete, which triggers cleanup of session attributes
  declared through a class-level `@SessionAttributes` annotation.
  See <<webflux-ann-sessionattributes>> for more details.

| `UriComponentsBuilder`
| For preparing a URL relative to the current request's host, port, scheme, and path.
  See <<webflux-uri-building>>.

| `@SessionAttribute`
| For access to any session attribute -- in contrast to model attributes stored in the session
  as a result of a class-level `@SessionAttributes` declaration. See
  <<webflux-ann-sessionattribute>> for more details.

| `@RequestAttribute`
| For access to request attributes. See <<webflux-ann-requestattrib>> for more details.

| Any other argument
| If a method argument is not matched to any of the above, it is, by default, resolved as
  a `@RequestParam` if it is a simple type, as determined by
  {api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty],
  or as a `@ModelAttribute`, otherwise.
|===


[[webflux-ann-return-types]]
==== Return Values
[.small]#<<web.adoc#mvc-ann-return-types, Web MVC>>#

The following table shows the supported controller method return values. Note that reactive
types from libraries such as Reactor, RxJava, <<webflux-reactive-libraries, or other>> are
generally supported for all return values.

[cols="1,2", options="header"]
|===
| Controller method return value | Description

| `@ResponseBody`
| The return value is encoded through `HttpMessageWriter` instances and written to the response.
  See <<webflux-ann-responsebody>>.

| `HttpEntity<B>`, `ResponseEntity<B>`
| The return value specifies the full response, including HTTP headers, and the body is encoded
  through `HttpMessageWriter` instances and written to the response.
  See <<webflux-ann-responseentity>>.

| `HttpHeaders`
| For returning a response with headers and no body.

| `String`
| A view name to be resolved with `ViewResolver` instances and used together with the implicit
  model -- determined through command objects and `@ModelAttribute` methods. The handler
  method can also programmatically enrich the model by declaring a `Model` argument
  (described <<webflux-viewresolution-handling, earlier>>).

| `View`
| A `View` instance to use for rendering together with the implicit model -- determined
  through command objects and `@ModelAttribute` methods. The handler method can also
  programmatically enrich the model by declaring a `Model` argument
  (described <<webflux-viewresolution-handling, earlier>>).

| `java.util.Map`, `org.springframework.ui.Model`
| Attributes to be added to the implicit model, with the view name implicitly determined
  based on the request path.

| `@ModelAttribute`
| An attribute to be added to the model, with the view name implicitly determined based
  on the request path.

  Note that `@ModelAttribute` is optional. See "`Any other return value`" later in
  this table.

| `Rendering`
| An API for model and view rendering scenarios.

| `void`
| A method with a `void`, possibly asynchronous (for example, `Mono<Void>`), return type (or a `null` return
  value) is considered to have fully handled the response if it also has a `ServerHttpResponse`,
  a `ServerWebExchange` argument, or an `@ResponseStatus` annotation. The same is also true
  if the controller has made a positive ETag or `lastModified` timestamp check.
  // TODO: See <<webflux-caching-etag-lastmodified>> for details.

  If none of the above is true, a `void` return type can also indicate "`no response body`" for
  REST controllers or default view name selection for HTML controllers.

| `Flux<ServerSentEvent>`, `Observable<ServerSentEvent>`, or other reactive type
| Emit server-sent events. The `ServerSentEvent` wrapper can be omitted when only data needs
  to be written (however, `text/event-stream` must be requested or declared in the mapping
  through the `produces` attribute).

| Any other return value
| If a return value is not matched to any of the above, it is, by default, treated as a view
  name, if it is `String` or `void` (default view name selection applies), or as a model
  attribute to be added to the model, unless it is a simple type, as determined by
  {api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty],
  in which case it remains unresolved.
|===


[[webflux-ann-typeconversion]]
==== Type Conversion
[.small]#<<web.adoc#mvc-ann-typeconversion, Web MVC>>#

Some annotated controller method arguments that represent String-based request input (for example,
`@RequestParam`, `@RequestHeader`, `@PathVariable`, `@MatrixVariable`, and `@CookieValue`)
can require type conversion if the argument is declared as something other than `String`.

For such cases, type conversion is automatically applied based on the configured converters.
By default, simple types (such as `int`, `long`, `Date`, and others) are supported. Type conversion
can be customized through a `WebDataBinder` (see <<webflux-ann-initbinder>>) or by registering
`Formatters` with the `FormattingConversionService` (see <<core.adoc#format, Spring Field Formatting>>).


[[webflux-ann-matrix-variables]]
==== Matrix Variables
[.small]#<<web.adoc#mvc-ann-matrix-variables, Web MVC>>#

https://tools.ietf.org/html/rfc3986#section-3.3[RFC 3986] discusses name-value pairs in
path segments. In Spring WebFlux, we refer to those as "`matrix variables`" based on an
https://www.w3.org/DesignIssues/MatrixURIs.html["`old post`"] by Tim Berners-Lee, but they
can be also be referred to as URI path parameters.

Matrix variables can appear in any path segment, with each variable separated by a semicolon and
multiple values separated by commas -- for example, `"/cars;color=red,green;year=2012"`. Multiple
values can also be specified through repeated variable names -- for example,
`"color=red;color=green;color=blue"`.

Unlike Spring MVC, in WebFlux, the presence or absence of matrix variables in a URL does
not affect request mappings. In other words, you are not required to use a URI variable
to mask variable content. That said, if you want to access matrix variables from a
controller method, you need to add a URI variable to the path segment where matrix
variables are expected. The following example shows how to do so:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// GET /pets/42;q=11;r=22

	@GetMapping("/pets/{petId}")
	public void findPet(@PathVariable String petId, @MatrixVariable int q) {

		// petId == 42
		// q == 11
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// GET /pets/42;q=11;r=22

	@GetMapping("/pets/{petId}")
	fun findPet(@PathVariable petId: String, @MatrixVariable q: Int) {

		// petId == 42
		// q == 11
	}
----


Given that all path segments can contain matrix variables, you may sometimes need to
disambiguate which path variable the matrix variable is expected to be in,
as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// GET /owners/42;q=11/pets/21;q=22

	@GetMapping("/owners/{ownerId}/pets/{petId}")
	public void findPet(
			@MatrixVariable(name="q", pathVar="ownerId") int q1,
			@MatrixVariable(name="q", pathVar="petId") int q2) {

		// q1 == 11
		// q2 == 22
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/owners/{ownerId}/pets/{petId}")
	fun findPet(
			@MatrixVariable(name = "q", pathVar = "ownerId") q1: Int,
			@MatrixVariable(name = "q", pathVar = "petId") q2: Int) {

		// q1 == 11
		// q2 == 22
	}
----

You can define a matrix variable may be defined as optional and specify a default value
as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// GET /pets/42

	@GetMapping("/pets/{petId}")
	public void findPet(@MatrixVariable(required=false, defaultValue="1") int q) {

		// q == 1
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// GET /pets/42

	@GetMapping("/pets/{petId}")
	fun findPet(@MatrixVariable(required = false, defaultValue = "1") q: Int) {

		// q == 1
	}
----

To get all matrix variables, use a `MultiValueMap`, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// GET /owners/42;q=11;r=12/pets/21;q=22;s=23

	@GetMapping("/owners/{ownerId}/pets/{petId}")
	public void findPet(
			@MatrixVariable MultiValueMap<String, String> matrixVars,
			@MatrixVariable(pathVar="petId") MultiValueMap<String, String> petMatrixVars) {

		// matrixVars: ["q" : [11,22], "r" : 12, "s" : 23]
		// petMatrixVars: ["q" : 22, "s" : 23]
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// GET /owners/42;q=11;r=12/pets/21;q=22;s=23

	@GetMapping("/owners/{ownerId}/pets/{petId}")
	fun findPet(
			@MatrixVariable matrixVars: MultiValueMap<String, String>,
			@MatrixVariable(pathVar="petId") petMatrixVars: MultiValueMap<String, String>) {

		// matrixVars: ["q" : [11,22], "r" : 12, "s" : 23]
		// petMatrixVars: ["q" : 22, "s" : 23]
	}
----


[[webflux-ann-requestparam]]
==== `@RequestParam`
[.small]#<<web.adoc#mvc-ann-requestparam, Web MVC>>#

You can use the `@RequestParam` annotation to bind query parameters to a method argument in a
controller. The following code snippet shows the usage:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	@RequestMapping("/pets")
	public class EditPetForm {

		// ...

		@GetMapping
		public String setupForm(@RequestParam("petId") int petId, Model model) { <1>
			Pet pet = this.clinic.loadPet(petId);
			model.addAttribute("pet", pet);
			return "petForm";
		}

		// ...
	}
----
<1> Using `@RequestParam`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.ui.set

	@Controller
	@RequestMapping("/pets")
	class EditPetForm {

		// ...

		@GetMapping
		fun setupForm(@RequestParam("petId") petId: Int, model: Model): String { // <1>
			val pet = clinic.loadPet(petId)
			model["pet"] = pet
			return "petForm"
		}

		// ...
	}
----
<1> Using `@RequestParam`.

TIP: The Servlet API "`request parameter`" concept conflates query parameters, form
data, and multiparts into one. However, in WebFlux, each is accessed individually through
`ServerWebExchange`. While `@RequestParam` binds to query parameters only, you can use
data binding to apply query parameters, form data, and multiparts to a
<<webflux-ann-modelattrib-method-args, command object>>.

Method parameters that use the `@RequestParam` annotation are required by default, but
you can specify that a method parameter is optional by setting the required flag of a `@RequestParam`
to `false` or by declaring the argument with a `java.util.Optional`
wrapper.

Type conversion is applied automatically if the target method parameter type is not
`String`. See <<webflux-ann-typeconversion>>.

When a `@RequestParam` annotation is declared on a `Map<String, String>` or
`MultiValueMap<String, String>` argument, the map is populated with all query parameters.

Note that use of `@RequestParam` is optional -- for example, to set its attributes. By
default, any argument that is a simple value type (as determined by
{api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty])
and is not resolved by any other argument resolver is treated as if it were annotated
with `@RequestParam`.


[[webflux-ann-requestheader]]
==== `@RequestHeader`
[.small]#<<web.adoc#mvc-ann-requestheader, Web MVC>>#

You can use the `@RequestHeader` annotation to bind a request header to a method argument in a
controller.

The following example shows a request with headers:

[literal]
[subs="verbatim,quotes"]
----
Host                    localhost:8080
Accept                  text/html,application/xhtml+xml,application/xml;q=0.9
Accept-Language         fr,en-gb;q=0.7,en;q=0.3
Accept-Encoding         gzip,deflate
Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive              300
----

The following example gets the value of the `Accept-Encoding` and `Keep-Alive` headers:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/demo")
	public void handle(
			@RequestHeader("Accept-Encoding") String encoding, // <1>
			@RequestHeader("Keep-Alive") long keepAlive) { // <2>
		//...
	}
----
<1> Get the value of the `Accept-Encoging` header.
<2> Get the value of the `Keep-Alive` header.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/demo")
	fun handle(
			@RequestHeader("Accept-Encoding") encoding: String, // <1>
			@RequestHeader("Keep-Alive") keepAlive: Long) { // <2>
		//...
	}
----
<1> Get the value of the `Accept-Encoging` header.
<2> Get the value of the `Keep-Alive` header.

Type conversion is applied automatically if the target method parameter type is not
`String`. See <<webflux-ann-typeconversion>>.

When a `@RequestHeader` annotation is used on a `Map<String, String>`,
`MultiValueMap<String, String>`, or `HttpHeaders` argument, the map is populated
with all header values.

TIP: Built-in support is available for converting a comma-separated string into an
array or collection of strings or other types known to the type conversion system. For
example, a method parameter annotated with `@RequestHeader("Accept")` may be of type
`String` but also of `String[]` or `List<String>`.


[[webflux-ann-cookievalue]]
==== `@CookieValue`
[.small]#<<web.adoc#mvc-ann-cookievalue, Web MVC>>#

You can use the `@CookieValue` annotation to bind the value of an HTTP cookie to a method argument
in a controller.

The following example shows a request with a cookie:

[literal,subs="verbatim,quotes"]
----
JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84
----

The following code sample demonstrates how to get the cookie value:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/demo")
	public void handle(@CookieValue("JSESSIONID") String cookie) { // <1>
		//...
	}
----
<1> Get the cookie value.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/demo")
	fun handle(@CookieValue("JSESSIONID") cookie: String) { // <1>
		//...
	}
----
<1> Get the cookie value.


Type conversion is applied automatically if the target method parameter type is not
`String`. See <<webflux-ann-typeconversion>>.


[[webflux-ann-modelattrib-method-args]]
==== `@ModelAttribute`
[.small]#<<web.adoc#mvc-ann-modelattrib-method-args, Web MVC>>#

You can use the `@ModelAttribute` annotation on a method argument to access an attribute from the
model or have it instantiated if not present. The model attribute is also overlain with
the values of query parameters and form fields whose names match to field names. This is
referred to as data binding, and it saves you from having to deal with parsing and
converting individual query parameters and form fields. The following example binds an instance of `Pet`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	public String processSubmit(@ModelAttribute Pet pet) { } // <1>
----
<1> Bind an instance of `Pet`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	fun processSubmit(@ModelAttribute pet: Pet): String { } // <1>
----
<1> Bind an instance of `Pet`.

The `Pet` instance in the preceding example is resolved as follows:

* From the model if already added through <<webflux-ann-modelattrib-methods>>.
* From the HTTP session through <<webflux-ann-sessionattributes>>.
* From the invocation of a default constructor.
* From the invocation of a "`primary constructor`" with arguments that match query
parameters or form fields. Argument names are determined through JavaBeans
`@ConstructorProperties` or through runtime-retained parameter names in the bytecode.

After the model attribute instance is obtained, data binding is applied. The
`WebExchangeDataBinder` class matches names of query parameters and form fields to field
names on the target `Object`. Matching fields are populated after type conversion is applied
where necessary. For more on data binding (and validation), see
<<core.adoc#validation, Validation>>. For more on customizing data binding, see
<<webflux-ann-initbinder>>.

Data binding can result in errors. By default, a `WebExchangeBindException` is raised, but,
to check for such errors in the controller method, you can add a `BindingResult` argument
immediately next to the `@ModelAttribute`, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	public String processSubmit(@ModelAttribute("pet") Pet pet, BindingResult result) { <1>
		if (result.hasErrors()) {
			return "petForm";
		}
		// ...
	}
----
<1> Adding a `BindingResult`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	fun processSubmit(@ModelAttribute("pet") pet: Pet, result: BindingResult): String { // <1>
		if (result.hasErrors()) {
			return "petForm"
		}
		// ...
	}
----
<1> Adding a `BindingResult`.

You can automatically apply validation after data binding by adding the
`javax.validation.Valid` annotation or Spring's `@Validated` annotation (see also
<<core.adoc#validation-beanvalidation, Bean Validation>> and
<<core.adoc#validation, Spring validation>>). The following example uses the `@Valid` annotation:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	public String processSubmit(@Valid @ModelAttribute("pet") Pet pet, BindingResult result) { // <1>
		if (result.hasErrors()) {
			return "petForm";
		}
		// ...
	}
----
<1> Using `@Valid` on a model attribute argument.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	fun processSubmit(@Valid @ModelAttribute("pet") pet: Pet, result: BindingResult): String { // <1>
		if (result.hasErrors()) {
			return "petForm"
		}
		// ...
	}
----
<1> Using `@Valid` on a model attribute argument.

Spring WebFlux, unlike Spring MVC, supports reactive types in the model -- for example,
`Mono<Account>` or `io.reactivex.Single<Account>`. You can declare a `@ModelAttribute` argument
with or without a reactive type wrapper, and it will be resolved accordingly,
to the actual value if necessary. However, note that, to use a `BindingResult`
argument, you must declare the `@ModelAttribute` argument before it without a reactive
type wrapper, as shown earlier. Alternatively, you can handle any errors through the
reactive type, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	public Mono<String> processSubmit(@Valid @ModelAttribute("pet") Mono<Pet> petMono) {
		return petMono
			.flatMap(pet -> {
				// ...
			})
			.onErrorResume(ex -> {
				// ...
			});
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	fun processSubmit(@Valid @ModelAttribute("pet") petMono: Mono<Pet>): Mono<String> {
		return petMono
				.flatMap { pet ->
					// ...
				}
				.onErrorResume{ ex ->
					// ...
				}
	}
----

Note that use of `@ModelAttribute` is optional -- for example, to set its attributes.
By default, any argument that is not a simple value type( as determined by
{api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty])
and is not resolved by any other argument resolver is treated as if it were annotated
with `@ModelAttribute`.


[[webflux-ann-sessionattributes]]
==== `@SessionAttributes`
[.small]#<<web.adoc#mvc-ann-sessionattributes, Web MVC>>#

`@SessionAttributes` is used to store model attributes in the `WebSession` between
requests. It is a type-level annotation that declares session attributes used by a
specific controller. This typically lists the names of model attributes or types of
model attributes that should be transparently stored in the session for subsequent
requests to access.

Consider the following example:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	@SessionAttributes("pet") <1>
	public class EditPetForm {
		// ...
	}
----
<1> Using the `@SessionAttributes` annotation.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	@SessionAttributes("pet") // <1>
	class EditPetForm {
		// ...
	}
----
<1> Using the `@SessionAttributes` annotation.

On the first request, when a model attribute with the name, `pet`, is added to the model,
it is automatically promoted to and saved in the `WebSession`. It remains there until
another controller method uses a `SessionStatus` method argument to clear the storage,
as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	@SessionAttributes("pet") // <1>
	public class EditPetForm {

		// ...

		@PostMapping("/pets/{id}")
		public String handle(Pet pet, BindingResult errors, SessionStatus status) { // <2>
			if (errors.hasErrors()) {
				// ...
			}
				status.setComplete();
				// ...
			}
		}
	}
----
<1> Using the `@SessionAttributes` annotation.
<2> Using a `SessionStatus` variable.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	@SessionAttributes("pet") // <1>
	class EditPetForm {

		// ...

		@PostMapping("/pets/{id}")
		fun handle(pet: Pet, errors: BindingResult, status: SessionStatus): String { // <2>
			if (errors.hasErrors()) {
				// ...
			}
			status.setComplete()
			// ...
		}
	}
----
<1> Using the `@SessionAttributes` annotation.
<2> Using a `SessionStatus` variable.


[[webflux-ann-sessionattribute]]
==== `@SessionAttribute`
[.small]#<<web.adoc#mvc-ann-sessionattribute, Web MVC>>#

If you need access to pre-existing session attributes that are managed globally
(that is, outside the controller -- for example, by a filter) and may or may not be present,
you can use the `@SessionAttribute` annotation on a method parameter, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/")
	public String handle(@SessionAttribute User user) { // <1>
		// ...
	}
----
<1> Using `@SessionAttribute`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/")
	fun handle(@SessionAttribute user: User): String { // <1>
		// ...
	}
----
<1> Using `@SessionAttribute`.

For use cases that require adding or removing session attributes, consider injecting
`WebSession` into the controller method.

For temporary storage of model attributes in the session as part of a controller
workflow, consider using `SessionAttributes`, as described in
<<webflux-ann-sessionattributes>>.


[[webflux-ann-requestattrib]]
==== `@RequestAttribute`
[.small]#<<web.adoc#mvc-ann-requestattrib, Web MVC>>#

Similarly to `@SessionAttribute`, you can use the `@RequestAttribute` annotation to
access pre-existing request attributes created earlier (for example, by a `WebFilter`),
as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/")
	public String handle(@RequestAttribute Client client) { <1>
		// ...
	}
----
<1> Using `@RequestAttribute`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/")
	fun handle(@RequestAttribute client: Client): String { // <1>
		// ...
	}
----
<1> Using `@RequestAttribute`.


[[webflux-multipart-forms]]
==== Multipart Content
[.small]#<<web.adoc#mvc-multipart-forms, Web MVC>>#

As explained in <<webflux-multipart>>, `ServerWebExchange` provides access to multipart
content. The best way to handle a file upload form (for example, from a browser) in a controller
is through data binding to a <<webflux-ann-modelattrib-method-args, command object>>,
as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	class MyForm {

		private String name;

		private MultipartFile file;

		// ...

	}

	@Controller
	public class FileUploadController {

		@PostMapping("/form")
		public String handleFormUpload(MyForm form, BindingResult errors) {
			// ...
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MyForm(
			val name: String,
			val file: MultipartFile)

	@Controller
	class FileUploadController {

		@PostMapping("/form")
		fun handleFormUpload(form: MyForm, errors: BindingResult): String {
			// ...
		}

	}
----

You can also submit multipart requests from non-browser clients in a RESTful service
scenario. The following example uses a file along with JSON:

[literal,subs="verbatim,quotes"]
----
POST /someUrl
Content-Type: multipart/mixed

--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name="meta-data"
Content-Type: application/json; charset=UTF-8
Content-Transfer-Encoding: 8bit

{
	"name": "value"
}
--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name="file-data"; filename="file.properties"
Content-Type: text/xml
Content-Transfer-Encoding: 8bit
... File Data ...
----

You can access individual parts with `@RequestPart`, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/")
	public String handle(@RequestPart("meta-data") Part metadata, // <1>
			@RequestPart("file-data") FilePart file) { // <2>
		// ...
	}
----
<1> Using `@RequestPart` to get the metadata.
<2> Using `@RequestPart` to get the file.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/")
	fun handle(@RequestPart("meta-data") Part metadata, // <1>
			@RequestPart("file-data") FilePart file): String { // <2>
		// ...
	}
----
<1> Using `@RequestPart` to get the metadata.
<2> Using `@RequestPart` to get the file.


To deserialize the raw part content (for example, to JSON -- similar to `@RequestBody`),
you can declare a concrete target `Object`, instead of `Part`, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/")
	public String handle(@RequestPart("meta-data") MetaData metadata) { // <1>
		// ...
	}
----
<1> Using `@RequestPart` to get the metadata.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/")
	fun handle(@RequestPart("meta-data") metadata: MetaData): String { // <1>
		// ...
	}
----
<1> Using `@RequestPart` to get the metadata.

You can use `@RequestPart` in combination with `javax.validation.Valid` or Spring's
`@Validated` annotation, which causes Standard Bean Validation to be applied. Validation
errors lead to a `WebExchangeBindException` that results in a 400 (BAD_REQUEST) response.
The exception contains a `BindingResult` with the error details and can also be handled
in the controller method by declaring the argument with an async wrapper and then using
error related operators:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/")
	public String handle(@Valid @RequestPart("meta-data") Mono<MetaData> metadata) {
		// use one of the onError* operators...
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/")
	fun handle(@Valid @RequestPart("meta-data") metadata: MetaData): String {
		// ...
	}
----

To access all multipart data as a `MultiValueMap`, you can use `@RequestBody`,
as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/")
	public String handle(@RequestBody Mono<MultiValueMap<String, Part>> parts) { // <1>
		// ...
	}
----
<1> Using `@RequestBody`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/")
	fun handle(@RequestBody parts: MultiValueMap<String, Part>): String { // <1>
		// ...
	}
----
<1> Using `@RequestBody`.


To access multipart data sequentially, in streaming fashion, you can use `@RequestBody` with
`Flux<Part>` (or `Flow<Part>` in Kotlin) instead, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/")
	public String handle(@RequestBody Flux<Part> parts) { <1>
		// ...
	}
----
<1> Using `@RequestBody`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/")
	fun handle(@RequestBody parts: Flow<Part>): String { // <1>
		// ...
	}
----
<1> Using `@RequestBody`.


[[webflux-ann-requestbody]]
==== `@RequestBody`
[.small]#<<web.adoc#mvc-ann-requestbody, Web MVC>>#

You can use the `@RequestBody` annotation to have the request body read and deserialized into an
`Object` through an <<webflux-codecs,HttpMessageReader>>.
The following example uses a `@RequestBody` argument:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/accounts")
	public void handle(@RequestBody Account account) {
		// ...
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/accounts")
	fun handle(@RequestBody account: Account) {
		// ...
	}
----

Unlike Spring MVC, in WebFlux, the `@RequestBody` method argument supports reactive types
and fully non-blocking reading and (client-to-server) streaming.

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/accounts")
	public void handle(@RequestBody Mono<Account> account) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/accounts")
	fun handle(@RequestBody accounts: Flow<Account>) {
		// ...
	}
----

You can use the <<webflux-config-message-codecs>> option of the <<webflux-config>> to
configure or customize message readers.

You can use `@RequestBody` in combination with `javax.validation.Valid` or Spring's
`@Validated` annotation, which causes Standard Bean Validation to be applied. Validation
errors cause a `WebExchangeBindException`, which results in a 400 (BAD_REQUEST) response.
The exception contains a `BindingResult` with error details and can be handled in the
controller method by declaring the argument with an async wrapper and then using error
related operators:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/accounts")
	public void handle(@Valid @RequestBody Mono<Account> account) {
		// use one of the onError* operators...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/accounts")
	fun handle(@Valid @RequestBody account: Mono<Account>) {
		// ...
	}
----


[[webflux-ann-httpentity]]
==== `HttpEntity`
[.small]#<<web.adoc#mvc-ann-httpentity, Web MVC>>#

`HttpEntity` is more or less identical to using <<webflux-ann-requestbody>> but is based on a
container object that exposes request headers and the body. The following example uses an
`HttpEntity`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/accounts")
	public void handle(HttpEntity<Account> entity) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/accounts")
	fun handle(entity: HttpEntity<Account>) {
		// ...
	}
----


[[webflux-ann-responsebody]]
==== `@ResponseBody`
[.small]#<<web.adoc#mvc-ann-responsebody, Web MVC>>#

You can use the `@ResponseBody` annotation on a method to have the return serialized
to the response body through an <<webflux-codecs, HttpMessageWriter>>. The following
example shows how to do so:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/accounts/{id}")
	@ResponseBody
	public Account handle() {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/accounts/{id}")
	@ResponseBody
	fun handle(): Account {
		// ...
	}
----

`@ResponseBody` is also supported at the class level, in which case it is inherited by
all controller methods. This is the effect of `@RestController`, which is nothing more
than a meta-annotation marked with `@Controller` and `@ResponseBody`.

`@ResponseBody` supports reactive types, which means you can return Reactor or RxJava
types and have the asynchronous values they produce rendered to the response.
For additional details, see <<webflux-codecs-streaming>> and
<<webflux-codecs-jackson,JSON rendering>>.

You can combine `@ResponseBody` methods with JSON serialization views.
See <<webflux-ann-jackson>> for details.

You can use the <<webflux-config-message-codecs>> option of the <<webflux-config>> to
configure or customize message writing.


[[webflux-ann-responseentity]]
==== `ResponseEntity`
[.small]#<<web.adoc#mvc-ann-responseentity, Web MVC>>#

`ResponseEntity` is like <<webflux-ann-responsebody>> but with status and headers. For example:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/something")
	public ResponseEntity<String> handle() {
		String body = ... ;
		String etag = ... ;
		return ResponseEntity.ok().eTag(etag).build(body);
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/something")
	fun handle(): ResponseEntity<String> {
		val body: String = ...
		val etag: String = ...
		return ResponseEntity.ok().eTag(etag).build(body)
	}
----

WebFlux supports using a single value <<webflux-reactive-libraries, reactive type>> to
produce the `ResponseEntity` asynchronously, and/or single and multi-value reactive types
for the body.


[[webflux-ann-jackson]]
==== Jackson JSON

Spring offers support for the Jackson JSON library.

[[webflux-ann-jsonview]]
===== JSON Views
[.small]#<<web.adoc#mvc-ann-jackson, Web MVC>>#

Spring WebFlux provides built-in support for
https://www.baeldung.com/jackson-json-view-annotation[Jackson's Serialization Views],
which allows rendering only a subset of all fields in an `Object`. To use it with
`@ResponseBody` or `ResponseEntity` controller methods, you can use Jackson's
`@JsonView` annotation to activate a serialization view class, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RestController
	public class UserController {

		@GetMapping("/user")
		@JsonView(User.WithoutPasswordView.class)
		public User getUser() {
			return new User("eric", "7!jd#h23");
		}
	}

	public class User {

		public interface WithoutPasswordView {};
		public interface WithPasswordView extends WithoutPasswordView {};

		private String username;
		private String password;

		public User() {
		}

		public User(String username, String password) {
			this.username = username;
			this.password = password;
		}

		@JsonView(WithoutPasswordView.class)
		public String getUsername() {
			return this.username;
		}

		@JsonView(WithPasswordView.class)
		public String getPassword() {
			return this.password;
		}
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RestController
	class UserController {

		@GetMapping("/user")
		@JsonView(User.WithoutPasswordView::class)
		fun getUser(): User {
			return User("eric", "7!jd#h23")
		}
	}

	class User(
			@JsonView(WithoutPasswordView::class) val username: String,
			@JsonView(WithPasswordView::class) val password: String
	) {
		interface WithoutPasswordView
		interface WithPasswordView : WithoutPasswordView
	}
----

NOTE: `@JsonView` allows an array of view classes but you can only specify only one per
controller method. Use a composite interface if you need to activate multiple views.



[[webflux-ann-modelattrib-methods]]
=== `Model`
[.small]#<<web.adoc#mvc-ann-modelattrib-methods, Web MVC>>#

You can use the `@ModelAttribute` annotation:

* On a <<webflux-ann-modelattrib-method-args, method argument>> in `@RequestMapping` methods
to create or access an Object from the model and to bind it to the request through a
`WebDataBinder`.
* As a method-level annotation in `@Controller` or `@ControllerAdvice` classes, helping
to initialize the model prior to any `@RequestMapping` method invocation.
* On a `@RequestMapping` method to mark its return value as a model attribute.

This section discusses `@ModelAttribute` methods, or the second item from the preceding list.
A controller can have any number of `@ModelAttribute` methods. All such methods are
invoked before `@RequestMapping` methods in the same controller. A `@ModelAttribute`
method can also be shared across controllers through `@ControllerAdvice`. See the section on
<<webflux-ann-controller-advice>> for more details.

`@ModelAttribute` methods have flexible method signatures. They support many of the same
arguments as `@RequestMapping` methods (except for `@ModelAttribute` itself and anything
related to the request body).

The following example uses a `@ModelAttribute` method:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ModelAttribute
	public void populateModel(@RequestParam String number, Model model) {
		model.addAttribute(accountRepository.findAccount(number));
		// add more ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ModelAttribute
	fun populateModel(@RequestParam number: String, model: Model) {
		model.addAttribute(accountRepository.findAccount(number))
		// add more ...
	}
----

The following example adds one attribute only:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ModelAttribute
	public Account addAccount(@RequestParam String number) {
		return accountRepository.findAccount(number);
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ModelAttribute
	fun addAccount(@RequestParam number: String): Account {
		return accountRepository.findAccount(number);
	}
----

NOTE: When a name is not explicitly specified, a default name is chosen based on the type,
as explained in the javadoc for {api-spring-framework}/core/Conventions.html[`Conventions`].
You can always assign an explicit name by using the overloaded `addAttribute` method or
through the name attribute on `@ModelAttribute` (for a return value).

Spring WebFlux, unlike Spring MVC, explicitly supports reactive types in the model
(for example, `Mono<Account>` or `io.reactivex.Single<Account>`). Such asynchronous model
attributes can be transparently resolved (and the model updated) to their actual values
at the time of `@RequestMapping` invocation, provided a `@ModelAttribute` argument is
declared without a wrapper, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ModelAttribute
	public void addAccount(@RequestParam String number) {
	    Mono<Account> accountMono = accountRepository.findAccount(number);
	    model.addAttribute("account", accountMono);
	}

	@PostMapping("/accounts")
	public String handle(@ModelAttribute Account account, BindingResult errors) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.ui.set

	@ModelAttribute
	fun addAccount(@RequestParam number: String) {
		val accountMono: Mono<Account> = accountRepository.findAccount(number)
		model["account"] = accountMono
	}

	@PostMapping("/accounts")
	fun handle(@ModelAttribute account: Account, errors: BindingResult): String {
		// ...
	}
----


In addition, any model attributes that have a reactive type wrapper are resolved to their
actual values (and the model updated) just prior to view rendering.

You can also use `@ModelAttribute` as a method-level annotation on `@RequestMapping`
methods, in which case the return value of the `@RequestMapping` method is interpreted as a
model attribute. This is typically not required, as it is the default behavior in HTML
controllers, unless the return value is a `String` that would otherwise be interpreted
as a view name. `@ModelAttribute` can also help to customize the model attribute name,
as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/accounts/{id}")
	@ModelAttribute("myAccount")
	public Account handle() {
		// ...
		return account;
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/accounts/{id}")
	@ModelAttribute("myAccount")
	fun handle(): Account {
		// ...
		return account
	}
----



[[webflux-ann-initbinder]]
=== `DataBinder`
[.small]#<<web.adoc#mvc-ann-initbinder, Web MVC>>#

`@Controller` or `@ControllerAdvice` classes can have `@InitBinder` methods, to
initialize instances of `WebDataBinder`. Those, in turn, are used to:

* Bind request parameters (that is, form data or query) to a model object.
* Convert `String`-based request values (such as request parameters, path variables,
headers, cookies, and others) to the target type of controller method arguments.
* Format model object values as `String` values when rendering HTML forms.

`@InitBinder` methods can register controller-specific `java.bean.PropertyEditor` or
Spring `Converter` and `Formatter` components. In addition, you can use the
<<webflux-config-conversion, WebFlux Java configuration>> to register `Converter` and
`Formatter` types in a globally shared `FormattingConversionService`.

`@InitBinder` methods support many of the same arguments that `@RequestMapping` methods
do, except for `@ModelAttribute` (command object) arguments. Typically, they are declared
with a `WebDataBinder` argument, for registrations, and a `void` return value.
The following example uses the `@InitBinder` annotation:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class FormController {

		@InitBinder // <1>
		public void initBinder(WebDataBinder binder) {
			SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
			dateFormat.setLenient(false);
			binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));
		}

		// ...
	}
----
<1> Using the `@InitBinder` annotation.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	class FormController {

		@InitBinder // <1>
		fun initBinder(binder: WebDataBinder) {
			val dateFormat = SimpleDateFormat("yyyy-MM-dd")
			dateFormat.isLenient = false
			binder.registerCustomEditor(Date::class.java, CustomDateEditor(dateFormat, false))
		}

		// ...
	}
----

Alternatively, when using a `Formatter`-based setup through a shared
`FormattingConversionService`, you could re-use the same approach and register
controller-specific `Formatter` instances, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class FormController {

		@InitBinder
		protected void initBinder(WebDataBinder binder) {
			binder.addCustomFormatter(new DateFormatter("yyyy-MM-dd")); <1>
		}

		// ...
	}
----
<1> Adding a custom formatter (a `DateFormatter`, in this case).

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	class FormController {

		@InitBinder
		fun initBinder(binder: WebDataBinder) {
			binder.addCustomFormatter(DateFormatter("yyyy-MM-dd")) // <1>
		}

		// ...
	}
----
<1> Adding a custom formatter (a `DateFormatter`, in this case).



[[webflux-ann-controller-exceptions]]
=== Managing Exceptions
[.small]#<<web.adoc#mvc-ann-exceptionhandler, Web MVC>>#

`@Controller` and <<webflux-ann-controller-advice, @ControllerAdvice>> classes can have
`@ExceptionHandler` methods to handle exceptions from controller methods. The following
example includes such a handler method:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class SimpleController {

		// ...

		@ExceptionHandler // <1>
		public ResponseEntity<String> handle(IOException ex) {
			// ...
		}
	}
----
<1> Declaring an `@ExceptionHandler`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	class SimpleController {

		// ...

		@ExceptionHandler // <1>
		fun handle(ex: IOException): ResponseEntity<String> {
			// ...
		}
	}
----
<1> Declaring an `@ExceptionHandler`.


The exception can match against a top-level exception being propagated (that is, a direct
`IOException` being thrown) or against the immediate cause within a top-level wrapper
exception (for example, an `IOException` wrapped inside an `IllegalStateException`).

For matching exception types, preferably declare the target exception as a method argument,
as shown in the preceding example. Alternatively, the annotation declaration can narrow the
exception types to match. We generally recommend being as specific as possible in the
argument signature and to declare your primary root exception mappings on a
`@ControllerAdvice` prioritized with a corresponding order.
See <<web.adoc#mvc-ann-exceptionhandler, the MVC section>> for details.

NOTE: An `@ExceptionHandler` method in WebFlux supports the same method arguments and
return values as a `@RequestMapping` method, with the exception of request body-
and `@ModelAttribute`-related method arguments.

Support for `@ExceptionHandler` methods in Spring WebFlux is provided by the
`HandlerAdapter` for `@RequestMapping` methods. See <<webflux-dispatcher-handler>>
for more detail.


[[webflux-ann-rest-exceptions]]
==== REST API exceptions
[.small]#<<web.adoc#mvc-ann-rest-exceptions, Web MVC>>#

A common requirement for REST services is to include error details in the body of the
response. The Spring Framework does not automatically do so, because the representation
of error details in the response body is application-specific. However, a
`@RestController` can use `@ExceptionHandler` methods with a `ResponseEntity` return
value to set the status and the body of the response. Such methods can also be declared
in `@ControllerAdvice` classes to apply them globally.

NOTE: Note that Spring WebFlux does not have an equivalent for the Spring MVC
`ResponseEntityExceptionHandler`, because WebFlux raises only `ResponseStatusException`
(or subclasses thereof), and those do not need to be translated to
an HTTP status code.



[[webflux-ann-controller-advice]]
=== Controller Advice
[.small]#<<web.adoc#mvc-ann-controller-advice, Web MVC>>#

Typically, the `@ExceptionHandler`, `@InitBinder`, and `@ModelAttribute` methods apply
within the `@Controller` class (or class hierarchy) in which they are declared. If you
want such methods to apply more globally (across controllers), you can declare them in a
class annotated with `@ControllerAdvice` or `@RestControllerAdvice`.

`@ControllerAdvice` is annotated with `@Component`, which means that such classes can be
registered as Spring beans through <<core.adoc#beans-java-instantiating-container-scan,
component scanning>>. `@RestControllerAdvice` is a composed annotation that is annotated
with both `@ControllerAdvice` and `@ResponseBody`, which essentially means
`@ExceptionHandler` methods are rendered to the response body through message conversion
(versus view resolution or template rendering).

On startup, the infrastructure classes for `@RequestMapping` and `@ExceptionHandler`
methods detect Spring beans annotated with `@ControllerAdvice` and then apply their
methods at runtime. Global `@ExceptionHandler` methods (from a `@ControllerAdvice`) are
applied _after_ local ones (from the `@Controller`). By contrast, global `@ModelAttribute`
and `@InitBinder` methods are applied _before_ local ones.

By default, `@ControllerAdvice` methods apply to every request (that is, all controllers),
but you can narrow that down to a subset of controllers by using attributes on the
annotation, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// Target all Controllers annotated with @RestController
	@ControllerAdvice(annotations = RestController.class)
	public class ExampleAdvice1 {}

	// Target all Controllers within specific packages
	@ControllerAdvice("org.example.controllers")
	public class ExampleAdvice2 {}

	// Target all Controllers assignable to specific classes
	@ControllerAdvice(assignableTypes = {ControllerInterface.class, AbstractController.class})
	public class ExampleAdvice3 {}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// Target all Controllers annotated with @RestController
	@ControllerAdvice(annotations = [RestController::class])
	public class ExampleAdvice1 {}

	// Target all Controllers within specific packages
	@ControllerAdvice("org.example.controllers")
	public class ExampleAdvice2 {}

	// Target all Controllers assignable to specific classes
	@ControllerAdvice(assignableTypes = [ControllerInterface::class, AbstractController::class])
	public class ExampleAdvice3 {}
----

The selectors in the preceding example are evaluated at runtime and may negatively impact
performance if used extensively. See the
{api-spring-framework}/web/bind/annotation/ControllerAdvice.html[`@ControllerAdvice`]
javadoc for more details.

include::webflux-functional.adoc[leveloffset=+1]




[[webflux-uri-building]]
== URI Links
[.small]#<<web.adoc#mvc-uri-building, Web MVC>>#

This section describes various options available in the Spring Framework to prepare URIs.

include::web-uris.adoc[leveloffset=+2]

include::webflux-cors.adoc[leveloffset=+1]




[[webflux-web-security]]
== Web Security
[.small]#<<web.adoc#mvc-web-security, Web MVC>>#

The https://projects.spring.io/spring-security/[Spring Security] project provides support
for protecting web applications from malicious exploits. See the Spring Security
reference documentation, including:

* {doc-spring-security}/html5/#jc-webflux[WebFlux Security]
* {doc-spring-security}/html5/#test-webflux[WebFlux Testing Support]
* {doc-spring-security}/html5/#csrf[CSRF Protection]
* {doc-spring-security}/html5/#headers[Security Response Headers]

include::webflux-view.adoc[leveloffset=+1]




[[webflux-caching]]
== HTTP Caching
[.small]#<<web.adoc#mvc-caching, Web MVC>>#

HTTP caching can significantly improve the performance of a web application. HTTP caching
revolves around the `Cache-Control` response header and subsequent conditional request
headers, such as `Last-Modified` and `ETag`. `Cache-Control` advises private (for example, browser)
and public (for example, proxy) caches how to cache and re-use responses. An `ETag` header is used
to make a conditional request that may result in a 304 (NOT_MODIFIED) without a body,
if the content has not changed. `ETag` can be seen as a more sophisticated successor to
the `Last-Modified` header.

This section describes the HTTP caching related options available in Spring WebFlux.



[[webflux-caching-cachecontrol]]
=== `CacheControl`
[.small]#<<web.adoc#mvc-caching-cachecontrol, Web MVC>>#

{api-spring-framework}/http/CacheControl.html[`CacheControl`] provides support for
configuring settings related to the `Cache-Control` header and is accepted as an argument
in a number of places:

* <<webflux-caching-etag-lastmodified>>
* <<webflux-caching-static-resources>>

While https://tools.ietf.org/html/rfc7234#section-5.2.2[RFC 7234] describes all possible
directives for the `Cache-Control` response header, the `CacheControl` type takes a
use case-oriented approach that focuses on the common scenarios, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// Cache for an hour - "Cache-Control: max-age=3600"
	CacheControl ccCacheOneHour = CacheControl.maxAge(1, TimeUnit.HOURS);

	// Prevent caching - "Cache-Control: no-store"
	CacheControl ccNoStore = CacheControl.noStore();

	// Cache for ten days in public and private caches,
	// public caches should not transform the response
	// "Cache-Control: max-age=864000, public, no-transform"
	CacheControl ccCustom = CacheControl.maxAge(10, TimeUnit.DAYS).noTransform().cachePublic();
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// Cache for an hour - "Cache-Control: max-age=3600"
	val ccCacheOneHour = CacheControl.maxAge(1, TimeUnit.HOURS)

	// Prevent caching - "Cache-Control: no-store"
	val ccNoStore = CacheControl.noStore()

	// Cache for ten days in public and private caches,
	// public caches should not transform the response
	// "Cache-Control: max-age=864000, public, no-transform"
	val ccCustom = CacheControl.maxAge(10, TimeUnit.DAYS).noTransform().cachePublic()

----



[[webflux-caching-etag-lastmodified]]
=== Controllers
[.small]#<<web.adoc#mvc-caching-etag-lastmodified, Web MVC>>#

Controllers can add explicit support for HTTP caching. We recommend doing so, since the
`lastModified` or `ETag` value for a resource needs to be calculated before it can be compared
against conditional request headers. A controller can add an `ETag` and `Cache-Control`
settings to a `ResponseEntity`, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/book/{id}")
	public ResponseEntity<Book> showBook(@PathVariable Long id) {

		Book book = findBook(id);
		String version = book.getVersion();

		return ResponseEntity
				.ok()
				.cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))
				.eTag(version) // lastModified is also available
				.body(book);
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/book/{id}")
	fun showBook(@PathVariable id: Long): ResponseEntity<Book> {

		val book = findBook(id)
		val version = book.getVersion()

		return ResponseEntity
				.ok()
				.cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))
				.eTag(version) // lastModified is also available
				.body(book)
	}
----

The preceding example sends a 304 (NOT_MODIFIED) response with an empty body if the comparison
to the conditional request headers indicates the content has not changed. Otherwise, the
`ETag` and `Cache-Control` headers are added to the response.

You can also make the check against conditional request headers in the controller,
as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RequestMapping
	public String myHandleMethod(ServerWebExchange exchange, Model model) {

		long eTag = ... // <1>

		if (exchange.checkNotModified(eTag)) {
			return null; // <2>
		}

		model.addAttribute(...); // <3>
		return "myViewName";
	}
----
<1> Application-specific calculation.
<2> Response has been set to 304 (NOT_MODIFIED). No further processing.
<3> Continue with request processing.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RequestMapping
	fun myHandleMethod(exchange: ServerWebExchange, model: Model): String? {

		val eTag: Long = ... // <1>

		if (exchange.checkNotModified(eTag)) {
			return null// <2>
		}

		model.addAttribute(...) // <3>
		return "myViewName"
	}
----
<1> Application-specific calculation.
<2> Response has been set to 304 (NOT_MODIFIED). No further processing.
<3> Continue with request processing.

There are three variants for checking conditional requests against `eTag` values, `lastModified`
values, or both. For conditional `GET` and `HEAD` requests, you can set the response to
304 (NOT_MODIFIED). For conditional `POST`, `PUT`, and `DELETE`, you can instead set the response
to 412 (PRECONDITION_FAILED) to prevent concurrent modification.



[[webflux-caching-static-resources]]
=== Static Resources
[.small]#<<web.adoc#mvc-caching-static-resources, Web MVC>>#

You should serve static resources with a `Cache-Control` and conditional response headers
for optimal performance. See the section on configuring <<webflux-config-static-resources>>.




[[webflux-config]]
== WebFlux Config
[.small]#<<web.adoc#mvc-config, Web MVC>>#

The WebFlux Java configuration declares the components that are required to process
requests with annotated controllers or functional endpoints, and it offers an API to
customize the configuration. That means you do not need to understand the underlying
beans created by the Java configuration. However, if you want to understand them,
you can see them in `WebFluxConfigurationSupport` or read more about what they are
in <<webflux-special-bean-types>>.

For more advanced customizations, not available in the configuration API, you can
gain full control over the configuration through the
<<webflux-config-advanced-java>>.



[[webflux-config-enable]]
=== Enabling WebFlux Config
[.small]#<<web.adoc#mvc-config-enable, Web MVC>>#

You can use the `@EnableWebFlux` annotation in your Java config, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	public class WebConfig {
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebFlux
	class WebConfig
----

The preceding example registers a number of Spring WebFlux
<<webflux-special-bean-types, infrastructure beans>> and adapts to dependencies
available on the classpath -- for JSON, XML, and others.



[[webflux-config-customize]]
=== WebFlux config API
[.small]#<<web.adoc#mvc-config-customize, Web MVC>>#

In your Java configuration, you can implement the `WebFluxConfigurer` interface,
as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	public class WebConfig implements WebFluxConfigurer {

		// Implement configuration methods...
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
@Configuration
@EnableWebFlux
class WebConfig : WebFluxConfigurer {

	// Implement configuration methods...
}
----



[[webflux-config-conversion]]
=== Conversion, formatting
[.small]#<<web.adoc#mvc-config-conversion, Web MVC>>#

By default, formatters for various number and date types are installed, along with support
for customization via `@NumberFormat` and `@DateTimeFormat` on fields.

To register custom formatters and converters in Java config, use the following:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	public class WebConfig implements WebFluxConfigurer {

		@Override
		public void addFormatters(FormatterRegistry registry) {
			// ...
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebFlux
	class WebConfig : WebFluxConfigurer {

		override fun addFormatters(registry: FormatterRegistry) {
			// ...
		}
	}
----

By default Spring WebFlux considers the request Locale when parsing and formatting date
values. This works for forms where dates are represented as Strings with "input" form
fields. For "date" and "time" form fields, however, browsers use a fixed format defined
in the HTML spec. For such cases date and time formatting can be customized as follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	public class WebConfig implements WebFluxConfigurer {

		@Override
		public void addFormatters(FormatterRegistry registry) {
			DateTimeFormatterRegistrar registrar = new DateTimeFormatterRegistrar();
			registrar.setUseIsoFormat(true);
			registrar.registerFormatters(registry);
      	}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebFlux
	class WebConfig : WebFluxConfigurer {

		override fun addFormatters(registry: FormatterRegistry) {
			val registrar = DateTimeFormatterRegistrar()
			registrar.setUseIsoFormat(true)
			registrar.registerFormatters(registry)
		}
	}
----

NOTE: See <<core.adoc#format-FormatterRegistrar-SPI, `FormatterRegistrar` SPI>>
and the `FormattingConversionServiceFactoryBean` for more information on when to
use `FormatterRegistrar` implementations.



[[webflux-config-validation]]
=== Validation
[.small]#<<web.adoc#mvc-config-validation, Web MVC>>#

By default, if <<core.adoc#validation-beanvalidation-overview, Bean Validation>> is present
on the classpath (for example, the Hibernate Validator), the `LocalValidatorFactoryBean`
is registered as a global <<core.adoc#validator,validator>> for use with `@Valid` and
`@Validated` on `@Controller` method arguments.

In your Java configuration, you can customize the global `Validator` instance,
as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	public class WebConfig implements WebFluxConfigurer {

		@Override
		public Validator getValidator(); {
			// ...
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebFlux
	class WebConfig : WebFluxConfigurer {

		override fun getValidator(): Validator {
			// ...
		}

	}
----

Note that you can also register `Validator` implementations locally,
as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class MyController {

		@InitBinder
		protected void initBinder(WebDataBinder binder) {
			binder.addValidators(new FooValidator());
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	class MyController {

		@InitBinder
		protected fun initBinder(binder: WebDataBinder) {
			binder.addValidators(FooValidator())
		}
	}
----


TIP: If you need to have a `LocalValidatorFactoryBean` injected somewhere, create a bean and
mark it with `@Primary` in order to avoid conflict with the one declared in the MVC config.



[[webflux-config-content-negotiation]]
=== Content Type Resolvers
[.small]#<<web.adoc#mvc-config-content-negotiation, Web MVC>>#

You can configure how Spring WebFlux determines the requested media types for
`@Controller` instances from the request. By default, only the `Accept` header is checked,
but you can also enable a query parameter-based strategy.

The following example shows how to customize the requested content type resolution:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	public class WebConfig implements WebFluxConfigurer {

		@Override
		public void configureContentTypeResolver(RequestedContentTypeResolverBuilder builder) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebFlux
	class WebConfig : WebFluxConfigurer {

		override fun configureContentTypeResolver(builder: RequestedContentTypeResolverBuilder) {
			// ...
		}
	}
----



[[webflux-config-message-codecs]]
=== HTTP message codecs
[.small]#<<web.adoc#mvc-config-message-converters, Web MVC>>#

The following example shows how to customize how the request and response body are read and written:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	public class WebConfig implements WebFluxConfigurer {

		@Override
		public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebFlux
	class WebConfig : WebFluxConfigurer {

		override fun configureHttpMessageCodecs(configurer: ServerCodecConfigurer) {
			// ...
		}
	}
----

`ServerCodecConfigurer` provides a set of default readers and writers. You can use it to add
more readers and writers, customize the default ones, or replace the default ones completely.

For Jackson JSON and XML, consider using
{api-spring-framework}/http/converter/json/Jackson2ObjectMapperBuilder.html[`Jackson2ObjectMapperBuilder`],
which customizes Jackson's default properties with the following ones:

* https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/DeserializationFeature.html#FAIL_ON_UNKNOWN_PROPERTIES[`DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES`] is disabled.
* https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/MapperFeature.html#DEFAULT_VIEW_INCLUSION[`MapperFeature.DEFAULT_VIEW_INCLUSION`] is disabled.

It also automatically registers the following well-known modules if they are detected on the classpath:

* https://github.com/FasterXML/jackson-datatype-joda[`jackson-datatype-joda`]: Support for Joda-Time types.
* https://github.com/FasterXML/jackson-datatype-jsr310[`jackson-datatype-jsr310`]: Support for Java 8 Date and Time API types.
* https://github.com/FasterXML/jackson-datatype-jdk8[`jackson-datatype-jdk8`]: Support for other Java 8 types, such as `Optional`.
* https://github.com/FasterXML/jackson-module-kotlin[`jackson-module-kotlin`]: Support for Kotlin classes and data classes.



[[webflux-config-view-resolvers]]
=== View Resolvers
[.small]#<<web.adoc#mvc-config-view-resolvers, Web MVC>>#

The following example shows how to configure view resolution:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	public class WebConfig implements WebFluxConfigurer {

		@Override
		public void configureViewResolvers(ViewResolverRegistry registry) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebFlux
	class WebConfig : WebFluxConfigurer {

		override fun configureViewResolvers(registry: ViewResolverRegistry) {
			// ...
		}
	}
----

The `ViewResolverRegistry` has shortcuts for view technologies with which the Spring Framework
integrates. The following example uses FreeMarker (which also requires configuring the
underlying FreeMarker view technology):

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	public class WebConfig implements WebFluxConfigurer {


		@Override
		public void configureViewResolvers(ViewResolverRegistry registry) {
			registry.freeMarker();
		}

		// Configure Freemarker...

		@Bean
		public FreeMarkerConfigurer freeMarkerConfigurer() {
			FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
			configurer.setTemplateLoaderPath("classpath:/templates");
			return configurer;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebFlux
	class WebConfig : WebFluxConfigurer {
		
		override fun configureViewResolvers(registry: ViewResolverRegistry) {
			registry.freeMarker()
		}

		// Configure Freemarker...

		@Bean
		fun freeMarkerConfigurer() = FreeMarkerConfigurer().apply {
			setTemplateLoaderPath("classpath:/templates")
		}
	}
----

You can also plug in any `ViewResolver` implementation, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	public class WebConfig implements WebFluxConfigurer {


		@Override
		public void configureViewResolvers(ViewResolverRegistry registry) {
			ViewResolver resolver = ... ;
			registry.viewResolver(resolver);
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebFlux
	class WebConfig : WebFluxConfigurer {

		override fun configureViewResolvers(registry: ViewResolverRegistry) {
			val resolver: ViewResolver = ...
			registry.viewResolver(resolver
		}
	}
----

To support <<webflux-multiple-representations>> and rendering other formats
through view resolution (besides HTML), you can configure one or more default views based
on the `HttpMessageWriterView` implementation, which accepts any of the available
<<webflux-codecs>> from `spring-web`. The following example shows how to do so:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	public class WebConfig implements WebFluxConfigurer {


		@Override
		public void configureViewResolvers(ViewResolverRegistry registry) {
			registry.freeMarker();

			Jackson2JsonEncoder encoder = new Jackson2JsonEncoder();
			registry.defaultViews(new HttpMessageWriterView(encoder));
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebFlux
	class WebConfig : WebFluxConfigurer {


		override fun configureViewResolvers(registry: ViewResolverRegistry) {
			registry.freeMarker()

			val encoder = Jackson2JsonEncoder()
			registry.defaultViews(HttpMessageWriterView(encoder))
		}

		// ...
	}
----

See <<webflux-view>> for more on the view technologies that are integrated with Spring WebFlux.



[[webflux-config-static-resources]]
=== Static Resources
[.small]#<<web.adoc#mvc-config-static-resources, Web MVC>>#

This option provides a convenient way to serve static resources from a list of
{api-spring-framework}/core/io/Resource.html[`Resource`]-based locations.

In the next example, given a request that starts with `/resources`, the relative path is
used to find and serve static resources relative to `/static` on the classpath. Resources
are served with a one-year future expiration to ensure maximum use of the browser cache
and a reduction in HTTP requests made by the browser. The `Last-Modified` header is also
evaluated and, if present, a `304` status code is returned. The following list shows
the example:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	public class WebConfig implements WebFluxConfigurer {

		@Override
		public void addResourceHandlers(ResourceHandlerRegistry registry) {
			registry.addResourceHandler("/resources/**")
				.addResourceLocations("/public", "classpath:/static/")
				.setCacheControl(CacheControl.maxAge(365, TimeUnit.DAYS));
		}

	}
----
[source,kotlin,indent=0,subs="verbatim",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebFlux
	class WebConfig : WebFluxConfigurer {

		override fun addResourceHandlers(registry: ResourceHandlerRegistry) {
			registry.addResourceHandler("/resources/**")
					.addResourceLocations("/public", "classpath:/static/")
					.setCacheControl(CacheControl.maxAge(365, TimeUnit.DAYS))
		}
	}
----

// TODO: See also <<webflux-caching-static-resources, HTTP caching support for static resources>>.

The resource handler also supports a chain of
{api-spring-framework}/web/reactive/resource/ResourceResolver.html[`ResourceResolver`] implementations and
{api-spring-framework}/web/reactive/resource/ResourceTransformer.html[`ResourceTransformer`] implementations,
which can be used to create a toolchain for working with optimized resources.

You can use the `VersionResourceResolver` for versioned resource URLs based on an MD5 hash
computed from the content, a fixed application version, or other information. A
`ContentVersionStrategy` (MD5 hash) is a good choice with some notable exceptions (such as
JavaScript resources used with a module loader).

The following example shows how to use `VersionResourceResolver` in your Java configuration:

[source,java,indent=0,subs="verbatim",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	public class WebConfig implements WebFluxConfigurer {

		@Override
		public void addResourceHandlers(ResourceHandlerRegistry registry) {
			registry.addResourceHandler("/resources/**")
					.addResourceLocations("/public/")
					.resourceChain(true)
					.addResolver(new VersionResourceResolver().addContentVersionStrategy("/**"));
		}

	}
----
[source,kotlin,indent=0,subs="verbatim",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebFlux
	class WebConfig : WebFluxConfigurer {

		override fun addResourceHandlers(registry: ResourceHandlerRegistry) {
			registry.addResourceHandler("/resources/**")
					.addResourceLocations("/public/")
					.resourceChain(true)
					.addResolver(VersionResourceResolver().addContentVersionStrategy("/**"))
		}

	}
----

You can use `ResourceUrlProvider` to rewrite URLs and apply the full chain of resolvers and
transformers (for example, to insert versions). The WebFlux configuration provides a `ResourceUrlProvider`
so that it can be injected into others.

Unlike Spring MVC, at present, in WebFlux, there is no way to transparently rewrite static
resource URLs, since there are no view technologies that can make use of a non-blocking chain
of resolvers and transformers. When serving only local resources, the workaround is to use
`ResourceUrlProvider` directly (for example, through a custom element) and block.

Note that, when using both `EncodedResourceResolver` (for example, Gzip, Brotli encoded) and
`VersionedResourceResolver`, they must be registered in that order, to ensure content-based
versions are always computed reliably based on the unencoded file.

https://www.webjars.org/documentation[WebJars] are also supported through the
`WebJarsResourceResolver` which is automatically registered when the
`org.webjars:webjars-locator-core` library is present on the classpath. The resolver can
re-write URLs to include the version of the jar and can also match against incoming URLs
without versions -- for example, from `/jquery/jquery.min.js` to
`/jquery/1.2.0/jquery.min.js`.



[[webflux-config-path-matching]]
=== Path Matching
[.small]#<<web.adoc#mvc-config-path-matching, Web MVC>>#

You can customize options related to path matching. For details on the individual options, see the
{api-spring-framework}/web/reactive/config/PathMatchConfigurer.html[`PathMatchConfigurer`] javadoc.
The following example shows how to use `PathMatchConfigurer`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	public class WebConfig implements WebFluxConfigurer {

		@Override
		public void configurePathMatch(PathMatchConfigurer configurer) {
			configurer
				.setUseCaseSensitiveMatch(true)
				.setUseTrailingSlashMatch(false)
				.addPathPrefix("/api",
						HandlerTypePredicate.forAnnotation(RestController.class));
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebFlux
	class WebConfig : WebFluxConfigurer {

		@Override
		fun configurePathMatch(configurer: PathMatchConfigurer) {
			configurer
				.setUseCaseSensitiveMatch(true)
				.setUseTrailingSlashMatch(false)
				.addPathPrefix("/api",
						HandlerTypePredicate.forAnnotation(RestController::class.java))
		}
	}
----

[TIP]
====
Spring WebFlux relies on a parsed representation of the request path called
`RequestPath` for access to decoded path segment values, with semicolon content removed
(that is, path or matrix variables). That means, unlike in Spring MVC, you need not indicate
whether to decode the request path nor whether to remove semicolon content for
path matching purposes.

Spring WebFlux also does not support suffix pattern matching, unlike in Spring MVC, where we
are also <<web.adoc#mvc-ann-requestmapping-suffix-pattern-match, recommend>> moving away from
reliance on it.
====



[[webflux-config-advanced-java]]
=== Advanced Configuration Mode
[.small]#<<web.adoc#mvc-config-advanced-java, Web MVC>>#

`@EnableWebFlux` imports `DelegatingWebFluxConfiguration` that:

*  Provides default Spring configuration for WebFlux applications

* detects and delegates to `WebFluxConfigurer` implementations to customize that configuration.

For advanced mode, you can remove `@EnableWebFlux` and extend directly from
`DelegatingWebFluxConfiguration` instead of implementing `WebFluxConfigurer`,
as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class WebConfig extends DelegatingWebFluxConfiguration {

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class WebConfig : DelegatingWebFluxConfiguration {

		// ...
	}
----

You can keep existing methods in `WebConfig`, but you can now also override bean declarations
from the base class and still have any number of other `WebMvcConfigurer` implementations on
the classpath.




[[webflux-http2]]
== HTTP/2
[.small]#<<web.adoc#mvc-http2, Web MVC>>#

HTTP/2 is supported with Reactor Netty, Tomcat, Jetty, and Undertow. However, there are
considerations related to server configuration. For more details, see the
https://github.com/spring-projects/spring-framework/wiki/HTTP-2-support[HTTP/2 wiki page].
