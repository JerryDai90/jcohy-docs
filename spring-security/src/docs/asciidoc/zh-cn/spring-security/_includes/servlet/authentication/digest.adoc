
[[digest-processing-filter]]
== DigestAuthenticationFilter
`DigestAuthenticationFilter` 能够处理HTTP请求头中提供的摘要身份验证凭据。摘要式身份验证试图解决基本身份验证的许多弱点，特别是通过确保凭据不会以明文形式通过网络发送来解决。许多用户代理都支持摘要式身份验证，包括Mozilla Firefox和Internet Explorer。 HTTP摘要认证的标准由RFC 2617定义，该标准更新了RFC 2069规定的摘要认证的早期版本。
大多数用户代理实现RFC2617。SpringSecurity的 `DigestAuthenticationFilter` 与 "`auth`" 保护质量（qop）兼容由RFC 2617所规定，它也提供与RFC 2069的向后兼容性。如果您需要使用未加密的HTTP（即没有TLS / HTTPS）并且希望最大程度地提高身份验证过程的安全性，则摘要身份验证是一种更具吸引力的选择。实际上，如RFC 2518第17.1节所述，摘要式身份验证是WebDAV协议的强制性要求。

[NOTE]
====
您不应该在现代应用程序中使用Digest，因为它不安全。 最明显的问题是您必须以纯文本，加密或MD5格式存储密码。 所有这些存储格式都被认为是不安全的。 相反，您应该使用一种单向自适应密码哈希（即bCrypt，PBKDF2，SCrypt等）。
====

Digest 认证的核心是“一次性”。 这是服务器生成的值。 Spring Security的随机数采用以下格式：

[source,txt]
----
base64(expirationTime + ":" + md5Hex(expirationTime + ":" + key))
expirationTime:   The date and time when the nonce expires, expressed in milliseconds
key:              A private key to prevent modification of the nonce token
----

`DigestAuthenticationEntryPoint` 具有一个属性，该属性指定用于生成随机数令牌的密钥，以及一个 `nonceValiditySeconds` 属性，用于确定到期时间（默认值300，等于五分钟）。在随机数有效的情况下，摘要是通过串联各种字符串来计算的，
这些字符串包括用户名，密码，随机数，所请求的URI，客户端生成的随机数（仅由用户代理生成每个请求的随机值），领域名称等，然后执行MD5哈希。服务器和用户代理都执行此摘要计算，如果它们不同意包含的值（例如密码），
则会产生不同的哈希码。在Spring Security实现中，如果服务器生成的随机数刚刚过期（但摘要有效），则 `DigestAuthenticationEntryPoint` 将发送 `"stale = true"` 标头。这告诉用户代理无需打扰用户（因为密码和用户名等是正确的），而只需使用新的随机数重试即可。

`DigestAuthenticationEntryPoint` 的 `nonceValiditySeconds` 参数的适当值取决于您的应用程序。
极其安全的应用程序应注意，在达到随机数所包含的 `expirationTime` 之前，可以使用拦截的身份验证头来模拟主体。 这是选择适当设置时的关键原则，但是对于非常安全的应用程序，在最初的情况下不会在 TLS/HTTPS 上运行是不寻常的。

由于Digest 认证的实施更为复杂，因此经常会出现用户代理问题。 例如，Internet Explorer无法在同一会话中的后续请求上提供 "`opaque`" 令牌。
因此，Spring Security过滤器将所有状态信息封装到 "`nonce`" 令牌中。 在我们的测试中，Spring Security的实现可与Mozilla Firefox和Internet Explorer可靠地配合，正确处理随机数超时等。

[[digest-config]]
=== 配置
现在，我们已经对理论进行了回顾，让我们看看如何使用它。 要实现HTTP Digest 认证，必须在过滤器链中定义 `DigestAuthenticationFilter`。 应用程序上下文将需要定义 `DigestAuthenticationFilter` 及其必需的协作者：

[source,xml]
----
<bean id="digestFilter" class=
	"org.springframework.security.web.authentication.www.DigestAuthenticationFilter">
<property name="userDetailsService" ref="jdbcDaoImpl"/>
<property name="authenticationEntryPoint" ref="digestEntryPoint"/>
<property name="userCache" ref="userCache"/>
</bean>

<bean id="digestEntryPoint" class=
	"org.springframework.security.web.authentication.www.DigestAuthenticationEntryPoint">
<property name="realmName" value="Contacts Realm via Digest Authentication"/>
<property name="key" value="acegi"/>
<property name="nonceValiditySeconds" value="10"/>
</bean>
----

需要配置的 `UserDetailsService`，因为 `DigestAuthenticationFilter` 必须直接访问用户的明文密码。 如果您在DAO footnote:[如果将 `DigestAuthenticationFilter.passwordAlreadyEncoded` 设置为 `true`，则可以将密码编码为 `HEX(MD5(username:realm:password))`格式。但是，其他密码编码将不适用于摘要身份验证。]中使用编码的密码，则Digest 认证将不起作用。
DAO协作者以及 `UserCache` 通常直接与 `DaoAuthenticationProvider` 共享。 `authenticationEntryPoint` 属性必须是 `DigestAuthenticationEntryPoint`，以便 `DigestAuthenticationFilter` 可以获取正确的 `realmName` 和用于摘要计算的密钥。

与 `BasicAuthenticationFilter` 一样，如果身份验证成功，则会将身份验证请求令牌放入 `SecurityContextHolder` 中。 如果身份验证事件成功，或者由于HTTP标头不包含摘要身份验证请求而未尝试身份验证，则过滤器链将照常继续。
如上一段所述，只有当身份验证失败并调用 `AuthenticationEntryPoint` 时，过滤器链才会被中断。

 Digest 认证的RFC提供了一系列附加功能，以进一步提高安全性。 例如，可以在每个请求上更改随机数。 尽管如此，Spring Security实现仍被设计为使实现的复杂性最小化（以及无疑会出现的用户代理不兼容性），并避免需要存储服务器端状态。
如果您希望更详细地探索这些功能，则可以邀请您阅读RFC 2617。 据我们所知，Spring Security的实现确实符合此RFC的最低标准。