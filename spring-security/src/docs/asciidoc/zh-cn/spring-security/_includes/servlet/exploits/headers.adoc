[[headers]]
[[ns-headers]]
= 安全HTTP响应头
本节讨论了Spring Security添加响应头的支持。

== 默认安全请求头
Spring Security允许用户轻松注入默认的安全头，以帮助保护其应用程序。
Spring Security的默认值为包含以下请求头：

[source,http]
----
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Content-Type-Options: nosniff
Strict-Transport-Security: max-age=31536000 ; includeSubDomains
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
----

NOTE: 仅在HTTPS请求上添加严格传输安全性

有关这些请求头中的每个头部的更多详细信息，请参阅相应的部分：

* <<headers-cache-control,缓存控制>>
* <<headers-content-type-options,Content Type 选项>>
* <<headers-hsts,HTTP严格传输安全>>
* <<headers-frame-options,X-Frame-Options>>
* <<headers-xss-protection,X-XSS-Protection>>

虽然这些头标头中的每一个均被视为最佳实践，但应注意，并非所有客户端都使用标头，因此鼓励进行其他测试。

您可以自定义特定的标头。 例如，假设希望您的HTTP响应头如下所示：

[source,http]
----
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Content-Type-Options: nosniff
X-Frame-Options: SAMEORIGIN
X-XSS-Protection: 1; mode=block
----

具体来说，您希望所有默认标头都具有以下自定义设置：

* <<headers-frame-options,X-Frame-Options>> 允许来自相同域的任何请求
* <<headers-hsts,HTTP Strict Transport Security (HSTS)>> 不会添加到响应中不会添加到响应中

您可以使用以下Java配置轻松完成此操作

[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
		WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers ->
			    headers
				    .frameOptions(frameOptions ->
				        frameOptions.sameOrigin()
				    )
				    .httpStrictTransportSecurity(hsts ->
				        hsts.disable()
				    )
			);
	}
}
----

另外，如果您使用的是Spring Security XML Configuration，则可以使用以下代码：

[source,xml]
----
<http>
	<!-- ... -->

	<headers>
		<frame-options policy="SAMEORIGIN" />
		<hsts disable="true"/>
	</headers>
</http>
----

如果您不想添加默认值，并且希望对应使用的内容进行明确控制，则可以禁用默认值。 下面提供了基于Java和XML的配置示例：

如果您使用的是Spring Security的Java配置，则以下内容只会添加<<headers-cache-control,Cache Control>>。


[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // ...
            .headers(headers ->
                headers
                    // do not use any default headers unless explicitly listed
                    .defaultsDisabled()
                    .cacheControl(withDefaults())
            );
    }
}
----

以下XML将仅添加 <<headers-cache-control,Cache Control>>。

[source,xml]
----
<http>
	<!-- ... -->

	<headers defaults-disabled="true">
		<cache-control/>
	</headers>
</http>
----


如有必要，可以使用以下Java配置禁用所有HTTP安全响应头：

[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // ...
            .headers(headers ->
                headers.disable()
            );
    }
}
----

如有必要，您可以使用以下XML配置禁用所有HTTP安全响应头：

[source,xml]
----
<http>
	<!-- ... -->

	<headers disabled="true" />
</http>
----

[[headers-cache-control]]
== 缓存控制
过去，Spring Security要求您为Web应用程序提供自己的缓存控件。 当时看来这是合理的，但是浏览器缓存已经演变为包括用于安全连接的缓存。
这意味着用户可以查看经过身份验证的页面，然后注销，然后恶意用户可以使用浏览器历史记录来查看缓存的页面。 为了帮助缓解这种情况，Spring Security添加了缓存控制支持，该支持将在响应中插入以下标头。

[source]
----
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
----

只需添加没有子元素的  <<nsa-headers,<headers>>> 元素即可自动添加Cache Control和许多其他保护。 但是，如果只希望缓存控制，则可以使用Spring Security的XML名称空间通过  <<nsa-cache-control,<cache-control>>>  元素和 <<nsa-headers-defaults-disabled,headers@defaults-disabled>>  属性来启用此功能。

[source,xml]
----
<http>
	<!-- ... -->

	<headers defaults-disable="true">
		<cache-control />
	</headers>
</http>
----

同样，您可以使用以下命令在Java配置中仅启用缓存控制：

[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // ...
            .headers(headers ->
                headers
                    .defaultsDisabled()
                    .cacheControl(withDefaults())
            );
    }
}
----

如果您确实想缓存特定的响应，则您的应用程序可以有选择地调用 https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletResponse.html#setHeader(java.lang.String,java.lang.String)[HttpServletResponse.setHeader(String,String)] 来覆盖Spring Security设置的标头。 这对于确保正确缓存CSS，JavaScript和图像之类的内容很有用。

使用Spring Web MVC时，通常是在您的配置中完成。 例如，以下配置将确保为所有资源设置缓存头：

[source,java]
----
@EnableWebMvc
public class WebMvcConfiguration implements WebMvcConfigurer {

	@Override
	public void addResourceHandlers(ResourceHandlerRegistry registry) {
		registry
			.addResourceHandler("/resources/**")
			.addResourceLocations("/resources/")
			.setCachePeriod(31556926);
	}

	// ...
}
----

[[headers-content-type-options]]
== Content Type 选项
历史上，包括Internet Explorer在内的浏览器都会尝试使用 https://en.wikipedia.org/wiki/Content_sniffing[content sniffing] 来猜测请求的内容类型。 这允许浏览器通过猜测未指定内容类型的资源上的内容类型来改善用户体验。 例如，如果浏览器遇到一个未指定内容类型的JavaScript文件，它将能够猜测该内容类型然后执行。

[NOTE]
允许上传内容时，还有许多其他事情（即，仅在不同的域中显示文档，确保设置了Content-Type标头，清理文档等）。 但是，这些措施不在Spring Security提供的范围之内。 指出禁用内容嗅探时也很重要，您必须指定内容类型才能使内容正常工作。

内容嗅探的问题在于，这允许恶意用户使用多义词（即，可以作为多种内容类型有效的文件）执行XSS攻击。 例如，某些网站可能允许用户向网站提交有效的附言文档并进行查看。 恶意用户可能会创建一个也是 http://webblaze.cs.berkeley.edu/papers/barth-caballero-song.pdf[有效JavaScript文件的Postscript文档]，并对其执行XSS攻击。

可以通过在响应中添加以下标头来禁用内容嗅探：

[source]
----
X-Content-Type-Options: nosniff
----

与高速缓存控制元素一样，在使用不带子元素的<headers>元素时，默认情况下会添加nosniff指令。 但是，如果您想更多地控制添加哪些标题，可以使用  <<nsa-content-type-options,<content-type-options>>>  元素和 <<nsa-headers-defaults-disabled,headers@defaults-disabled>> 属性，如下所示：

[source,xml]
----
<http>
	<!-- ... -->

	<headers defaults-disabled="true">
		<content-type-options />
	</headers>
</http>
----

默认情况下，Spring Security Java配置添加了X-Content-Type-Options标头。如果要对标题进行更多控制，则可以使用以下命令显式指定内容类型选项：

[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // ...
            .headers(headers ->
                headers
                    .defaultsDisabled()
                    .contentTypeOptions(withDefaults())
            );
    }
}
----

[[headers-hsts]]
== HTTP Strict Transport Security (HSTS)
当您输入您的银行的网站，您进入 mybank.example.com 或进入 https://mybank.example.com[] 如果您忽略了 https 协议，您可能会受到 https://en.wikipedia.org/wiki/Man-in-the-middle_attack[中间人攻击]。
即使网站执行重定向到 https://mybank.example.com， 恶意用户也可以截获初始HTTP请求并操纵响应(即重定向到  https://mibank.example.com  并窃取他们的凭证)。

许多用户忽略了https协议，这就是创建HTTP https://tools.ietf.org/html/rfc6797[严格传输安全性（HSTS）]的原因。 将 mybank.example.com 添加为 https://tools.ietf.org/html/rfc6797#section-5.1[HSTS主机] 后，浏览器可以提前知道对 mybank.example.com 的任何请求都应解释为https://mybank.example.com。 这大大降低了发生中间人攻击的可能性。

[NOTE]
根据 https://tools.ietf.org/html/rfc6797#section-7.2[RFC6797]，HSTS头仅注入到HTTPS响应中。 为了使浏览器能够确认标头，浏览器必须首先信任对用于建立连接的SSL证书（不仅仅是SSL证书）进行签名的CA。

将站点标记为HSTS主机的一种方法是将主机预加载到浏览器中。 另一方法是将“ Strict-Transport-Security”标头添加到响应中。 例如，以下内容将指示浏览器将域视为一年的HSTS主机（一年大约31536000秒）：

[source]
----
Strict-Transport-Security: max-age=31536000 ; includeSubDomains ; preload
----

可选的includeSubDomains指令指示Spring Security子域（即secure.mybank.example.com）也应被视为HSTS域。

可选的preload指令指示Spring Security该域应在浏览器中预加载为HSTS域。 有关HSTS预加载的更多详细信息，请参见 https://hstspreload.org。

与其他头文件一样，Spring Security默认添加HSTS。 您可以使用 <<nsa-hsts,<hsts>>> 元素来自定义HSTS标头，如下所示：

[source,xml]
----
<http>
	<!-- ... -->

	<headers>
		<hsts
			include-subdomains="true"
			max-age-seconds="31536000" preload="true" />
	</headers>
</http>
----

同样，您只能使用Java配置启用HSTS标头：

[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // ...
            .headers(headers ->
                headers
                    .httpStrictTransportSecurity(hsts ->
                        hsts
                            .includeSubDomains(true)
                            .preload(true)
                            .maxAgeInSeconds(31536000)
                    )
            );
    }
}
----

[[headers-hpkp]]
== HTTP Public Key Pinning (HPKP)
HTTP Public Key Pinning（HPKP）是一项安全功能，它告诉Web客户端将特定的加密公共密钥与某个Web服务器相关联，以防止使用伪造证书的中间人（MITM）攻击。

为了确保TLS会话中使用的服务器公钥的真实性，此公钥被包装到X.509证书中，该证书通常由证书颁发机构（CA）签名。 浏览器之类的Web客户端信任许多这样的CA，它们都可以为任意域名创建证书。
如果攻击者能够入侵单个CA，则他们可以对各种TLS连接执行MITM攻击。 HPKP可以通过告诉客户端哪个公钥属于某个Web服务器来规避HTTPS协议的这种威胁。 HPKP是首次使用信任（TOFU）技术。
Web服务器第一次通过特殊的HTTP标头告知客户端哪个公钥属于它时，客户端会在给定的时间段内存储此信息。 当客户端再次访问服务器时，它期望包含公钥的证书，该公钥的指纹已经通过HPKP知道。 如果服务器提供了未知的公共密钥，则客户端应向用户显示警告。

[NOTE]
由于用户代理需要根据SSL证书链验证引脚，因此HPKP标头仅注入HTTPS响应中。

通过HTTPS访问网站时，为您的网站启用此功能就像返回Public-Key-Pins HTTP标头一样简单。 例如，以下内容将指示用户代理仅将2个引脚的引脚验证失败报告给指定的URI（通过  https://tools.ietf.org/html/rfc7469#section-2.1.4[*_report-uri_*]  指令）：

[source]
----
Public-Key-Pins-Report-Only: max-age=5184000 ; pin-sha256="d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=" ; pin-sha256="E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=" ; report-uri="https://example.net/pkp-report" ; includeSubDomains
----

https://tools.ietf.org/html/rfc7469#section-3[*_pin validation failure report_*]  是一种标准的JSON结构，可以通过Web应用程序自己的API或公共托管的HPKP报告服务（例如 https://report-uri.io/[*_REPORT-URI_*] ）捕获。

可选的includeSubDomains指令指示浏览器也使用给定的引脚来验证子域。

与其他标头相反，Spring Security默认情况下不添加HPKP。 您可以使用e <<nsa-hpkp,<hpkp>>> 元素来自定义HPKP标头，如下所示：

[source,xml]
----
<http>
	<!-- ... -->

	<headers>
		<hpkp
			include-subdomains="true"
			report-uri="https://example.net/pkp-report">
			<pins>
					<pin algorithm="sha256">d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=</pin>
					<pin algorithm="sha256">E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=</pin>
			</pins>
		</hpkp>
	</headers>
</http>
----

同样，您可以使用Java配置启用HPKP标头：

[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers ->
			    headers
					.httpPublicKeyPinning(hpkp ->
					    hpkp
							.includeSubDomains(true)
							.reportUri("https://example.net/pkp-report")
							.addSha256Pins("d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=", "E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=")
				    )
			);
	}
}
----

[[headers-frame-options]]
== X-Frame-Options
允许将您的网站添加到框架可能是一个安全问题。 例如，使用聪明的CSS样式用户可能会被诱骗点击他们不想要的内容（https://www.youtube.com/watch?v=3mk0RySeNsU[视频演示]）。 例如，登录到其银行的用户可以单击将按钮授予其他用户访问权限。 这种攻击称为 https://en.wikipedia.org/wiki/Clickjacking[Clickjacking]。

[NOTE]
处理点击劫持的另一种现代方法是使用<<headers-csp,第14.2.8节“内容安全策略（CSP）” >>.

有许多方法可以缓解点击劫持攻击。 例如，要保护旧版浏览器免遭点击劫持攻击，可以使用分帧代码。 虽然不完美，但是对于传统浏览器而言， https://www.owasp.org/index.php/Clickjacking_Defense_Cheat_Sheet#Best-for-now_Legacy_Browser_Frame_Breaking_Script[frame breaking code] 是最好的选择。

解决点击劫持的更现代方法是使用 https://developer.mozilla.org/en-US/docs/HTTP/X-Frame-Options[X-Frame-Options]  头：

[source]
----
X-Frame-Options: DENY
----

X-Frame-Options响应标头指示浏览器阻止响应中带有此标头的任何网站呈现在框架中。 默认情况下，Spring Security禁用iframe中的呈现。

您可以使用 <<nsa-frame-options,frame-options>> 元素来自定义X-Frame-Options。 例如，以下内容将指示Spring Security使用 "X-Frame-Options:SAMEORIGIN"，它允许在同一域内的iframe：

[source,xml]
----
<http>
	<!-- ... -->

	<headers>
		<frame-options
		policy="SAMEORIGIN" />
	</headers>
</http>
----

同样，您可以使用以下方法自定义框架选项以在Java配置中使用相同的来源：

[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // ...
            .headers(headers ->
                headers
                    .frameOptions(frameOptions ->
                        frameOptions
                            .sameOrigin()
                    )
            );
    }
}
----

[[headers-xss-protection]]
== X-XSS-Protection
一些浏览器内置了对过滤掉 https://www.owasp.org/index.php/Testing_for_Reflected_Cross_site_scripting_(OWASP-DV-001)[reflected XSS attacks]的支持。 这绝非万无一失，但确实有助于XSS保护。

通常默认情况下会启用过滤，因此添加标头通常只会确保标头已启用，并指示浏览器在检测到XSS攻击时应采取的措施。
例如，过滤器可能会尝试以最小侵入性的方式更改内容以仍然呈现所有内容。 有时，这种替换本身可能会成为 https://hackademix.net/2009/11/21/ies-xss-filter-creates-xss-vulnerabilities/[XSS漏洞本身]。 相反，最好是阻止内容，而不要尝试对其进行修复。 为此，我们可以添加以下标头：

[source]
----
X-XSS-Protection: 1; mode=block
----

默认情况下包含此标头。但是，我们可以根据需要自定义它。例如：

[source,xml]
----
<http>
	<!-- ... -->

	<headers>
		<xss-protection block="false"/>
	</headers>
</http>
----

同样，您可以使用以下命令在Java配置中自定义XSS保护：

[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // ...
            .headers(headers ->
                headers
                    .xssProtection(xssProtection ->
                        xssProtection
                            .block(false)
                    )
            );
    }
}
----

[[headers-csp]]
== Content Security Policy (CSP)

https://www.w3.org/TR/CSP2/[Content Security Policy (CSP)] 是Web应用程序可以利用的一种机制，可以缓解诸如跨站点脚本（XSS）之类的内容注入漏洞。 CSP是一种声明性策略，为Web应用程序作者提供了一种工具，可以声明该Web应用程序希望从中加载资源的来源，并最终将这些信息通知客户端（用户代理）。

[NOTE]
内容安全策略并非旨在解决所有内容注入漏洞。 取而代之的是，可以利用CSP帮助减少内容注入攻击所造成的危害。 作为第一道防线，Web应用程序作者应验证其输入并对其输出进行编码。

Web应用程序可以通过在响应中包括以下HTTP标头之一来使用CSP：

* *_Content-Security-Policy_*
* *_Content-Security-Policy-Report-Only_*

这些标头中的每一个都用作将 *_安全策略传递_* 给客户端的机制。 安全策略包含一组 *_安全策略指令_*（例如 _script-src_ 和 _object-src_ ），每个指令负责声明对特定资源表示形式的限制。

例如，Web应用程序可以通过在响应中包含以下标头来声明它希望从特定的受信任源中加载脚本：

[source]
----
Content-Security-Policy: script-src https://trustedscripts.example.com
----

用户代理会阻止尝试从另一个源（而不是 _script-src_ 指令中声明的内容）加载脚本。 此外，如果在安全策略中声明了  https://www.w3.org/TR/CSP2/#directive-report-uri[*_report-uri_*]  指令，则用户代理会将违反行为报告给声明的URL。

例如，如果Web应用程序违反了已声明的安全策略，则以下响应标头将指示用户代理将违规报告发送到策略的  _report-uri_  指令中指定的URL。

[source]
----
Content-Security-Policy: script-src https://trustedscripts.example.com; report-uri /csp-report-endpoint/
----

https://www.w3.org/TR/CSP2/#violation-reports[*_Violation reports_*] 是标准的JSON结构，可以由Web应用程序自己的API或公共托管的CSP违规报告服务（例如 https://report-uri.io/[*_REPORT-URI_*]）捕获。

Content-Security-Policy-Report-Only标头为Web应用程序作者和管理员提供了监视安全策略而不是强制执行这些策略的功能。 该标题通常在试验和/或开发站点的安全策略时使用。 当某个策略被认为有效时，可以通过使用  _Content-Security-Policy_  标头字段来强制实施。

给定以下响应头，该策略声明可以从两个可能的来源之一加载脚本。

[source]
----
Content-Security-Policy-Report-Only: script-src 'self' https://trustedscripts.example.com; report-uri /csp-report-endpoint/
----

如果站点违反了此策略，则通过尝试从  _evil.com_ 加载脚本，用户代理会将违规报告发送到  _report-uri_  指令指定的声明URL，但是仍然允许违规资源加载。

[[headers-csp-configure]]
=== 配置内容安全策略

请注意，Spring Security默认不会添加内容安全策略。 Web应用程序作者必须声明安全策略以强制执行和/或监视受保护的资源。

例如，给定以下安全策略：

[source]
----
script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/
----

您可以使用带有 <<nsa-content-security-policy,<content-security-policy>>> 元素的XML配置来启用CSP标头，如下所示：

[source,xml]
----
<http>
	<!-- ... -->

	<headers>
		<content-security-policy
			policy-directives="script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/" />
	</headers>
</http>
----

要启用CSP _'report-only'_ 标头，请按以下方式配置元素：

[source,xml]
----
<http>
	<!-- ... -->

	<headers>
		<content-security-policy
			policy-directives="script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"
			report-only="true" />
	</headers>
</http>
----

同样，您可以使用Java配置启用CSP标头，如下所示：

[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // ...
            .headers(headers ->
                headers
                    .contentSecurityPolicy(csp ->
                        csp
                            .policyDirectives("script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/")
                       )
            );
    }
}
----

要启用CSP _'report-only'_  标头，请提供以下Java配置：

[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // ...
            .headers(headers ->
                headers
                    .contentSecurityPolicy(csp ->
                        csp
                            .policyDirectives("script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/")
                            .reportOnly()
                    )
            );
    }
}
----

[[headers-csp-links]]
=== 其他资源
将内容安全策略应用于Web应用程序通常是一项艰巨的任务。 以下资源可以为您的站点制定有效的安全策略提供进一步的帮助。

https://www.html5rocks.com/en/tutorials/security/content-security-policy/[内容安全策略简介]

https://developer.mozilla.org/en-US/docs/Web/Security/CSP[CSP指南-Mozilla开发人员网络]

https://www.w3.org/TR/CSP2/[W3C候选人推荐]

[[headers-referrer]]
== 推荐人策略

https://www.w3.org/TR/referrer-policy[Referrer Policy] 是一种机制，Web应用程序可以利用该机制来管理引荐来源网址字段，该字段包含用户所在的最后一页。 Spring Security的方法是使用 https://www.w3.org/TR/referrer-policy/[Referrer Policy] 头，该标头提供了不同的https://www.w3.org/TR/referrer-policy/#referrer-policies[策略]：

[source]
----
Referrer-Policy: same-origin
----

Referrer-Policy响应头指示浏览器让目的地知道用户先前所在的源。

[[headers-referrer-configure]]
=== 配置推荐人策略

Spring Security默认情况下不添加Referrer Policy标头。 您可以使用带有  <<nsa-referrer-policy,<referrer-policy>>>  元素的XML配置来启用Referrer-Policy标头，如下所示：

[source,xml]
----
<http>
	<!-- ... -->

	<headers>
		<referrer-policy policy="same-origin" />
	</headers>
</http>
----

同样，您可以使用Java配置启用Referrer Policy标头，如下所示：

[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // ...
            .headers(headers ->
                headers
                    .referrerPolicy(referrerPolicy ->
                        referrerPolicy
                            .policy(ReferrerPolicy.SAME_ORIGIN)
                    )
            );
    }
}
----


[[headers-feature]]
== Feature Policy （功能策略）

https://wicg.github.io/feature-policy/[Feature Policy] 功能策略是一种机制，允许Web开发人员在浏览器中选择性地启用，禁用和修改某些API和Web功能的行为。

[source]
----
Feature-Policy: geolocation 'self'
----

借助功能策略，开发人员可以为浏览器选择一套“策略”，以实施整个站点中使用的特定功能。 这些政策限制了网站可以访问或修改某些功能的浏览器默认行为的API。

[[headers-feature-configure]]
=== 配置功能策略

Spring Security默认不添加功能策略标头。 您可以使用带有 <<nsa-feature-policy,<feature-policy>>> 元素的XML配置来启用Feature-Policy标头，如下所示：

[source,xml]
----
<http>
	<!-- ... -->

	<headers>
		<feature-policy policy-directives="geolocation 'self'" />
	</headers>
</http>
----

同样，您可以使用Java配置启用功能策略标头，如下所示：

[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // ...
            .headers(headers ->
                headers
                    .featurePolicy("geolocation 'self'")
            );
    }
}
----

[[headers-clearsitedata]]
== 清除站点数据

https://www.w3.org/TR/clear-site-data/[Clear Site Data] 清除站点数据是一种机制，通过该机制，当HTTP响应包含以下标头时，可以删除所有浏览器端数据（Cookie，本地存储等）：

[source]
----
Clear-Site-Data: "cache", "cookies", "storage", "executionContexts"
----

这是注销时执行的不错的清理操作。

[[headers-clearsitedata-configure]]
=== 配置清除站点数据

Spring Security默认不会添加“清除站点数据”标头。 您可以将应用程序配置为在注销时发送此标头，如下所示：

[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // ...
            .logout()
                .addLogoutHandler(new HeaderWriterLogoutHandler(new ClearSiteDataHeaderWriter(CACHE, COOKIES)));
    }
}
----

[NOTE]
不建议您通过 `headers()` 指令配置此标题编写器。这样做的原因是，将删除任何会话状态（例如  `JSESSIONID` cookie），从而有效地注销用户。

[[headers-custom]]
== 自定义 Headers
Spring Security具有使您可以方便地将更常见的安全标头添加到您的应用程序的机制。但是，它也提供了挂钩来启用添加自定义标头。

[[headers-static]]
=== Static Headers
有时您可能希望将不支持的自定义安全标头注入应用程序中。例如，给定以下自定义安全标头：

[source]
----
X-Custom-Security-Header: header-value
----

使用XML名称空间时，可以使用 <<nsa-header,<header>>>  元素将这些标头添加到响应中，如下所示：

[source,xml]
----
<http>
	<!-- ... -->

	<headers>
		<header name="X-Custom-Security-Header" value="header-value"/>
	</headers>
</http>
----

同样，可以使用Java配置将标头添加到响应中，如下所示：

[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // ...
            .headers(headers ->
                headers
                    .addHeaderWriter(new StaticHeadersWriter("X-Custom-Security-Header","header-value"))
            );
    }
}
----

[[headers-writer]]
=== Headers Writer
如果名称空间或Java配置不支持所需的标头，则可以创建自定义的 `HeadersWriter` 实例，甚至提供 `HeadersWriter` 的自定义实现。

让我们看一个使用 `XFrameOptionsHeaderWriter` 的自定义实例的示例。 也许您希望允许对相同来源的内容进行框架化。 可以通过将 <<nsa-frame-options-policy,policy>>  属性设置为  "SAMEORIGIN" 轻松地支持它，但是让我们来看一个使用 <<nsa-header-ref,ref>> 属性的更明确的示例。

[source,xml]
----
<http>
	<!-- ... -->

	<headers>
		<header ref="frameOptionsWriter"/>
	</headers>
</http>
<!-- Requires the c-namespace.
See https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-c-namespace
-->
<beans:bean id="frameOptionsWriter"
	class="org.springframework.security.web.header.writers.frameoptions.XFrameOptionsHeaderWriter"
	c:frameOptionsMode="SAMEORIGIN"/>
----


我们还可以使用Java配置将内容框架限制为相同来源：


[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // ...
            .headers(headers ->
                headers
                    .addHeaderWriter(new XFrameOptionsHeaderWriter(XFrameOptionsMode.SAMEORIGIN))
            );
    }
}
----



[[headers-delegatingrequestmatcherheaderwriter]]
=== DelegatingRequestMatcherHeaderWriter
有时您可能只想为某些请求编写标头。 例如，也许您只想保护登录页面免于陷害。 您可以使用 `DelegatingRequestMatcherHeaderWriter` 这样做。 使用XML名称空间配置时，可以使用以下方法完成：

[source,xml]
----
<http>
	<!-- ... -->

	<headers>
		<frame-options disabled="true"/>
		<header ref="headerWriter"/>
	</headers>
</http>

<beans:bean id="headerWriter"
	class="org.springframework.security.web.header.writers.DelegatingRequestMatcherHeaderWriter">
	<beans:constructor-arg>
		<bean class="org.springframework.security.web.util.matcher.AntPathRequestMatcher"
			c:pattern="/login"/>
	</beans:constructor-arg>
	<beans:constructor-arg>
		<beans:bean
			class="org.springframework.security.web.header.writers.frameoptions.XFrameOptionsHeaderWriter"/>
	</beans:constructor-arg>
</beans:bean>
----


我们还可以使用Java配置防止将内容构架到登录页面：


[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        RequestMatcher matcher = new AntPathRequestMatcher("/login");
        DelegatingRequestMatcherHeaderWriter headerWriter =
            new DelegatingRequestMatcherHeaderWriter(matcher,new XFrameOptionsHeaderWriter());
        http
            // ...
            .headers(headers ->
                headers
                    .frameOptions(frameOptions ->
                        frameOptions.disable()
                    )
                    .addHeaderWriter(headerWriter)
            );
    }
}
----

