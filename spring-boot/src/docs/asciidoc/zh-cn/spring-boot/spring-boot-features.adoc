[[boot-features]]
= Spring Boot Features
include::attributes.adoc[]

本部分将介绍 Spring Boot 相关的细节内容。在这里，您可以学习到可能需要使用和自定义的主要功能。您如果还没有做好充分准备，可能需要阅读 "<<getting-started.adoc#getting-started,入门>>" 和 "<<using-spring-boot.adoc#using-boot,使用 Spring Boot>>" ，以便打下前期基础。

[[boot-features-spring-application]]
== SpringApplication
`SpringApplication` 类提供了一种可通过运行 `main()` 方法来启动 Spring 应用的简单方式。多数情况下，您只需要委托给静态的 `SpringApplication.run` 方法：

[source,java,indent=0]
----
	public static void main(String[] args) {
		SpringApplication.run(MySpringConfiguration.class, args);
	}
----

当应用启动时，您应该会看到类似以下的内容输出：

[indent=0,subs="attributes"]
----
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::   v{spring-boot-version}

2019-04-31 13:09:54.117  INFO 56603 --- [           main] o.s.b.s.app.SampleApplication            : Starting SampleApplication v0.1.0 on mycomputer with PID 56603 (/apps/myapp.jar started by pwebb)
2019-04-31 13:09:54.166  INFO 56603 --- [           main] ationConfigServletWebServerApplicationContext : Refreshing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@6e5a8246: startup date [Wed Jul 31 00:08:16 PDT 2013]; root of context hierarchy
2019-04-01 13:09:56.912  INFO 41370 --- [           main] .t.TomcatServletWebServerFactory : Server initialized with port: 8080
2019-04-01 13:09:57.501  INFO 41370 --- [           main] o.s.b.s.app.SampleApplication            : Started SampleApplication in 2.992 seconds (JVM running for 3.658)
----

默认情况下，将显示 `INFO` 级别的日志信息，包括一些应用启动相关信息。如果您需要修改 `INFO` 日志级别，请参考<<boot-features-custom-log-levels,日志等级>>。

使用主应用程序类包中的实现版本来确定应用程序版本。 可以通过将 `spring.main.log-startup-info` 设置为 `false` 来关闭启动信息记录。 这还将关闭对应用程序活动配置文件的日志记录。

TIP: 要在启动期间添加其他日志记录，可以在 `SpringApplication` 的子类中重写 `logStartupInfo(boolean)`。


[[boot-features-startup-failure]]
=== 启动失败
如果您的应用无法启动，注册的 `FailureAnalyzers` 可能会提供有相关的错误信息和解决问题的具体方法。例如，如果您在已经被占用的 `8080` 端口上启动了一个 web 应用，会看到类似以下的错误信息：

[indent=0]
----
	***************************
	APPLICATION FAILED TO START
	***************************

	Description:

	Embedded servlet container failed to start. Port 8080 was already in use.

	Action:

	Identify and stop the process that's listening on port 8080 or configure this application to listen on another port.
----

NOTE: Spring Boot 提供了许多的 `FailureAnalyzer` 实现，您也可以<<howto.adoc#howto-failure-analyzer,添加自己的实现>>。

如果没有失败分析器能够处理的异常，您仍然可以显示完整的条件报告以便更好地了解出现的问题。为此，您需要针对 `org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener` <<boot-features-external-config,启用 `debug` 属性>> 或者<<boot-features-custom-log-levels,开启 `DEBUG` 日志>>。

例如，如果您使用 `java -jar` 运行应用，可以按以下方式启用 `debug` 属性：

[indent=0,subs="attributes"]
----
	$ java -jar myproject-0.0.1-SNAPSHOT.jar --debug
----



[[boot-features-lazy-initialization]]
=== 延迟初始化
`SpringApplication` 允许延迟地初始化应用程序。 启用延迟初始化后，将根据需要创建bean，而不是在应用程序启动期间创建bean。 因此，启用延迟初始化可以减少应用程序启动所需的时间。 在Web应用程序中，启用延迟初始化将导致许多与Web相关的Bean直到收到HTTP请求后才被初始化。

延迟初始化的缺点是，它可能会延迟发现应用程序问题的时间。 如果错误配置的Bean延迟初始化，则启动期间将不再发生故障，并且只有在初始化Bean时问题才会变得明显。 还必须注意确保JVM有足够的内存来容纳所有应用程序的bean，而不仅仅是启动期间初始化的bean。 由于这些原因，默认情况下不会启用延迟初始化，因此建议在启用延迟初始化之前先对JVM的堆大小进行微调。

可以使用 `SpringApplicationBuilder` 上的 `lazyInitialization` 方法或 `SpringApplication` 上的 `setLazyInitialization` 方法以编程方式启用延迟初始化。 另外，可以使用 configprop:spring.main.lazy-initialization[] 属性启用它，如以下示例所示：

[source,properties,indent=0,configprops]
----
	spring.main.lazy-initialization=true
----

TIP: 如果要在对应用程序其余部分使用延迟初始化时禁用某些bean的延迟初始化，则可以使用 `@Lazy(false)` 注解将它们的延迟属性显式设置为 `false`。



[[boot-features-banner]]
=== 自定义 banner
可以通过在 classpath 下添加一个 `banner.txt` 文件，或者将 configprop:spring.banner.location[]  属性指向该文件的位置来更改启动时打印的 banner。如果文件采用了非 UTF-8 编码，您可以设置 `spring.banner.charset` 来解决。除了文本文件，
您还可以将 `banner.gif`、`banner.jpg` 或者 `banner.png` 图片文件添加到 classpath 下，或者设置 configprop:spring.banner.image.location[] 属性。指定的图片将会被转换成 ASCII 形式并打印在 banner 文本上方。

您可以在 `banner.txt` 文件中使用以下占位符：

.Banner 变量
|===
| 变量 | 描述

| `${application.version}`
| 您的应用版本号，声明在 `MANIFEST.MF` 中。例如，`Implementation-Version: 1.0` 将被打印为 `1.0`。

| `${application.formatted-version}`
| 您的应用版本号，声明在 `MANIFEST.MF` 中，格式化之后打印（用括号括起来，以 `v` 为前缀），例如 (`v1.0`)。

| `${spring-boot.version}`
| 您使用的 Spring Boot 版本。例如 `{spring-boot-version}`。

| `${spring-boot.formatted-version}`
| 您使用的 Spring Boot 版本格式化之后显示（用括号括起来，以 `v` 为前缀）。例如 `(v{spring-boot-version})`。

| `${Ansi.NAME}` (or `${AnsiColor.NAME}`, `${AnsiBackground.NAME}`, `${AnsiStyle.NAME}`)
| 其中 `NAME` 是 ANSI 转义码的名称。有关详细信息，请参阅 {spring-boot-module-code}/ansi/AnsiPropertySource.java[`AnsiPropertySource`]。

| `${application.title}`
| 您的应用标题，声明在 `MANIFEST.MF` 中，例如 `Implementation-Title: MyApp` 打印为 `MyApp`。
|===

TIP: 如果您想以编程的方式生成 banner，可以使用 `SpringApplication.setBanner(​...)` 方法。使用 `org.springframework.boot.Banner` 接口并实现自己的 `printBanner()` 方法。

您还可以使用 configprop:spring.main.banner-mode[] 属性来确定是否必须在  `System.out` (`console`) 上打印 banner，还是使用日志记录器 (`log`)或者都不打印(`off`)。

打印的 banner 被注册名为 `springBootBanner` 的单例 bean。

[[boot-features-customizing-spring-application]]
=== 自定义 SpringApplication
如果 `SpringApplication` 的默认设置不符合您的想法，您可以创建本地实例进行定制化。例如，要关闭 banner，您可以这样：

[source,java,indent=0]
----
	public static void main(String[] args) {
		SpringApplication app = new SpringApplication(MySpringConfiguration.class);
		app.setBannerMode(Banner.Mode.OFF);
		app.run(args);
	}
----

NOTE: 传入 `SpringApplication` 的构造参数是 spring bean 的配置源。大多情况下是引用 `@Configuration` 类，但您也可以引用 XML 配置或者被扫描的包。

也可以使用 `application.properties` 文件配置 `SpringApplication`。有关详细信息，请参见_<<boot-features-external-config,外部化配置>>_。

关于配置选项的完整列表，请参阅  {spring-boot-module-api}/SpringApplication.html[`SpringApplication` Javadoc]。

[[boot-features-fluent-builder-api]]
=== Fluent Builder API

如果您需要构建一个有层级关系的 `ApplicationContext`（具有父/子关系的多上下文），或者偏向使用 fluent（流式）构建器 API，可以使用 `SpringApplicationBuilder`。

`SpringApplicationBuilder` 允许您链式调用多个方法，包括能创建出具有层次结构的 `parent` 和 `child` 方法。

例如：

[source,java,indent=0]
----
include::{code-examples}/builder/SpringApplicationBuilderExample.java[tag=hierarchy]
----

NOTE: 创建层级的 `ApplicationContext` 时有部分限制，比如 Web 组件必须包含在子上下文中，并且相同的 `Environment` 将作用于父子上下文。有关详细信息，请参阅 {spring-boot-module-api}/builder/SpringApplicationBuilder.html[`SpringApplicationBuilder` Javadoc] 。

[[boot-features-application-events-and-listeners]]
=== 应用程序事件与监听器

除了常见的 Spring Framework 事件，比如  {spring-framework-api}/context/event/ContextRefreshedEvent.html[`ContextRefreshedEvent`]，`SpringApplication` 还会发送其他应用程序事件。

[NOTE]
====
在 `ApplicationContext` 创建之前，实际上触发了一些事件，因此您不能像 `@Bean` 一样注册监听器。您可以通过 `SpringApplication.addListeners(​...)` 或者 `SpringApplicationBuilder.listeners(...​)` 方法注册它们。
如果您希望无论应用使用何种创建方式都能自动注册这些监听器，您都可以将 `META-INF/spring.factories` 文件添加到项目中，并使用 `org.springframework.context.ApplicationListener` 属性键指向您的监听器。
比如：`org.springframework.context.ApplicationListener=com.example.project.MyListener`

[indent=0]
----
	org.springframework.context.ApplicationListener=com.example.project.MyListener
----

====

当您运行应用时，应用程序事件将按照以下顺序发送：

. 在开始应用开始运行但还没有进行任何处理时（除了注册监听器和初始化器[initializer]），将发送 `ApplicationStartingEvent`。
. 当 Environment 被上下文使用，但是在上下文创建之前，将发送 `ApplicationEnvironmentPreparedEvent`。
. 准备 `ApplicationContext` 并调用 `ApplicationContextInitializers` 之后但在加载任何bean定义之前，将发送 `ApplicationContextInitializedEvent`。
. 开始刷新之前，bean 定义被加载之后发送 `ApplicationPreparedEvent`。
. 在上下文刷新之后且所有的应用和命令行运行器（command-line runner）被调用之前发送 `ApplicationStartedEvent`。
. 在应用程序和命令行运行器（command-line runner）被调用之后，将发出 `ApplicationReadyEvent`，该事件用于通知应用已经准备处理请求。
. 如果启动时发生异常，将发送 `ApplicationFailedEvent`。

上面的列表仅包含绑定到 `SpringApplication` 的 `SpringApplicationEvents`。 除这些以外，以下事件也在 `ApplicationPreparedEvent` 之后和 `ApplicationStartedEvent` 之前发布：

. 刷新 `ApplicationContext` 时，将发送 `ContextRefreshedEvent`。
. `WebServer` 准备就绪后，将发送 `WebServerInitializedEvent`。 `ServletWebServerInitializedEvent` 和 `ReactiveWebServerInitializedEvent` 分别是servlet和reactive变量。

TIP: 您可能不会经常使用应用程序事件，但了解他们的存在还是很有必要的。在框架内部，Spring Boot 使用这些事件来处理各种任务。

应用程序事件发送使用了 Spring Framework 的事件发布机制。该部分机制确保在子上下文中发布给监听器的事件也会发布给所有祖先上下文中的监听器。因此，如果您的应用程序使用有层级结构的 `SpringApplication` 实例，则监听器可能会收到同种类型应用程序事件的多个实例。

为了让监听器能够区分其上下文事件和后代上下文事件，您应该注入其应用程序上下文，然后将注入的上下文与事件的上下文进行比较。可以通过实现 `ApplicationContextAware` 来注入上下文，如果监听器是 bean，则使用 `@Autowired` 注入上下文。

[[boot-features-web-environment]]
=== Web 环境
`SpringApplication` 试图为您创建正确类型的 `ApplicationContext`。确定 `WebApplicationType` 的算法非常简单：

* 如果存在 Spring MVC，则使用 `AnnotationConfigServletWebServerApplicationContext`
* 如果 Spring MVC 不存在且存在 Spring WebFlux，则使用 `AnnotationConfigReactiveWebServerApplicationContext`
* 否则，使用 `AnnotationConfigApplicationContext`

这意味着如果您在同一个应用程序中使用了 Spring MVC 和 Spring WebFlux 中的新 `WebClient`，默认情况下将使用 Spring MVC。您可以通过调用 `setWebApplicationType(WebApplicationType)` 修改默认行为。

也可以调用 `setApplicationContextClass(...)` 来完全控制 `ApplicationContext` 类型。

TIP: 在 JUnit 测试中使用 `SpringApplication` 时，通常需要调用 `setWebApplicationType(WebApplicationType.NONE)`。

[[boot-features-application-arguments]]
=== 访问应用程序参数
如果您需要访问从 `SpringApplication.run(​...)` 传入的应用程序参数，可以注入一个 `org.springframework.boot.ApplicationArguments` bean。`ApplicationArguments` 接口提供了访问原始 `String[]` 参数以及解析后的 `option` 和 `non-option` 参数的方法：

[source,java,indent=0]
----
	import org.springframework.boot.*;
	import org.springframework.beans.factory.annotation.*;
	import org.springframework.stereotype.*;

	@Component
	public class MyBean {

		@Autowired
		public MyBean(ApplicationArguments args) {
			boolean debug = args.containsOption("debug");
			List<String> files = args.getNonOptionArgs();
			// if run with "--debug logfile.txt" debug=true, files=["logfile.txt"]
		}

	}
----

TIP: Spring Boot 还向 Spring `Environment` 注册了一个 `CommandLinePropertySource`。这允许您可以使用 `@Value` 注解注入单个应用参数。

[[boot-features-command-line-runner]]
=== 使用 ApplicationRunner 或 CommandLineRunner
如果您需要在 `SpringApplication` 启动时运行一些代码，可以实现 `ApplicationRunner` 或者 `CommandLineRunner` 接口。这两个接口的工作方式是一样的，都提供了一个单独的 `run` 方法，它将在 `SpringApplication.run(​...)` 完成之前调用。

`CommandLineRunner` 接口提供了访问应用程序字符串数组形式参数的方法，而 `ApplicationRunner` 则使用了上述的 `ApplicationArguments` 接口。以下示例展示 `CommandLineRunner` 和 `run` 方法的使用：

[source,java,indent=0]
----
	import org.springframework.boot.*;
	import org.springframework.stereotype.*;

	@Component
	public class MyBean implements CommandLineRunner {

		public void run(String... args) {
			// Do something...
		}

	}
----

如果您定义了多个 `CommandLineRunner` 或者 `ApplicationRunner` bean，则必须指定调用顺序，您可以实现 `org.springframework.core.Ordered` 接口，也可以使用 `org.springframework.core.annotation.Order` 注解解决顺序问题。

[[boot-features-application-exit]]
=== 应用程序退出
每个 `SpringApplication` 注册了一个 JVM 关闭钩子，以确保 `ApplicationContext` 在退出时可以优雅关闭。所有标准的 Spring 生命周期回调（比如 `DisposableBean` 接口，或者 `@PreDestroy` 注解）都可以使用。

此外，如果希望在调用 `SpringApplication.exit()` 时返回特定的退出码，则 bean 可以实现 `org.springframework.boot.ExitCodeGenerator` 接口。之后退出码将传递给 `System.exit()` 以将其作为状态码返回，如示例所示：

[source,java,indent=0]
----
include::{code-examples}/ExitCodeApplication.java[tag=example]
----

此外，`ExitCodeGenerator` 接口可以通过异常实现。遇到这类异常时，Spring Boot 将返回实现的 `getExitCode()` 方法提供的退出码。

[[boot-features-application-admin]]
=== 管理功能
可以通过指定 configprop:spring.application.admin.enabled[]  属性来为应用程序启用管理相关的功能。其将在 `MBeanServer` 平台上暴露  {spring-boot-module-code}/admin/SpringApplicationAdminMXBean.java[`SpringApplicationAdminMXBean`]。您可以使用此功能来远程管理 Spring Boot 应用。该功能对服务包装器的实现也是非常有用的。

TIP: 如果您想知道应用程序在哪一个 HTTP 端口上运行，请使用 `local.server.port` 键获取该属性。



[[boot-features-external-config]]
== 外部化配置
Spring Boot 可以让您的配置外部化，以便可以在不同环境中使用相同的应用程序代码。您可以使用 properties 文件、YAML 文件、环境变量或者命令行参数来外部化配置。可以使用 `@Value` 注解将属性值直接注入到 bean 中，可通过 Spring 的 `Environment` 访问，
或者通过 `@ConfigurationProperties` <<boot-features-external-config-typesafe-configuration-properties,绑定到结构化对象>>。

Spring Boot 使用了一个非常特别的 `PropertySource` 指令，用于智能覆盖默认值。属性将按照以下顺序处理：

. 当 devtools 被激活， `$HOME/.config/spring-boot` 文件夹中的 <<using-spring-boot.adoc#using-boot-devtools-globalsettings,Devtools 全局设置属性>>。
. 在测试中使用到的 {spring-framework-api}/test/context/TestPropertySource.html[`@TestPropertySource`] 注解。
. 在测试中使用到的 `properties` 属性，可以是 {spring-boot-test-module-api}/context/SpringBootTest.html[`@SpringBootTest`] 和 <<boot-features-testing-spring-boot-applications-testing-autoconfigured-tests,用于测试应用程序某部分的测试注解>>。
. 命令行参数。
. 来自 `SPRING_APPLICATION_JSON` 的属性（嵌入在环境变量或者系统属性【system propert】中的内联 JSON）。
. `ServletConfig` 初始化参数。
. `ServletContext` 初始化参数。
. 来自 `java:comp/env` 的 JNDI 属性。
. Java 系统属性（`System.getProperties()`）。
. 操作系统环境变量。
. 只有 `random.*` 属性的 `RandomValuePropertySource`。
. 在已打包的 jar 外部的 <<boot-features-external-config-profile-specific-properties,指定 profile 的应用属性文件>> (`application-\{profile}.properties` 和 YAML 变量).
. 在已打包的 jar 内部的<<boot-features-external-config-profile-specific-properties,指定 profile 的应用属性文件>> (`application-\{profile}.properties` 和 YAML 变量).
. 在已打包的 jar 外部的应用属性文件 (`application.properties` 和 YAML 变量).
. 在已打包的 jar 内部的应用属性文件 (`application.properties` 和 YAML 变量).
. 在 `@Configuration` 类上的 {spring-framework-api}/context/annotation/PropertySource.html[`@PropertySource`]  注解。
请注意，在刷新应用程序上下文之前，不会将此类属性源添加到环境中。 现在配置某些属性（如 `logging.*` 和 `spring.main.*` ）为时已晚，这些属性在刷新开始之前就已读取。
. 默认属性（使用 `SpringApplication.setDefaultProperties` 指定）。

举个例子，假设开发的 `@Component` 使用了 `name` 属性，可以这样：

[source,java,indent=0]
----
	import org.springframework.stereotype.*;
	import org.springframework.beans.factory.annotation.*;

	@Component
	public class MyBean {

	    @Value("${name}")
	    private String name;

	    // ...

	}
----

在您的应用程序的 classpath 中（比如在 jar 中），您可以有一个 `application.properties`，它为 name 提供了一个合适的默认属性值。当在新环境中运行时，您可以在 jar 外面提供一个 `application.properties` 来覆盖 `name`。对于一次性测试，您可以使用命令行指定形式启动（比如 `java -jar app.jar --name="Spring"`）。

[[boot-features-external-config-application-json]]
[TIP]
====
`SPRING_APPLICATION_JSON` 属性可以在命令行中提供一个环境变量。比如在 UN*X shell 中：

[indent=0]
----
	$ SPRING_APPLICATION_JSON='{"acme":{"name":"test"}}' java -jar myapp.jar
----

在此示例中，您可以在 Spring `Environment` 中使用 `acme.name=test`，也可以在系统属性（System property）中将 JSON 作为 `spring.application.json` 属性提供：

[indent=0]
----
	$ java -Dspring.application.json='{"name":"test"}' -jar myapp.jar
----

或者以命令行参数形式：

[indent=0]
----
	$ java -jar myapp.jar --spring.application.json='{"name":"test"}'
----

或者将 JSON 作为一个 JNDI 变量：`java:comp/env/spring.application.json`。
====



[[boot-features-external-config-random-values]]
=== 配置随机值
`RandomValuePropertySource` 对于随机值注入非常有用（比如在保密场景或者测试用例中)。它可以产生 integer、long、uuid 和 string。如下示例：

[source,properties,indent=0]
----
	my.secret=${random.value}
	my.number=${random.int}
	my.bignumber=${random.long}
	my.uuid=${random.uuid}
	my.number.less.than.ten=${random.int(10)}
	my.number.in.range=${random.int[1024,65536]}
----

`random.int*` 语法为 `OPEN value (,max) CLOSE`，`OPEN,CLOSE` 可为任意字符，`value,max` 为整数。如果使用了 `max`，`value` 则为最小值，`max` 为最大值。

[[boot-features-external-config-command-line-args]]
=== 访问命令行属性
默认情况下，`SpringApplication` 将所有命令行选项参数（即以 `--` 开头的参数，比如 `--server.port=9000`）转换为属性，并将它们添加到 Spring `Environment` 中。如之前所述，命令行属性始终优先于其他属性源。

如果您不希望将命令行属性添加到 `Environment`，可以使用 `SpringApplication.setAddCommandLineProperties(false)` 来禁用它们。

[[boot-features-external-config-application-property-files]]
=== 应用程序属性文件
`SpringApplication` 从以下位置的 `application.properties` 文件中加载属性（properties），并将它们添加到 Spring `Environment` 中：
`SpringApplication` loads properties from `application.properties` files in the following locations and adds them to the Spring `Environment`:

. 当前目录的 `/config` 子目录
. 当前目录
. classpath 上的 `/config` 包
. classpath 根路径

列表按序号优先级排序，序号越小，优先级越高。

NOTE: 您还可以 <<boot-features-external-config-yaml, 使用 YAML（.yml） 文件>>来替代 '.properties'.

如果您不喜欢 `application.properties` 作为配置文件名，则可以通过指定  configprop:spring.config.name[]  环境属性来切换到另一个文件名。您还可以使用 `spring.config.location` 环境属性来引用一个显式位置（以逗号分隔的目录位置或文件路径列表）。
以下示例展示了如何指定其他文件名：

[indent=0]
----
	$ java -jar myproject.jar --spring.config.name=myproject
----

以下示例展示了如何指定两个位置：

[indent=0]
----
	$ java -jar myproject.jar --spring.config.location=classpath:/default.properties,classpath:/override.properties
----

WARNING: `spring.config.name` 和 `spring.config.location` 在程序启动早期就用来确定哪些文件必须加载，因此必须将它们定义为环境属性（通常是 OS 环境变量、系统属性或命令行参数）。

如果 `spring.config.location` 包含目录（而不是文件），则它们应该以 `/` 结尾（并且在运行期间，在加载之前追加从 `spring.config.name` 生成的名称，包括指定 profile 的文件名）。
`spring.config.location` 中指定的文件按原样使用，不支持指定 profile 形式，并且可被任何指定 profile 的文件的属性所覆盖。

配置位置以相反的顺序搜索。默认情况下，配置的位置为 `classpath:/,classpath:/config/,file:./,file:./config/`。生成的搜索顺序如下：

. `file:./config/`
. `file:./`
. `classpath:/config/`
. `classpath:/`

使用了 `spring.config.location` 配置自定义配置位置时，默认位置配置将被替代。例如，如果 `spring.config.location` 配置为 `classpath:/custom-config/,file:./custom-config/`，搜索顺序将变为以下：

. `file:./custom-config/`
. `classpath:custom-config/`

或者，当使用 `spring.config.additional-location` 配置自定义配置位置时，除了使用默认位置外，还会使用它们。这些其他（additional）位置将在默认位置之前搜索。例如，如果将其他位置配置为  `classpath:/custom-config/,file:./custom-config/` ，则搜索顺序将变为以下内容：

. `file:./custom-config/`
. `classpath:custom-config/`
. `file:./config/`
. `file:./`
. `classpath:/config/`
. `classpath:/`

该搜索顺序允许您在一个配置文件中指定默认值，然后有选择地覆盖另一个配置文件中的值。您可以在 `application.properties`（或您使用 `spring.config.name` 指定的其他文件）中的某个默认位置为应用程序提供默认值。之后，在运行时，这些默认值将被自定义位置中的某个文件所覆盖。

NOTE: 如果您使用的是环境变量而不是系统属性，大部分操作系统都不允许使用 . 分隔的键名，但您可以使用下划线来代替（例如，使用 `SPRING_CONFIG_NAME` 而不是 `spring.config.name`）。

NOTE: 如果应用程序在容器中运行，则可以使用 JNDI 属性（`java:comp/env`）或 servlet 上下文初始化参数来代替环境变量或系统属性。(in `java:comp/env`)



[[boot-features-external-config-profile-specific-properties]]
=== 特定 Profile 的属性文件
除 `application.properties` 文件外，还可以使用以下命名约定定义特定 profile 的属性文件：application-{profile}.properties。Environment 有一组默认配置文件（默认情况下为 `default`），如果未设置激活的（active）profile，则使用这些配置文件。换句话说，如果没有显式激活 profile，则会加载 `application-default.properties` 中的属性。

特定 profile 的属性文件从与标准 `application.properties` 相同的位置加载，特定 profile 的属性文件无论是否在打包的 jar 内部，都始终覆盖非特定文件。

如果指定了多个配置文件，则应用 last-wins 策略（优先采取最后一个）。例如，configprop:spring.profiles.active[] 属性指定的配置文件是在使用 `SpringApplication` API 配置的配置文件之后添加的，因此优先应用。

NOTE: 如果在 `spring.config.location` 中指定了文件，则不考虑这些文件的特定 profile 形式。如果您还想使用特定 profile 的属性文件，请在 `spring.config.location` 中使用目录形式。

[[boot-features-external-config-placeholders-in-properties]]
=== 属性中的占位符
`application.properties` 中的值在使用时通过现有的 `Environment` 进行过滤，因此您可以返回之前定义的值（例如，从系统属性）。

[source,properties,indent=0]
----
	app.name=MyApp
	app.description=${app.name} is a Spring Boot application
----

TIP: 您还可以使用此技术创建现有 Spring Boot 属性的简短形式。有关详细信息，请参见 _<<howto.adoc#howto-use-short-command-line-arguments,使用简短命令行参数>>_ 。

[[boot-features-encrypting-properties]]
=== 加密属性
Spring Boot 没有为加密属性值提供任何内置支持，然而，它提供了修改 Spring `Environment` 包含的值所必需的钩子。`EnvironmentPostProcessor` 接口允许您在应用程序启动之前操作 Environment。
有关详细信息，请参见 <<howto.adoc#howto-customize-the-environment-or-application-context,在启动前自定义 Environment 或 ApplicationContext>> 。

如果您正在寻找一种可用于存储凭据和密码的安全方法， https://cloud.spring.io/spring-cloud-vault/[Spring Cloud Vault]  项目支持在  https://www.vaultproject.io/[HashiCorp Vault] 中存储外部化配置。

[[boot-features-external-config-yaml]]
=== 使用 YAML 代替属性文件
https://yaml.org[YAML] 是 JSON 的超集，是一个可用于指定层级配置数据的便捷格式。只要在 classpath 上有 https://bitbucket.org/asomov/snakeyaml[SnakeYAML]  库，`SpringApplication` 类就会自动支持 YAML 作为属性文件（properties）的替代。

NOTE: 如果使用 `starter`，则 `spring-boot-starter` 会自动提供 SnakeYAML。

[[boot-features-external-config-loading-yaml]]
==== 加载 YAML
Spring Framework 提供了两个便捷类，可用于加载 YAML 文档。`YamlPropertiesFactoryBean` 将 YAML 加载为 `Properties`，`YamlMapFactoryBean` 将 YAML 加载为 `Map`。

例如以下 YAML 文档：

[source,yaml,indent=0]
----
	environments:
		dev:
			url: https://dev.example.com
			name: Developer Setup
		prod:
			url: https://another.example.com
			name: My Cool App
----

前面的示例将转换为以下属性（properties）：

[source,properties,indent=0]
----
	environments.dev.url=https://dev.example.com
	environments.dev.name=Developer Setup
	environments.prod.url=https://another.example.com
	environments.prod.name=My Cool App
----

YAML 列表表示带有 `[index]` 下标引用的属性键。例如以下 YAML：

[source,yaml,indent=0]
----
	 my:
		servers:
			- dev.example.com
			- another.example.com
----

以上示例将转成以下属性：

[source,properties,indent=0]
----
	my.servers[0]=dev.example.com
	my.servers[1]=another.example.com
----

要使用 Spring Boot 的 Binder 工具来绑定这样配置到属性（这是 `@ConfigurationProperties` 所做的），你需要在目标 bean 中有一个 `java.util.List`（或 `Set`）类型的属性，你需要为其提供一个 setter 或者使用可变值初始化它。 例如，以下示例展示将上述的配置与属性绑定：

[source,java,indent=0]
----
	@ConfigurationProperties(prefix="my")
	public class Config {

		private List<String> servers = new ArrayList<String>();

		public List<String> getServers() {
			return this.servers;
		}
	}
----



[[boot-features-external-config-exposing-yaml-to-spring]]
==== 在 Spring Environment 中将 YAML 暴露为属性
`YamlPropertySourceLoader` 类可用于在 Spring `Environment` 中将 YAML 暴露为 `PropertySource`。这样做可以让您使用带占位符语法的 `@Value` 注解来访问 YAML 属性。

[[boot-features-external-config-multi-profile-yaml]]
==== 多 profile YAML 文档
您可以使用 `spring.profiles` key 在单个文件中指定多个特定 profile 的 YAML 文档，以指示文档何时应用，如下所示：

[source,yaml,indent=0]
----
	server:
		address: 192.168.1.100
	---
	spring:
		profiles: development
	server:
		address: 127.0.0.1
	---
	spring:
		profiles: production & eu-central
	server:
		address: 192.168.1.120
----

在前面示例中，如果 `development` profile 处于激活状态，则 `server.address` 属性得值为 `127.0.0.1`。 同样，如果 `production` 和 `eu-central` profile 处于激活状态，则 `server.address` 属性的值为 `192.168.1.120`。
如果未激活 `development`、`production` 或 `eu-central` profile，则该属性的值为 `192.168.1.100`。

[NOTE]
====
因此，`spring.profiles` 可以包含一个简单的 profile 名称（例如 `production`）或一个 profile 表达式。profile 表达式允许表达更复杂的 profile 逻辑，例如  `production & (eu-central | eu-west)`。有关详细信息，请查阅{spring-framework-docs}core.html#beans-definition-profiles-java[reference guide]。
====

如果在应用程序上下文启动时没有显式激活，则激活默认 profile。因此，在以下 YAML 中，我们为 `spring.security.user.password` 设置了一个值，该值仅在 default profile 中可用：

[source,yaml,indent=0]
----
	server:
	  port: 8000
	---
	spring:
	  profiles: default
	  security:
	    user:
	      password: weak
----

然而，在以下示例中，始终设置密码，因为它未附加到任何 profile，如果需要更改，必须在所有其他 profile 中显式重置：

[source,yaml,indent=0]
----
	server:
	  port: 8000
	spring:
	  security:
	    user:
	      password: weak
----

使用 `spring.profiles` 元素来指定 Spring profile 可以选择通过使用 `!` 字符来取反（否定）。如果为单个文档指定了否定和非否定的 profile，则至少一个非否定的 profile 必须匹配，没有否定的 profile 可以匹配。

[[boot-features-external-config-yaml-shortcomings]]
==== YAML 的缺点
无法使用 `@PropertySource` 注解加载 YAML 文件。因此，如果您需要以这种方式加载值，请使用属性文件（properties）。

在特定于配置文件的YAML文件中使用多YAML文档语法可能会导致意外行为。 例如，考虑文件中的以下配置：

.application-dev.yml
[source,yaml,indent=0]
----
	server:
	  port: 8000
	---
	spring:
	  profiles: "!test"
	  security:
	    user:
	      password: "secret"
----

如果使用参数 `--spring.profiles.active=dev` 运行该应用程序，则可能希望将 `security.user.password` 设置为 "`secret`"，但事实并非如此。

嵌套文档将被过滤，因为主文件名为 `application-dev.yml`。 它已经被认为是特定于配置文件的，并且嵌套文档将被忽略。

TIP: 我们建议您不要混用特定于配置文件的YAML文件和多个YAML文档。 坚持只使用其中之一。

[[boot-features-external-config-typesafe-configuration-properties]]
=== 类型安全的配置属性
使用 `@Value("${property}")` 注解来注入配置属性有时会很麻烦，特别是如果您使用了多个属性或者您的数据本质上是分层结构。Spring Boot 提供了另一种使用属性的方法，该方法使用强类型的 bean 来管理和验证应用程序的配置，如下所示：

TIP: 另请参见<<boot-features-external-config-vs-value, `@Value` 和类型安全的配置属性之间的区别>>。

[[boot-features-external-config-java-bean-binding]]
==== JavaBean 属性绑定
可以绑定一个声明标准JavaBean属性的bean，如以下示例所示：

[source,java,indent=0]
----
	package com.example;

	import java.net.InetAddress;
	import java.util.ArrayList;
	import java.util.Collections;
	import java.util.List;

	import org.springframework.boot.context.properties.ConfigurationProperties;

	@ConfigurationProperties("acme")
	public class AcmeProperties {

		private boolean enabled;

		private InetAddress remoteAddress;

		private final Security security = new Security();

		public boolean isEnabled() { ... }

		public void setEnabled(boolean enabled) { ... }

		public InetAddress getRemoteAddress() { ... }

		public void setRemoteAddress(InetAddress remoteAddress) { ... }

		public Security getSecurity() { ... }

		public static class Security {

			private String username;

			private String password;

			private List<String> roles = new ArrayList<>(Collections.singleton("USER"));

			public String getUsername() { ... }

			public void setUsername(String username) { ... }

			public String getPassword() { ... }

			public void setPassword(String password) { ... }

			public List<String> getRoles() { ... }

			public void setRoles(List<String> roles) { ... }

		}
	}
----

前面的 POJO 定义了以下属性：

* `acme.enabled`, 默认值为 `false`。
* `acme.remote-address`, 可以从 `String` 强制转换的类型。
* `acme.security.username`, 内嵌一个 `security` 对象，其名称由属性名称决定。特别是，返回类型根本没有使用，可能是 `SecurityProperties`。
* `acme.security.password`.
* `acme.security.roles`, `String` 集合。 默认为 `USER`.

NOTE: Spring Boot自动配置大量使用 `@ConfigurationProperties` 来轻松配置自动配置的bean。 与自动配置类相似，Spring Boot中可用的 `@ConfigurationProperties` 类仅供内部使用。 通过属性文件，YAML文件，环境变量等配置的映射到该类的属性是公共API，
但是该类本身的内容并不意味着可以直接使用。

[NOTE]
====
getter 和 setter 通常是必需的，因为绑定是通过标准的 Java Bean 属性描述符来完成，就像在 Spring MVC 中一样。以下情况可以省略 setter：

* Map，只要它们要初始化，就需要一个 getter 但不一定需要setter，因为它们可以被 binder 修改。
* 集合和数组可以通过一个索引（通常使用 YAML）或使用单个逗号分隔值（属性）进行访问。最后一种情况必须使用 setter。我们建议始终为此类型添加 setter。如果初始化集合，请确保它是可变的（如上例所示）。
* 如果初始化嵌套的 POJO 属性（如前面示例中的 `Security` 字段），则不需要 setter。如果您希望 binder 使用其默认构造函数动态创建实例，则需要一个 setter。

有些人可能会使用 Project Lombok 来自动生成 getter 和 setter。请确保 Lombok 不为此类型生成任何特定构造函数，因为容器会自动使用它来实例化对象。

最后，考虑到标准 Java Bean 属性，不支持对静态属性的绑定。
====

[[boot-features-external-config-constructor-binding]]
==== 构造函数绑定
上一节中的示例可以以不变的方式重写，如下例所示：

[source,java,indent=0]
----
	package com.example;

	import java.net.InetAddress;
	import java.util.List;

	import org.springframework.boot.context.properties.ConfigurationProperties;
	import org.springframework.boot.context.properties.ConstructorBinding;
	import org.springframework.boot.context.properties.DefaultValue;

	@ConstructorBinding
	@ConfigurationProperties("acme")
	public class AcmeProperties {

		private final boolean enabled;

		private final InetAddress remoteAddress;

		private final Security security;

		public AcmeProperties(boolean enabled, InetAddress remoteAddress, Security security) {
			this.enabled = enabled;
			this.remoteAddress = remoteAddress;
			this.security = security;
		}

		public boolean isEnabled() { ... }

		public InetAddress getRemoteAddress() { ... }

		public Security getSecurity() { ... }

		public static class Security {

			private final String username;

			private final String password;

			private final List<String> roles;

			public Security(String username, String password,
					@DefaultValue("USER") List<String> roles) {
				this.username = username;
				this.password = password;
				this.roles = roles;
			}

			public String getUsername() { ... }

			public String getPassword() { ... }

			public List<String> getRoles() { ... }

		}

	}
----

在此设置中，`@ConstructorBinding` 注解用于指示应使用构造函数绑定。 这意味着绑定器将期望找到带有您希望绑定的参数的构造函数。

`@ConstructorBinding` 类的嵌套成员（例如上例中的 `Security` ）也将通过其构造函数进行绑定。

可以使用 `@DefaultValue` 指定默认值，并且将应用相同的转换服务将 `String` 值强制为缺少属性的目标类型。

NOTE: 要使用构造函数绑定，必须使用 `@EnableConfigurationProperties` 或配置属性扫描来启用该类。 您不能对通过常规Spring机制创建的bean使用构造函数绑定（例如 `@Component` bean，通过 `@Bean` 方法创建的bean或使用 `@Import` 加载的bean）

TIP: 如果您的类具有多个构造函数，则还可以直接在应绑定的构造函数上使用 `@ConstructorBinding`。



[[boot-features-external-config-enabling]]
==== 启用 `@ConfigurationProperties` 注解的类型
Spring Boot提供了绑定 `@ConfigurationProperties` 类型并将其注册为Bean的基础架构。 您可以逐类启用配置属性，也可以启用与组件扫描类似的方式进行配置属性扫描。

有时，用 `@ConfigurationProperties` 注释的类可能不适用于扫描，例如，如果您正在开发自己的自动配置，或者想要有条件地启用它们。 在这些情况下，请使用 `@EnableConfigurationProperties` 批注指定要处理的类型列表。 可以在任何 `@Configuration` 类上完成此操作，如以下示例所示：

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(AcmeProperties.class)
	public class MyConfiguration {
	}
----

要使用配置属性扫描，请将 `@ConfigurationPropertiesScan` 批注添加到您的应用程序。 通常，它被添加到使用 `@SpringBootApplication` 注释的主应用程序类中，但可以将其添加到任何 `@Configuration` 类中。
默认情况下，将从声明注释的类的包中进行扫描。 如果要定义要扫描的特定程序包，可以按照以下示例所示进行操作：

[source,java,indent=0]
----
	@SpringBootApplication
	@ConfigurationPropertiesScan({ "com.example.app", "org.acme.another" })
	public class MyApplication {
	}
----

[NOTE]
====
当以这种方式注册 `@ConfigurationProperties` bean 时，bean 具有一个固定格式的名称：`<prefix>-<fqn>`，其中 <prefix> 是 `@ConfigurationProperties` 注解中指定的环境 key 前缀，`<fqn>` 是 bean 的完全限定类名。如果注解未提供任何前缀，则仅使用 bean 的完全限定类名。

上面示例中的 bean 名称为 `acme-com.example.AcmeProperties`。
====

即使前面的配置为 `AcmeProperties` 创建了一个 bean，我们也建议 `@ConfigurationProperties` 只处理环境（environment），特别是不要从上下文中注入其他 bean。
对于极端情况，可以使用setter注入或框架提供的任何 `*Aware` 接口（例如，需要访问 `Environment` 的 `EnvironmentAware`）。 如果仍然想使用构造函数注入其他bean，则必须使用 `@Component` 注释配置属性bean，并使用基于JavaBean的属性绑定。

[[boot-features-external-config-using]]
==== 使用 `@ConfigurationProperties` 注解类型
这种配置样式与 `SpringApplication` 外部YAML配置特别有效，如以下示例所示：

[source,yaml,indent=0]
----
	# application.yml

	acme:
		remote-address: 192.168.1.1
		security:
			username: admin
			roles:
			  - USER
			  - ADMIN

	# additional configuration as required
----

要使用 `@ConfigurationProperties` bean，您可以使用与其他 bean 相同的方式注入它们，如下所示：

[source,java,indent=0]
----
	@Service
	public class MyService {

		private final AcmeProperties properties;

		@Autowired
		public MyService(AcmeProperties properties) {
		    this.properties = properties;
		}

	 	//...

		@PostConstruct
		public void openConnection() {
			Server server = new Server(this.properties.getRemoteAddress());
			// ...
		}

	}
----

TIP: 使用 `@ConfigurationProperties` 还可以生成元数据文件，IDE 可以通过这些文件来为您自己的 key 提供自动完成功能。有关详细信息，请参阅<<appendix-configuration-metadata.adoc#configuration-metadata,附录 B：配置元数据>> 。

[[boot-features-external-config-3rd-party-configuration]]
==== 第三方配置
`@ConfigurationProperties` 除了可以使用来注解类之外，您还可以在公共的 `@Bean` 方法上使用。当您想要将属性绑定到您掌控之外的第三方组件时，这样做特别有用。

要使用 `Environment` 属性配置 bean，请将 `@ConfigurationProperties` 添加到 bean 注册上，如下所示：

[source,java,indent=0]
----
	@ConfigurationProperties(prefix = "another")
	@Bean
	public AnotherComponent anotherComponent() {
		...
	}
----

使用 `another` 前缀定义的所有属性都使用与前面的 `AcmeProperties` 示例类似的方式映射到 `AnotherComponent` bean。

[[boot-features-external-config-relaxed-binding]]
==== 宽松绑定
Spring Boot 使用一些宽松的规则将 `Environment` 属性绑定到 `@ConfigurationProperties` bean，因此 `Environment` 属性名不需要和 bean 属性名精确匹配。
常见的示例包括使用了 `-` 符号分割的环境属性（例如，`context-path` 绑定到 `contextPath`）和大写环境属性（例如，`PORT` 绑定到 `port`）。

如下 `@ConfigurationProperties` 类：

[source,java,indent=0]
----
	@ConfigurationProperties(prefix="acme.my-project.person")
	public class OwnerProperties {

		private String firstName;

		public String getFirstName() {
			return this.firstName;
		}

		public void setFirstName(String firstName) {
			this.firstName = firstName;
		}

	}
----

在上述示例中，同样可以使用以下属性名称：

.宽松绑定
[cols="1,4"]
|===
| 属性 | 描述

| `acme.my-project.person.first-name`
| Kebab 风格（短横线命名），建议在 `.properties` 和 `.yml` 文件中使用。

| `acme.myProject.person.firstName`
| 标准驼峰式风格。

| `acme.my_project.person.first_name`
| 下划线表示法，`.properties` 和 `.yaml` 文件中的另外一种格式。

| `ACME_MYPROJECT_PERSON_FIRSTNAME`
| 大写风格，当使用系统环境变量时推荐使用该风格。
|===

NOTE: 注解的 `prefix` 值必须是 kebab (短横线命名)风格（小写并用 `-` 分隔，例如 `acme.my-project.person`）。

.每种属性源（property source）的宽松绑定规则
[cols="2,4,4"]
|===
| 属性源 | 简单类型 | 列表集合类型

| Properties 文件
| 驼峰式、短横线式或下划线式
| 	标准列表语法使用 `[ ]` 或逗号分隔值

| YAML 文件
| 驼峰式、短横线式或者下划线式
| 标准 YAML 列表语法或者逗号分隔值

| 环境变量
| 大写并且以下划线作为定界符，`_` 不能放在属性名之间使用
| 数字值两边使用下划线连接，例如 `MY_ACME_1_OTHER = my.acme[1].other`

| 系统属性
| 驼峰式、短横线式或者下划线式
| 标准列表语法使用 `[ ]` 或逗号分隔值
|===

TIP: 我们建议，属性尽可能以小写的短横线格式存储，比如 `my.property-name=acme`。

当绑定到 `Map` 属性时，如果 `key` 包含除小写字母数字字符或 `-` 以外的任何内容，则需要使用括号表示法来保留原始值。如果 key 没有使用 `[]` 包裹，则里面的任何非字母数字字符或 `-` 的字符都将被删除。例如，将以下属性绑定到一个 `Map`：

[source,yaml,indent=0]
----
	acme:
	  map:
	    "[/key1]": value1
	    "[/key2]": value2
	    /key3: value3

----

上面的属性将绑定到一个 `Map` 上，其中 `/key1`，`/key2` 和 `key3` 作为 map 的 key。

NOTE: 对于YAML文件，方括号需要用引号引起来，以便正确解析 keys。


[[boot-features-external-config-complex-type-merge]]
==== 合并复杂类型
当列表集合（list）在多个地方配置时，整个列表集合将被替换。

例如，假设带有 `name` 和 `description` 属性的 `MyPojo` 对象默认为 `null`。以下示例中，`AcmeProperties` 暴露了一个 `MyPojo` 对象列表集合：

[source,java,indent=0]
----
	@ConfigurationProperties("acme")
	public class AcmeProperties {

		private final List<MyPojo> list = new ArrayList<>();

		public List<MyPojo> getList() {
			return this.list;
		}

	}
----

配置可以如下：

[source,yaml,indent=0]
----
	acme:
	  list:
	    - name: my name
	      description: my description
	---
	spring:
	  profiles: dev
	acme:
	  list:
	    - name: my another name
----

如果 `dev` 配置文件未激活，则 `AcmeProperties.list` 只包含一条 `MyPojo` 条目，如之前所述。但是，如果激活了 `dev` 配置文件，列表集合仍然只包含一个条目（name 属性值为 `my another name`，description 为 `null`）。
此配置不会向列表集合中添加第二个 `MyPojo` 实例，也不会合并条目。

在多个配置文件中指定一个 `List` 时，最高优先级（并且只有一个）的列表集合将被使用。可做如下配置：

[source,yaml,indent=0]
----
	acme:
	  list:
	    - name: my name
	      description: my description
	    - name: another name
	      description: another description
	---
	spring:
	  profiles: dev
	acme:
	  list:
	    - name: my another name
----

在前面示例中，如果 `dev` 配置文件处于活动状态，则 `AcmeProperties.list` 包含一个 `MyPojo` 条目（name 为 `my another name`，description 为 `null`）。对于 YAML 而言，逗号分隔的列表和YAML 列表同样会完全覆盖列表集合的内容。

对于 Map 属性，您可以绑定来自多个源中提取的属性值。但是，对于多个源中的相同属性，则使用高优先级最高的属性。以下示例从 `AcmeProperties` 暴露了一个 `Map<String, MyPojo>`：

[source,java,indent=0]
----
	@ConfigurationProperties("acme")
	public class AcmeProperties {

		private final Map<String, MyPojo> map = new HashMap<>();

		public Map<String, MyPojo> getMap() {
			return this.map;
		}

	}
----

可以考虑以下配置：

[source,yaml,indent=0]
----
	acme:
	  map:
	    key1:
	      name: my name 1
	      description: my description 1
	---
	spring:
	  profiles: dev
	acme:
	  map:
	    key1:
	      name: dev name 1
	    key2:
	      name: dev name 2
	      description: dev description 2
----

如果 `dev` 配置文件未激活，则 `AcmeProperties.map` 只包含一个带 `key1` key 的条目（name 为 `my name 1`，description 为 `my description 1`）。
如果激活了 `dev` 配置文件，则 map 将包含两个条目， key 分别为 `key1`（name 为 `dev name 1` 和 description 为 `my description 1`）和 `key2`（name 为 `dev name 2` 和 description 为 `dev description 2`）。

NOTE: 前面的合并规则适用于所有不同属性源的属性，而不仅仅是 YAML 文件。

[[boot-features-external-config-conversion]]
==== 属性转换
当外部应用程序属性（application properties） 绑定到 `@ConfigurationProperties` bean 时，Spring Boot 会尝试将其属性强制转换为正确的类型。如果需要自定义类型转换，可以提供 `ConversionService` bean（名为 `conversionService` 的 bean）或自定义属性编辑器（通过 `CustomEditorConfigurer` bean）或自定义转换器（带有注解为 `@ConfigurationPropertiesBinding` 的 bean 定义）。

NOTE: 由于该 bean 在应用程序生命周期早期就被请求 ，因此请限制 `ConversionService` 使用的依赖。您在创建时可能无法完全初始化所需的依赖。如果配置 key 为非强制需要，您可能希望重命名自定义的 `ConversionService`，并仅依赖于使用 `@ConfigurationPropertiesBinding` 限定的自定义转换器。

[[boot-features-external-config-conversion-duration]]
===== 转换 duration
Spring Boot 支持持续时间（duration）表达。如果您暴露一个 `java.time.Duration` 属性，则可以在应用程序属性中使用以下格式：

* 常规 `long` 表示（除非指定 `@DurationUnit`，否则使用毫秒作为默认单位）
* {java-api}/java/time/Duration.html#parse-java.lang.CharSequence-[used by `java.time.Duration`] 使用的标准 ISO-8601 格式
* 一种更易读的格式，值和单位在一起（例如 `10s` 表示 10 秒）

思考以下示例：

[source,java,indent=0]
----
include::{code-examples}/context/properties/bind/AppSystemProperties.java[tag=example]
----

指定一个会话超时时间为 `30` 秒，使用 `30`、`PT30S` 和 `30s` 等形式都是可以的。读取超时时间设置为 `500ms`，可以采用以下任何一种形式：`500`、`PT0.5S` 和 `500ms`。

您也可以使用任何支持的单位来标识：

* `ns` 纳秒
* `us` 微秒
* `ms` 毫秒
* `s` 秒
* `m` 分
* `h` 小时
* `d` 天

默认单位是毫秒，可以使用 `@DurationUnit` 配合上面的单位示例重写。

TIP: 要从先前仅使用 `Long` 来表示持续时间的版本进行升级，如果切换到 `Duration` 时不是毫秒，请定义单位（使用 `@DurationUnit`）。这样做可以提供透明的升级路径，同时支持更丰富的格式。

[[boot-features-external-config-conversion-datasize]]
===== 转换 Data Size
Spring Framework 有一个 `DataSize` 值类型，允许以字节表示大小。如果暴露一个 `DataSize` 属性，则可以在应用程序属性中使用以下格式：

* 常规的 `long` 表示（使用字节作为默认单位，除非指定了 `@DataSizeUnit`）
* 更具有可读性的格式，值和单位在一起（例如 `10MB` 表示 10 兆字节）

请思考以下示例：

[source,java,indent=0]
----
include::{code-examples}/context/properties/bind/AppIoProperties.java[tag=example]
----

要指定 `10` 兆字节的缓冲大小，使用 `10` 和 `10MB` 是等效的。`256` 字节的大小可以指定为 `256` 或 `256B`。

您也可以使用任何支持的单位：

* `B` 字节
* `KB` 千字节
* `MB` 兆字节
* `GB` 千兆字节
* `TB` 兆兆字节

默认单位是字节，可以使用 `@DataSizeUnit` 配合上面的示例单位重写。

TIP: 要从先前仅使用 `Long` 来表示大小的版本进行升级，请确保在切换到 `DataSize` 不是字节的情况下定义单位（使用 `@DataSizeUnit`）。这样做可以提供透明的升级路径，同时支持更丰富的格式。

[[boot-features-external-config-validation]]
==== @ConfigurationProperties 验证
只要使用了 Spring 的 `@Validated` 注解，Spring Boot 就会尝试验证 `@ConfigurationProperties` 类。您可以直接在配置类上使用 JSR-303 `javax.validation` 约束注解。为此，请确保 JSR-303 实现在 classpath 上，然后将约束注解添加到字段上，如下所示：

[source,java,indent=0]
----
	@ConfigurationProperties(prefix="acme")
	@Validated
	public class AcmeProperties {

		@NotNull
		private InetAddress remoteAddress;

		// ... getters and setters

	}
----

TIP: 您还可以通过使用 `@Validated` 注解创建配置属性的 `@Bean` 方法来触发验证。

虽然绑定时也会验证嵌套属性，但最好的做法还是将关联字段注解上 `@Valid`。这可确保即使未找到嵌套属性也会触发验证。以下示例基于前面的 `AcmeProperties` 示例：

[source,java,indent=0]
----
	@ConfigurationProperties(prefix="acme")
	@Validated
	public class AcmeProperties {

		@NotNull
		private InetAddress remoteAddress;

		@Valid
		private final Security security = new Security();

		// ... getters and setters

		public static class Security {

			@NotEmpty
			public String username;

			// ... getters and setters

		}

	}
----

您还可以通过创建一个名为 `configurationPropertiesValidator` 的 bean 定义来添加自定义 Spring `Validator`。应该将 @Bean 方法声明为 `static`。
配置属性验证器在应用程序生命周期的早期创建，将 `@Bean` 方法声明为 `static` 可以无需实例化 `@Configuration` 类来创建 bean。这样做可以避免早期实例化可能导致的意外问题。这里有一个属性验证示例，讲解了如何设置。

TIP: `spring-boot-actuator` 模块包括一个暴露所有 `@ConfigurationPropertie`s bean 的端点。可将 Web 浏览器指向 `/actuator/configprops` 或使用等效的 JMX 端点。有关详细信息，请参阅 "<<production-ready-features.adoc#production-ready-endpoints, 生产就绪功能>>" 部分。

[[boot-features-external-config-vs-value]]
==== `@ConfigurationProperties` 与 `@Value` 对比
`@Value` 注解是核心容器功能，它不提供与类型安全配置属性相同的功能。下表总结了 `@ConfigurationProperties` 和 `@Value` 支持的功能：

[cols="4,2,2"]
|===
| 功能 |`@ConfigurationProperties` |`@Value`

| <<boot-features-external-config-relaxed-binding,宽松绑定>>
| Yes
| No

| <<appendix-configuration-metadata.adoc#configuration-metadata,元数据支持>>
| Yes
| No

| `SpEL` 表达式
| No
| Yes
|===

如果您要为自己的组件定义一组配置 key，我们建议您将它们分组到使用 `@ConfigurationProperties` 注解的 POJO 中。您应该知道，由于 `@Value` 不支持宽松绑定，因此如果您需要通过环境变量来提供值，它并不是一个好的选择。

最后，虽然您可以在 `@Value` 中编写 SpEL 表达式，但来自<<boot-features-external-config-application-property-files,应用程序属性文件>>的此类表达式并不会被处理。

[[boot-features-profiles]]
== Profiles
Spring Profile 提供了一种应用程序配置部分隔离并使其仅在特定环境中可用的方法。可以使用 `@Profile` 来注解任何 `@Component` 或 `@Configuration` 以指定何时加载它，如下所示：

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	@Profile("production")
	public class ProductionConfiguration {

		// ...

	}
----

NOTE: 如果 `@ConfigurationProperties` Bean是通过 `@EnableConfigurationProperties` 而非自动扫描注册的，则需要在 `@EnableConfigurationProperties` 注解的 `@Configuration` 类上指定 `@Profile` 注解。
在扫描 `@ConfigurationProperties` 的情况下，可以在 `@ConfigurationProperties` 类本身上指定 `@Profile`。

您可以使用 configprop:spring.profiles.active[] `Environment` 属性指定哪些配置文件处于激活状态。您可以使用本章前面介绍的任何方法指定属性。例如，您可以将其包含在 `application.properties` 中，如下所示：

[source,properties,indent=0,configprops]
----
	spring.profiles.active=dev,hsqldb
----

您还可以在命令行上使用以下开关指定它：`--spring.profiles.active=dev,hsqldb`。



[[boot-features-adding-active-profiles]]
=== 添加激活 Profile
configprop:spring.profiles.active[] 属性遵循与其他属性相同的排序规则：应用优先级最高的 `PropertySource`。这意味着您可以在 `application.properties` 中指定激活配置文件，然后使用命令行开关替换它们。

有时，将特定 profile 的属性添加到激活配置文件而不是替换它们，这种方式也是很有用的。 configprop:spring.profiles.include[]  属性可无条件地添加激活配置文件。`SpringApplication` 入口还有一个 Java API，用于设置其他 profile（即，在 `spring.profiles.active` 属性激活的 profile 之上）。请参阅 {spring-boot-module-api}/SpringApplication.html[SpringApplication] 中的 `setAdditionalProfiles()` 方法。

例如，当使用开关 `--spring.profiles.active=prod` 运行有以下属性的应用程序时，`proddb` 和 `prodmq` 配置文件也会被激活：

[source,yaml,indent=0]
----
	---
	my.property: fromyamlfile
	---
	spring.profiles: prod
	spring.profiles.include:
	  - proddb
	  - prodmq
----

NOTE: 请记住，可以在 YAML 文档中定义 `spring.profiles` 属性，以确定此特定文档何时包含在配置中。有关更多详细信息，请参见<<howto.adoc#howto-change-configuration-depending-on-the-environment,根据环境更改配置>>。

[[boot-features-programmatically-setting-profiles]]
=== 以编程方式设置 Profile
您可以在应用程序运行之前通过调用 `SpringApplication.setAdditionalProfiles(…)` 以编程方式设置活动配置文件。 也可以使用Spring的 `ConfigurableEnvironment` 接口激活 profile。

[[boot-features-profile-specific-configuration]]
=== 特定 Profile 的配置文件
特定 profile 的 `application.properties`（或 `application.yml`）和通过 `@ConfigurationProperties` 引用的文件被当做文件并加载。有关详细信息，请参见 "<<boot-features-external-config-profile-specific-properties,特定 Profile 的属性文件>>" 。

[[boot-features-logging]]
== 日志记录
Spring Boot 使用 https://commons.apache.org/logging[Commons Logging]  记录所有内部日志，但开放日志的底层实现。其为 {java-api}/java/util/logging/package-summary.html[Java Util Logging] 、https://logging.apache.org/log4j/2.x/[Log4J2] 和 https://logback.qos.ch/[Logback] 提供了默认配置。在每种情况下，日志记录器都预先配置为使用控制台输出，并且还提供可选的文件输出。

默认情况下，如果您使用了 `Starter`，则使用 Logback 进行日志记录。还包括合适的 Logback 路由，以确保在使用 Java Util Logging、Commons Logging、Log4J 或 SLF4J 的依赖库都能正常工作。

TIP: Java 有很多日志框架可供使用。如果以上列表让您感到困惑，请不要担心。通常，您不需要更改日志依赖，并且 Spring Boot 提供的默认配置可以保证日志正常工作。

TIP: 将应用程序部署到Servlet容器或应用程序服务器时，通过Java Util Logging API执行的日志记录不会路由到应用程序的日志中。 这样可以防止容器或其他已部署到容器中的应用程序执行的日志记录出现在应用程序的日志中。


[[boot-features-logging-format]]
=== 日志格式
Spring Boot 默认日志输出类似于以下示例：

[indent=0]
----
2019-03-05 10:57:51.112  INFO 45469 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/7.0.52
2019-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2019-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1358 ms
2019-03-05 10:57:51.698  INFO 45469 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: 'dispatcherServlet' to [/]
2019-03-05 10:57:51.702  INFO 45469 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]
----

输出以下项：

* 日期和时间：毫秒精度，易于排序。
* 日志级别：`ERROR`、`WARN`、`INFO`、`DEBUG` 或 `TRACE`。
* 进程 ID。
* 一个 `---` 分隔符，用于区分实际日志内容的开始。
* 线程名称：在方括号中（可能会截断控制台输出）。
* 日志记录器名称：这通常是源类名称（通常为缩写）。
* 日志内容。

NOTE: Logback 没有 `FATAL` 级别。该级别映射到 `ERROR`。

[[boot-features-logging-console-output]]
=== 控制台输出
默认日志配置会在写入时将消息回显到控制台。默认情况下，会记录 `ERROR`、`WARN` 和 `INFO` 级别的日志。您还可以通过使用 `--debug `标志启动应用程序来启用调试模式。

[indent=0]
----
	$ java -jar myapp.jar --debug
----

NOTE: 您还可以在 `application.properties` 中指定 `debug=true`。

启用调试模式后，核心日志记录器（内嵌容器、Hibernate 和 Spring Boot）将被配置为输出更多日志信息。启用调试模式不会将应用程序配置为使用 `DEBUG` 级别记录所有日志内容。

或者，您可以通过使用 `--trace` 标志（或在 `application.properties` 中的设置 `trace=true`）启动应用程序来启用跟踪模式。这样做可以为选择的核心日志记录器（内嵌容器、Hibernate 模式生成和整个 Spring 组合）启用日志追踪。

[[boot-features-logging-color-coded-output]]
==== 着色输出
如果您的终端支持 ANSI，则可以使用颜色输出来提高可读性。您可以将 `spring.output.ansi.enabled` 设置为 {spring-boot-module-api}/ansi/AnsiOutput.Enabled.html[受支持的值] 以覆盖自动检测。

可使用 `%clr`  转换字配置颜色编码。最简单形式是，转换器根据日志级别对输出进行着色，如下所示：

[source,indent=0]
----
%clr(%5p)
----

下表描述日志级别与颜色的映射关系：

|===
| Level | Color

| `FATAL`
| Red

| `ERROR`
| Red

| `WARN`
| Yellow

| `INFO`
| Green

| `DEBUG`
| Green

| `TRACE`
| Green
|===

或者，您可以通过将其作为转换选项指定应使用的颜色或样式。例如，要将文本变为黄色，请使用以下设置：

[source,indent=0]
----
%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){yellow}
----

支持以下颜色和样式：

* `blue`
* `cyan`
* `faint`
* `green`
* `magenta`
* `red`
* `yellow`



[[boot-features-logging-file-output]]
=== 文件输出
默认情况下，Spring Boot 仅记录到控制台，不会写入日志文件。想除了控制台输出之外还要写入日志文件，则需要设置 `logging.file` 或 `logging.path` 属性（例如，在 `application.properties` 中）。

下表展示了如何与 `logging.*` 属性一起使用：

.Logging 属性
[cols="1,1,1,4"]
|===
| configprop:logging.file.name[] | configprop:logging.file.path[] | Example | Description

| _(none)_
| _(none)_
|
| 仅在控制台输出

| 指定文件
| _(none)_
| `my.log`
| 写入指定的日志文件。名称可以是绝对位置或相对于当前目录。

| _(none)_
| 指定目录
| `/var/log`
| 将 `spring.log` 写入指定的目录。名称可以是绝对位置或相对于当前目录。
|===

日志文件在达到 `10MB` 时会轮转，并且与控制台输出一样，默认情况下会记录 `ERROR`、`WARN` 和 `INFO` 级别的内容。可以使用 `logging.file.max-size` 属性更改大小限制。除非已设置 `logging.file.max-history` 属性，否则以前轮转的文件将无限期归档。
可以使用 `logging.file.total-size-cap` 限制日志归档文件的总大小。 当日志归档的总大小超过该阈值时，将删除备份。 要在应用程序启动时强制清除日志归档文件，请使用 `logging.file.clean-history-on-start` 属性。

TIP: 日日志属性独立于实际的日志底层。因此，spring Boot 不管理特定的配置 key（例如 Logback 的 `logback.configurationFile`）。


[[boot-features-custom-log-levels]]
=== 日志等级
所有受支持的日志记录系统都可以使用 `logging.level.<logger-name>=<level>` 来设置 Spring `Environment` 中的记录器等级（例如，在 `application.properties` 中）。其中 level 是 `TRACE`、`DEBUG`、`INFO`、`WARN`、`ERROR`、`FATAL` 和 `OFF` 其中之一。可以使用 `logging.level.root` 配置 `root` 记录器。

以下示例展示了 `application.properties` 中默认的日志记录设置：

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	logging.level.root=warn
	logging.level.org.springframework.web=debug
	logging.level.org.hibernate=error
----

也可以使用环境变量设置日志记录级别。 例如， `LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_WEB=DEBUG` 会将 `org.springframework.web` 设置为 `DEBUG`。

NOTE: 以上方法仅适用于程序包级别的日志记录。 由于宽松的绑定总是将环境变量转换为小写，因此无法以这种方式为单个类配置日志记录。 如果需要为类配置日志记录，则可以使用  <<boot-features-external-config-application-json, the `SPRING_APPLICATION_JSON`>> 变量。

[[boot-features-custom-log-groups]]
=== 日志组
将相关记录器组合在一起以便可以同时配置，这通常很有用。例如，您可以更改所有 Tomcat 相关记录器的日志记录级别，但您无法轻松记住顶层的包名。

为了解决这个问题，Spring Boot 允许您在 Spring `Environment` 中定义日志记录组。例如，以下通过将 tomcat 组添加到 `application.properties` 来定义 tomcat 组：

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	logging.group.tomcat=org.apache.catalina, org.apache.coyote, org.apache.tomcat
----

定义后，您可以使用一行配置来更改组中所有记录器的级别：

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	logging.level.tomcat=TRACE
----

Spring Boot 包含以下预定义的日志记录组，可以直接使用：

[cols="1,4"]
|===
| 名称 | 日志记录器

| web
| `org.springframework.core.codec`, `org.springframework.http`, `org.springframework.web`, `org.springframework.boot.actuate.endpoint.web`, `org.springframework.boot.web.servlet.ServletContextInitializerBeans`

| sql
| `org.springframework.jdbc.core`, `org.hibernate.SQL`, `org.jooq.tools.LoggerListener`
|===



[[boot-features-custom-log-configuration]]
=== 自定义日志配置
可以通过在 classpath 中引入适合的库来激活各种日志记录系统，并且可以通过在 classpath 的根目录中或在以下 Spring Environment 属性指定的位置提供合适的配置文件来进一步自定义：logging.config。

您可以使用 `org.springframework.boot.logging.LoggingSystem` 系统属性强制 Spring Boot 使用特定的日志记录系统。该值应该是一个实现了 `LoggingSystem` 的类的完全限定类名。您还可以使用 `none` 值完全禁用 Spring Boot 的日志记录配置。


NOTE: 由于日志记录在创建 `ApplicationContext` 之前初始化，因此无法在 Spring `@Configuration` 文件中控制来自 `@PropertySources` 的日志记录。更改日志记录系统或完全禁用它的唯一方法是通过系统属性设置。

根据您的日志记录系统，将加载以下文件：

|===
| 日志记录系统 | 文件

| Logback
| `logback-spring.xml`, `logback-spring.groovy`, `logback.xml`, 或者 `logback.groovy`

| Log4j2
| `log4j2-spring.xml` 或者 `log4j2.xml`

| JDK (Java Util Logging)
| `logging.properties`
|===

NOTE: 如果可能，我们建议您使用 `-spring` 的形式来配置日志记录（比如 `logback-spring.xml` 而不是 `logback.xml`）。如果使用标准的配置位置，Spring 无法完全控制日志初始化。

WARNING: Java Util Logging 存在已知的类加载问题，这些问题在以 'executable jar' 运行时会触发。如果可能的话，我们建议您在使用可执行 jar 方式运行时避免使用它。 .

为了进行自定义，部分其他属性会从 Spring `Environment` 传输到 `System` 属性，如下表所述：

|===
| Spring Environment | 系统属性 | 说明

| configprop:logging.exception-conversion-word[]
| `LOG_EXCEPTION_CONVERSION_WORD`
| 记录异常时使用的转换字。

| configprop:logging.file.clean-history-on-start[]
| `LOG_FILE_CLEAN_HISTORY_ON_START`
| 是否在启动时清除存档日志文件（如果启用了LOG_FILE）。 （仅默认的Logback设置受支持。）

| configprop:logging.file.name[]
| `LOG_FILE`
| 如果已定义，则在默认日志配置中使用它。

| configprop:logging.file.max-size[]
| `LOG_FILE_MAX_SIZE`
| 最大日志文件大小（如果启用了 LOG_FILE）。（仅支持默认的 Logback 设置。）

| configprop:logging.file.max-history[]
| `LOG_FILE_MAX_HISTORY`
| 要保留的归档日志文件最大数量（如果启用了 LOG_FILE）。（仅支持默认的 Logback 设置。）

| configprop:logging.file.path[]
| `LOG_PATH`
| 如果已定义，则在默认日志配置中使用它。

| configprop:logging.file.total-size-cap[]
| `LOG_FILE_TOTAL_SIZE_CAP`
| 要保留的日志备份的总大小（如果启用了LOG_FILE）。 （仅默认的Logback设置受支持。）

| configprop:logging.pattern.console[]
| `CONSOLE_LOG_PATTERN`
| 要在控制台上使用的日志模式（stdout）。（仅支持默认的 Logback 设置。）

| configprop:logging.pattern.dateformat[]
| `LOG_DATEFORMAT_PATTERN`
| 日志日期格式的 Appender 模式。（仅支持默认的 Logback 设置。）

| configprop:logging.pattern.file[]
| `FILE_LOG_PATTERN`
| 要在文件中使用的日志模式（如果启用了 `LOG_FILE`）。（仅支持默认的 Logback 设置。）

| configprop:logging.pattern.level[]
| `LOG_LEVEL_PATTERN`
| 渲染日志级别时使用的格式（默认值为 `%5p`）。（仅支持默认的 Logback 设置。）

| configprop:logging.pattern.rolling-file-name[]
| `ROLLING_FILE_NAME_PATTERN`
| 过渡日志文件名的模式(默认 `$\{LOG_FILE}.%d\{yyyy-MM-dd}.%i.gz`)。

| `PID`
| `PID`
| 当前进程 ID（如果可能，则在未定义为 OS 环境变量时发现）。
|===

所有受支持的日志记录系统在解析其配置文件时都可以参考系统属性。有关示例，请参阅 `spring-boot.jar` 中的默认配置：

* {spring-boot-code}/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/logback/defaults.xml[Logback]
* {spring-boot-code}/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/log4j2/log4j2.xml[Log4j 2]
* {spring-boot-code}/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/java/logging-file.properties[Java Util logging]

[TIP]
====
如果要在日志记录属性中使用占位符，则应使用 <<boot-features-external-config-placeholders-in-properties,Spring Boot 的语法>>，而不是使用底层框架的语法。值得注意的是，如果使用 Logback，则应使用 `:` 作为属性名称与其默认值之间的分隔符，而不是使用 `:-`。
====

[TIP]
====
您可以通过仅覆盖 `LOG_LEVEL_PATTERN`（或带 Logback 的 `logging.pattern.level`）将 MDC 和其他特别的内容添加到日志行。例如，如果使用 `logging.pattern.level=user:%X{user} %5p`，则默认日志格式包含 user MDC 项（如果存在），如下所示:

[indent=0]
----
	2019-08-30 12:30:04.031 user:someone INFO 22174 --- [  nio-8080-exec-0] demo.Controller
	Handling authenticated request
----
====



[[boot-features-logback-extensions]]
=== Logback 扩展
Spring Boot 包含许多 Logback 扩展，可用于进行高级配置。您可以在 `logback-spring.xml` 配置文件中使用这些扩展。

NOTE: 由于标准的 `logback.xml` 配置文件加载过早，因此无法在其中使用扩展。您需要使用 `logback-spring.xml` 或定义 `logging.config` 属性。

WARNING: 扩展不能与 Logback 的 https://logback.qos.ch/manual/configuration.html#autoScan[配置扫描] 一起使用。如果尝试这样做，更改配置文件会导致发生类似以下错误日志： .

[indent=0]
----
	ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProperty], current ElementPath is [[configuration][springProperty]]
	ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProfile], current ElementPath is [[configuration][springProfile]]
----



==== 特定 Profile 配置
`<springProfile>` 标签允许您根据激活的 Spring profile 选择性地包含或排除配置部分。在 `<configuration>` 元素中的任何位置都支持配置 profile。使用 `name` 属性指定哪个 proifle 接受配置。`<springProfile>` 标记可以包含简单的 proifle 名称（例如 `staging`）或 profile 表达式。profile 表达式允许表达更复杂的 profile 逻辑，
例如 `production & (eu-central | eu-west)`。有关详细信息，请查阅 {spring-framework-docs}core.html#beans-definition-profiles-java[参考指南] 。以下清单展示了三个示例 profile：

[source,xml,indent=0]
----
	<springProfile name="staging">
		<!-- configuration to be enabled when the "staging" profile is active -->
	</springProfile>

	<springProfile name="dev | staging">
		<!-- configuration to be enabled when the "dev" or "staging" profiles are active -->
	</springProfile>

	<springProfile name="!production">
		<!-- configuration to be enabled when the "production" profile is not active -->
	</springProfile>
----



==== 环境属性
使用 `<springProperty>` 标签可以让您暴露 Spring 环境（`Environment`）中的属性，以便在 Logback 中使用。如果在 Logback 配置中访问来自 `application.properties` 文件的值，这样做很有用。标签的工作方式与 Logback 的标准 `<property>` 标签类似。但是，您可以指定属性（来自 `Environment`）的 `source`，而不是指定直接的 `value`。如果需要将属性存储在 `local` 范围以外的其他位置，则可以使用 `scope` 属性。
如果需要回退值（如果未在 `Environment` 中设置该属性），则可以使用 `defaultValue` 属性。以下示例展示了如何暴露属性以便在 Logback 中使用：

[source,xml,indent=0]
----
	<springProperty scope="context" name="fluentHost" source="myapp.fluentd.host"
			defaultValue="localhost"/>
	<appender name="FLUENT" class="ch.qos.logback.more.appenders.DataFluentAppender">
		<remoteHost>${fluentHost}</remoteHost>
		...
	</appender>
----

NOTE: 必须以 kebab 风格（短横线小写风格）指定 `source`（例如 `my.property-name`）。但可以使用宽松规则将属性添加到 `Environment` 中。

[[boot-features-internationalization]]
== 国际化
Spring Boot支持本地化消息，因此您的应用程序可以迎合不同语言首选项的用户。 默认情况下，Spring Boot在类路径的根目录下查找 `messages` 资源包的存在。

NOTE: 当已配置资源束的默认属性文件可用时（即默认情况下为 `messages.properties`），将应用自动配置。 如果您的资源包仅包含特定于语言的属性文件，则需要添加默认文件。 如果找不到与任何配置的基本名称匹配的属性文件，将没有自动配置的 `MessageSource`。

可以使用 `spring.messages` 命名空间配置资源包的基本名称以及其他几个属性，如以下示例所示：

[source,properties,indent=0,configprops]
----
	spring.messages.basename=messages,config.i18n.messages
	spring.messages.fallback-to-system-locale=false
----

TIP: `spring.messages.basename` 支持以逗号分隔的位置列表，可以是包限定符，也可以是从类路径根目录解析的资源。

有关更多支持的选项，请参见 {spring-boot-autoconfigure-module-code}/context/MessageSourceProperties.java[`MessageSourceProperties`]

[[boot-features-json]]
== JSON
Spring Boot 为三个 JSON 映射库提供了内置集成：

- Gson
- Jackson
- JSON-B

Jackson 是首选和默认的库。

[[boot-features-json-jackson]]
=== Jackson
Spring Boot 提供了 Jackson 的自动配置，Jackson 是 `spring-boot-starter-json` 的一部分。当 Jackson 在 classpath 上时，会自动配置 `ObjectMapper` bean。Spring Boot 提供了几个配置属性来 <<howto.adoc#howto-customize-the-jackson-objectmapper,自定义 `ObjectMapper` 的配置>>。

[[boot-features-json-gson]]
=== Gson
Spring Boot 提供 Gson 的自动配置。当 `Gson` 在 classpath 上时，会自动配置 Gson bean。Spring Boot 提供了几个 `spring.gson.*` 配置属性来自定义配置。为了获得更多控制，可以使用一个或多个 `GsonBuilderCustomizer` bean。

[[boot-features-json-json-b]]
=== JSON-B
Spring Boot 提供了 JSON-B 的自动配置。当 JSON-B API 和实现在 classpath 上时，将自动配置 `Jsonb` bean。首选的 JSON-B 实现是 Apache Johnzon，它提供了依赖管理。

[[boot-features-developing-web-applications]]
== 开发 Web 应用程序
Spring Boot 非常适合用于开发 web 应用程序。您可以使用嵌入式 Tomcat、Jetty 或者 Undertow 来创建一个独立（self-contained）的 HTTP 服务器。大多数 web 应用程序使用 `spring-boot-starter-web` 模块来快速搭建和运行，您也可以选择使用 `spring-boot-starter-webflux` 模块来构建响应式（reactive） web 应用程序。

如果您尚未开发过 Spring Boot web 应用程序，则可以按照 _<<getting-started.adoc#getting-started-first-application, 入门>>_  章节中的“Hello World!”示例进行操作。

[[boot-features-spring-mvc]]
=== Spring Web MVC 框架
{spring-framework-docs}web.html#mvc[Spring Web MVC 框架] （通常简称“Spring MVC”）是一个富模型-视图-控制器的 web 框架。Spring MVC 允许您创建 `@Controller` 或者 `@RestController` bean 来处理传入的 HTTP 请求。控制器中的方法通过 `@RequestMapping` 注解映射到 HTTP。

以下是一个使用了 `@RestController` 来响应 JSON 数据的典型示例：

[source,java,indent=0]
----
	@RestController
	@RequestMapping(value="/users")
	public class MyRestController {

		@RequestMapping(value="/{user}", method=RequestMethod.GET)
		public User getUser(@PathVariable Long user) {
			// ...
		}

		@RequestMapping(value="/{user}/customers", method=RequestMethod.GET)
		List<Customer> getUserCustomers(@PathVariable Long user) {
			// ...
		}

		@RequestMapping(value="/{user}", method=RequestMethod.DELETE)
		public User deleteUser(@PathVariable Long user) {
			// ...
		}

	}
----

Spring MVC 是 Spring Framework 核心的一部分，详细介绍可参考其 {spring-framework-docs}web.html#mvc[参考文档]。 https://spring.io/guides 还提供了几个 Spring MVC 相关的指南。

[[boot-features-spring-mvc-auto-configuration]]
==== Spring MVC 自动配置
Spring Boot 提供了适用于大多数 Spring MVC 应用的自动配置（auto-configuration）。

自动配置在 Spring 默认功能上添加了以下功能：

* 引入 `ContentNegotiatingViewResolver` 和 `BeanNameViewResolver` bean。
* 支持服务静态资源，包括对 WebJar 的支持（<<boot-features-spring-mvc-static-content,见下文>>）。
* 自动注册 `Converter`、`GenericConverter` 和 `Formatter` bean。
* 支持 `HttpMessageConverter`（ <<boot-features-spring-mvc-message-converters,见下文>>）。
* 自动注册 `MessageCodesResolver`（<<boot-features-spring-message-codes,见下文>>）。
* 支持静态 `index.html`。
* 支持自定义 `Favicon` （<<boot-features-spring-mvc-favicon,见下文>>）。
* 自动使用 `ConfigurableWebBindingInitializer` bean（<<boot-features-spring-mvc-web-binding-initializer,见下文>>）。

如果您想保留 Spring Boot MVC 的功能，并且需要添加其他  {spring-framework-docs}web.html#mvc[MVC configuration]（interceptor、formatter 和视图控制器等），可以添加自己的 `WebMvcConfigurerAdapter` 类型的 `@Configuration` 类，但不能带 `@EnableWebMvc` 注解。

如果您想自定义 `RequestMappingHandlerMapping`、`RequestMappingHandlerAdapter` 或者 `ExceptionHandlerExceptionResolver` 实例，可以声明一个 `WebMvcRegistrationsAdapter` 实例来提供这些组件。

如果您想完全掌控 Spring MVC，可以添加自定义注解了 `@EnableWebMvc` 的 `@Configuration` 配置类。

[[boot-features-spring-mvc-message-converters]]
==== HttpMessageConverters
Spring MVC 使用 `HttpMessageConverter` 接口来转换 HTTP 的请求和响应。开箱即用功能包含了合适的默认值，比如对象可以自动转换为 JSON（使用 Jackson 库）或者 XML（优先使用 Jackson XML 扩展，其次为 JAXB）。字符串默认使用 `UTF-8` 编码。

如果您需要添加或者自定义转换器（converter），可以使用 Spring Boot 的 `HttpMessageConverters` 类：

[source,java,indent=0]
----
	import org.springframework.boot.autoconfigure.http.HttpMessageConverters;
	import org.springframework.context.annotation.*;
	import org.springframework.http.converter.*;

	@Configuration(proxyBeanMethods = false)
	public class MyConfiguration {

		@Bean
		public HttpMessageConverters customConverters() {
			HttpMessageConverter<?> additional = ...
			HttpMessageConverter<?> another = ...
			return new HttpMessageConverters(additional, another);
		}

	}
----

上下文中的所有 `HttpMessageConverter` bean 都将被添加到转换器列表中。您也可以用这种方式来覆盖默认转换器。

[[boot-features-json-components]]
==== 自定义 JSON Serializer 和 Deserializer
如果您使用 Jackson 序列化和反序列化 JSON 数据，可能需要自己编写 `JsonSerializer` 和 `JsonDeserializer` 类。
自定义序列化器（serializer）的做法通常是 https://github.com/FasterXML/jackson-docs/wiki/JacksonHowToCustomSerializers[通过一个模块来注册 Jackson]， 然而 Spring Boot 提供了一个备选的 `@JsonComponent` 注解，它可以更加容易地直接注册 Spring Bean。

您可以直接在 `JsonSerializer` 或者 `JsonDeserializer` 实现上使用 `@JsonComponent` 注解。您也可以在将序列化器/反序列化器（deserializer）作为内部类的类上使用。例如：

[source,java,indent=0]
----
	import java.io.*;
	import com.fasterxml.jackson.core.*;
	import com.fasterxml.jackson.databind.*;
	import org.springframework.boot.jackson.*;

	@JsonComponent
	public class Example {

		public static class Serializer extends JsonSerializer<SomeObject> {
			// ...
		}

		public static class Deserializer extends JsonDeserializer<SomeObject> {
			// ...
		}

	}
----

`ApplicationContext` 中所有的 `@JsonComponent` bean 将被自动注册到 Jackson 中，由于 `@JsonComponent` 使用 `@Component` 注解标记，因此组件扫描（component-scanning）规则将对其生效。

Spring Boot 还提供了 {spring-boot-module-code}/jackson/JsonObjectSerializer.java[`JsonObjectSerializer`] 和 {spring-boot-module-code}/jackson/JsonObjectDeserializer.java[`JsonObjectDeserializer`] 基类，
它们在序列化对象时为标准的 Jackson 版本提供了有用的替代方案。有关详细信息，请参阅 Javadoc 中的 {spring-boot-module-api}/jackson/JsonObjectSerializer.html[`JsonObjectSerializer`] 和 {spring-boot-module-api}/jackson/JsonObjectDeserializer.html[`JsonObjectDeserializer`]。

[[boot-features-spring-message-codes]]
==== MessageCodesResolver
Spring MVC 有一个从绑定错误中生成错误码的策略，用于渲染错误信息：`MessageCodesResolver`。如果您设置了 `spring.mvc.message-codes-resolver.format` 属性值为 `PREFIX_ERROR_CODE` 或 `POSTFIX_ERROR_CODE`，
Spring Boot 将为你创建该策略（请参阅 {spring-framework-api}/validation/DefaultMessageCodesResolver.Format.html[`DefaultMessageCodesResolver.Format`] 中的枚举）。

[[boot-features-spring-mvc-static-content]]
==== 静态内容
默认情况下，Spring Boot 将在 classpath 或者 `ServletContext` 根目录下从名为 `/static` （`/public`、`/resources` 或 `/META-INF/resources`）目录中服务静态内容。它使用了 Spring MVC 的 `ResourceHttpRequestHandler`，因此您可以通过添加自己的 `WebMvcConfigurerAdapter` 并重写 `addResourceHandlers` 方法来修改此行为。

在一个独立的（stand-alone） web 应用程序中，来自容器的默认 servlet 也是被启用的，并充当一个回退支援，Spring 决定不处理 `ServletContext` 根目录下的静态资源，容器的默认 servlet 也将会处理。大多情况下，这是不会发生的（除非您修改了默认的 MVC 配置），因为 Spring 始终能通过 `DispatcherServlet` 来处理请求。

默认情况下，资源被映射到 `/**`，但可以通过 spring.mvc.static-path-pattern 属性调整。比如，将所有资源重定位到 `/resources/**`：

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	spring.mvc.static-path-pattern=/resources/**
----

您还可以使用 `spring.resources.static-locations` 属性来自定义静态资源的位置（使用一个目录位置列表替换默认值）。根 Servlet context path `/` 自动作为一个 location 添加进来。

除了上述提到的标准静态资源位置之外，还有一种特殊情况是用于 https://www.webjars.org/[Webjars content]。如果以 Webjar 格式打包，则所有符合 `/webjars/**` 的资源都将从 jar 文件中服务。

TIP: 如果您的应用程序要包成 jar，请不要使用 `src/main/webapp` 目录。虽然此目录是一个通用标准，但它只适用于 war 打包，如果生成的是一个 jar，它将被绝大多数的构建工具所忽略。

Spring Boot 还支持 Spring MVC 提供的高级资源处理功能，允许使用例如静态资源缓存清除（cache busting）或者 Webjar 版本无关 URL。

要使用 Webjar 版本无关 URL 功能，只需要添加 `webjars-locator-core` 依赖。然后声明您的 Webjar，以 jQuery 为例，添加的 `"/webjars/jquery/dist/jquery.min.js"` 将变成 `"/webjars/jquery/x.y.z/dist/jquery.min.js"`，其中 `x.y.z` 是 Webjar 的版本。

NOTE: 如果您使用 JBoss，则需要声明 `webjars-locator-jboss-vfs` 依赖，而不是 `webjars-locator-core`，否则所有 Webjar 将被解析成 `404`。

要使用缓存清除功能，以下配置为所有静态资源配置了一个缓存清除方案，实际上是在 URL 上添加了一个内容哈希，例如 `<link href="/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css"/>`：

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	spring.resources.chain.strategy.content.enabled=true
	spring.resources.chain.strategy.content.paths=/**
----

NOTE: 模板中的资源链接在运行时被重写，这得益于 `ResourceUrlEncodingFilter` 为 Thymeleaf 和 FreeMarker 自动配置。在使用 JSP 时，您应该手动声明此过滤器。其他模板引擎现在还不会自动支持，但可以与自定义模板宏（macro）/helper 和  {spring-framework-api}/web/servlet/resource/ResourceUrlProvider.html[`ResourceUrlProvider`] 结合使用。

当使用例如 Javascript 模块加载器动态加载资源时，重命名文件是不可选的。这也是为什么支持其他策略并且可以组合使用的原因。fixed策略将在 URL 中添加一个静态版本字符串，而不是更改文件名：

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	spring.resources.chain.strategy.content.enabled=true
	spring.resources.chain.strategy.content.paths=/**
	spring.resources.chain.strategy.fixed.enabled=true
	spring.resources.chain.strategy.fixed.paths=/js/lib/
	spring.resources.chain.strategy.fixed.version=v12
----

使用此配置，JavaScript 模块定位在 `"/js/lib/"` 下使用固定版本策略（`"/v12/js/lib/mymodule.js"`），而其他资源仍使用内容策略（`<link href="/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css"/>`）。

有关更多支持选项，请参阅 {spring-boot-autoconfigure-module-code}/web/ResourceProperties.java[`ResourceProperties`]。

[TIP]
====
该功能已经在一个专门的 https://spring.io/blog/2014/07/24/spring-framework-4-1-handling-static-web-resources[博客文章]和 {spring-framework-docs}web.html#mvc-config-static-resources[Spring 框架的参考文档]中进行了详细描述
====

[[boot-features-spring-mvc-welcome-page]]
==== 欢迎页面
Spring Boot 支持静态和模板化的欢迎页面。它首先在配置的静态内容位置中查找 `index.html` 文件。如果找不到，则查找 `index` 模板。如果找到其中任何一个，它将自动用作应用程序的欢迎页面。

[[boot-features-spring-mvc-favicon]]
==== 自定义 Favicon

Spring Boot 在配置的静态内容位置和根 classpath 中查找 `favicon.ico`（按顺序）。如果该文件存在，则将被自动用作应用程序的 favicon。

[[boot-features-spring-mvc-pathmatch]]
==== 路径匹配与内容协商
Spring MVC 可以通过查看请求路径并将其与应用程序中定义的映射相匹配，将传入的 HTTP 请求映射到处理程序（例如 Controller 方法上的 `@GetMapping` 注解）。

Spring Boot 默认选择禁用后缀模式匹配，这意味着像 `"GET /projects/spring-boot.json"` 这样的请求将不会与 `@GetMapping("/projects/spring-boot")` 映射匹配。这被视为是 {spring-framework-docs}web.html#mvc-ann-requestmapping-suffix-pattern-match[Spring MVC 应用程序的最佳实践] 。此功能在过去对于 HTTP 客户端没有发送正确的 Accept 请求头的情况还是很有用的，我们需要确保将正确的内容类型发送给客户端。如今，内容协商（Content Negotiation）更加可靠。

还有其他方法可以处理 HTTP 客户端发送不一致 Accept 请求头问题。我们可以使用查询参数来确保像 `"GET /projects/spring-boot?format=json"` 这样的请求映射到 `@GetMapping("/projects/spring-boot")`，而不是使用后缀匹配：

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	spring.mvc.contentnegotiation.favor-parameter=true

	# We can change the parameter name, which is "format" by default:
	# spring.mvc.contentnegotiation.parameter-name=myparam

	# We can also register additional file extensions/media types with:
	spring.mvc.contentnegotiation.media-types.markdown=text/markdown
----

如果您了解相关注意事项并仍希望应用程序使用后缀模式匹配，则需要以下配置：

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	spring.mvc.contentnegotiation.favor-path-extension=true
	spring.mvc.pathmatch.use-suffix-pattern=true
----

或者，不打开所有后缀模式，仅打开支持已注册的后缀模式更加安全：

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	spring.mvc.contentnegotiation.favor-path-extension=true
	spring.mvc.pathmatch.use-registered-suffix-pattern=true

	# You can also register additional file extensions/media types with:
	# spring.mvc.contentnegotiation.media-types.adoc=text/asciidoc
----



[[boot-features-spring-mvc-web-binding-initializer]]
==== ConfigurableWebBindingInitializer
Spring MVC 使用一个 `WebBindingInitializer` 为特定的请求初始化 `WebDataBinder`。如果您创建了自己的 `ConfigurableWebBindingInitializer` `@Bean`，Spring Boot 将自动配置 Spring MVC 使用它。

[[boot-features-spring-mvc-template-engines]]
==== 模板引擎
除了 REST web 服务之外，您还可以使用 Spring MVC 来服务动态 HTML 内容。Spring MVC 支持多种模板技术，包括 Thymeleaf、FreeMarker 和 JSP。当然，许多其他模板引擎也有自己的 Spring MVC 集成。

Spring Boot 包含了以下的模板引擎的自动配置支持：

 * https://freemarker.apache.org/docs/[FreeMarker]
 * http://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_the_markuptemplateengine[Groovy]
 * https://www.thymeleaf.org[Thymeleaf]
 * https://mustache.github.io/[Mustache]

TIP: 如果可以，请尽量避免使用 JSP，当使用了内嵌 servlet 容器，会有几个<<boot-features-jsp-limitations, 已知限制>>。

当您使用这些模板引擎的其中一个并附带了默认配置时，您的模板将从 `src/main/resources/templates` 自动获取。

TIP: IntelliJ IDEA 根据您运行应用程序的方式来对 classpath 进行不同的排序。在 IDE 中通过 main 方法来运行应用程序将导致与使用 Maven 或 Gradle 或来以 jar 包方式引用程序的排序有所不同，可能会导致 Spring Boot 找不到 classpath 中的模板。如果您碰到到此问题，可以重新排序 IDE 的 classpath 来放置模块的 classes 和 `resources` 到首位。或者，您可以配置模板前缀来搜索 classpath 中的每一个 `templates` 目录，比如：`classpath*:/templates/`。

[[boot-features-error-handling]]
==== 错误处理
默认情况下，Spring Boot 提供了一个使用了比较合理的方式来处理所有错误的 `/error` 映射，其在 servlet 容器中注册了一个全局错误页面。对于机器客户端而言，它将产生一个包含错误、HTTP 状态和异常消息的 JSON 响应。对于浏览器客户端而言，将以 HTML 格式呈现相同数据的 whitelabel 错误视图（可添加一个解析到 `error` 的 `View` 进行自定义）。
要完全替换默认行为，您可以实现 `ErrorController` 并注册该类型的 bean，或者简单地添加一个类型为 `ErrorAttributes` 的 bean 来替换内容，但继续使用现用机制。

TIP: `BasicErrorController` 可以作为自定义 `ErrorController` 的基类，这非常有用，尤其是在您想添加一个新的内容类型（默认专门处理 `text/html`，并为其他内容提供后备）处理器的情况下。要做到这点，您只需要继承 `BasicErrorController` 并添加一个带有 `produces` 属性的 `@RequestMapping` 注解的公共方法，之后创建一个新类型的 bean。

您还可以定义一个带有 `@ControllerAdvice` 注解的类来自定义为特定控制器或异常类型返回的 JSON 文档：

[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	@ControllerAdvice(basePackageClasses = AcmeController.class)
	public class AcmeControllerAdvice extends ResponseEntityExceptionHandler {

		@ExceptionHandler(YourException.class)
		@ResponseBody
		ResponseEntity<?> handleControllerException(HttpServletRequest request, Throwable ex) {
			HttpStatus status = getStatus(request);
			return new ResponseEntity<>(new CustomErrorType(status.value(), ex.getMessage()), status);
		}

		private HttpStatus getStatus(HttpServletRequest request) {
			Integer statusCode = (Integer) request.getAttribute("javax.servlet.error.status_code");
			if (statusCode == null) {
				return HttpStatus.INTERNAL_SERVER_ERROR;
			}
			return HttpStatus.valueOf(statusCode);
		}

	}
----

以上示例中，如果同包下定义的控制器 `AcmeController` 抛出了 `YourException`，则将使用 `CustomerErrorType` 类型的 POJO 来代替 `ErrorAttributes` 做 JSON 呈现。

[[boot-features-error-handling-custom-error-pages]]
===== 自定义错误页面
如果您想在自定义的 HTML 错误页面上显示给定的状态码，请将文件添加到 `/error` 文件夹中。错误页面可以是静态 HTML（添加在任意静态资源文件夹下) 或者使用模板构建。文件的名称应该是确切的状态码或者一个序列掩码。

例如，要将 404 映射到一个静态 HTML 文件，文件夹结构可以如下：

[source,indent=0,subs="verbatim,quotes,attributes"]
----
	src/
	 +- main/
	     +- java/
	     |   + <source code>
	     +- resources/
	         +- public/
	             +- error/
	             |   +- 404.html
	             +- <other public assets>
----

使用 FreeMarker 模板来映射所有 `5xx` 错误，文件夹的结构如下：

[source,indent=0,subs="verbatim,quotes,attributes"]
----
	src/
	 +- main/
	     +- java/
	     |   + <source code>
	     +- resources/
	         +- templates/
	             +- error/
	             |   +- 5xx.ftlh
	             +- <other templates>
----

对于更复杂的映射，您还通过可以添加实现了 `ErrorViewResolver` 接口的 bean 来处理：

[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	public class MyErrorViewResolver implements ErrorViewResolver {

		@Override
		public ModelAndView resolveErrorView(HttpServletRequest request,
				HttpStatus status, Map<String, Object> model) {
			// Use the request or status to optionally return a ModelAndView
			return ...
		}

	}
----

您还可以使用常规的 Spring MVC 功能，比如  {spring-framework-docs}web.html#mvc-exceptionhandlers[`@ExceptionHandler` methods]  方法和  {spring-framework-docs}web.html#mvc-ann-controller-advice[`@ControllerAdvice`]。之后，`ErrorController` 将能接收任何未处理的异常。

[[boot-features-error-handling-mapping-error-pages-without-mvc]]
===== 映射到 Spring MVC 之外的错误页面
对于不使用 Spring MVC 的应用程序，您可以使用 `ErrorPageRegistrar` 接口来直接注册 `ErrorPages`。抽象部分直接与底层的内嵌 servlet 容器一起工作，即使您没有 Spring MVC `DispatcherServlet` 也能使用。

[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	@Bean
	public ErrorPageRegistrar errorPageRegistrar(){
		return new MyErrorPageRegistrar();
	}

	// ...

	private static class MyErrorPageRegistrar implements ErrorPageRegistrar {

		@Override
		public void registerErrorPages(ErrorPageRegistry registry) {
			registry.addErrorPages(new ErrorPage(HttpStatus.BAD_REQUEST, "/400"));
		}

	}
----

NOTE: 如果您注册了一个 `ErrorPage`，它的路径最终由一个 `Filter`（例如，像一些非 Spring web 框架一样，比如 Jersey 和 Wicket）处理，则必须将 `Filter` 显式注册为一个 `ERROR` dispatcher，如下示例：

[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	@Bean
	public FilterRegistrationBean myFilter() {
		FilterRegistrationBean registration = new FilterRegistrationBean();
		registration.setFilter(new MyFilter());
		...
		registration.setDispatcherTypes(EnumSet.allOf(DispatcherType.class));
		return registration;
	}
----

请注意，默认的 `FilterRegistrationBean` 不包含 `ERROR` 调度器（dispatcher）类型。



[[boot-features-error-handling-websphere]]
当心：当部署到 servlet 容器时，Spring Boot 使用其错误页面过滤器会将有错误状态的请求转发到相应的错误页面。如果尚未提交响应，则只能将请求转发到正确的错误页面。
默认情况下，WebSphere Application Server 8.0 及更高版本在成功完成 servlet 的 service 方法后提交响应。您应该将 `com.ibm.ws.webcontainer.invokeFlushAfterService` 设置为 `false` 来禁用此行为。

[[boot-features-spring-hateoas]]
==== Spring HATEOAS
如果您想开发一个使用超媒体（hypermedia）的 RESTful API，Spring Boot 提供的 Spring HATEOAS 自动配置在大多数应用程序都工作得非常好。自动配置取代了 `@EnableHypermediaSupport` 的需要，
并注册了一些 bean，以便能轻松构建基于超媒体的应用程序，其包括了一个 `LinkDiscoverers` （用于客户端支持）和一个用于配置将响应正确呈现的 ObjectMapper。ObjectMapper 可以通过设置 `spring.jackson.*` 属性或者 `Jackson2ObjectMapperBuilder` bean （如果存在）自定义。

您可以使用 `@EnableHypermediaSupport` 来控制 Spring HATEOAS 的配置。请注意，这使得上述的自定义 `ObjectMapper` 被禁用。

[[boot-features-cors]]
==== CORS 支持
https://en.wikipedia.org/wiki/Cross-origin_resource_sharing[Cross-origin resource sharing] 跨域资源共享（Cross-origin resource sharing，CORS）是 https://caniuse.com/#feat=cors[most browsers]实现的一个 https://www.w3.org/TR/cors/[W3C specification] ，其可允许您以灵活的方式指定何种跨域请求可以被授权，而不是使用一些不太安全和不太强大的方式（比如 IFRAME 或者 JSONP）。

Spring MVC 从 4.2 版本起开始 {spring-framework-docs}web.html#mvc-cors[支持 CORS]。您可在 Spring Boot 应用程序中使用 {spring-framework-api}/web/bind/annotation/CrossOrigin.html[`@CrossOrigin`]  注解 {spring-framework-docs}web.html#mvc-cors-controller[配置控制器方法]启用 CORS。
还可以通过注册一个 `WebMvcConfigurer` bean 并自定义 `addCorsMappings(CorsRegistry)` 方法来定义 {spring-framework-docs}web.html#mvc-cors-global[全局 CORS 配置] ：

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	public class MyConfiguration {

		@Bean
		public WebMvcConfigurer corsConfigurer() {
			return new WebMvcConfigurer() {
				@Override
				public void addCorsMappings(CorsRegistry registry) {
					registry.addMapping("/api/**");
				}
			};
		}
	}
----



[[boot-features-webflux]]
=== Spring WebFlux 框架
Spring WebFlux 是 Spring Framework 5.0 中新引入的一个响应式 Web 框架。与 Spring MVC 不同，它不需要 Servlet API，完全异步且无阻塞，并通过 https://projectreactor.io/[Reactor 项目] 实现响应式流（https://www.reactive-streams.org/[Reactive Streams]）规范。

[source,java,indent=0]
----
	@RestController
	@RequestMapping("/users")
	public class MyRestController {

		@GetMapping("/{user}")
		public Mono<User> getUser(@PathVariable Long user) {
			// ...
		}

		@GetMapping("/{user}/customers")
		public Flux<Customer> getUserCustomers(@PathVariable Long user) {
			// ...
		}

		@DeleteMapping("/{user}")
		public Mono<User> deleteUser(@PathVariable Long user) {
			// ...
		}

	}
----

"`WebFlux.fn`" 为函数式调用方式，它将路由配置与请求处理分开，如下所示：

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	public class RoutingConfiguration {

		@Bean
		public RouterFunction<ServerResponse> monoRouterFunction(UserHandler userHandler) {
			return route(GET("/{user}").and(accept(APPLICATION_JSON)), userHandler::getUser)
					.andRoute(GET("/{user}/customers").and(accept(APPLICATION_JSON)), userHandler::getUserCustomers)
					.andRoute(DELETE("/{user}").and(accept(APPLICATION_JSON)), userHandler::deleteUser);
		}

	}

	@Component
	public class UserHandler {

		public Mono<ServerResponse> getUser(ServerRequest request) {
			// ...
		}

		public Mono<ServerResponse> getUserCustomers(ServerRequest request) {
			// ...
		}

		public Mono<ServerResponse> deleteUser(ServerRequest request) {
			// ...
		}
	}
----

WebFlux 是 Spring Framework 的一部分，详细信息可查看其 {spring-framework-docs}web-reactive.html#webflux-fn[参考文档]。

TIP: 您可以根据需要定义尽可能多的 `RouterFunction` bean 来模块化路由定义。如果需要设定优先级，Bean 可以指定顺序。

首先，将 `spring-boot-starter-webflux` 模块添加到您的应用程序中。

NOTE: 在应用程序中同时添加 `spring-boot-starter-web` 和 `spring-boot-starter-webflux` 模块会导致Spring Boot 自动配置 Spring MVC，而不是使用 `WebFlux`。这样做的原因是因为许多 Spring 开发人员将 `spring-boot-starter-webflux` 添加到他们的 Spring MVC 应用程序中只是为了使用响应式 `WebClient`。
您仍然可以通过设置 `SpringApplication.setWebApplicationType(WebApplicationType.REACTIVE)` 来强制执行您选择的应用程序类型。

[[boot-features-webflux-auto-configuration]]
==== Spring WebFlux 自动配置
Spring Boot 为 Spring WebFlux 提供自动配置，适用于大多数应用程序。

自动配置在 Spring 的默认基础上添加了以下功能：

* 为 `HttpMessageReader` 和 `HttpMessageWriter` 实例配置编解码器（<<boot-features-webflux-httpcodecs,稍后将介绍>>）。
* 支持提供静态资源，包括对 `WebJars` 的支持（<<boot-features-spring-mvc-static-content,稍后将介绍>>）。

如果你要保留 Spring Boot WebFlux 功能并且想要添加其他  {spring-framework-docs}web-reactive.html#webflux-config[`WebFlux` 配置]，可以添加自己的 `@Configuration` 类，类型为 `WebFluxConfigurer`，但不包含 `@EnableWebFlux`。

如果您想完全控制 Spring WebFlux，可以将 `@EnableWebFlux` 注解到自己的 `@Configuration`。

[[boot-features-webflux-httpcodecs]]
==== 使用 HttpMessageReader 和 HttpMessageWriter 作为 HTTP 编解码器
Spring WebFlux 使用 `HttpMessageReader` 和 `HttpMessageWriter` 接口来转换 HTTP 的请求和响应。它们通过检测 classpath 中可用的类库，配置了 `CodecConfigurer` 生成合适的默认值。

Spring Boot 通过使用 `CodecCustomizer` 实例加强定制。例如，`spring.jackson.*` 配置 key 应用于 Jackson 编解码器。

如果需要添加或自定义编解码器，您可以创建一个自定义的 `CodecCustomizer` 组件，如下所示：

[source,java,indent=0]
----
	import org.springframework.boot.web.codec.CodecCustomizer;

	@Configuration(proxyBeanMethods = false)
	public class MyConfiguration {

		@Bean
		public CodecCustomizer myCodecCustomizer() {
			return codecConfigurer -> {
				// ...
			};
		}

	}
----

您还可以利用 <<boot-features-json-components,Boot 自定义 JSON 序列化器和反序列化器>>。

[[boot-features-webflux-static-content]]
==== 静态内容
默认情况下，Spring Boot 将在 classpath 或者 `ServletContext` 根目录下从名为 `/static` （`/public`、`/resources` 或 `/META-INF/resources`）目录中服务静态内容。它使用了 Spring WebFlux 的 `ResourceWebHandler`，因此您可以通过添加自己的 `WebFluxConfigurer` 并重写 `addResourceHandlers` 方法来修改此行为。

默认情况下，资源被映射到 `/**`，但可以通过 `spring.webflux.static-path-pattern` 属性调整。比如，将所有资源重定位到 `/resources/**`：

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	spring.webflux.static-path-pattern=/resources/**
----

您还可以使用 `spring.resources.static-locations` 属性来自定义静态资源的位置（使用一个目录位置列表替换默认值），如果这样做，默认的欢迎页面检测会切换到您自定义的位置。因此，如果启动时有任何其中一个位置存在 `index.html`，那么它将是应用程序的主页。

除了上述提到的标准静态资源位置之外，还有一种特殊情况是用于 https://www.webjars.org/[Webjars 内容] 。如果以 Webjar 格式打包，则所有符合 `/webjars/**` 的资源都将从 jar 文件中服务。

TIP: Spring WebFlux 应用程序并不严格依赖于 Servlet API，因此它们不能作为 war 文件部署，也不能使用 `src/main/webapp` 目录。

[[boot-features-webflux-template-engines]]
==== 模板引擎
除了 REST web 服务之外，您还可以使用 Spring WebFlux 来服务动态 HTML 内容。Spring WebFlux 支持多种模板技术，包括 Thymeleaf、FreeMarker 和 Mustache。

Spring Boot 包含了以下的模板引擎的自动配置支持：

 * https://freemarker.apache.org/docs/[FreeMarker]
 * https://www.thymeleaf.org[Thymeleaf]
 * https://mustache.github.io/[Mustache]

当您使用这些模板引擎的其中一个并附带了默认配置时，您的模板将从 `src/main/resources/templates` 自动获取。



[[boot-features-webflux-error-handling]]
==== Error Handling
Spring Boot 提供了一个 `WebExceptionHandler`，它以合理的方式处理所有错误。它在处理顺序中的位置紧接在 WebFlux 提供的处理程序之前，这些处理器排序是最后的。对于机器客户端，它会生成一个 JSON 响应，其中包含错误详情、HTTP 状态和异常消息。对于浏览器客户端，有一个 whitelabel 错误处理程序，它以 HTML 格式呈现同样的数据。您还可以提供自己的 HTML 模板来显示错误（请参阅<<boot-features-webflux-error-handling-custom-error-pages,下一节>>）。

自定义此功能的第一步通常会沿用现有机制，但替换或扩充了错误内容。为此，您可以添加 `ErrorAttributes` 类型的 bean。

想要更改错误处理行为，可以实现 `ErrorWebExceptionHandler` 并注册该类型的 bean。因为 `WebExceptionHandler` 是一个非常底层的异常处理器，所以 Spring Boot 还提供了一个方便的 `AbstractErrorWebExceptionHandler` 来让你以 WebFlux 的方式处理错误，如下所示：

[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	public class CustomErrorWebExceptionHandler extends AbstractErrorWebExceptionHandler {

		// Define constructor here

		@Override
		protected RouterFunction<ServerResponse> getRoutingFunction(ErrorAttributes errorAttributes) {

			return RouterFunctions
					.route(aPredicate, aHandler)
					.andRoute(anotherPredicate, anotherHandler);
		}

	}
----

要获得更完整的功能，您还可以直接继承 `DefaultErrorWebExceptionHandler` 并覆盖相关方法。

[[boot-features-webflux-error-handling-custom-error-pages]]
===== 自定义错误页面
如果您想在自定义的 HTML 错误页面上显示给定的状态码，请将文件添加到 `/error` 文件夹中。错误页面可以是静态 HTML（添加在任意静态资源文件夹下) 或者使用模板构建。文件的名称应该是确切的状态码或者一个序列掩码。

例如，要将 404 映射到一个静态 HTML 文件，文件夹结构可以如下：

[source,indent=0,subs="verbatim,quotes,attributes"]
----
	src/
	 +- main/
	     +- java/
	     |   + <source code>
	     +- resources/
	         +- public/
	             +- error/
	             |   +- 404.html
	             +- <other public assets>
----

使用 Mustache 模板来映射所有 `5xx` 错误，文件夹的结构如下：

[source,indent=0,subs="verbatim,quotes,attributes"]
----
	src/
	 +- main/
	     +- java/
	     |   + <source code>
	     +- resources/
	         +- templates/
	             +- error/
	             |   +- 5xx.mustache
	             +- <other templates>
----



[[boot-features-webflux-web-filters]]
==== Web 过滤器
Spring WebFlux 提供了一个 `WebFilter` 接口，可以通过实现该接口来过滤 HTTP 请求/响应消息交换。在应用程序上下文中找到的 `WebFilter` bean 将自动用于过滤每个消息交换。

如果过滤器的执行顺序很重要，则可以实现 `Ordered` 接口或使用 `@Order` 注解来指定顺序。Spring Boot 自动配置可能为您配置了几个 Web 过滤器。执行此操作时，将使用下表中的顺序：

|===
| Web Filter | Order

| `MetricsWebFilter`
| `Ordered.HIGHEST_PRECEDENCE + 1`

| `WebFilterChainProxy` (Spring Security)
| `-100`

| `HttpTraceWebFilter`
| `Ordered.LOWEST_PRECEDENCE - 10`
|===



[[boot-features-jersey]]
=== JAX-RS 与 Jersey
如果您喜欢 JAX-RS 编程模型的 REST 端点，则可以使用一个实现来替代 Spring MVC。https://jersey.github.io/[Jersey] 和 https://cxf.apache.org/[Apache CXF] 都能开箱即用。CXF 要求在应用程序上下文中以 `@Bean` 的方式将它注册为一个 `Servlet` 或者 `Filter`。Jersey 有部分原生 Spring 支持，所以我们也在 starter 中提供了与 Spring Boot 整合的自动配置支持。

要使用 Jersey，只需要将 `spring-boot-starter-jersey` 作为依赖引入，然后您需要一个 `ResourceConfig` 类型的 `@Bean`，您可以在其中注册所有端点：

[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	@Component
	public class JerseyConfig extends ResourceConfig {

		public JerseyConfig() {
			register(Endpoint.class);
		}

	}
----

WARNING: Jersey 对于扫描可执行归档文件的支持是相当有限的。例如，它无法扫描一个<<deployment.adoc#deployment-install, 完整的可执行 jar 文件>>中的端点，同样，当运行一个可执行的 war 文件时，它也无法扫描包中 `WEB-INF/classes` 下的端点。为了避免该限制，您不应该使用 `packages` 方法，应该使用上述的 `register` 方法来单独注册每一个端点。

您可以注册任意数量实现了 `ResourceConfigCustomizer` 的 bean，以实现更高级的定制化。

所有注册的端点都应注解了 `@Components` 并具有 HTTP 资源注解（ `@GET` 等），例如：

[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	@Component
	@Path("/hello")
	public class Endpoint {

		@GET
		public String message() {
			return "Hello";
		}

	}
----

由于 Endpoint 是一个 Spring `@Component`，它的生命周期由 Spring 管理，您可以使用 `@Autowired` 注入依赖并使用 `@Value` 注入外部配置。默认情况下，Jersey servlet 将被注册并映射到 `/*`。您可以通过将 `@ApplicationPath` 添加到 `ResourceConfig` 来改变此行为。

默认情况下，Jersey 在 `ServletRegistrationBean` 类型的 @Bean 中被设置为一个名为 `jerseyServletRegistration` 的 Servlet。默认情况下，该 servlet 将被延迟初始化，您可以使用 `spring.jersey.servlet.load-on-startup` 自定义。
您可以禁用或通过创建一个自己的同名 bean 来覆盖该 bean。您还可以通过设置 `spring.jersey.type=filter` 使用过滤器替代 servlet（该情况下， 替代或覆盖 `@Bean` 的为 `jerseyFilterRegistration`）。
该过滤器有一个 `@Order`，您可以使用 `spring.jersey.filter.order` 设置。可以使用 `spring.jersey.init.*` 指定一个 map 类型的 property 以给定 servlet 和过滤器的初始化参数。

这里有一个 Jersey 示例，您可以解如何设置。

[[boot-features-embedded-container]]
=== 内嵌 Servlet 容器支持
Spring Boot 包含了对内嵌 https://tomcat.apache.org/[Tomcat], https://www.eclipse.org/jetty/[Jetty], 和 https://github.com/undertow-io/undertow[Undertow] 服务器的支持。大部分开发人员只需简单地使用对应的 Starter 来获取完整的配置实例。默认情况下，内嵌服务器将监听 `8080` 上的 HTTP 请求。

[[boot-features-embedded-container-servlets-filters-listeners]]
==== Servlets, Filters, 与  listeners
使用内嵌 servlet 容器时，您可以使用 Spring bean 或者扫描方式来注册 Servlet 规范中的 Servlet、Filter 和所有监听器（比如 `HttpSessionListener`）。

[[boot-features-embedded-container-servlets-filters-listeners-beans]]
===== 将 Servlet、Filter 和 Listener 注册为 Spring
任何 `Servlet`、`Filter` 或 `*Listener` 的 Spring bean 实例都将被注册到内嵌容器中。如果您想引用 `application.properties` 中的某个值，这可能会特别方便。

默认情况下，如果上下文只包含单个 Servlet，它将映射到 `/`。在多个 Servlet bean 的情况下，bean 的名称将用作路径的前缀。Filter 将映射到 `/*`。

如果基于约定配置的映射不够灵活，您可以使用 `ServletRegistrationBean`、`FilterRegistrationBean` 和 `ServletListenerRegistrationBean` 类来完全控制。

通常把过滤器 bean 无序是安全的。 如果需要特定的顺序，则应使用 `@Order` 注释 `Filter` 或使其实现 `Ordered`。 您不能通过使用 `@Order` 注释 `Filter` 的bean方法来配置 `Filter` 的顺序。
如果您不能更改 `Filter` 类以添加 `@Order` 或实现 `Ordered`，则必须为 `Filter` 定义一个 `FilterRegistrationBean` 并使用 `setOrder(int)` 方法设置注册bean的顺序。
则应避免在 `Ordered.HIGHEST_PRECEDENCE` 顺序点配置读取请求体的过滤器，因为它的字符编码可能与应用程序的字符编码配置不一致。如果一个 Servlet 过滤器包装了请求，则应使用小于或等于 `OrderedFilter.REQUEST_WRAPPER_FILTER_MAX_ORDER` 的顺序点对其进行配置。

TIP: 要查看应用程序中每个过滤器的顺序，请为 `web` <<boot-features-custom-log-groups,logging group>> (`logging.level.web=debug`) 启用调试级别的日志记录。 然后，将在启动时记录已注册过滤器的详细信息，包括其顺序和URL模式。.

WARNING: 注册 `Filter` Bean时要小心，因为它们是在应用程序生命周期中很早就初始化的。 如果需要注册与其他bean交互的 `Filter`，请考虑改用  {spring-boot-module-api}/web/servlet/DelegatingFilterProxyRegistrationBean.html[`DelegatingFilterProxyRegistrationBean`] 。

[[boot-features-embedded-container-context-initializer]]
==== Servlet 上下文初始化
内嵌 servlet 容器不会直接执行 Servlet 3.0+ 的 `javax.servlet.ServletContainerInitializer` 接口或 Spring 的 `org.springframework.web.WebApplicationInitializer` 接口。这是一个有意的设计决策，旨在降低在 war 内运行时第三方类库产生的风险，防止破坏 Sring Boot 应用程序。

如果您需要在 Spring Boot 应用程序中执行 servlet 上下文初始化，则应注册一个实现了 `org.springframework.boot.context.embedded.ServletContextInitializer` 接口的 bean。`onStartup` 方法提供了针对 `ServletContext` 的访问入口，如果需要，它可以容易作为现有 `WebApplicationInitializer` 的适配器。

[[boot-features-embedded-container-servlets-filters-listeners-scanning]]
===== 扫描 Servlet、Filter 和 Listener
使用内嵌容器时，可以使用 `@ServletComponentScan` 启用带 `@WebServlet`、`@WebFilter` 和 `@WebListener` 注解的类自动注册。

TIP: `@ServletComponentScan` 在独立（standalone）容器中不起作用，因容器将使用内置发现机制来代替。

[[boot-features-embedded-container-application-context]]
==== ServletWebServerApplicationContext
Spring Boot 底层使用了一个不同的 `ApplicationContext` 类型来支持内嵌 servlet。`ServletWebServerApplicationContext` 是一个特殊 `WebApplicationContext` 类型，它通过搜索单个 `ServletWebServerFactory` bean 来引导自身。通常，`TomcatServletWebServerFactory`、 `JettyServletWebServerFactory` 或者 `UndertowServletWebServerFactory` 中的一个将被自动配置。

NOTE: 通常，你不需要知道这些实现类。大部分应用程序会自动配置，并为您创建合适的 `ApplicationContext` 和 `ServletWebServerFactory`。

[[boot-features-customizing-embedded-containers]]
==== 自定义内嵌 Servlet 容器

可以使用 Spring `Environment` 属性来配置通用的 servlet 容器设置。通常，您可以在 `application.properties` 文件中定义这些属性。

常用服务器设置包括：

* 网络设置：监听 HTTP 请求的端口（`server.port`），绑定接口地址到 `server.address` 等。
* 会话设置：是否持久会话（`server.session.persistence`）、session 超时（`server.session.timeout`）、会话数据存放位置（`server.session.store-dir`）和 session-cookie 配置（`server.session.cookie.*`）。
* 错误管理：错误页面位置（`server.error.path`）等。
* <<howto.adoc#howto-configure-ssl,SSL>>
* <<howto.adoc#how-to-enable-http-response-compression,HTTP 压缩>>

Spring Boot 尽可能暴露通用的设置，但并不总是都可以。针对这些情况，专用的命名空间为特定的服务器提供了自定义功能（请参阅 `server.tomcat` 和 `server.undertow`）。例如，您可以使用内嵌 servlet 容器的特定功能来配置 <<howto.adoc#howto-configure-accesslogs,access logs>>。

TIP: 有关完整的内容列表，请参阅 {spring-boot-autoconfigure-module-code}/web/ServerProperties.java[`ServerProperties`]  类。

[[boot-features-programmatic-embedded-container-customization]]
===== 以编程方式自定义
如果您需要以编程的方式配置内嵌 servlet 容器，可以注册一个是实现了 `WebServerFactoryCustomizer` 接口的 Spring bean。`WebServerFactoryCustomizer` 提供了对 `ConfigurableServletWebServerFactory` 的访问入口，其中包含了许多自定义 setter 方法。以下示例使用了编程方式来设置端口：

[source,java,indent=0]
----
	import org.springframework.boot.web.server.WebServerFactoryCustomizer;
	import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;
	import org.springframework.stereotype.Component;

	@Component
	public class CustomizationBean implements WebServerFactoryCustomizer<ConfigurableServletWebServerFactory> {

		@Override
		public void customize(ConfigurableServletWebServerFactory server) {
			server.setPort(9000);
		}

	}
----

NOTE: `TomcatServletWebServerFactory`, `JettyServletWebServerFactory` 和 `UndertowServletWebServerFactory` 是 `ConfigurableServletWebServerFactory` 的具体子类，它们分别为 Tomcat、Jetty 和 Undertow 提供了额外的自定义 setter 方法。.



[[boot-features-customizing-configurableservletwebserverfactory-directly]]
===== 直接自定义 ConfigurableServletWebServerFactory
如果上述的自定义方式太局限，您可以自己注册 `TomcatServletWebServerFactory`、`JettyServletWebServerFactory` 或 `UndertowServletWebServerFactory` bean。

[source,java,indent=0]
----
	@Bean
	public ConfigurableServletWebServerFactory webServerFactory() {
		TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();
		factory.setPort(9000);
		factory.setSessionTimeout(10, TimeUnit.MINUTES);
		factory.addErrorPages(new ErrorPage(HttpStatus.NOT_FOUND, "/notfound.html"));
		return factory;
	}
----

Setter 方法提供了许多配置选项。还有几个 hook 保护方法供您深入定制。有关详细信息，请参阅 {spring-boot-module-api}/web/servlet/server/ConfigurableServletWebServerFactory.html[源码文档]。

[[boot-features-jsp-limitations]]
==== JSP 局限
当运行使用了内嵌 servlet 容器的 Spring Boot 应用程序时（打包为可执行归档文件），JSP 支持将存在一些限制。

* 如果您使用 war 打包，在 Jetty 和 Tomcat 中可以正常工作，使用 `java -jar` 启动时，可执行的 war 可正常使用，并且还可以部署到任何标准容器。使用可执行 jar 时不支持 JSP。

* Undertow 不支持 JSP。

* 创建自定义的 `error.jsp` 页面不会覆盖<<boot-features-error-handling,默认错误处理视图>>，应该使用<<boot-features-error-handling-custom-error-pages,自定义错误页面>>来代替。 .

[[boot-features-reactive-server]]
=== 内嵌响应式服务器支持
Spring Boot 包括对以下内嵌响应式 Web 服务器的支持：Reactor Netty、Tomcat、Jetty 和 Undertow。大多数开发人员使用对应的 Starter 来获取一个完全配置的实例。默认情况下，内嵌服务器在 8080 端口上监听 HTTP 请求。

[[boot-features-reactive-server-resources]]
=== 响应式服务器资源配置
在自动配置 Reactor Netty 或 Jetty 服务器时，Spring Boot 将创建特定的 bean 为服务器实例提供 HTTP 资源：`ReactorResourceFactory` 或 `JettyResourceFactory`。

默认情况下，这些资源也将与 Reactor Netty 和 Jetty 客户端共享以获得最佳性能，具体如下：

* 用于服务器和客户端的的相同技术
* 客户端实例使用了 Spring Boot 自动配置的 `WebClient.Builder` bean 构建。

开发人员可以通过提供自定义的 `ReactorResourceFactory` 或 `JettyResourceFactory` bean 来重写 Jetty 和 Reactor Netty 的资源配置 —— 将应用于客户端和服务器。

您可以在 <<boot-features-webclient-runtime, WebClient Runtime >>章节中了解有关客户端资源配置的更多内容。

[[boot-features-rsocket]]
== RSocket
https://rsocket.io[RSocket] 是用于字节流传输的二进制协议。 它通过通过单个连接传递的异步消息来启用对称交互模型。

Spring框架的 `spring-messaging` 模块在客户端和服务器端都支持RSocket请求者和响应者。 有关更多详细信息，请参见Spring Framework参考中的 {spring-framework-docs}web-reactive.html#rsocket-spring[RSocket 部分]，其中包括RSocket协议的概述。

[[boot-features-rsocket-strategies-auto-configuration]]
=== RSocket策略自动配置
Spring Boot自动配置一个 `RSocketStrategies` bean，该bean提供了编码和解码RSocket有效负载所需的所有基础结构。 默认情况下，自动配置将尝试（按顺序）配置以下内容：

. Jackson的  https://cbor.io/[CBOR] 编解码器
. Jackson的 JSON  编解码器

`spring-boot-starter-socket` 启动器提供了两个依赖项。 查阅 <<boot-features-json-jackson,Jackson支持>>部分，以了解有关定制可能性的更多信息。

开发人员可以通过创建实现 `RSocketStrategiesCustomizer` 接口的bean来自定义 `RSocketStrategies` 组件。 请注意，它们的 `@Order` 很重要，因为它确定编解码器的顺序。

[[boot-features-rsocket-server-auto-configuration]]
=== RSocket服务器自动配置
Spring Boot提供了RSocket服务器自动配置。 所需的依赖关系由 `spring-boot-starter-rsocket` 提供。

Spring Boot允许从WebFlux服务器通过WebSocket公开RSocket，或支持独立的RSocket服务器。 这取决于应用程序的类型及其配置。

对于WebFlux应用程序（即 `WebApplicationType.REACTIVE` 类型），仅当以下属性匹配时，RSocket服务器才会插入Web服务器：

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	spring.rsocket.server.mapping-path=/rsocket # a mapping path is defined
	spring.rsocket.server.transport=websocket # websocket is chosen as a transport
	#spring.rsocket.server.port= # no port is defined
----

WARNING: 由于RSocket本身是使用该库构建的，因此只有Reactor Netty支持将RSocket插入Web服务器。

另外，RSocket TCP或Websocket服务器也可以作为独立的嵌入式服务器启动。 除了依赖性要求之外，唯一需要的配置是为该服务器定义端口：

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	spring.rsocket.server.port=9898 # the only required configuration
	spring.rsocket.server.transport=tcp # you're free to configure other properties
----



[[boot-features-rsocket-messaging]]
=== Spring Messaging RSocket支持
Spring Boot将为RSocket自动配置Spring Messaging基础结构。

这意味着Spring Boot将创建一个 `RSocketMessageHandler` bean，该bean将处理对您的应用程序的RSocket请求。


[[boot-features-rsocket-requester]]
=== 使用 `RSocketRequester` 调用RSocket服务
在服务器和客户端之间建立 `RSocket` 通道后，任何一方都可以向另一方发送或接收请求。

作为服务器，您可以在RSocket `@Controller` 的任何处理程序方法上注入 `RSocketRequester` 实例。 作为客户端，您需要首先配置和建立RSocket连接。 在这种情况下，Spring Boot会使用预期的编解码器自动配置 `RSocketRequester.Builder`。

`RSocketRequester.Builder` 实例是一个原型bean，这意味着每个注入点将为您提供一个新实例。 这样做是有目的的，因为此构建器是有状态的，因此您不应使用同一实例创建具有不同设置的请求者。

以下代码显示了一个典型示例：

[source,java,indent=0]
----
	@Service
	public class MyService {

		private final RSocketRequester rsocketRequester;

		public MyService(RSocketRequester.Builder rsocketRequesterBuilder) {
			this.rsocketRequester = rsocketRequesterBuilder
					.connectTcp("example.org", 9898).block();
		}

		public Mono<User> someRSocketCall(String name) {
			return this.requester.route("user").data(name)
					.retrieveMono(User.class);
		}

	}
----



[[boot-features-security]]
== 安全
默认情况下，如果 {spring-security}[Spring Security]  在 classpath 上，则 Web 应用程序是受保护的。Spring Boot 依赖 Spring Security 的内容协商策略来确定是使用 `httpBasic` 还是 `formLogin`。
要给 Web 应用程序添加方法级别的安全保护，可以使用 `@EnableGlobalMethodSecurity` 注解设置。有关更多其他信息，您可以在  {spring-security-docs}#jc-method[Spring Security 参考指南]中找到。

默认的 `UserDetailsService` 只有一个用户。用户名为 `user`，密码是随机的，在应用程序启动时会以 INFO 级别打印出来，如下所示：

[indent=0]
----
	Using generated security password: 78fa095d-3f4c-48b1-ad50-e24c31d5cf35
----

NOTE: 如果您对日志配置进行微调，请确保将 `org.springframework.boot.autoconfigure.security` 的级别设置为 `INFO`。否则，默认密码不会打印出来。

您可以通过提供 `spring.security.user.name` 和 `spring.security.user.password` 来更改用户名和密码。

您在 Web 应用程序中默认会获得以下基本功能：

* 一个 `UserDetailsService`（或 WebFlux 应用程序中的 `ReactiveUserDetailsService`）bean，采用内存存储形式，有一个自动生成密码的用户（有关用户属性，请参阅  {spring-boot-module-api}/autoconfigure/security/SecurityProperties.User.html[`SecurityProperties.User`] ）。
* 用于整个应用程序（如果 actuator 在 classpath 上，则包括 actuator 端点）基于表单登录或 HTTP Basic 认证（取决于 Content-Type）。
* 一个用于发布身份验证事件的 `DefaultAuthenticationEventPublisher`。

您可以通过为其添加一个 bean 来提供不同的 `AuthenticationEventPublisher`。

[[boot-features-security-mvc]]
=== MVC 安全
默认的安全配置在 `SecurityAutoConfiguration` 和 `UserDetailsServiceAutoConfiguration` 中实现。 `SecurityAutoConfiguration` 导入用于 Web 安全的 `SpringBootWebSecurityConfiguration`，`UserDetailsServiceAutoConfiguration` 配置身份验证，这同样适用于非 Web 应用程序。要完全关闭默认的 Web 应用程序安全配置，可以添加 `WebSecurityConfigurerAdapter` 类型的 bean（这样做不会禁用 `UserDetailsService` 配置或 `Actuator` 的安全保护）。

要同时关闭 `UserDetailsService` 配置，您可以添加 `UserDetailsService`、`AuthenticationProvider` 或 `AuthenticationManager` 类型的 bean。Spring Boot 示例中有几个使用了安全保护的应用程序，他们或许可以帮助到您。

可以通过添加自定义 `WebSecurityConfigurerAdapter` 来重写访问规则。Spring Boot 提供了便捷方法，可用于重写 `actuator` 端点和静态资源的访问规则。`EndpointRequest` 可用于创建一个基于 `management.endpoints.web.base-path` 属性的 `RequestMatcher`。`PathRequest` 可用于为常用位置中的资源创建一个 `RequestMatcher`。

[[boot-features-security-webflux]]
=== WebFlux 安全
与 Spring MVC 应用程序类似，您可以通过添加 `spring-boot-starter-security` 依赖来保护 WebFlux 应用程序。默认的安全配置在 `ReactiveSecurityAutoConfiguration` 和 `UserDetailsServiceAutoConfiguration` 中实现。`ReactiveSecurityAutoConfiguration` 导入用于 Web 安全的 `WebFluxSecurityConfiguration`，`UserDetailsServiceAutoConfiguration` 配置身份验证，这同样适用于非 Web 应用程序。要完全关闭默认的 Web 应用程序安全配置，可以添加 `WebFilterChainProxy` 类型的 bean（这样做不会禁用 `UserDetailsService` 配置或 `Actuator` 的安全保护）。

要同时关闭 `UserDetailsService` 配置，您可以添加 `ReactiveUserDetailsService` 或 `ReactiveAuthenticationManager` 类型的 bean。

可以通过添加自定义 `SecurityWebFilterChain` 来重写访问规则。Spring Boot 提供了便捷方法，可用于重写 `actuator` 端点和静态资源的访问规则。`EndpointRequest` 可用于创建一个基于 `management.endpoints.web.base-path` 属性的 `ServerWebExchangeMatcher`。

`PathRequest` 可用于为常用位置中的资源创建一个 `ServerWebExchangeMatcher`。

例如，您可以通过添加以下内容来自定义安全配置：

[source,java,indent=0]
----
include::{code-examples}/web/security/CustomWebFluxSecurityExample.java[tag=configuration]
----



[[boot-features-security-oauth2]]
=== OAuth2
https://oauth.net/2/[OAuth2] 是 Spring 支持的一种广泛使用的授权框架。



[[boot-features-security-oauth2-client]]
==== 客户端
如果您的 classpath 上有 `spring-security-oauth2-client`，则可以利用一些自动配置来轻松设置 OAuth2/Open ID Connect 客户端。该配置使用 `OAuth2ClientProperties` 的属性。相同的属性适用于 servlet 和响应式应用程序。

您可以在 `spring.security.oauth2.client` 前缀下注册多个 OAuth2 客户端和提供者（provider），如下所示：

[source,properties,indent=0,configprops]
----
	spring.security.oauth2.client.registration.my-client-1.client-id=abcd
	spring.security.oauth2.client.registration.my-client-1.client-secret=password
	spring.security.oauth2.client.registration.my-client-1.client-name=Client for user scope
	spring.security.oauth2.client.registration.my-client-1.provider=my-oauth-provider
	spring.security.oauth2.client.registration.my-client-1.scope=user
	spring.security.oauth2.client.registration.my-client-1.redirect-uri=https://my-redirect-uri.com
	spring.security.oauth2.client.registration.my-client-1.client-authentication-method=basic
	spring.security.oauth2.client.registration.my-client-1.authorization-grant-type=authorization_code

	spring.security.oauth2.client.registration.my-client-2.client-id=abcd
	spring.security.oauth2.client.registration.my-client-2.client-secret=password
	spring.security.oauth2.client.registration.my-client-2.client-name=Client for email scope
	spring.security.oauth2.client.registration.my-client-2.provider=my-oauth-provider
	spring.security.oauth2.client.registration.my-client-2.scope=email
	spring.security.oauth2.client.registration.my-client-2.redirect-uri=https://my-redirect-uri.com
	spring.security.oauth2.client.registration.my-client-2.client-authentication-method=basic
	spring.security.oauth2.client.registration.my-client-2.authorization-grant-type=authorization_code

	spring.security.oauth2.client.provider.my-oauth-provider.authorization-uri=https://my-auth-server/oauth/authorize
	spring.security.oauth2.client.provider.my-oauth-provider.token-uri=https://my-auth-server/oauth/token
	spring.security.oauth2.client.provider.my-oauth-provider.user-info-uri=https://my-auth-server/userinfo
	spring.security.oauth2.client.provider.my-oauth-provider.user-info-authentication-method=header
	spring.security.oauth2.client.provider.my-oauth-provider.jwk-set-uri=https://my-auth-server/token_keys
	spring.security.oauth2.client.provider.my-oauth-provider.user-name-attribute=name
----

对于支持 https://openid.net/specs/openid-connect-discovery-1_0.html[OpenID Connect discovery] 的 OpenID Connect 提供者，可以进一步简化配置。需要使用 `issuer-uri` 配置提供者，`issuer-uri` 是其 Issuer Identifier 的 URI。
例如，如果提供的 issuer-uri 是  "https://example.com"，则将对 "https://example.com/.well-known/openid-configuration" 发起一个  `OpenID Provider Configuration Request`。期望结果是一个 `OpenID Provider Configuration Response`。以下示例展示了如何使用 `issuer-uri` 配置一个 OpenID Connect Provider：

[source,properties,indent=0,configprops]
----
	spring.security.oauth2.client.provider.oidc-provider.issuer-uri=https://dev-123456.oktapreview.com/oauth2/default/
----

默认情况下，Spring Security 的 `OAuth2LoginAuthenticationFilter` 仅处理与 `/login/oauth2/code/*` 相匹配的 URL。如果要自定义 `redirect-uri` 以使用其他匹配模式，则需要提供配置以处理该自定义模式。例如，对于 servlet 应用程序，您可以添加类似于以下 `WebSecurityConfigurerAdapter`：

[source,java,indent=0]
----
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.authorizeRequests()
				.anyRequest().authenticated()
				.and()
			.oauth2Login()
				.redirectionEndpoint()
					.baseUri("/custom-callback");
	}
}
----

[[boot-features-security-oauth2-common-providers]]
===== OAuth2 客户端注册常见的提供者
对于常见的 OAuth2 和 OpenID 提供者（provider），包括 Google、Github、Facebook 和 Okta，我们提供了一组提供者默认设置（分别是 google、github、facebook 和 okta）。

如果您不需要自定义这些提供者，则可以将 `provider` 属性设置为您需要推断默认值的属性。此外，如果客户端注册的 key 与默认支持的提供者匹配，则 Spring Boot 也会推断出来。

换而言之，以下示例中的两个配置使用了 Google 提供者：

[source,properties,indent=0,configprops]
----
	spring.security.oauth2.client.registration.my-client.client-id=abcd
	spring.security.oauth2.client.registration.my-client.client-secret=password
	spring.security.oauth2.client.registration.my-client.provider=google

	spring.security.oauth2.client.registration.google.client-id=abcd
	spring.security.oauth2.client.registration.google.client-secret=password
----



[[boot-features-security-oauth2-server]]
==== 资源服务器
如果在 classpath 上有 `spring-security-oauth2-resource-server`，只要指定了 JWK Set URI 或 OIDC Issuer URI，Spring Boot 就可以设置 OAuth2 资源服务器，如下所示：

[source,properties,indent=0,configprops]
----
	spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://example.com/oauth2/default/v1/keys
----

[source,properties,indent=0,configprops]
----
	spring.security.oauth2.resourceserver.jwt.issuer-uri=https://dev-123456.oktapreview.com/oauth2/default/
----

NOTE: 如果授权服务器不支持JWK设置URI，则可以使用用于验证JWT签名的公共密钥来配置资源服务器。 可以使用 `spring.security.oauth2.resourceserver.jwt.public-key-location` 属性来完成此操作，该属性值需要指向包含PEM编码的x509格式的公钥的文件。

相同的属性适用于 servlet 和响应式应用程序。

或者，您可以为 servlet 应用程序定义自己的 JwtDecoder bean，或为响应式应用程序定义 `ReactiveJwtDecoder`。


如果使用不透明令牌而不是JWT，则可以配置以下属性以通过自省来验证令牌：

[source,properties,indent=0,configprops]
----
	spring.security.oauth2.resourceserver.opaquetoken.introspection-uri=https://example.com/check-token
	spring.security.oauth2.resourceserver.opaquetoken.client-id=my-client-id
	spring.security.oauth2.resourceserver.opaquetoken.client-secret=my-client-secret
----

同样，相同的属性适用于servlet和反应式应用程序。

另外，您可以为Servlet应用程序定义自己的 `OpaqueTokenIntrospector` Bean，或者为反应性应用程序定义 `ReactiveOpaqueTokenIntrospector`。

==== 授权服务器
目前，Spring Security 没有提供 OAuth 2.0 授权服务器实现。但此功能可从 {spring-security-oauth2}[Spring Security OAuth] 项目获得，该项目最终会被 Spring Security 所取代。在此之前，您可以使用 `spring-security-oauth2-autoconfigure` 模块轻松设置 OAuth 2.0 授权服务器，请参阅 https://docs.spring.io/spring-security-oauth2-boot[其文档]以获取详细信息。

[[boot-features-security-saml]]
=== SAML 2.0

[[boot-features-security-saml2-relying-party]]
==== 依赖方
如果您在类路径中具有 `spring-security-saml2-service-provider`，则可以利用一些自动配置功能来轻松设置SAML 2.0依赖方。 此配置利用 `Saml2RelyingPartyProperties` 下的属性。

依赖方注册代表身份提供商IDP和服务提供商SP之间的配对配置。 您可以在 `spring.security.saml2.relyingparty` 前缀下注册多个依赖方，如以下示例所示：

[source,properties,indent=0,configprops]
----
	spring.security.saml2.relyingparty.registration.my-relying-party1.signing.credentials[0].private-key-location=path-to-private-key
	spring.security.saml2.relyingparty.registration.my-relying-party1.signing.credentials[0].certificate-location=path-to-certificate
	spring.security.saml2.relyingparty.registration.my-relying-party1.identityprovider.verification.credentials[0].certificate-location=path-to-verification-cert
	spring.security.saml2.relyingparty.registration.my-relying-party1.identityprovider.entity-id=remote-idp-entity-id1
	spring.security.saml2.relyingparty.registration.my-relying-party1.identityprovider.sso-url=https://remoteidp1.sso.url

	spring.security.saml2.relyingparty.registration.my-relying-party2.signing.credentials[0].private-key-location=path-to-private-key
    spring.security.saml2.relyingparty.registration.my-relying-party2.signing.credentials[0].certificate-location=path-to-certificate
    spring.security.saml2.relyingparty.registration.my-relying-party2.identityprovider.verification.credentials[0].certificate-location=path-to-other-verification-cert
    spring.security.saml2.relyingparty.registration.my-relying-party2.identityprovider.entity-id=remote-idp-entity-id2
    spring.security.saml2.relyingparty.registration.my-relying-party2.identityprovider.sso-url=https://remoteidp2.sso.url
----



[[boot-features-security-actuator]]
=== Actuator 安全
出于安全考虑，默认情况下禁用除 `/health` 和 `/info` 之外的所有 actuator。可用 `management.endpoints.web.exposure.include` 属性启用 actuator。

如果 Spring Security 位于 classpath 上且没有其他 WebSecurityConfigurerAdapter，则除了 `/health` 和 `/info` 之外的所有 actuator 都由 Spring Boot 自动配置保护。如果您定义了自定义 `WebSecurityConfigurerAdapter`，则 Spring Boot 自动配置将不再生效，您可以完全控制 actuator 的访问规则。

NOTE: 在设置 `management.endpoints.web.exposure.include` 之前，请确保暴露的 actuator 没有包含敏感信息和 / 或被防火墙保护亦或受 Spring Security 之类的保护。

[[boot-features-security-csrf]]
==== 跨站请求伪造保护
由于 Spring Boot 依赖 Spring Security 的默认值配置，因此默认情况下会启用 CSRF 保护。这意味着当使用默认安全配置时，需要 `POST`（shutdown 和 loggers 端点）、`PUT` 或 `DELETE` 的 actuator 端点将返回 403 禁止访问错误。

NOTE: 我们建议仅在创建非浏览器客户端使用的服务时才完全禁用 CSRF 保护。

有关 CSRF 保护的其他信息，请参阅 {spring-security-docs}#csrf[Spring Security 参考指南]



[[boot-features-sql]]
== 使用 SQL 数据库
{spring-framework}[Spring Framework]  为 SQL 数据库提供了广泛的支持。从直接使用 `JdbcTemplate` 进行 JDBC 访问到完全的对象关系映射（object relational mapping）技术，比如 Hibernate。{spring-data}[Spring Data]提供了更多级别的功能，直接从接口创建的 `Repository` 实现，并使用了约定从方法名生成查询。

[[boot-features-configure-datasource]]
=== 配置数据源
Java 的 `javax.sql.DataSource` 接口提供了一个使用数据库连接的标准方法。通常，数据源使用 URL 和一些凭据信息来建立数据库连接。

TIP: 查看 <<howto.adoc#howto-configure-a-datasource,"`How-to`" 部分>> 获取更多高级示例，通常您可以完全控制数据库的配置。

[[boot-features-embedded-database-support]]
==== 内嵌数据库支持
使用内嵌内存数据库来开发应用程序非常方便的。显然，内存数据库不提供持久存储。在应用启动时，您需要填充数据库，并在应用程序结束时丢弃数据。

TIP: How-to 部分包含了<<howto.adoc#howto-database-initialization, 如何初始化数据库>>方面的内容。

Spring Boot 可以自动配置内嵌 https://www.h2database.com[H2], http://hsqldb.org/[HSQL], 和 https://db.apache.org/derby/[Derby]  数据库。您不需要提供任何连接 URL，只需为您想要使用的内嵌数据库引入特定的构建依赖。

[NOTE]
====
如果您在测试中使用此功能，您可能会注意到，无论使用了多少应用程序上下文，整个测试套件都会重复使用相同的数据库。如果您想确保每个上下文都有一个单独的内嵌数据库，则应该将 `spring.datasource.generate-unique-name` 设置为 `true`。
====

以下是 POM 依赖示例：

[source,xml,indent=0]
----
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-data-jpa</artifactId>
	</dependency>
	<dependency>
		<groupId>org.hsqldb</groupId>
		<artifactId>hsqldb</artifactId>
		<scope>runtime</scope>
	</dependency>
----

NOTE: 要自动配置内嵌数据库，您需要一个 `spring-jdbc` 依赖。在这个例子中，它是通过 `spring-boot-starter-data-jpa` 引入。

TIP: 如果出于某些原因，您需要配置内嵌数据库的连接 URL，则应注意确保禁用数据库的自动关闭功能。
如果您使用 H2，则应该使用 `DB_CLOSE_ON_EXIT=FALSE` 来设置。如果您使用 HSQLDB，则确保不使用 `shutdown=true`。禁用数据库的自动关闭功能允许 Spring Boot 控制数据库何时关闭，从而确保一旦不再需要访问数据库时就触发。

[[boot-features-connect-to-production-database]]
==== 连接生产数据库
生产数据库连接也可以使用使用 `DataSource` 自动配置。Spring Boot 使用以下算法来选择一个特定的实现：

. 出于性能和并发性的考虑，我们更喜欢 https://github.com/brettwooldridge/HikariCP[HikariCP]  连接池。如果 HikariCP 可用，我们总是选择它。
. 否则，如果 Tomcat 池 DataSource 可用，我们将使用它。
. 如果 HikariCP 和 Tomcat 池数据源不可用，但 https://commons.apache.org/proper/commons-dbcp/[Commons DBCP2]  可用，我们将使用它。

如果您使用了 `spring-boot-starter-jdbc` 或者 `spring-boot-starter-data-jpa starter`，您将自动得到 HikariCP 依赖。

NOTE: 您完全可以绕过该算法，并通过 `spring.datasource.type` 属性指定要使用的连接池。如果您在 Tomcat 容器中运行应用程序，默认提供 `tomcat-jdbc`，这点尤其重要。

TIP: 可以手动配置其他连接池。如果您定义了自己的 `DataSource` bean，则自动配置将不会触发。

数据源配置由 `spring.datasource.*` 中的外部属性所控制。例如，您可以在 `application.properties` 中声明以下部分：

[source,properties,indent=0,configprops]
----
	spring.datasource.url=jdbc:mysql://localhost/test
	spring.datasource.username=dbuser
	spring.datasource.password=dbpass
	spring.datasource.driver-class-name=com.mysql.jdbc.Driver
----

NOTE: 您至少应该使用 `spring.datasource.url` 属性来指定 URL，否则 Spring Boot 将尝试自动配置内嵌数据库。

TIP: 通常您不需要指定 `driver-class-name`，因为 Spring boot 可以从 `url` 推导出大多数数据库。

NOTE: 对于要创建的池 `DataSource`，我们需要能够验证有效的 Driver 类是否可用，因此我们在使用之前进行检查。例如，如果您设置了 `spring.datasource.driver-class-name=com.mysql.jdbc.Driver`，那么该类必须可加载。

有关更多支持选项，请参阅  {spring-boot-autoconfigure-module-code}/jdbc/DataSourceProperties.java[`DataSourceProperties`] 。
这些都是标准选项，与实际的实现无关。还可以使用各自的前缀（`spring.datasource.hikari.*`、`spring.datasource.tomcat.*` 和 `spring.datasource.dbcp2.*`）微调实现特定的设置。请参考您现在使用的连接池实现的文档来获取更多信息。

例如，如果你使用  https://tomcat.apache.org/tomcat-8.0-doc/jdbc-pool.html#Common_Attributes[Tomcat connection pool]，则可以自定义许多其他设置，如下：

[source,properties,indent=0,configprops]
----
	# Number of ms to wait before throwing an exception if no connection is available.
	spring.datasource.tomcat.max-wait=10000

	# Maximum number of active connections that can be allocated from this pool at the same time.
	spring.datasource.tomcat.max-active=50

	# Validate the connection before borrowing it from the pool.
	spring.datasource.tomcat.test-on-borrow=true
----



[[boot-features-connecting-to-a-jndi-datasource]]
==== 连接 JNDI 数据源
如果要将 Spring Boot 应用程序部署到应用服务器（Application Server）上，您可能想使用应用服务器的内置功能和 JNDI 访问方式来配置和管理数据源。

`spring.datasource.jndi-name` 属性可作为 `spring.datasource.url`、`spring.datasource.username` 和 `spring.datasource.password` 属性的替代方法，用于从特定的 JNDI 位置访问 `DataSource`。例如，`application.properties` 中的以下部分展示了如何访问 JBoss AS 定义的 `DataSource`：

[source,properties,indent=0,configprops]
----
	spring.datasource.jndi-name=java:jboss/datasources/customers
----

[[boot-features-using-jdbc-template]]
=== 使用 JdbcTemplate
Spring 的 `JdbcTemplate` 和 `NamedParameterJdbcTemplate` 类是自动配置的，您可以使用 `@Autowire` 将它们直接注入您的 bean 中：

[source,java,indent=0]
----
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.jdbc.core.JdbcTemplate;
	import org.springframework.stereotype.Component;

	@Component
	public class MyBean {

		private final JdbcTemplate jdbcTemplate;

		@Autowired
		public MyBean(JdbcTemplate jdbcTemplate) {
			this.jdbcTemplate = jdbcTemplate;
		}

		// ...

	}
----

您可以使用 `spring.jdbc.template.*` 属性来自定义一些 template 的属性，如下：

[source,properties,indent=0,configprops]
----
	spring.jdbc.template.max-rows=500
----

NOTE: `NamedParameterJdbcTemplate` 在底层重用了相同的 `JdbcTemplate` 实例。如果定义了多个 `JdbcTemplate` 且没有声明 primary 主候选，则不会自动配置 `NamedParameterJdbcTemplate`。

[[boot-features-jpa-and-spring-data]]
=== JPA 与 Spring Data JPA
Java Persistence API（Java 持久化 API）是一项标准技术，可让您将对象映射到关系数据库。`spring-boot-starter-data-jpa` POM 提供了一个快速起步的方法。它提供了以下关键依赖：

* Hibernate:  最受欢迎的 JPA 实现之一。
* Spring Data JPA: 可以轻松地实现基于 JPA 的资源库。
* Spring ORMs:  Spring Framework 的核心 ORM 支持

TIP: 我们不会在这里介绍太多关于 JPA 或者  {spring-data}[Spring Data]  的相关内容。您可以在 https://spring.io 上查看使用 https://spring.io/guides/gs/accessing-data-jpa/["`JPA 访问数据`"]，获取阅读 {spring-data-jpa}[Spring Data JPA] 和 https://hibernate.org/orm/documentation/[Hibernate] 的参考文档。

[[boot-features-entity-classes]]
==== 实体类
通常，JPA Entity（实体）类是在 `persistence.xml` 文件中指定的。使用了 Spring Boot，该文件将不是必需的，可以使用 Entity Scanning（实体扫描）来代替。默认情况下，将搜索主配置类（使用了 `@EnableAutoConfiguration` 或 `@SpringBootApplication` 注解）下面的所有包。

任何用了 `@Entity`、`@Embeddable` 或者 `@MappedSuperclass` 注解的类将被考虑。一个典型的实体类如下：

[source,java,indent=0]
----
	package com.example.myapp.domain;

	import java.io.Serializable;
	import javax.persistence.*;

	@Entity
	public class City implements Serializable {

		@Id
		@GeneratedValue
		private Long id;

		@Column(nullable = false)
		private String name;

		@Column(nullable = false)
		private String state;

		// ... additional members, often include @OneToMany mappings

		protected City() {
			// no-args constructor required by JPA spec
			// this one is protected since it shouldn't be used directly
		}

		public City(String name, String state) {
			this.name = name;
			this.state = state;
		}

		public String getName() {
			return this.name;
		}

		public String getState() {
			return this.state;
		}

		// ... etc

	}
----

TIP: 您可以使用 `@EntityScan` 注解自定义实体类的扫描位置。请参见 "`<<howto.adoc#howto-separate-entity-definitions-from-spring-configuration,从 Spring configuration 配置中分离 @Entity 定义>>`"  章节。

[[boot-features-spring-data-jpa-repositories]]
==== Spring Data JPA 资源库
{spring-data-jpa}[Spring Data JPA]  资源库（repository）是接口，您可以定义用于访问数据。JAP 查询是根据您的方法名自动创建。例如，`CityRepository` 接口可以声明 `findAllByState(String state)` 方法来查找指定状态下的所有城市。

对于更加复杂的查询，您可以使用 Spring Data 的 {spring-data-jpa-api}/repository/Query.html[`Query`] 注解

Spring Data 资源库通常继承自 {spring-data-commons-api}/repository/Repository.html[`Repository`] 或者 {spring-data-commons-api}/repository/CrudRepository.html[`CrudRepository`] 接口。如果您使用了自动配置，则将从包含主配置类（使用了 `@EnableAutoConfiguration` 或 `@SpringBootApplication` 注解）的包中搜索资源库：

以下是一个典型的 Spring Data 资源库接口定义：

[source,java,indent=0]
----
	package com.example.myapp.domain;

	import org.springframework.data.domain.*;
	import org.springframework.data.repository.*;

	public interface CityRepository extends Repository<City, Long> {

		Page<City> findAll(Pageable pageable);

		City findByNameAndStateAllIgnoringCase(String name, String state);

	}
----

Spring Data JPA 资源库支持三种不同的引导模式：`default`、`deferred` 和 `lazy`。要启用延迟或懒惰引导，请将 `spring.data.jpa.repositories.bootstrap-mode` 分别设置为 `deferred` 或 `lazy`。使用延迟或延迟引导时，自动配置的 `EntityManagerFactoryBuilder` 将使用上下文的 `AsyncTaskExecutor` （如果有）作为 `applicationTaskExecutor`。

TIP: 我们几乎没有接触到 Spring Data JPA 的表面内容。有关详细信息，请查阅 {spring-data-jdbc-docs}[Spring Data JPA 参考文档]。

[[boot-features-creating-and-dropping-jpa-databases]]
==== 创建和删除 JPA 数据库
默认情况下，仅当您使用了内嵌数据库（H2、HSQL 或 Derby）时才会自动创建 JPA 数据库。您可以使用 `spring.jpa.*` 属性显式配置 JPA 设置。例如，要创建和删除表，您可以将以下内容添加到 `application.properties` 中：

[indent=0]
----
	spring.jpa.hibernate.ddl-auto=create-drop
----

NOTE: 关于上述功能，Hibernate 自己的内部属性名称（如果您记住更好）为 `hibernate.hbm2ddl.auto`。您可以使用 `spring.jpa.properties.*`（在添加到实体管理器之前，该前缀将被删除）来将 Hibernate 原生属性一同设置：

[indent=0]
----
	spring.jpa.properties.hibernate.globally_quoted_identifiers=true
----

上面示例中将 `true` 值设置给 `hibernate.globally_quoted_identifiers` 属性，该属性将传给 Hibernate 实体管理器。

默认情况下，DDL 执行（或验证）将延迟到 `ApplicationContext` 启动后。还有一个 `spring.jpa.generate-ddl` 标志，如果 Hibernate 自动配置是激活的，那么它将不会被使用，因为 `ddl-auto` 设置更细粒度。

[[boot-features-jpa-in-web-environment]]
==== 在视图中打开 EntityManager
如果您正在运行 web 应用程序，Spring Boot 将默认注册  {spring-framework-api}/orm/jpa/support/OpenEntityManagerInViewInterceptor.html[`OpenEntityManagerInViewInterceptor`] 用于在视图中打开 EntityManager 模式，即运允许在 web 视图中延迟加载。如果您不想开启这个行为，则应在 `application.properties` 中将 `spring.jpa.open-in-view` 设置为 `false`。

[[boot-features-data-jdbc]]
=== Spring Data JDBC
Spring Data 包含了对 JDBC 资源库的支持，并将自动为 `CrudRepository` 上的方法生成 SQL。对于更高级的查询，它提供了 `@Query` 注解。

当 classpath 下存在必要的依赖时，Spring Boot 将自动配置 Spring Data 的 JDBC 资源库。可以通过添加单个 `spring-boot-starter-data-jdbc` 依赖引入到项目中。如有必要，可通过在应用程序中添加 `@EnableJdbcRepositories` 注解或 `JdbcConfiguration` 子类来控制 Spring Data JDBC 的配置。

TIP: 有关 Spring Data JDBC 的完整详细信息，请参阅 {spring-data-jdbc-docs}[参考文档]。

[[boot-features-sql-h2-console]]
=== 使用 H2 的 Web 控制台
https://www.h2database.com[H2 database] 数据库提供了一个 https://www.h2database.com/html/quickstart.html#h2_console[基于浏览器的控制台]基于浏览器的控制台，Spring Boot 可以为您自动配置。当满足以下条件时，控制台将自动配置：

* 您开发的是一个基于 servlet 的 web 应用程序
* `com.h2database:h2` 在 classpath 上
* 您使用了 <<using-spring-boot.adoc#using-boot-devtools,Spring Boot 的开发者工具>>.

TIP: 如果您不使用 Spring Boot 的开发者工具，但仍希望使用 H2 的控制台，则可以通过将 `spring.h2.console.enabled` 属性设置为 `true` 来实现。

NOTE: H2 控制台仅用于开发期间，因此应注意确保 `spring.h2.console.enabled` 在生产环境中没有设置为 `true`。

[[boot-features-sql-h2-console-custom-path]]
==== 更改 H2 控制台的路径
默认情况下，控制台的路径为 `/h2-console`。你可以使用 `spring.h2.console.path` 属性来自定义控制台的路径。

[[boot-features-jooq]]
=== 使用 jOOQ
Java 面向对象查询（Java Object Oriented Querying，https://www.jooq.org/[jOOQ]）是一款广受欢迎的产品，出自  https://www.datageekery.com/[Data Geekery]，它可以通过数据库生成 Java 代码，并允许您使用流式 API 来构建类型安全的 SQL 查询。商业版和开源版都可以与 Spring Boot 一起使用。

==== 代码生成
要使用 jOOQ 的类型安全查询，您需要从数据库模式生成 Java 类。您可以按照 {jooq-docs}/#jooq-in-7-steps-step3[jOOQ 用户手册]中的说明进行操作。如果您使用了 `jooq-codegen-maven` 插件，并且还使用了 `spring-boot-starter-parent` 父 POM，则可以安全地省略掉插件的 `<version>` 标签。
您还可以使用 Spring Boot 定义的版本变量（例如 `h2.version`）来声明插件的数据库依赖。以下是一个示例：

[source,xml,indent=0]
----
	<plugin>
		<groupId>org.jooq</groupId>
		<artifactId>jooq-codegen-maven</artifactId>
		<executions>
			...
		</executions>
		<dependencies>
			<dependency>
				<groupId>com.h2database</groupId>
				<artifactId>h2</artifactId>
				<version>${h2.version}</version>
			</dependency>
		</dependencies>
		<configuration>
			<jdbc>
				<driver>org.h2.Driver</driver>
				<url>jdbc:h2:~/yourdatabase</url>
			</jdbc>
			<generator>
				...
			</generator>
		</configuration>
	</plugin>
----



==== 使用 DSLContext
jOOQ 提供的流式 API 是通过 `org.jooq.DSLContext` 接口初始化的。Spring Boot 将自动配置一个 `DSLContext` 作为 Spring Bean，并且将其连接到应用程序的 `DataSource`。要使用 `DSLContext`，您只需要 `@Autowire` 它：

[source,java,indent=0]
----
	@Component
	public class JooqExample implements CommandLineRunner {

		private final DSLContext create;

		@Autowired
		public JooqExample(DSLContext dslContext) {
			this.create = dslContext;
		}

	}
----

TIP: jOOQ 手册建议使用名为 `create` 的变量来保存 `DSLContext`。

您可以使用 `DSLContext` 构建查询：

[source,java,indent=0]
----
	public List<GregorianCalendar> authorsBornAfter1980() {
		return this.create.selectFrom(AUTHOR)
			.where(AUTHOR.DATE_OF_BIRTH.greaterThan(new GregorianCalendar(1980, 0, 1)))
			.fetch(AUTHOR.DATE_OF_BIRTH);
	}
----



==== jOOQ SQL 方言
除非配置了 `spring.jooq.sql-dialect` 属性，否则 Spring Boot 会自动判定用于数据源的 SQL 方言。如果 Spring Boot 无法检测到方言，则使用 `DEFAULT`。

NOTE: Spring Boot 只能自动配置 jOOQ 开源版本支持的方言。



==== 自定义  jOOQ
可通过定义自己的 `@Bean` 来实现更高级的功能，这些自定义将在创建 jOOQ `Configuration` 时使用。您可以为以下 jOOQ 类型定义 bean：

* `ConnectionProvider`
* `ExecutorProvider`
* `TransactionProvider`
* `RecordMapperProvider`
* `RecordUnmapperProvider`
* `Settings`
* `RecordListenerProvider`
* `ExecuteListenerProvider`
* `VisitListenerProvider`
* `TransactionListenerProvider`

如果要完全控制 jOOQ 配置，您可以创建自己的 `org.jooq.Configuration` `@Bean`。



[[boot-features-nosql]]
== 使用 NoSQL 技术
Spring Data提供了其他项目来帮助您访问各种NoSQL技术，包括：

* {spring-data-mongodb}[MongoDB]
* {spring-data-neo4j}[Neo4J]
* {spring-data-elasticsearch}[Elasticsearch]
* {spring-data-solr}[Solr]
* {spring-data-redis}[Redis]
* {spring-data-gemfire}[GemFire] or {spring-data-geode}[Geode]
* {spring-data-cassandra}[Cassandra]
* {spring-data-couchbase}[Couchbase]
* {spring-data-ldap}[LDAP]

Spring Boot为Redis，MongoDB，Neo4j，Elasticsearch，Solr Cassandra，Couchbase和LDAP提供自动配置。 您可以使用其他项目，但必须自己进行配置。 请参阅 {spring-data} 中的相应参考文档。

[[boot-features-redis]]
=== Redis
https://redis.io/[Redis] 是一个集缓存、消息代理和键值存储等丰富功能的数据库。Spring Boot 为 https://github.com/lettuce-io/lettuce-core/[Lettuce] 和 https://github.com/xetorthio/jedis/[Jedis] 客户端类库提供了基本自动配置，https://github.com/spring-projects/spring-data-redis[Spring Data Redis] 为他们提供了上层抽象。

使用 `spring-boot-starter-data-redis` starter 可方便地引入相关依赖。默认情况下，它使用 https://github.com/lettuce-io/lettuce-core/[Lettuce]。该 starter 可处理传统应用程序和响应式应用程序。

TIP: 我们还提供了一个 `spring-boot-starter-data-redis-reactive` starter，以便与其他带有响应式支持的存储保持一致。

[[boot-features-connecting-to-redis]]
==== 连接 Redis
您可以像所有 Spring Bean 一样注入自动配置的 `RedisConnectionFactory`、`StringRedisTemplate` 或普通的 `RedisTemplate` 实例。默认情况下，实例将尝试在 `localhost:6379` 上连接 Redis 服务器，以下是 bean 示例：

[source,java,indent=0]
----
	@Component
	public class MyBean {

		private StringRedisTemplate template;

		@Autowired
		public MyBean(StringRedisTemplate template) {
			this.template = template;
		}

		// ...

	}
----

TIP: 您还可以注册任意数量个实现了 `LettuceClientConfigurationBuilderCustomizer` 的 bean，以进行更高级的自定义。如果你使用 Jedis，则可以使用 `JedisClientConfigurationBuilderCustomizer`。

如果您添加了自己的任何一个自动配置类型的 `@Bean`，它将替换默认设置（除了 `RedisTemplate`，由于排除是基于 bean 名称，而 `redisTemplate` 不是它的类型）。默认情况下，如果 `commons-pool2` 在 classpath 上，您将获得一个连接池工厂。

[[boot-features-mongodb]]
=== MongoDB
https://www.mongodb.com/[MongoDB] 是一个开源的 NoSQL 文档数据库，其使用了类似 JSON 的模式（schema）来替代传统基于表的关系数据。Spring Boot 为 MongoDB 提供了几种便利的使用方式，包括 `spring-boot-starter-data-mongodb` 和 `spring-boot-starter-data-mongodb-reactive` starter。

[[boot-features-connecting-to-mongodb]]
==== 连接 MongoDB 数据库
您可以注入一个自动配置的 `org.springframework.data.mongodb.MongoDbFactory` 来访问 Mongo 数据库。默认情况下，该实例将尝试在 `mongodb://localhost/test` 上连接 MongoDB 服务器，以下示例展示了如何连接到 MongoDB 数据库：

[source,java,indent=0]
----
	import org.springframework.data.mongodb.MongoDbFactory;
	import com.mongodb.DB;

	@Component
	public class MyBean {

		private final MongoDbFactory mongo;

		@Autowired
		public MyBean(MongoDbFactory mongo) {
			this.mongo = mongo;
		}

		// ...

		public void example() {
			DB db = mongo.getDb();
			// ...
		}

	}
----

您可以通过设置 `spring.data.mongodb.uri` 属性来更改 URL 和配置其他设置，如副本集（replica set）：

[source,properties,indent=0,configprops]
----
	spring.data.mongodb.uri=mongodb://user:secret@mongo1.example.com:12345,mongo2.example.com:23456/test
----

另外，只要您使用了 Mongo 2.x，请指定 `host/port`。比如，您可能要在 `application.properties` 中声明以下内容：

[source,properties,indent=0,configprops]
----
	spring.data.mongodb.host=mongoserver
	spring.data.mongodb.port=27017
----

如果您已经定义了自己的 `MongoClient`，它将被用于自动配置合适的 `MongoDbFactory`。支持 `com.mongodb.MongoClient` 和 `com.mongodb.client.MongoClient`。

NOTE: 如果您使用 Mongo 3.0 Java 驱动，则不支持 `spring.data.mongodb.host` 和 `spring.data.mongodb.port`。这种情况下，应该使用 `spring.data.mongodb.uri` 来提供所有配置。

TIP: 如果未指定 `spring.data.mongodb.port`，则使用默认值 `27017`。您可以将上述示例中的改行配置删除掉。

TIP: 如果您不使用 Spring Data Mongo，则可以注入 `com.mongodb.MongoClient` bean 来代替 `MongoDbFactory`。如果要完全控制建立 MongoDB 连接，您还可以声明自己的 `MongoDbFactory` 或者 `MongoClient` bean。

NOTE: 如果您使用的是响应式驱动，则 SSL 需要 Netty。 如果 Netty 可用且 factory 尚未自定义，则自动配置会自动配置此 factory。

[[boot-features-mongo-template]]
==== MongoTemplate
{spring-data-mongodb}[Spring Data MongoDB] 提供了一个 {spring-data-mongodb-api}/core/MongoTemplate.html[`MongoTemplate`]  类，它的设计与 Spring 的 `JdbcTemplate` 非常相似。与 `JdbcTemplate` 一样，Spring Boot 会自动配置一个 bean，以便您能注入模板：

[source,java,indent=0]
----
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.data.mongodb.core.MongoTemplate;
	import org.springframework.stereotype.Component;

	@Component
	public class MyBean {

		private final MongoTemplate mongoTemplate;

		@Autowired
		public MyBean(MongoTemplate mongoTemplate) {
			this.mongoTemplate = mongoTemplate;
		}

		// ...

	}
----

更多详细信息，参照 {spring-data-mongodb-api}/core/MongoOperations.html[`MongoOperations` Javadoc] 。

[[boot-features-spring-data-mongo-repositories]]
[[boot-features-spring-data-mongodb-repositories]]
==== Spring Data MongoDB Repositories
Spring Data 包含了对 MongoDB 资源库（repository）的支持。与之前讨论的 JPA 资源库一样，基本原理是根据方法名称自动构建查询。

事实上，Spring Data JPA 和 Spring Data MongoDB 共享通用的底层代码，因此你可以拿之前提到的 JPA 示例作为基础，假设 `City` 现在是一个 Mongo 数据类，而不是一个 JPA `@Entity`，他们方式工作相同：

[source,java,indent=0]
----
	package com.example.myapp.domain;

	import org.springframework.data.domain.*;
	import org.springframework.data.repository.*;

	public interface CityRepository extends Repository<City, Long> {

		Page<City> findAll(Pageable pageable);

		City findByNameAndStateAllIgnoringCase(String name, String state);

	}
----

TIP: 您可以使用 `@EntityScan` 注解来自定义文档扫描位置。

TIP: 有关 Spring Data MongoDB 的完整详细内容，包括其丰富的对象关系映射技术，请参考其 {spring-data-mongodb}[参考文档].



[[boot-features-mongo-embedded]]
==== 内嵌 Mongo
Spring Boot 提供了 https://github.com/flapdoodle-oss/de.flapdoodle.embed.mongo[内嵌 Mongo]的自动配置。要在 Spring Boot 应用程序中使用它，请添加依赖 `de.flapdoodle.embed:de.flapdoodle.embed.mongo`。

可以使用 `spring.data.mongodb.port` 属性来配置 Mongo 的监听端口。如果想随机分配空闲端口，请把值设置为 0。`MongoAutoConfiguration` 创建的 `MongoClient` 将自动配置随机分配的端口。

NOTE: 如果您不配置一个自定义端口，内嵌支持将默认使用一个随机端口（而不是 27017）。

如果您的 classpath 上有 SLF4J，Mongo 产生的输出将自动路由到名为 `org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongo` 的 logger。

您可以声明自己的 `IMongodConfig` 和 `IRuntimeConfig` bean 来控制 Mongo 实例的配置和日志路由。

可以通过声明 `DownloadConfigBuilderCustomizer` bean来定制下载配置。

[[boot-features-neo4j]]
=== Neo4j
https://neo4j.com/[Neo4j] 是一个开源的 NoSQL 图形数据库，它使用了一个节点由关系连接的富数据模型，比传统 RDBMS 的方式更适合连接大数据。Spring Boot 为 Neo4j 提供了便捷引入方式，包括 `spring-boot-starter-data-neo4j` starter。

[[boot-features-connecting-to-neo4j]]
==== 连接 Neo4j 数据库
您可以像任何 Spring Bean 一样注入一个自动配置的 `org.neo4j.ogm.session.Session`。默认情况下， 该实例将尝试使用在 `localhost:7687` 上使用 Bolt 协议连接到 Neo4j 服务器，以下示例展示了如何注入 一个 Neo4j `Session`：

[source,java,indent=0]
----
	@Component
	public class MyBean {

		private final Session session;

		@Autowired
		public MyBean(Session session) {
			this.session = session;
		}

		// ...

	}
----

您可以通过配置 `spring.data.neo4j.*` 属性来设置 uri 和凭据：

[source,properties,indent=0,configprops]
----
	spring.data.neo4j.uri=bolt://my-server:7687
	spring.data.neo4j.username=neo4j
	spring.data.neo4j.password=secret
----

您可以通过添加自己的 `org.neo4j.ogm.config.Configuration` Bean 来完全控制 session 创建。此外，添加 `SessionFactory` 类型的 Bean 会禁用自动配置，因此您可以掌控所有。

[[boot-features-connecting-to-neo4j-embedded]]
==== 使用内嵌模式
如果您将 `org.neo4j:neo4j-ogm-embedded-driver` 添加到应用程序的依赖中，Spring Boot 将自动配置一个进程内内嵌的 Neo4j 实例，当您的应用程序关闭时，该实例将不会保留任何数据。

NOTE: 内嵌 Neo4j OGM 驱动本身不提供 Neo4j 您必须自己声明 `org.neo4j:neo4j` 依赖，请参考 https://neo4j.com/docs/ogm-manual/current/reference/#reference:getting-started[the Neo4j OGM 文档] 获取兼容版本列表。

您可以通过设置 `spring.data.neo4j.embedded.enabled = false` 显式禁用嵌入式模式。

如果嵌入式驱动程序和Neo4j内核位于上述类路径上，则 <<boot-features-testing-spring-boot-applications-testing-autoconfigured-neo4j-test,Data Neo4j Tests>>会自动使用嵌入式Neo4j实例。

NOTE: 您可以通过在配置中提供数据库文件路径来为内嵌模式启用持久化，例如：`spring.data.neo4j.uri=file://var/tmp/graph.db`。

[[boot-features-neo4j-ogm-native-types]]
==== 使用本机类型
Neo4j-OGM可以将某些类型（例如  `java.time.*` 中的类型）映射到基于 `String` 的属性或Neo4j提供的本机类型之一。 出于向后兼容的原因，Neo4j-OGM的默认设置是使用基于字符串的表示形式。 要使用本机类型，请添加对 `org.neo4j:neo4j-ogm-embedded-native-types` 或 `org.neo4j：neo4j-ogm-embedded-native-types` 的依赖关系，并配置 `spring.data.neo4j.use-native-types` 属性，如以下示例所示：

[source,properties,indent=0,configprops]
----
	spring.data.neo4j.use-native-types=true
----

[[boot-features-neo4j-ogm-session]]
==== Neo4jSession
默认情况下，如果您正在运行 Web 应用程序，会话（session）将被绑定到当前请求的整个处理线程（即 Open Session in View 模式）。如果不希望此行为，您可以在 `application.properties` 中添加以下内容：

[source,properties,indent=0,configprops]
----
	spring.data.neo4j.open-in-view=false
----

[[boot-features-spring-data-neo4j-repositories]]
==== Spring Data Neo4j 资源库
Spring Data 包括了对 Neo4j 资源库的支持。

Spring Data Neo4j 与 Spring Data JPA 共享相同的通用底层代码，因此您可以直接把之前的 JPA 示例作为基础，假设 `City` 现在是一个 Neo4j OGM `@NodeEntity`，而不是一个 JPA `@Entity`，并且资源库抽象以相同的方式工作：

[source,java,indent=0]
----
	package com.example.myapp.domain;

	import java.util.Optional;

	import org.springframework.data.neo4j.repository.*;

	public interface CityRepository extends Neo4jRepository<City, Long> {

		Optional<City> findOneByNameAndState(String name, String state);

	}
----

`spring-boot-starter-data-neo4j` starter 支持资源库和事务管理。您可以在 `@Configuration` bean 上分别使用 `@EnableNeo4jRepositories` 和 `@EntityScan` 来自定义位置以查找资源库和实体。

TIP: 有关 Spring Data Neo4j 的完整详细信息，包括其对象映射技术，请参阅 {spring-data-neo4j-docs}[参考文档]。.

[[boot-features-solr]]
=== Solr
https://lucene.apache.org/solr/[Apache Solr] 是一个搜素引擎。Spring Boot 为 Solr 5 客户端类库提供了基本的自动配置，并且  https://github.com/spring-projects/spring-data-solr[Spring Data Solr] 为其提供给了顶层抽象。相关的依赖包含在了 `spring-boot-starter-data-solr` starter 中。

[[boot-features-connecting-to-solr]]
==== 连接 Solr
您可以像其他 Spring Bean 一样注入一个自动配置的 `SolrClient` 实例。默认情况下，该实例将尝试通过 `localhost:8983/solr` 连接到服务器，以下示例展示了如何注入一个 Solr bean：

[source,java,indent=0]
----
	@Component
	public class MyBean {

		private SolrClient solr;

		@Autowired
		public MyBean(SolrClient solr) {
			this.solr = solr;
		}

		// ...

	}
----

如果您添加了自己的 `SolrClient` 类型的 `@Bean`，它将替换掉默认配置。



[[boot-features-spring-data-solr-repositories]]
==== Spring Data Solr 资源库
Spring Data 包含了对 Apache Solr 资源库的支持。与之前讨论的 JPA 资源库一样，基本原理是根据方法名称自动构造查询。

事实上，Spring Data JPA 和 Spring Data Solr 共享了相同的通用底层代码，因此您可以使用之前的 JPA 示例作为基础，假设 `City` 现在是一个 `@SolrDocument` 类，而不是一个 JPA `@Entity`，它的工作方式相同。

TIP: 有关 Spring Data Solr 的完整详细内容，请参考其 {spring-data-solr-docs}[参考文档]。



[[boot-features-elasticsearch]]
=== Elasticsearch
https://www.elastic.co/products/elasticsearch[Elasticsearch] 是一个开源、分布式、RESTful 的实时搜索分析引擎。Spring Boot 为 Elasticsearch 提供了基本的自动配置。

Spring Boot 支持以下 HTTP 客户端：

Spring Boot 支持以下 HTTP 客户端：

* 官方 Java Low Level（低级） 和 High Level（高级） REST 客户端
* Spring Data Elasticsearch提供的 `ReactiveElasticsearchClient`

https://github.com/spring-projects/spring-data-elasticsearch[Spring Data Elasticsearch] 依旧使用传输客户端，但是Spring Data Elasticsearch和Elasticsearch本身已弃用了它的支持。 它将在将来的版本中删除。您可以使用 spring-boot-starter-data-elasticsearch starter 引入使用它。

由于Elasticsearch和Spring Data Elasticsearch为REST客户端提供了官方支持，因此  https://github.com/searchbox-io/Jest[Jest]  客户端也已被弃用。

[[boot-features-connecting-to-elasticsearch-rest]]
==== 使用 REST 客户端连接 Elasticsearch
Elasticsearch 提供了 https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/index.html[两个可用于查询集群的 REST 客户端] ：Low Level（低级） 和 High Level（高级）。

如果您的 classpath 上存在 `org.elasticsearch.client:elasticsearch-rest-client` 依赖，则 Spring Boot 将自动配置并注册默认目标为 `localhost:9200` 的 `RestClient` bean。您可以进一步调整 `RestClient` 的配置，如下所示：

[source,properties,indent=0,configprops]
----
	spring.elasticsearch.rest.uris=https://search.example.com:9200
	spring.elasticsearch.rest.read-timeout=10s
	spring.elasticsearch.rest.username=user
	spring.elasticsearch.rest.password=secret
----

您还可以注册实现任意数量的 `RestClientBuilderCustomizer` bean，以进行更高级的自定义。要完全控制注册流程，请定义 RestClient bean。

如果你 classpath 上有 `org.elasticsearch.client:elasticsearch-rest-high-level-client` 依赖，Spring Boot 将自动配置一个 `RestHighLevelClient`，它包装了所有现有的 `RestClient` bean，重用其 HTTP 配置。

[[boot-features-connecting-to-elasticsearch-reactive-rest]]
==== 使用 Reactive REST 客户端连接
{spring-data-elasticsearch}[Spring Data Elasticsearch] 提供了 `ReactiveElasticsearchClient`，用于以响应式查询 `Elasticsearch` 实例。 它基于 `WebFlux的WebClient` 构建，因此 `spring-boot-starter-elasticsearch` 和 `spring-boot-starter-webflux` 依赖。

默认情况下，Spring Boot将自动配置并注册一个针对  `http://localhost:9200` 的 `ReactiveElasticsearchClient` bean。 您可以进一步调整其配置，如以下示例所示：

[source,properties,indent=0,configprops]
----
	spring.data.elasticsearch.client.reactive.endpoints=search.example.com:9200
	spring.data.elasticsearch.client.reactive.use-ssl=true
	spring.data.elasticsearch.client.reactive.socket-timeout=10s
	spring.data.elasticsearch.client.reactive.username=user
	spring.data.elasticsearch.client.reactive.password=secret
----

如果配置属性不够，并且您想完全控制客户端配置，则可以注册自定义 `ClientConfiguration` bean。

[[boot-features-connecting-to-elasticsearch-jest]]
==== 使用 Jest 连接 Elasticsearch

现在，Spring Boot支持官方的 `RestHighLevelClient`，不再支持 `Jest`。

如果您的 classpath 上存在 `Jest`，则可以注入一个默认目标为 `http://localhost:9200`. 的自动配置 `JestClient`。您还可以进一步调整客户端配置：

[source,properties,indent=0,configprops]
----
	spring.elasticsearch.jest.uris=https://search.example.com:9200
	spring.elasticsearch.jest.read-timeout=10000
	spring.elasticsearch.jest.username=user
	spring.elasticsearch.jest.password=secret
----

您还可以注册任何数量实现了 `HttpClientConfigBuilderCustomizer` 的 bean，以进行更加高级的自定义。以下示例调整了其他 HTTP 设置：

[source,java,indent=0]
----
include::{code-examples}/elasticsearch/jest/JestClientCustomizationExample.java[tag=customizer]
----

要完全控制注册流程，请定义一个 `JestClient` bean。

[[boot-features-connecting-to-elasticsearch-spring-data]]
==== 使用 Spring Data 连接 Elasticsearch
要连接 Elasticsearch，必须定义由Spring Boot自动配置或由应用程序手动提供的 `RestHighLevelClient` bean（请参阅前面的部分）。 有了此配置后，可以像其他任何Spring bean一样注入 `ElasticsearchRestTemplate`，如以下示例所示：

[source,java,indent=0]
----
	@Component
	public class MyBean {

		private final ElasticsearchRestTemplate template;

		public MyBean(ElasticsearchRestTemplate template) {
			this.template = template;
		}

		// ...

	}
----

如果存在 `spring-data-elasticsearch` 和使用 `WebClient` 所需的依赖关系（通常是 `spring-boot-starter-webflux`）的情况下，Spring Boot还可以将 <<boot-features-connecting-to-elasticsearch-reactive-rest,ReactiveElasticsearchClient>>  和 `ReactiveElasticsearchTemplate` 自动配置为bean。 它们与其他REST客户端是等效的。

[[boot-features-spring-data-elasticsearch-repositories]]
==== Spring Data Elasticsearch 资源库
Spring Data 包含了对 Elasticsearch 资源库的支持，与之前讨论的 JPA 资源库一样，其原理是根据方法名称自动构造查询。

事实上，Spring Data JPA 与 Spring Data Elasticsearch 共享了相同的通用底层代码，因此您可以使用之前的 JPA 示例作为基础，假设 `City` 此时是一个 Elasticsearch `@Document` 类，而不是一个 JPA `@Entity`，它以相同的方式工作。

TIP: 有关 Spring Data Elasticsearch 的完整详细内容，请参阅其 {spring-data-elasticsearch-docs}[参考文]。 .

Spring Boot使用 `ElasticsearchRestTemplate` 或 `ReactiveElasticsearchTemplate` bean支持经典和响应式式 Elasticsearch 资源库。 给定所需的依赖项，最有可能由Spring Boot自动配置这些bean。

如果您希望使用自己的模板来支持Elasticsearch存储库，则可以添加自己的 `ElasticsearchRestTemplate` 或 `ElasticsearchOperations` @Bean，只要它名为 "elasticsearchTemplate" 即可。 同样适用于 `ReactiveElasticsearchTemplate` 和 `ReactiveElasticsearchOperations`，其bean名称为 "reactiveElasticsearchTemplate"。

您可以选择使用以下属性禁用存储库支持：

[source,properties,indent=0,configprops]
----
    spring.data.elasticsearch.repositories.enabled=false
----


[[boot-features-cassandra]]
=== Cassandra
https://cassandra.apache.org/[Cassandra] is an open source, distributed database management system designed to handle large amounts of data across many commodity servers.
Spring Boot offers auto-configuration for Cassandra and the abstractions on top of it provided by https://github.com/spring-projects/spring-data-cassandra[Spring Data Cassandra].


There is a `spring-boot-starter-data-cassandra` "`Starter`" for collecting the dependencies in a convenient way.



[[boot-features-connecting-to-cassandra]]
==== Connecting to Cassandra
You can inject an auto-configured `CassandraTemplate` or a Cassandra `Session` instance as you would with any other Spring Bean.
The `spring.data.cassandra.*` properties can be used to customize the connection.
Generally, you provide `keyspace-name` and `contact-points` properties, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.data.cassandra.keyspace-name=mykeyspace
	spring.data.cassandra.contact-points=cassandrahost1,cassandrahost2
----

You can also register an arbitrary number of beans that implement `ClusterBuilderCustomizer` for more advanced customizations.

The following code listing shows how to inject a Cassandra bean:

[source,java,indent=0]
----
	@Component
	public class MyBean {

		private CassandraTemplate template;

		@Autowired
		public MyBean(CassandraTemplate template) {
			this.template = template;
		}

		// ...

	}
----

If you add your own `@Bean` of type `CassandraTemplate`, it replaces the default.



[[boot-features-spring-data-cassandra-repositories]]
==== Spring Data Cassandra Repositories
Spring Data includes basic repository support for Cassandra.
Currently, this is more limited than the JPA repositories discussed earlier and needs to annotate finder methods with `@Query`.

TIP: For complete details of Spring Data Cassandra, refer to the https://docs.spring.io/spring-data/cassandra/docs/[reference documentation].



[[boot-features-couchbase]]
=== Couchbase
https://www.couchbase.com/[Couchbase] is an open-source, distributed, multi-model NoSQL document-oriented database that is optimized for interactive applications.
Spring Boot offers auto-configuration for Couchbase and the abstractions on top of it provided by https://github.com/spring-projects/spring-data-couchbase[Spring Data Couchbase].
There are `spring-boot-starter-data-couchbase` and `spring-boot-starter-data-couchbase-reactive` "`Starters`" for collecting the dependencies in a convenient way.



[[boot-features-connecting-to-couchbase]]
==== Connecting to Couchbase
You can get a `Bucket` and `Cluster` by adding the Couchbase SDK and some configuration.
The `spring.couchbase.*` properties can be used to customize the connection.
Generally, you provide the bootstrap hosts, bucket name, and password, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.couchbase.bootstrap-hosts=my-host-1,192.168.1.123
	spring.couchbase.bucket.name=my-bucket
	spring.couchbase.bucket.password=secret
----

TIP: You need to provide _at least_ the bootstrap host(s), in which case the bucket name is `default` and the password is an empty String.
Alternatively, you can define your own `org.springframework.data.couchbase.config.CouchbaseConfigurer` `@Bean` to take control over the whole configuration.

It is also possible to customize some of the `CouchbaseEnvironment` settings.
For instance, the following configuration changes the timeout to use to open a new `Bucket` and enables SSL support:

[source,properties,indent=0,configprops]
----
	spring.couchbase.env.timeouts.connect=3000
	spring.couchbase.env.ssl.key-store=/location/of/keystore.jks
	spring.couchbase.env.ssl.key-store-password=secret
----

Check the `spring.couchbase.env.*` properties for more details.



[[boot-features-spring-data-couchbase-repositories]]
==== Spring Data Couchbase Repositories
Spring Data includes repository support for Couchbase.
For complete details of Spring Data Couchbase, refer to the https://docs.spring.io/spring-data/couchbase/docs/current/reference/html/[reference documentation].

You can inject an auto-configured `CouchbaseTemplate` instance as you would with any other Spring Bean, provided a _default_ `CouchbaseConfigurer` is available (which happens when you enable Couchbase support, as explained earlier).

The following examples shows how to inject a Couchbase bean:

[source,java,indent=0]
----
	@Component
	public class MyBean {

		private final CouchbaseTemplate template;

		@Autowired
		public MyBean(CouchbaseTemplate template) {
			this.template = template;
		}

		// ...

	}
----

There are a few beans that you can define in your own configuration to override those provided by the auto-configuration:

* A `CouchbaseTemplate` `@Bean` with a name of `couchbaseTemplate`.
* An `IndexManager` `@Bean` with a name of `couchbaseIndexManager`.
* A `CustomConversions` `@Bean` with a name of `couchbaseCustomConversions`.

To avoid hard-coding those names in your own config, you can reuse `BeanNames` provided by Spring Data Couchbase.
For instance, you can customize the converters to use, as follows:

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	public class SomeConfiguration {

		@Bean(BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)
		public CustomConversions myCustomConversions() {
			return new CustomConversions(...);
		}

		// ...

	}
----

TIP: If you want to fully bypass the auto-configuration for Spring Data Couchbase, provide your own implementation of `org.springframework.data.couchbase.config.AbstractCouchbaseDataConfiguration`.



[[boot-features-ldap]]
=== LDAP
https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol[LDAP] (Lightweight Directory Access Protocol) is an open, vendor-neutral, industry standard application protocol for accessing and maintaining distributed directory information services over an IP network.
Spring Boot offers auto-configuration for any compliant LDAP server as well as support for the embedded in-memory LDAP server from https://www.ldap.com/unboundid-ldap-sdk-for-java[UnboundID].

LDAP abstractions are provided by https://github.com/spring-projects/spring-data-ldap[Spring Data LDAP].
There is a `spring-boot-starter-data-ldap` "`Starter`" for collecting the dependencies in a convenient way.



[[boot-features-ldap-connecting]]
==== Connecting to an LDAP Server
To connect to an LDAP server, make sure you declare a dependency on the `spring-boot-starter-data-ldap` "`Starter`" or `spring-ldap-core` and then declare the URLs of your server in your application.properties, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.ldap.urls=ldap://myserver:1235
	spring.ldap.username=admin
	spring.ldap.password=secret
----

If you need to customize connection settings, you can use the `spring.ldap.base` and `spring.ldap.base-environment` properties.

An `LdapContextSource` is auto-configured based on these settings.
If you need to customize it, for instance to use a `PooledContextSource`, you can still inject the auto-configured `LdapContextSource`.
Make sure to flag your customized `ContextSource` as `@Primary` so that the auto-configured `LdapTemplate` uses it.



[[boot-features-ldap-spring-data-repositories]]
==== Spring Data LDAP Repositories
Spring Data includes repository support for LDAP.
For complete details of Spring Data LDAP, refer to the https://docs.spring.io/spring-data/ldap/docs/1.0.x/reference/html/[reference documentation].

You can also inject an auto-configured `LdapTemplate` instance as you would with any other Spring Bean, as shown in the following example:


[source,java,indent=0]
----
	@Component
	public class MyBean {

		private final LdapTemplate template;

		@Autowired
		public MyBean(LdapTemplate template) {
			this.template = template;
		}

		// ...

	}
----



[[boot-features-ldap-embedded]]
==== Embedded In-memory LDAP Server
For testing purposes, Spring Boot supports auto-configuration of an in-memory LDAP server from https://www.ldap.com/unboundid-ldap-sdk-for-java[UnboundID].
To configure the server, add a dependency to `com.unboundid:unboundid-ldapsdk` and declare a configprop:spring.ldap.embedded.base-dn[] property, as follows:

[source,properties,indent=0,configprops]
----
	spring.ldap.embedded.base-dn=dc=spring,dc=io
----

[NOTE]
====
It is possible to define multiple base-dn values, however, since distinguished names usually contain commas, they must be defined using the correct notation.

In yaml files, you can use the yaml list notation:

[source,yaml,indent=0]
----
	spring.ldap.embedded.base-dn:
	  - dc=spring,dc=io
	  - dc=pivotal,dc=io
----

In properties files, you must include the index as part of the property name:

[source,properties,indent=0,configprops]
----
	spring.ldap.embedded.base-dn[0]=dc=spring,dc=io
	spring.ldap.embedded.base-dn[1]=dc=pivotal,dc=io
----

====

By default, the server starts on a random port and triggers the regular LDAP support.
There is no need to specify a configprop:spring.ldap.urls[] property.

If there is a `schema.ldif` file on your classpath, it is used to initialize the server.
If you want to load the initialization script from a different resource, you can also use the configprop:spring.ldap.embedded.ldif[] property.

By default, a standard schema is used to validate `LDIF` files.
You can turn off validation altogether by setting the configprop:spring.ldap.embedded.validation.enabled[] property.
If you have custom attributes, you can use configprop:spring.ldap.embedded.validation.schema[] to define your custom attribute types or object classes.



[[boot-features-influxdb]]
=== InfluxDB
https://www.influxdata.com/[InfluxDB] is an open-source time series database optimized for fast, high-availability storage and retrieval of time series data in fields such as operations monitoring, application metrics, Internet-of-Things sensor data, and real-time analytics.



[[boot-features-connecting-to-influxdb]]
==== Connecting to InfluxDB
Spring Boot auto-configures an `InfluxDB` instance, provided the `influxdb-java` client is on the classpath and the URL of the database is set, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.influx.url=https://172.0.0.1:8086
----

If the connection to InfluxDB requires a user and password, you can set the `spring.influx.user` and `spring.influx.password` properties accordingly.

InfluxDB relies on OkHttp.
If you need to tune the http client `InfluxDB` uses behind the scenes, you can register an `InfluxDbOkHttpClientBuilderProvider` bean.



[[boot-features-caching]]
== Caching
The Spring Framework provides support for transparently adding caching to an application.
At its core, the abstraction applies caching to methods, thus reducing the number of executions based on the information available in the cache.
The caching logic is applied transparently, without any interference to the invoker.
Spring Boot auto-configures the cache infrastructure as long as caching support is enabled via the `@EnableCaching` annotation.

NOTE: Check the {spring-framework-docs}integration.html#cache[relevant section] of the Spring Framework reference for more details.

In a nutshell, adding caching to an operation of your service is as easy as adding the relevant annotation to its method, as shown in the following example:

[source,java,indent=0]
----
	import org.springframework.cache.annotation.Cacheable;
	import org.springframework.stereotype.Component;

	@Component
	public class MathService {

		@Cacheable("piDecimals")
		public int computePiDecimal(int i) {
			// ...
		}

	}
----

This example demonstrates the use of caching on a potentially costly operation.
Before invoking `computePiDecimal`, the abstraction looks for an entry in the `piDecimals` cache that matches the `i` argument.
If an entry is found, the content in the cache is immediately returned to the caller, and the method is not invoked.
Otherwise, the method is invoked, and the cache is updated before returning the value.

CAUTION: You can also use the standard JSR-107 (JCache) annotations (such as `@CacheResult`) transparently.
However, we strongly advise you to not mix and match the Spring Cache and JCache annotations.

If you do not add any specific cache library, Spring Boot auto-configures a <<boot-features-caching-provider-simple,simple provider>> that uses concurrent maps in memory.
When a cache is required (such as `piDecimals` in the preceding example), this provider creates it for you.
The simple provider is not really recommended for production usage, but it is great for getting started and making sure that you understand the features.
When you have made up your mind about the cache provider to use, please make sure to read its documentation to figure out how to configure the caches that your application uses.
Nearly all providers require you to explicitly configure every cache that you use in the application.
Some offer a way to customize the default caches defined by the configprop:spring.cache.cache-names[] property.

TIP: It is also possible to transparently {spring-framework-docs}integration.html#cache-annotations-put[update] or {spring-framework-docs}integration.html#cache-annotations-evict[evict] data from the cache.



[[boot-features-caching-provider]]
=== Supported Cache Providers
The cache abstraction does not provide an actual store and relies on abstraction materialized by the `org.springframework.cache.Cache` and `org.springframework.cache.CacheManager` interfaces.

If you have not defined a bean of type `CacheManager` or a `CacheResolver` named `cacheResolver` (see {spring-framework-api}/cache/annotation/CachingConfigurer.html[`CachingConfigurer`]), Spring Boot tries to detect the following providers (in the indicated order):

. <<boot-features-caching-provider-generic,Generic>>
. <<boot-features-caching-provider-jcache,JCache (JSR-107)>> (EhCache 3, Hazelcast, Infinispan, and others)
. <<boot-features-caching-provider-ehcache2,EhCache 2.x>>
. <<boot-features-caching-provider-hazelcast,Hazelcast>>
. <<boot-features-caching-provider-infinispan,Infinispan>>
. <<boot-features-caching-provider-couchbase,Couchbase>>
. <<boot-features-caching-provider-redis,Redis>>
. <<boot-features-caching-provider-caffeine,Caffeine>>
. <<boot-features-caching-provider-simple,Simple>>

TIP: It is also possible to _force_ a particular cache provider by setting the configprop:spring.cache.type[] property.
Use this property if you need to <<boot-features-caching-provider-none,disable caching altogether>> in certain environment (such as tests).

TIP: Use the `spring-boot-starter-cache` "`Starter`" to quickly add basic caching dependencies.
The starter brings in `spring-context-support`.
If you add dependencies manually, you must include `spring-context-support` in order to use the JCache, EhCache 2.x, or Caffeine support.

If the `CacheManager` is auto-configured by Spring Boot, you can further tune its configuration before it is fully initialized by exposing a bean that implements the `CacheManagerCustomizer` interface.
The following example sets a flag to say that `null` values should be passed down to the underlying map:

[source,java,indent=0]
----
	@Bean
	public CacheManagerCustomizer<ConcurrentMapCacheManager> cacheManagerCustomizer() {
		return new CacheManagerCustomizer<ConcurrentMapCacheManager>() {
			@Override
			public void customize(ConcurrentMapCacheManager cacheManager) {
				cacheManager.setAllowNullValues(false);
			}
		};
	}
----

NOTE: In the preceding example, an auto-configured `ConcurrentMapCacheManager` is expected.
If that is not the case (either you provided your own config or a different cache provider was auto-configured), the customizer is not invoked at all.
You can have as many customizers as you want, and you can also order them by using `@Order` or `Ordered`.



[[boot-features-caching-provider-generic]]
==== Generic
Generic caching is used if the context defines _at least_ one `org.springframework.cache.Cache` bean.
A `CacheManager` wrapping all beans of that type is created.



[[boot-features-caching-provider-jcache]]
==== JCache (JSR-107)
https://jcp.org/en/jsr/detail?id=107[JCache] is bootstrapped through the presence of a `javax.cache.spi.CachingProvider` on the classpath (that is, a JSR-107 compliant caching library exists on the classpath), and the `JCacheCacheManager` is provided by the `spring-boot-starter-cache` "`Starter`".
Various compliant libraries are available, and Spring Boot provides dependency management for Ehcache 3, Hazelcast, and Infinispan.
Any other compliant library can be added as well.

It might happen that more than one provider is present, in which case the provider must be explicitly specified.
Even if the JSR-107 standard does not enforce a standardized way to define the location of the configuration file, Spring Boot does its best to accommodate setting a cache with implementation details, as shown in the following example:

[source,properties,indent=0,configprops]
----
    # Only necessary if more than one provider is present
	spring.cache.jcache.provider=com.acme.MyCachingProvider
	spring.cache.jcache.config=classpath:acme.xml
----

NOTE: When a cache library offers both a native implementation and JSR-107 support, Spring Boot prefers the JSR-107 support, so that the same features are available if you switch to a different JSR-107 implementation.

TIP: Spring Boot has <<boot-features-hazelcast,general support for Hazelcast>>.
If a single `HazelcastInstance` is available, it is automatically reused for the `CacheManager` as well, unless the configprop:spring.cache.jcache.config[] property is specified.

There are two ways to customize the underlying `javax.cache.cacheManager`:

* Caches can be created on startup by setting the configprop:spring.cache.cache-names[] property.
  If a custom `javax.cache.configuration.Configuration` bean is defined, it is used to customize them.
* `org.springframework.boot.autoconfigure.cache.JCacheManagerCustomizer` beans are invoked with the reference of the `CacheManager` for full customization.

TIP: If a standard `javax.cache.CacheManager` bean is defined, it is wrapped automatically in an `org.springframework.cache.CacheManager` implementation that the abstraction expects.
No further customization is applied to it.



[[boot-features-caching-provider-ehcache2]]
==== EhCache 2.x
https://www.ehcache.org/[EhCache] 2.x is used if a file named `ehcache.xml` can be found at the root of the classpath.
If EhCache 2.x is found, the `EhCacheCacheManager` provided by the `spring-boot-starter-cache` "`Starter`" is used to bootstrap the cache manager.
An alternate configuration file can be provided as well, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.cache.ehcache.config=classpath:config/another-config.xml
----



[[boot-features-caching-provider-hazelcast]]
==== Hazelcast
Spring Boot has <<boot-features-hazelcast,general support for Hazelcast>>.
If a `HazelcastInstance` has been auto-configured, it is automatically wrapped in a `CacheManager`.



[[boot-features-caching-provider-infinispan]]
==== Infinispan
https://infinispan.org/[Infinispan] has no default configuration file location, so it must be specified explicitly.
Otherwise, the default bootstrap is used.

[source,properties,indent=0,configprops]
----
	spring.cache.infinispan.config=infinispan.xml
----

Caches can be created on startup by setting the configprop:spring.cache.cache-names[] property.
If a custom `ConfigurationBuilder` bean is defined, it is used to customize the caches.

NOTE: The support of Infinispan in Spring Boot is restricted to the embedded mode and is quite basic.
If you want more options, you should use the official Infinispan Spring Boot starter instead.
See https://github.com/infinispan/infinispan-spring-boot[Infinispan's documentation] for more details.



[[boot-features-caching-provider-couchbase]]
==== Couchbase
If the https://www.couchbase.com/[Couchbase] Java client and the `couchbase-spring-cache` implementation are available and Couchbase is <<boot-features-couchbase,configured>>, a `CouchbaseCacheManager` is auto-configured.
It is also possible to create additional caches on startup by setting the configprop:spring.cache.cache-names[] property.
These caches operate on the `Bucket` that was auto-configured.
You can _also_ create additional caches on another `Bucket` by using the customizer.
Assume you need two caches (`cache1` and `cache2`) on the "main" `Bucket` and one (`cache3`) cache with a custom time to live of 2 seconds on the "`another`" `Bucket`.
You can create the first two caches through configuration, as follows:

[source,properties,indent=0,configprops]
----
	spring.cache.cache-names=cache1,cache2
----

Then you can define a `@Configuration` class to configure the extra `Bucket` and the `cache3` cache, as follows:

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	public class CouchbaseCacheConfiguration {

		private final Cluster cluster;

		public CouchbaseCacheConfiguration(Cluster cluster) {
			this.cluster = cluster;
		}

		@Bean
		public Bucket anotherBucket() {
			return this.cluster.openBucket("another", "secret");
		}

		@Bean
		public CacheManagerCustomizer<CouchbaseCacheManager> cacheManagerCustomizer() {
			return c -> {
				c.prepareCache("cache3", CacheBuilder.newInstance(anotherBucket())
						.withExpiration(2));
			};
		}

	}
----

This sample configuration reuses the `Cluster` that was created through auto-configuration.



[[boot-features-caching-provider-redis]]
==== Redis
If https://redis.io/[Redis] is available and configured, a `RedisCacheManager` is auto-configured.
It is possible to create additional caches on startup by setting the configprop:spring.cache.cache-names[] property and cache defaults can be configured by using `spring.cache.redis.*` properties.
For instance, the following configuration creates `cache1` and `cache2` caches with a _time to live_ of 10 minutes:

[source,properties,indent=0,configprops]
----
	spring.cache.cache-names=cache1,cache2
	spring.cache.redis.time-to-live=600000
----

NOTE: By default, a key prefix is added so that, if two separate caches use the same key, Redis does not have overlapping keys and cannot return invalid values.
We strongly recommend keeping this setting enabled if you create your own `RedisCacheManager`.

TIP: You can take full control of the configuration by adding a `RedisCacheConfiguration` `@Bean` of your own.
This can be useful if you're looking for customizing the serialization strategy.



[[boot-features-caching-provider-caffeine]]
==== Caffeine
https://github.com/ben-manes/caffeine[Caffeine] is a Java 8 rewrite of Guava's cache that supersedes support for Guava.
If Caffeine is present, a `CaffeineCacheManager` (provided by the `spring-boot-starter-cache` "`Starter`") is auto-configured.
Caches can be created on startup by setting the configprop:spring.cache.cache-names[] property and can be customized by one of the following (in the indicated order):

. A cache spec defined by `spring.cache.caffeine.spec`
. A `com.github.benmanes.caffeine.cache.CaffeineSpec` bean is defined
. A `com.github.benmanes.caffeine.cache.Caffeine` bean is defined

For instance, the following configuration creates `cache1` and `cache2` caches with a maximum size of 500 and a _time to live_ of 10 minutes

[source,properties,indent=0,configprops]
----
	spring.cache.cache-names=cache1,cache2
	spring.cache.caffeine.spec=maximumSize=500,expireAfterAccess=600s
----

If a `com.github.benmanes.caffeine.cache.CacheLoader` bean is defined, it is automatically associated to the `CaffeineCacheManager`.
Since the `CacheLoader` is going to be associated with _all_ caches managed by the cache manager, it must be defined as `CacheLoader<Object, Object>`.
The auto-configuration ignores any other generic type.



[[boot-features-caching-provider-simple]]
==== Simple
If none of the other providers can be found, a simple implementation using a `ConcurrentHashMap` as the cache store is configured.
This is the default if no caching library is present in your application.
By default, caches are created as needed, but you can restrict the list of available caches by setting the `cache-names` property.
For instance, if you want only `cache1` and `cache2` caches, set the `cache-names` property as follows:

[source,properties,indent=0,configprops]
----
	spring.cache.cache-names=cache1,cache2
----

If you do so and your application uses a cache not listed, then it fails at runtime when the cache is needed, but not on startup.
This is similar to the way the "real" cache providers behave if you use an undeclared cache.



[[boot-features-caching-provider-none]]
==== None
When `@EnableCaching` is present in your configuration, a suitable cache configuration is expected as well.
If you need to disable caching altogether in certain environments, force the cache type to `none` to use a no-op implementation, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.cache.type=none
----



[[boot-features-messaging]]
== Messaging
The Spring Framework provides extensive support for integrating with messaging systems, from simplified use of the JMS API using `JmsTemplate` to a complete infrastructure to receive messages asynchronously.
Spring AMQP provides a similar feature set for the Advanced Message Queuing Protocol.
Spring Boot also provides auto-configuration options for `RabbitTemplate` and RabbitMQ.
Spring WebSocket natively includes support for STOMP messaging, and Spring Boot has support for that through starters and a small amount of auto-configuration.
Spring Boot also has support for Apache Kafka.



[[boot-features-jms]]
=== JMS
The `javax.jms.ConnectionFactory` interface provides a standard method of creating a `javax.jms.Connection` for interacting with a JMS broker.
Although Spring needs a `ConnectionFactory` to work with JMS, you generally need not use it directly yourself and can instead rely on higher level messaging abstractions.
(See the {spring-framework-docs}integration.html#jms[relevant section] of the Spring Framework reference documentation for details.)
Spring Boot also auto-configures the necessary infrastructure to send and receive messages.



[[boot-features-activemq]]
==== ActiveMQ Support
When https://activemq.apache.org/[ActiveMQ] is available on the classpath, Spring Boot can also configure a `ConnectionFactory`.
If the broker is present, an embedded broker is automatically started and configured (provided no broker URL is specified through configuration).

NOTE: If you use `spring-boot-starter-activemq`, the necessary dependencies to connect or embed an ActiveMQ instance are provided, as is the Spring infrastructure to integrate with JMS.

ActiveMQ configuration is controlled by external configuration properties in `+spring.activemq.*+`.
For example, you might declare the following section in `application.properties`:

[source,properties,indent=0,configprops]
----
	spring.activemq.broker-url=tcp://192.168.1.210:9876
	spring.activemq.user=admin
	spring.activemq.password=secret
----

By default, a `CachingConnectionFactory` wraps the native `ConnectionFactory` with sensible settings that you can control by external configuration properties in `+spring.jms.*+`:

[source,properties,indent=0,configprops]
----
	spring.jms.cache.session-cache-size=5
----

If you'd rather use native pooling, you can do so by adding a dependency to `org.messaginghub:pooled-jms` and configuring the `JmsPoolConnectionFactory` accordingly, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.activemq.pool.enabled=true
	spring.activemq.pool.max-connections=50
----

TIP: See {spring-boot-autoconfigure-module-code}/jms/activemq/ActiveMQProperties.java[`ActiveMQProperties`] for more of the supported options.
You can also register an arbitrary number of beans that implement `ActiveMQConnectionFactoryCustomizer` for more advanced customizations.

By default, ActiveMQ creates a destination if it does not yet exist so that destinations are resolved against their provided names.



[[boot-features-artemis]]
==== Artemis Support
Spring Boot can auto-configure a `ConnectionFactory` when it detects that https://activemq.apache.org/artemis/[Artemis] is available on the classpath.
If the broker is present, an embedded broker is automatically started and configured (unless the mode property has been explicitly set).
The supported modes are `embedded` (to make explicit that an embedded broker is required and that an error should occur if the broker is not available on the classpath) and `native` (to connect to a broker using the `netty` transport protocol).
When the latter is configured, Spring Boot configures a `ConnectionFactory` that connects to a broker running on the local machine with the default settings.

NOTE: If you use `spring-boot-starter-artemis`, the necessary dependencies to connect to an existing Artemis instance are provided, as well as the Spring infrastructure to integrate with JMS.
Adding `org.apache.activemq:artemis-jms-server` to your application lets you use embedded mode.

Artemis configuration is controlled by external configuration properties in `+spring.artemis.*+`.
For example, you might declare the following section in `application.properties`:

[source,properties,indent=0,configprops]
----
	spring.artemis.mode=native
	spring.artemis.host=192.168.1.210
	spring.artemis.port=9876
	spring.artemis.user=admin
	spring.artemis.password=secret
----

When embedding the broker, you can choose if you want to enable persistence and list the destinations that should be made available.
These can be specified as a comma-separated list to create them with the default options, or you can define bean(s) of type `org.apache.activemq.artemis.jms.server.config.JMSQueueConfiguration` or `org.apache.activemq.artemis.jms.server.config.TopicConfiguration`, for advanced queue and topic configurations, respectively.

By default, a `CachingConnectionFactory` wraps the native `ConnectionFactory` with sensible settings that you can control by external configuration properties in `+spring.jms.*+`:

[source,properties,indent=0,configprops]
----
	spring.jms.cache.session-cache-size=5
----

If you'd rather use native pooling, you can do so by adding a dependency to `org.messaginghub:pooled-jms` and configuring the `JmsPoolConnectionFactory` accordingly, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.artemis.pool.enabled=true
	spring.artemis.pool.max-connections=50
----

See {spring-boot-autoconfigure-module-code}/jms/artemis/ArtemisProperties.java[`ArtemisProperties`] for more supported options.

No JNDI lookup is involved, and destinations are resolved against their names, using either the `name` attribute in the Artemis configuration or the names provided through configuration.



[[boot-features-jms-jndi]]
==== Using a JNDI ConnectionFactory
If you are running your application in an application server, Spring Boot tries to locate a JMS `ConnectionFactory` by using JNDI.
By default, the `java:/JmsXA` and `java:/XAConnectionFactory` location are checked.
You can use the configprop:spring.jms.jndi-name[] property if you need to specify an alternative location, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.jms.jndi-name=java:/MyConnectionFactory
----



[[boot-features-using-jms-sending]]
==== Sending a Message
Spring's `JmsTemplate` is auto-configured, and you can autowire it directly into your own beans, as shown in the following example:

[source,java,indent=0]
----
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.jms.core.JmsTemplate;
	import org.springframework.stereotype.Component;

	@Component
	public class MyBean {

		private final JmsTemplate jmsTemplate;

		@Autowired
		public MyBean(JmsTemplate jmsTemplate) {
			this.jmsTemplate = jmsTemplate;
		}

		// ...

	}
----

NOTE: {spring-framework-api}/jms/core/JmsMessagingTemplate.html[`JmsMessagingTemplate`] can be injected in a similar manner.
If a `DestinationResolver` or a `MessageConverter` bean is defined, it is associated automatically to the auto-configured `JmsTemplate`.



[[boot-features-using-jms-receiving]]
==== Receiving a Message
When the JMS infrastructure is present, any bean can be annotated with `@JmsListener` to create a listener endpoint.
If no `JmsListenerContainerFactory` has been defined, a default one is configured automatically.
If a `DestinationResolver` or a `MessageConverter` beans is defined, it is associated automatically to the default factory.

By default, the default factory is transactional.
If you run in an infrastructure where a `JtaTransactionManager` is present, it is associated to the listener container by default.
If not, the `sessionTransacted` flag is enabled.
In that latter scenario, you can associate your local data store transaction to the processing of an incoming message by adding `@Transactional` on your listener method (or a delegate thereof).
This ensures that the incoming message is acknowledged, once the local transaction has completed.
This also includes sending response messages that have been performed on the same JMS session.

The following component creates a listener endpoint on the `someQueue` destination:

[source,java,indent=0]
----
	@Component
	public class MyBean {

		@JmsListener(destination = "someQueue")
		public void processMessage(String content) {
			// ...
		}

	}
----

TIP: See {spring-framework-api}/jms/annotation/EnableJms.html[the Javadoc of `@EnableJms`] for more details.

If you need to create more `JmsListenerContainerFactory` instances or if you want to override the default, Spring Boot provides a `DefaultJmsListenerContainerFactoryConfigurer` that you can use to initialize a `DefaultJmsListenerContainerFactory` with the same settings as the one that is auto-configured.

For instance, the following example exposes another factory that uses a specific `MessageConverter`:

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	static class JmsConfiguration {

		@Bean
		public DefaultJmsListenerContainerFactory myFactory(
				DefaultJmsListenerContainerFactoryConfigurer configurer) {
			DefaultJmsListenerContainerFactory factory =
					new DefaultJmsListenerContainerFactory();
			configurer.configure(factory, connectionFactory());
			factory.setMessageConverter(myMessageConverter());
			return factory;
		}

	}
----

Then you can use the factory in any `@JmsListener`-annotated method as follows:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Component
	public class MyBean {

		@JmsListener(destination = "someQueue", **containerFactory="myFactory"**)
		public void processMessage(String content) {
			// ...
		}

	}
----



[[boot-features-amqp]]
=== AMQP
The Advanced Message Queuing Protocol (AMQP) is a platform-neutral, wire-level protocol for message-oriented middleware.
The Spring AMQP project applies core Spring concepts to the development of AMQP-based messaging solutions.
Spring Boot offers several conveniences for working with AMQP through RabbitMQ, including the `spring-boot-starter-amqp` "`Starter`".



[[boot-features-rabbitmq]]
==== RabbitMQ support
https://www.rabbitmq.com/[RabbitMQ] is a lightweight, reliable, scalable, and portable message broker based on the AMQP protocol.
Spring uses `RabbitMQ` to communicate through the AMQP protocol.

RabbitMQ configuration is controlled by external configuration properties in `+spring.rabbitmq.*+`.
For example, you might declare the following section in `application.properties`:

[source,properties,indent=0,configprops]
----
	spring.rabbitmq.host=localhost
	spring.rabbitmq.port=5672
	spring.rabbitmq.username=admin
	spring.rabbitmq.password=secret
----

Alternatively, you could configure the same connection using the `addresses` attributes:

[source,properties,indent=0]
----
	spring.rabbitmq.addresses=amqp://admin:secret@localhost
----

If a `ConnectionNameStrategy` bean exists in the context, it will be automatically used to name connections created by the auto-configured `ConnectionFactory`.
See {spring-boot-autoconfigure-module-code}/amqp/RabbitProperties.java[`RabbitProperties`] for more of the supported options.

TIP: See https://spring.io/blog/2010/06/14/understanding-amqp-the-protocol-used-by-rabbitmq/[Understanding AMQP, the protocol used by RabbitMQ] for more details.



[[boot-features-using-amqp-sending]]
==== Sending a Message
Spring's `AmqpTemplate` and `AmqpAdmin` are auto-configured, and you can autowire them directly into your own beans, as shown in the following example:

[source,java,indent=0]
----
	import org.springframework.amqp.core.AmqpAdmin;
	import org.springframework.amqp.core.AmqpTemplate;
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.stereotype.Component;

	@Component
	public class MyBean {

		private final AmqpAdmin amqpAdmin;
		private final AmqpTemplate amqpTemplate;

		@Autowired
		public MyBean(AmqpAdmin amqpAdmin, AmqpTemplate amqpTemplate) {
			this.amqpAdmin = amqpAdmin;
			this.amqpTemplate = amqpTemplate;
		}

		// ...

	}
----

NOTE: {spring-amqp-api}/rabbit/core/RabbitMessagingTemplate.html[`RabbitMessagingTemplate`] can be injected in a similar manner.
If a `MessageConverter` bean is defined, it is associated automatically to the auto-configured `AmqpTemplate`.

If necessary, any `org.springframework.amqp.core.Queue` that is defined as a bean is automatically used to declare a corresponding queue on the RabbitMQ instance.

To retry operations, you can enable retries on the `AmqpTemplate` (for example, in the event that the broker connection is lost):

[source,properties,indent=0,configprops]
----
	spring.rabbitmq.template.retry.enabled=true
	spring.rabbitmq.template.retry.initial-interval=2s
----

Retries are disabled by default.
You can also customize the `RetryTemplate` programmatically by declaring a `RabbitRetryTemplateCustomizer` bean.



[[boot-features-using-amqp-receiving]]
==== Receiving a Message
When the Rabbit infrastructure is present, any bean can be annotated with `@RabbitListener` to create a listener endpoint.
If no `RabbitListenerContainerFactory` has been defined, a default `SimpleRabbitListenerContainerFactory` is automatically configured and you can switch to a direct container using the configprop:spring.rabbitmq.listener.type[] property.
If a `MessageConverter` or a `MessageRecoverer` bean is defined, it is automatically associated with the default factory.

The following sample component creates a listener endpoint on the `someQueue` queue:

[source,java,indent=0]
----
	@Component
	public class MyBean {

		@RabbitListener(queues = "someQueue")
		public void processMessage(String content) {
			// ...
		}

	}
----

TIP: See {spring-amqp-api}/rabbit/annotation/EnableRabbit.html[the Javadoc of `@EnableRabbit`] for more details.

If you need to create more `RabbitListenerContainerFactory` instances or if you want to override the default, Spring Boot provides a `SimpleRabbitListenerContainerFactoryConfigurer` and a `DirectRabbitListenerContainerFactoryConfigurer` that you can use to initialize a `SimpleRabbitListenerContainerFactory` and a `DirectRabbitListenerContainerFactory` with the same settings as the factories used by the auto-configuration.

TIP: It does not matter which container type you chose.
Those two beans are exposed by the auto-configuration.

For instance, the following configuration class exposes another factory that uses a specific `MessageConverter`:

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	static class RabbitConfiguration {

		@Bean
		public SimpleRabbitListenerContainerFactory myFactory(
				SimpleRabbitListenerContainerFactoryConfigurer configurer) {
			SimpleRabbitListenerContainerFactory factory =
					new SimpleRabbitListenerContainerFactory();
			configurer.configure(factory, connectionFactory);
			factory.setMessageConverter(myMessageConverter());
			return factory;
		}

	}
----

Then you can use the factory in any `@RabbitListener`-annotated method, as follows:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Component
	public class MyBean {

		@RabbitListener(queues = "someQueue", **containerFactory="myFactory"**)
		public void processMessage(String content) {
			// ...
		}

	}
----

You can enable retries to handle situations where your listener throws an exception.
By default, `RejectAndDontRequeueRecoverer` is used, but you can define a `MessageRecoverer` of your own.
When retries are exhausted, the message is rejected and either dropped or routed to a dead-letter exchange if the broker is configured to do so.
By default, retries are disabled.
You can also customize the `RetryTemplate` programmatically by declaring a `RabbitRetryTemplateCustomizer` bean.

IMPORTANT: By default, if retries are disabled and the listener throws an exception, the delivery is retried indefinitely.
You can modify this behavior in two ways: Set the `defaultRequeueRejected` property to `false` so that zero re-deliveries are attempted or throw an `AmqpRejectAndDontRequeueException` to signal the message should be rejected.
The latter is the mechanism used when retries are enabled and the maximum number of delivery attempts is reached.



[[boot-features-kafka]]
=== Apache Kafka Support
https://kafka.apache.org/[Apache Kafka] is supported by providing auto-configuration of the `spring-kafka` project.

Kafka configuration is controlled by external configuration properties in `spring.kafka.*`.
For example, you might declare the following section in `application.properties`:

[source,properties,indent=0,configprops]
----
	spring.kafka.bootstrap-servers=localhost:9092
	spring.kafka.consumer.group-id=myGroup
----

TIP: To create a topic on startup, add a bean of type `NewTopic`.
If the topic already exists, the bean is ignored.

See {spring-boot-autoconfigure-module-code}/kafka/KafkaProperties.java[`KafkaProperties`] for more supported options.



[[boot-features-kafka-sending-a-message]]
==== Sending a Message
Spring's `KafkaTemplate` is auto-configured, and you can autowire it directly in your own beans, as shown in the following example:

[source,java,indent=0]
----
@Component
public class MyBean {

	private final KafkaTemplate kafkaTemplate;

	@Autowired
	public MyBean(KafkaTemplate kafkaTemplate) {
		this.kafkaTemplate = kafkaTemplate;
	}

	// ...

}
----

NOTE: If the property configprop:spring.kafka.producer.transaction-id-prefix[] is defined, a `KafkaTransactionManager` is automatically configured.
Also, if a `RecordMessageConverter` bean is defined, it is automatically associated to the auto-configured `KafkaTemplate`.



[[boot-features-kafka-receiving-a-message]]
==== Receiving a Message
When the Apache Kafka infrastructure is present, any bean can be annotated with `@KafkaListener` to create a listener endpoint.
If no `KafkaListenerContainerFactory` has been defined, a default one is automatically configured with keys defined in `spring.kafka.listener.*`.

The following component creates a listener endpoint on the `someTopic` topic:

[source,java,indent=0]
----
	@Component
	public class MyBean {

		@KafkaListener(topics = "someTopic")
		public void processMessage(String content) {
			// ...
		}

	}
----

If a `KafkaTransactionManager` bean is defined, it is automatically associated to the container factory.
Similarly, if a `ErrorHandler`, `AfterRollbackProcessor` or `ConsumerAwareRebalanceListener` bean is defined, it is automatically associated to the default factory.

Depending on the listener type, a `RecordMessageConverter` or `BatchMessageConverter` bean is associated to the default factory.
If only a `RecordMessageConverter` bean is present for a batch listener, it is wrapped in a `BatchMessageConverter`.

TIP: A custom `ChainedKafkaTransactionManager` must be marked `@Primary` as it usually references the auto-configured `KafkaTransactionManager` bean.



[[boot-features-kafka-streams]]
==== Kafka Streams
Spring for Apache Kafka provides a factory bean to create a `StreamsBuilder` object and manage the lifecycle of its streams.
Spring Boot auto-configures the required `KafkaStreamsConfiguration` bean as long as `kafka-streams` is on the classpath and Kafka Streams is enabled via the `@EnableKafkaStreams` annotation.

Enabling Kafka Streams means that the application id and bootstrap servers must be set.
The former can be configured using `spring.kafka.streams.application-id`, defaulting to `spring.application.name` if not set.
The latter can be set globally or specifically overridden just for streams.

Several additional properties are available using dedicated properties; other arbitrary Kafka properties can be set using the `spring.kafka.streams.properties` namespace.
See also <<boot-features-kafka-extra-props>> for more information.

To use the factory bean, simply wire `StreamsBuilder` into your `@Bean` as shown in the following example:

[source,java,indent=0]
----
include::{code-examples}/kafka/KafkaStreamsBeanExample.java[tag=configuration]
----

By default, the streams managed by the `StreamBuilder` object it creates are started automatically.
You can customize this behaviour using the configprop:spring.kafka.streams.auto-startup[] property.



[[boot-features-kafka-extra-props]]
==== Additional Kafka Properties
The properties supported by auto configuration are shown in <<appendix-application-properties.adoc#common-application-properties>>.
Note that, for the most part, these properties (hyphenated or camelCase) map directly to the Apache Kafka dotted properties.
Refer to the Apache Kafka documentation for details.

The first few of these properties apply to all components (producers, consumers, admins, and streams) but can be specified at the component level if you wish to use different values.
Apache Kafka designates properties with an importance of HIGH, MEDIUM, or LOW.
Spring Boot auto-configuration supports all HIGH importance properties, some selected MEDIUM and LOW properties, and any properties that do not have a default value.

Only a subset of the properties supported by Kafka are available directly through the `KafkaProperties` class.
If you wish to configure the producer or consumer with additional properties that are not directly supported, use the following properties:

[source,properties,indent=0,configprops]
----
	spring.kafka.properties.prop.one=first
	spring.kafka.admin.properties.prop.two=second
	spring.kafka.consumer.properties.prop.three=third
	spring.kafka.producer.properties.prop.four=fourth
	spring.kafka.streams.properties.prop.five=fifth
----

This sets the common `prop.one` Kafka property to `first` (applies to producers, consumers and admins), the `prop.two` admin property to `second`, the `prop.three` consumer property to `third`, the `prop.four` producer property to `fourth` and the `prop.five` streams property to `fifth`.

You can also configure the Spring Kafka `JsonDeserializer` as follows:

[source,properties,indent=0,configprops]
----
	spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer
	spring.kafka.consumer.properties.spring.json.value.default.type=com.example.Invoice
	spring.kafka.consumer.properties.spring.json.trusted.packages=com.example,org.acme
----

Similarly, you can disable the `JsonSerializer` default behavior of sending type information in headers:

[source,properties,indent=0,configprops]
----
	spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer
	spring.kafka.producer.properties.spring.json.add.type.headers=false
----

IMPORTANT: Properties set in this way override any configuration item that Spring Boot explicitly supports.



[[boot-features-embedded-kafka]]
==== Testing with Embedded Kafka
Spring for Apache Kafka provides a convenient way to test projects with an embedded Apache Kafka broker.
To use this feature, annotate a test class with `@EmbeddedKafka` from the `spring-kafka-test` module.
For more information, please see the Spring for Apache Kafka https://docs.spring.io/spring-kafka/docs/current/reference/html/#embedded-kafka-annotation[reference manual].

To make Spring Boot auto-configuration work with the aforementioned embedded Apache Kafka broker, you need to remap a system property for embedded broker addresses (populated by the `EmbeddedKafkaBroker`) into the Spring Boot configuration property for Apache Kafka.
There are several ways to do that:

* Provide a system property to map embedded broker addresses into configprop:spring.kafka.bootstrap-servers[] in the test class:

[source,java,indent=0]
----
static {
    System.setProperty(EmbeddedKafkaBroker.BROKER_LIST_PROPERTY, "spring.kafka.bootstrap-servers");
}
----

* Configure a property name on the `@EmbeddedKafka` annotation:

[source,java,indent=0]
----
@EmbeddedKafka(topics = "someTopic",
        bootstrapServersProperty = "spring.kafka.bootstrap-servers")
----

* Use a placeholder in configuration properties:

[source,properties,indent=0,configprops]
----
spring.kafka.bootstrap-servers=${spring.embedded.kafka.brokers}
----



[[boot-features-resttemplate]]
== Calling REST Services with `RestTemplate`
If you need to call remote REST services from your application, you can use the Spring Framework's {spring-framework-api}/web/client/RestTemplate.html[`RestTemplate`] class.
Since `RestTemplate` instances often need to be customized before being used, Spring Boot does not provide any single auto-configured `RestTemplate` bean.
It does, however, auto-configure a `RestTemplateBuilder`, which can be used to create `RestTemplate` instances when needed.
The auto-configured `RestTemplateBuilder` ensures that sensible `HttpMessageConverters` are applied to `RestTemplate` instances.

The following code shows a typical example:

[source,java,indent=0]
----
	@Service
	public class MyService {

		private final RestTemplate restTemplate;

		public MyService(RestTemplateBuilder restTemplateBuilder) {
			this.restTemplate = restTemplateBuilder.build();
		}

		public Details someRestCall(String name) {
			return this.restTemplate.getForObject("/{name}/details", Details.class, name);
		}

	}
----

TIP: `RestTemplateBuilder` includes a number of useful methods that can be used to quickly configure a `RestTemplate`.
For example, to add BASIC auth support, you can use `builder.basicAuthentication("user", "password").build()`.



[[boot-features-resttemplate-customization]]
=== RestTemplate Customization
There are three main approaches to `RestTemplate` customization, depending on how broadly you want the customizations to apply.

To make the scope of any customizations as narrow as possible, inject the auto-configured `RestTemplateBuilder` and then call its methods as required.
Each method call returns a new `RestTemplateBuilder` instance, so the customizations only affect this use of the builder.

To make an application-wide, additive customization, use a `RestTemplateCustomizer` bean.
All such beans are automatically registered with the auto-configured `RestTemplateBuilder` and are applied to any templates that are built with it.

The following example shows a customizer that configures the use of a proxy for all hosts except `192.168.0.5`:

[source,java,indent=0]
----
include::{code-examples}/web/client/RestTemplateProxyCustomizationExample.java[tag=customizer]
----

Finally, the most extreme (and rarely used) option is to create your own `RestTemplateBuilder` bean.
Doing so switches off the auto-configuration of a `RestTemplateBuilder` and prevents any `RestTemplateCustomizer` beans from being used.



[[boot-features-webclient]]
== Calling REST Services with `WebClient`
If you have Spring WebFlux on your classpath, you can also choose to use `WebClient` to call remote REST services.
Compared to `RestTemplate`, this client has a more functional feel and is fully reactive.
You can learn more about the `WebClient` in the dedicated {spring-framework-docs}web-reactive.html#webflux-client[section in the Spring Framework docs].

Spring Boot creates and pre-configures a `WebClient.Builder` for you; it is strongly advised to inject it in your components and use it to create `WebClient` instances.
Spring Boot is configuring that builder to share HTTP resources, reflect codecs setup in the same fashion as the server ones (see <<boot-features-webflux-httpcodecs,WebFlux HTTP codecs auto-configuration>>), and more.

The following code shows a typical example:

[source,java,indent=0]
----
	@Service
	public class MyService {

		private final WebClient webClient;

		public MyService(WebClient.Builder webClientBuilder) {
			this.webClient = webClientBuilder.baseUrl("https://example.org").build();
		}

		public Mono<Details> someRestCall(String name) {
			return this.webClient.get().uri("/{name}/details", name)
							.retrieve().bodyToMono(Details.class);
		}

	}
----



[[boot-features-webclient-runtime]]
=== WebClient Runtime
Spring Boot will auto-detect which `ClientHttpConnector` to use to drive `WebClient`, depending on the libraries available on the application classpath.
For now, Reactor Netty and Jetty RS client are supported.

The `spring-boot-starter-webflux` starter depends on `io.projectreactor.netty:reactor-netty` by default, which brings both server and client implementations.
If you choose to use Jetty as a reactive server instead, you should add a dependency on the Jetty Reactive HTTP client library, `org.eclipse.jetty:jetty-reactive-httpclient`.
Using the same technology for server and client has it advantages, as it will automatically share HTTP resources between client and server.

Developers can override the resource configuration for Jetty and Reactor Netty by providing a custom `ReactorResourceFactory` or `JettyResourceFactory` bean - this will be applied to both clients and servers.

If you wish to override that choice for the client, you can define your own `ClientHttpConnector` bean and have full control over the client configuration.

You can learn more about the {spring-framework-docs}web-reactive.html#webflux-client-builder[`WebClient` configuration options in the Spring Framework reference documentation].



[[boot-features-webclient-customization]]
=== WebClient Customization
There are three main approaches to `WebClient` customization, depending on how broadly you want the customizations to apply.

To make the scope of any customizations as narrow as possible, inject the auto-configured `WebClient.Builder` and then call its methods as required.
`WebClient.Builder` instances are stateful: Any change on the builder is reflected in all clients subsequently created with it.
If you want to create several clients with the same builder, you can also consider cloning the builder with `WebClient.Builder other = builder.clone();`.

To make an application-wide, additive customization to all `WebClient.Builder` instances, you can declare `WebClientCustomizer` beans and change the `WebClient.Builder` locally at the point of injection.

Finally, you can fall back to the original API and use `WebClient.create()`.
In that case, no auto-configuration or `WebClientCustomizer` is applied.



[[boot-features-validation]]
== Validation
The method validation feature supported by Bean Validation 1.1 is automatically enabled as long as a JSR-303 implementation (such as Hibernate validator) is on the classpath.
This lets bean methods be annotated with `javax.validation` constraints on their parameters and/or on their return value.
Target classes with such annotated methods need to be annotated with the `@Validated` annotation at the type level for their methods to be searched for inline constraint annotations.

For instance, the following service triggers the validation of the first argument, making sure its size is between 8 and 10:

[source,java,indent=0]
----
	@Service
	@Validated
	public class MyBean {

		public Archive findByCodeAndAuthor(@Size(min = 8, max = 10) String code,
				Author author) {
			...
		}

	}
----



[[boot-features-email]]
== Sending Email
The Spring Framework provides an easy abstraction for sending email by using the `JavaMailSender` interface, and Spring Boot provides auto-configuration for it as well as a starter module.

TIP: See the {spring-framework-docs}integration.html#mail[reference documentation] for a detailed explanation of how you can use `JavaMailSender`.

If `spring.mail.host` and the relevant libraries (as defined by `spring-boot-starter-mail`) are available, a default `JavaMailSender` is created if none exists.
The sender can be further customized by configuration items from the `spring.mail` namespace.
See {spring-boot-autoconfigure-module-code}/mail/MailProperties.java[`MailProperties`] for more details.

In particular, certain default timeout values are infinite, and you may want to change that to avoid having a thread blocked by an unresponsive mail server, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.mail.properties.mail.smtp.connectiontimeout=5000
	spring.mail.properties.mail.smtp.timeout=3000
	spring.mail.properties.mail.smtp.writetimeout=5000
----

It is also possible to configure a `JavaMailSender` with an existing `Session` from JNDI:

[source,properties,indent=0,configprops]
----
	spring.mail.jndi-name=mail/Session
----

When a `jndi-name` is set, it takes precedence over all other Session-related settings.



[[boot-features-jta]]
== Distributed Transactions with JTA
Spring Boot supports distributed JTA transactions across multiple XA resources by using either an https://www.atomikos.com/[Atomikos] or https://github.com/bitronix/btm[Bitronix] embedded transaction manager.
JTA transactions are also supported when deploying to a suitable Java EE Application Server.

When a JTA environment is detected, Spring's `JtaTransactionManager` is used to manage transactions.
Auto-configured JMS, DataSource, and JPA beans are upgraded to support XA transactions.
You can use standard Spring idioms, such as `@Transactional`, to participate in a distributed transaction.
If you are within a JTA environment and still want to use local transactions, you can set the configprop:spring.jta.enabled[] property to `false` to disable the JTA auto-configuration.



[[boot-features-jta-atomikos]]
=== Using an Atomikos Transaction Manager
https://www.atomikos.com/[Atomikos] is a popular open source transaction manager which can be embedded into your Spring Boot application.
You can use the `spring-boot-starter-jta-atomikos` starter to pull in the appropriate Atomikos libraries.
Spring Boot auto-configures Atomikos and ensures that appropriate `depends-on` settings are applied to your Spring beans for correct startup and shutdown ordering.

By default, Atomikos transaction logs are written to a `transaction-logs` directory in your application's home directory (the directory in which your application jar file resides).
You can customize the location of this directory by setting a configprop:spring.jta.log-dir[] property in your `application.properties` file.
Properties starting with `spring.jta.atomikos.properties` can also be used to customize the Atomikos `UserTransactionServiceImp`.
See the {spring-boot-module-api}/jta/atomikos/AtomikosProperties.html[`AtomikosProperties` Javadoc] for complete details.

NOTE: To ensure that multiple transaction managers can safely coordinate the same resource managers, each Atomikos instance must be configured with a unique ID.
By default, this ID is the IP address of the machine on which Atomikos is running.
To ensure uniqueness in production, you should configure the configprop:spring.jta.transaction-manager-id[] property with a different value for each instance of your application.



[[boot-features-jta-bitronix]]
=== Using a Bitronix Transaction Manager
https://github.com/bitronix/btm[Bitronix] is a popular open-source JTA transaction manager implementation.
You can use the `spring-boot-starter-jta-bitronix` starter to add the appropriate Bitronix dependencies to your project.
As with Atomikos, Spring Boot automatically configures Bitronix and post-processes your beans to ensure that startup and shutdown ordering is correct.

By default, Bitronix transaction log files (`part1.btm` and `part2.btm`) are written to a `transaction-logs` directory in your application home directory.
You can customize the location of this directory by setting the configprop:spring.jta.log-dir[] property.
Properties starting with `spring.jta.bitronix.properties` are also bound to the `bitronix.tm.Configuration` bean, allowing for complete customization.
See the https://github.com/bitronix/btm/wiki/Transaction-manager-configuration[Bitronix documentation] for details.

NOTE: To ensure that multiple transaction managers can safely coordinate the same resource managers, each Bitronix instance must be configured with a unique ID.
By default, this ID is the IP address of the machine on which Bitronix is running.
To ensure uniqueness in production, you should configure the configprop:spring.jta.transaction-manager-id[] property with a different value for each instance of your application.



[[boot-features-jta-javaee]]
=== Using a Java EE Managed Transaction Manager
If you package your Spring Boot application as a `war` or `ear` file and deploy it to a Java EE application server, you can use your application server's built-in transaction manager.
Spring Boot tries to auto-configure a transaction manager by looking at common JNDI locations (`java:comp/UserTransaction`, `java:comp/TransactionManager`, and so on).
If you use a transaction service provided by your application server, you generally also want to ensure that all resources are managed by the server and exposed over JNDI.
Spring Boot tries to auto-configure JMS by looking for a `ConnectionFactory` at the JNDI path (`java:/JmsXA` or `java:/XAConnectionFactory`), and you can use the <<boot-features-connecting-to-a-jndi-datasource, configprop:spring.datasource.jndi-name[] property>> to configure your `DataSource`.



[[boot-features-jta-mixed-jms]]
=== Mixing XA and Non-XA JMS Connections
When using JTA, the primary JMS `ConnectionFactory` bean is XA-aware and participates in distributed transactions.
In some situations, you might want to process certain JMS messages by using a non-XA `ConnectionFactory`.
For example, your JMS processing logic might take longer than the XA timeout.

If you want to use a non-XA `ConnectionFactory`, you can inject the `nonXaJmsConnectionFactory` bean rather than the `@Primary` `jmsConnectionFactory` bean.
For consistency, the `jmsConnectionFactory` bean is also provided by using the bean alias `xaJmsConnectionFactory`.

The following example shows how to inject `ConnectionFactory` instances:

[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	// Inject the primary (XA aware) ConnectionFactory
	@Autowired
	private ConnectionFactory defaultConnectionFactory;

	// Inject the XA aware ConnectionFactory (uses the alias and injects the same as above)
	@Autowired
	@Qualifier("xaJmsConnectionFactory")
	private ConnectionFactory xaConnectionFactory;

	// Inject the non-XA aware ConnectionFactory
	@Autowired
	@Qualifier("nonXaJmsConnectionFactory")
	private ConnectionFactory nonXaConnectionFactory;
----



[[boot-features-jta-supporting-alternative-embedded]]
=== Supporting an Alternative Embedded Transaction Manager
The {spring-boot-module-code}/jms/XAConnectionFactoryWrapper.java[`XAConnectionFactoryWrapper`] and {spring-boot-module-code}/jdbc/XADataSourceWrapper.java[`XADataSourceWrapper`] interfaces can be used to support alternative embedded transaction managers.
The interfaces are responsible for wrapping `XAConnectionFactory` and `XADataSource` beans and exposing them as regular `ConnectionFactory` and `DataSource` beans, which transparently enroll in the distributed transaction.
DataSource and JMS auto-configuration use JTA variants, provided you have a `JtaTransactionManager` bean and appropriate XA wrapper beans registered within your `ApplicationContext`.

The {spring-boot-module-code}/jta/bitronix/BitronixXAConnectionFactoryWrapper.java[BitronixXAConnectionFactoryWrapper] and {spring-boot-module-code}/jta/bitronix/BitronixXADataSourceWrapper.java[BitronixXADataSourceWrapper] provide good examples of how to write XA wrappers.



[[boot-features-hazelcast]]
== Hazelcast
If https://hazelcast.com/[Hazelcast] is on the classpath and a suitable configuration is found, Spring Boot auto-configures a `HazelcastInstance` that you can inject in your application.

If you define a `com.hazelcast.config.Config` bean, Spring Boot uses that.
If your configuration defines an instance name, Spring Boot tries to locate an existing instance rather than creating a new one.

If you define a `com.hazelcast.config.Config` bean, Spring Boot uses that.
If your configuration defines an instance name, Spring Boot tries to locate an existing instance rather than creating a new one.

You could also specify the Hazelcast configuration file to use through configuration, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.hazelcast.config=classpath:config/my-hazelcast.xml
----

Otherwise, Spring Boot tries to find the Hazelcast configuration from the default locations: `hazelcast.xml` in the working directory or at the root of the classpath, or a `.yaml` counterpart in the same locations.
We also check if the `hazelcast.config` system property is set.
See the https://docs.hazelcast.org/docs/latest/manual/html-single/[Hazelcast documentation] for more details.

If `hazelcast-client` is present on the classpath, Spring Boot first attempts to create a client by checking the following configuration options:

* The presence of a `com.hazelcast.client.config.ClientConfig` bean.
* A configuration file defined by the configprop:spring.hazelcast.config[] property.
* The presence of the `hazelcast.client.config` system property.
* A `hazelcast-client.xml` in the working directory or at the root of the classpath.
* A `hazelcast-client.yaml` in the working directory or at the root of the classpath.

NOTE: Spring Boot also has <<boot-features-caching-provider-hazelcast,explicit caching support for Hazelcast>>.
If caching is enabled, the `HazelcastInstance` is automatically wrapped in a `CacheManager` implementation.



[[boot-features-quartz]]
== Quartz Scheduler
Spring Boot offers several conveniences for working with the https://www.quartz-scheduler.org/[Quartz scheduler], including the `spring-boot-starter-quartz` "`Starter`".
If Quartz is available, a `Scheduler` is auto-configured (through the `SchedulerFactoryBean` abstraction).

Beans of the following types are automatically picked up and associated with the `Scheduler`:

* `JobDetail`: defines a particular Job.
  `JobDetail` instances can be built with the `JobBuilder` API.
* `Calendar`.
* `Trigger`: defines when a particular job is triggered.

By default, an in-memory `JobStore` is used.
However, it is possible to configure a JDBC-based store if a `DataSource` bean is available in your application and if the configprop:spring.quartz.job-store-type[] property is configured accordingly, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.quartz.job-store-type=jdbc
----

When the JDBC store is used, the schema can be initialized on startup, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.quartz.jdbc.initialize-schema=always
----

WARNING: By default, the database is detected and initialized by using the standard scripts provided with the Quartz library.
These scripts drop existing tables, deleting all triggers on every restart.
It is also possible to provide a custom script by setting the configprop:spring.quartz.jdbc.schema[] property.

To have Quartz use a `DataSource` other than the application's main `DataSource`, declare a `DataSource` bean, annotating its `@Bean` method with `@QuartzDataSource`.
Doing so ensures that the Quartz-specific `DataSource` is used by both the `SchedulerFactoryBean` and for schema initialization.

By default, jobs created by configuration will not overwrite already registered jobs that have been read from a persistent job store.
To enable overwriting existing job definitions set the configprop:spring.quartz.overwrite-existing-jobs[] property.

Quartz Scheduler configuration can be customized using `spring.quartz` properties and `SchedulerFactoryBeanCustomizer` beans, which allow programmatic `SchedulerFactoryBean` customization.
Advanced Quartz configuration properties can be customized using `spring.quartz.properties.*`.

NOTE: In particular, an `Executor` bean is not associated with the scheduler as Quartz offers a way to configure the scheduler via `spring.quartz.properties`.
If you need to customize the task executor, consider implementing `SchedulerFactoryBeanCustomizer`.

Jobs can define setters to inject data map properties.
Regular beans can also be injected in a similar manner, as shown in the following example:

[source,java,indent=0]
----
	public class SampleJob extends QuartzJobBean {

		private MyService myService;

		private String name;

		// Inject "MyService" bean
		public void setMyService(MyService myService) { ... }

		// Inject the "name" job data property
		public void setName(String name) { ... }

		@Override
		protected void executeInternal(JobExecutionContext context)
				throws JobExecutionException {
			...
		}

	}
----



[[boot-features-task-execution-scheduling]]
== Task Execution and Scheduling
In the absence of an `Executor` bean in the context, Spring Boot auto-configures a `ThreadPoolTaskExecutor` with sensible defaults that can be automatically associated to asynchronous task execution (`@EnableAsync`) and Spring MVC asynchronous request processing.

[TIP]
====
If you have defined a custom `Executor` in the context, regular task execution (i.e. `@EnableAsync`) will use it transparently but the Spring MVC support will not be configured as it requires an `AsyncTaskExecutor` implementation (named `applicationTaskExecutor`).
Depending on your target arrangement, you could change your `Executor` into a `ThreadPoolTaskExecutor` or define both a `ThreadPoolTaskExecutor` and an `AsyncConfigurer` wrapping your custom `Executor`.

The auto-configured `TaskExecutorBuilder` allows you to easily create instances that reproduce what the auto-configuration does by default.
====

The thread pool uses 8 core threads that can grow and shrink according to the load.
Those default settings can be fine-tuned using the `spring.task.execution` namespace as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.task.execution.pool.max-size=16
	spring.task.execution.pool.queue-capacity=100
	spring.task.execution.pool.keep-alive=10s
----

This changes the thread pool to use a bounded queue so that when the queue is full (100 tasks), the thread pool increases to maximum 16 threads.
Shrinking of the pool is more aggressive as threads are reclaimed when they are idle for 10 seconds (rather than 60 seconds by default).

A `ThreadPoolTaskScheduler` can also be auto-configured if need to be associated to scheduled task execution (`@EnableScheduling`).
The thread pool uses one thread by default and those settings can be fine-tuned using the `spring.task.scheduling` namespace.

Both a `TaskExecutorBuilder` bean and a `TaskSchedulerBuilder` bean are made available in the context if a custom executor or scheduler needs to be created.



[[boot-features-integration]]
== Spring Integration
Spring Boot offers several conveniences for working with {spring-integration}[Spring Integration], including the `spring-boot-starter-integration` "`Starter`".
Spring Integration provides abstractions over messaging and also other transports such as HTTP, TCP, and others.
If Spring Integration is available on your classpath, it is initialized through the `@EnableIntegration` annotation.

Spring Boot also configures some features that are triggered by the presence of additional Spring Integration modules.
If `spring-integration-jmx` is also on the classpath, message processing statistics are published over JMX.
If `spring-integration-jdbc` is available, the default database schema can be created on startup, as shown in the following line:

[source,properties,indent=0,configprops]
----
	spring.integration.jdbc.initialize-schema=always
----

See the {spring-boot-autoconfigure-module-code}/integration/IntegrationAutoConfiguration.java[`IntegrationAutoConfiguration`] and {spring-boot-autoconfigure-module-code}/integration/IntegrationProperties.java[`IntegrationProperties`] classes for more details.

By default, if a Micrometer `meterRegistry` bean is present, Spring Integration metrics will be managed by Micrometer.
If you wish to use legacy Spring Integration metrics, add a `DefaultMetricsFactory` bean to the application context.



[[boot-features-session]]
== Spring Session
Spring Boot provides {spring-session}[Spring Session] auto-configuration for a wide range of data stores.
When building a Servlet web application, the following stores can be auto-configured:

* JDBC
* Redis
* Hazelcast
* MongoDB

When building a reactive web application, the following stores can be auto-configured:

* Redis
* MongoDB

If a single Spring Session module is present on the classpath, Spring Boot uses that store implementation automatically.
If you have more than one implementation, you must choose the {spring-boot-autoconfigure-module-code}/session/StoreType.java[`StoreType`] that you wish to use to store the sessions.
For instance, to use JDBC as the back-end store, you can configure your application as follows:

[source,properties,indent=0,configprops]
----
    spring.session.store-type=jdbc
----

TIP: You can disable Spring Session by setting the `store-type` to `none`.

Each store has specific additional settings.
For instance, it is possible to customize the name of the table for the JDBC store, as shown in the following example:

[source,properties,indent=0,configprops]
----
    spring.session.jdbc.table-name=SESSIONS
----

For setting the timeout of the session you can use the configprop:spring.session.timeout[] property.
If that property is not set, the auto-configuration falls back to the value of configprop:server.servlet.session.timeout[].



[[boot-features-jmx]]
== Monitoring and Management over JMX
Java Management Extensions (JMX) provide a standard mechanism to monitor and manage applications.
Spring Boot exposes the most suitable `MBeanServer` as a bean with an ID of `mbeanServer`.
Any of your beans that are annotated with Spring JMX annotations (`@ManagedResource`, `@ManagedAttribute`, or `@ManagedOperation`) are exposed to it.

If your platform provides a standard `MBeanServer`, Spring Boot will use that and default to the VM `MBeanServer` if necessary.
If all that fails, a new `MBeanServer` will be created.

See the {spring-boot-autoconfigure-module-code}/jmx/JmxAutoConfiguration.java[`JmxAutoConfiguration`] class for more details.



[[boot-features-testing]]
== Testing
Spring Boot provides a number of utilities and annotations to help when testing your application.
Test support is provided by two modules: `spring-boot-test` contains core items, and `spring-boot-test-autoconfigure` supports auto-configuration for tests.

Most developers use the `spring-boot-starter-test` "`Starter`", which imports both Spring Boot test modules as well as JUnit Jupiter, AssertJ, Hamcrest, and a number of other useful libraries.

[TIP]
====
The starter also brings the vintage engine so that you can run both JUnit 4 and JUnit 5 tests.
If you have migrated your tests to JUnit 5, you should exclude JUnit 4 support, as shown in the following example:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-test</artifactId>
		<scope>test</scope>
		<exclusions>
			<exclusion>
				<groupId>org.junit.vintage</groupId>
				<artifactId>junit-vintage-engine</artifactId>
			</exclusion>
		</exclusions>
	</dependency>
----
====



[[boot-features-test-scope-dependencies]]
=== Test Scope Dependencies
The `spring-boot-starter-test` "`Starter`" (in the `test` `scope`) contains the following provided libraries:

* https://junit.org/junit5[JUnit 5] (including the vintage engine for backward compatibility with JUnit 4): The de-facto standard for unit testing Java applications.
* {spring-framework-docs}testing.html#integration-testing[Spring Test] & Spring Boot Test: Utilities and integration test support for Spring Boot applications.
* https://joel-costigliola.github.io/assertj/[AssertJ]: A fluent assertion library.
* https://github.com/hamcrest/JavaHamcrest[Hamcrest]: A library of matcher objects (also known as constraints or predicates).
* https://mockito.github.io[Mockito]: A Java mocking framework.
* https://github.com/skyscreamer/JSONassert[JSONassert]: An assertion library for JSON.
* https://github.com/jayway/JsonPath[JsonPath]: XPath for JSON.

We generally find these common libraries to be useful when writing tests.
If these libraries do not suit your needs, you can add additional test dependencies of your own.



[[boot-features-testing-spring-applications]]
=== Testing Spring Applications
One of the major advantages of dependency injection is that it should make your code easier to unit test.
You can instantiate objects by using the `new` operator without even involving Spring.
You can also use _mock objects_ instead of real dependencies.

Often, you need to move beyond unit testing and start integration testing (with a Spring `ApplicationContext`).
It is useful to be able to perform integration testing without requiring deployment of your application or needing to connect to other infrastructure.

The Spring Framework includes a dedicated test module for such integration testing.
You can declare a dependency directly to `org.springframework:spring-test` or use the `spring-boot-starter-test` "`Starter`" to pull it in transitively.

If you have not used the `spring-test` module before, you should start by reading the {spring-framework-docs}testing.html#testing[relevant section] of the Spring Framework reference documentation.



[[boot-features-testing-spring-boot-applications]]
=== Testing Spring Boot Applications
A Spring Boot application is a Spring `ApplicationContext`, so nothing very special has to be done to test it beyond what you would normally do with a vanilla Spring context.

NOTE: External properties, logging, and other features of Spring Boot are installed in the context by default only if you use `SpringApplication` to create it.

Spring Boot provides a `@SpringBootTest` annotation, which can be used as an alternative to the standard `spring-test` `@ContextConfiguration` annotation when you need Spring Boot features.
The annotation works by <<boot-features-testing-spring-boot-applications-detecting-config,creating the `ApplicationContext` used in your tests through `SpringApplication`>>.
In addition to `@SpringBootTest` a number of other annotations are also provided for <<boot-features-testing-spring-boot-applications-testing-autoconfigured-tests,testing more specific slices>> of an application.

TIP: If you are using JUnit 4, don't forget to also add `@RunWith(SpringRunner.class)` to your test, otherwise the annotations will be ignored.
If you are using JUnit 5, there's no need to add the equivalent `@ExtendWith(SpringExtension.class)` as `@SpringBootTest` and the other `@…Test` annotations are already annotated with it.

By default, `@SpringBootTest` will not start a server.
You can use the `webEnvironment` attribute of `@SpringBootTest` to further refine how your tests run:

* `MOCK`(Default) : Loads a web `ApplicationContext` and provides a mock web environment.
  Embedded servers are not started when using this annotation.
	If a web environment is not available on your classpath, this mode transparently falls back to creating a regular non-web `ApplicationContext`.
	It can be used in conjunction with <<boot-features-testing-spring-boot-applications-testing-with-mock-environment, `@AutoConfigureMockMvc` or `@AutoConfigureWebTestClient`>> for mock-based testing of your web application.
* `RANDOM_PORT`: Loads a `WebServerApplicationContext` and provides a real web environment.
  Embedded servers are started and listen on a random port.
* `DEFINED_PORT`: Loads a `WebServerApplicationContext` and provides a real web environment.
  Embedded servers are started and listen on a defined port (from your `application.properties`) or on the default port of `8080`.
* `NONE`: Loads an `ApplicationContext` by using `SpringApplication` but does not provide _any_ web environment (mock or otherwise).

NOTE: If your test is `@Transactional`, it rolls back the transaction at the end of each test method by default.
However, as using this arrangement with either `RANDOM_PORT` or `DEFINED_PORT` implicitly provides a real servlet environment, the HTTP client and server run in separate threads and, thus, in separate transactions.
Any transaction initiated on the server does not roll back in this case.

NOTE: `@SpringBootTest` with `webEnvironment = WebEnvironment.RANDOM_PORT` will also start the management server on a separate random port if your application uses a different port for the management server.



[[boot-features-testing-spring-boot-applications-detecting-web-app-type]]
==== Detecting Web Application Type
If Spring MVC is available, a regular MVC-based application context is configured.
If you have only Spring WebFlux, we'll detect that and configure a WebFlux-based application context instead.

If both are present, Spring MVC takes precedence.
If you want to test a reactive web application in this scenario, you must set the configprop:spring.main.web-application-type[] property:

[source,java,indent=0]
----
	@SpringBootTest(properties = "spring.main.web-application-type=reactive")
	class MyWebFluxTests { ... }
----



[[boot-features-testing-spring-boot-applications-detecting-config]]
==== Detecting Test Configuration
If you are familiar with the Spring Test Framework, you may be used to using `@ContextConfiguration(classes=...)` in order to specify which Spring `@Configuration` to load.
Alternatively, you might have often used nested `@Configuration` classes within your test.

When testing Spring Boot applications, this is often not required.
Spring Boot's `@*Test` annotations search for your primary configuration automatically whenever you do not explicitly define one.

The search algorithm works up from the package that contains the test until it finds a class annotated with `@SpringBootApplication` or `@SpringBootConfiguration`.
As long as you <<using-spring-boot.adoc#using-boot-structuring-your-code, structured your code>> in a sensible way, your main configuration is usually found.

[NOTE]
====
If you use a <<boot-features-testing-spring-boot-applications-testing-autoconfigured-tests, test annotation to test a more specific slice of your application>>, you should avoid adding configuration settings that are specific to a particular area on the <<boot-features-testing-spring-boot-applications-testing-user-configuration, main method's application class>>.

The underlying component scan configuration of `@SpringBootApplication` defines exclude filters that are used to make sure slicing works as expected.
If you are using an explicit `@ComponentScan` directive on your `@SpringBootApplication`-annotated class, be aware that those filters will be disabled.
If you are using slicing, you should define them again.
====

If you want to customize the primary configuration, you can use a nested `@TestConfiguration` class.
Unlike a nested `@Configuration` class, which would be used instead of your application's primary configuration, a nested `@TestConfiguration` class is used in addition to your application's primary configuration.

NOTE: Spring's test framework caches application contexts between tests.
Therefore, as long as your tests share the same configuration (no matter how it is discovered), the potentially time-consuming process of loading the context happens only once.



[[boot-features-testing-spring-boot-applications-excluding-config]]
==== Excluding Test Configuration
If your application uses component scanning (for example, if you use `@SpringBootApplication` or `@ComponentScan`), you may find top-level configuration classes that you created only for specific tests accidentally get picked up everywhere.

As we <<boot-features-testing-spring-boot-applications-detecting-config,have seen earlier>>, `@TestConfiguration` can be used on an inner class of a test to customize the primary configuration.
When placed on a top-level class, `@TestConfiguration` indicates that classes in `src/test/java` should not be picked up by scanning.
You can then import that class explicitly where it is required, as shown in the following example:

[source,java,indent=0]
----
	@SpringBootTest
	@Import(MyTestsConfiguration.class)
	class MyTests {

		@Test
		void exampleTest() {
			...
		}

	}
----

NOTE: If you directly use `@ComponentScan` (that is, not through `@SpringBootApplication`) you need to register the `TypeExcludeFilter` with it.
See {spring-boot-module-api}/context/TypeExcludeFilter.html[the Javadoc] for details.




[[boot-features-testing-spring-boot-application-arguments]]
==== Using Application Arguments
If your application expects <<boot-features-application-arguments,arguments>>, you can
have `@SpringBootTest` inject them using the `args` attribute.

[source,java,indent=0]
----
include::{code-examples}/test/context/ApplicationArgumentsExampleTests.java[tag=example]
----



[[boot-features-testing-spring-boot-applications-testing-with-mock-environment]]
==== Testing with a mock environment
By default, `@SpringBootTest` does not start the server.
If you have web endpoints that you want to test against this mock environment, you can additionally configure {spring-framework-docs}/testing.html#spring-mvc-test-framework[`MockMvc`] as shown in the following example:

[source,java,indent=0]
----
include::{code-examples}/test/web/MockMvcExampleTests.java[tag=test-mock-mvc]
----

TIP: If you want to focus only on the web layer and not start a complete `ApplicationContext`, consider <<boot-features-testing-spring-boot-applications-testing-autoconfigured-mvc-tests,using `@WebMvcTest` instead>>.

Alternatively, you can configure a {spring-framework-docs}testing.html#webtestclient-tests[`WebTestClient`] as shown in the following example:

[source,java,indent=0]
----
include::{code-examples}/test/web/MockWebTestClientExampleTests.java[tag=test-mock-web-test-client]
----

[TIP]
====
Testing within a mocked environment is usually faster than running with a full Servlet container.
However, since mocking occurs at the Spring MVC layer, code that relies on lower-level Servlet container behavior cannot be directly tested with MockMvc.

For example, Spring Boot's error handling is based on the "`error page`" support provided by the Servlet container.
This means that, whilst you can test your MVC layer throws and handles exceptions as expected, you cannot directly test that a specific <<boot-features-error-handling-custom-error-pages, custom error page>> is rendered.
If you need to test these lower-level concerns, you can start a fully running server as described in the next section.
====



[[boot-features-testing-spring-boot-applications-testing-with-running-server]]
==== Testing with a running server
If you need to start a full running server, we recommend that you use random ports.
If you use `@SpringBootTest(webEnvironment=WebEnvironment.RANDOM_PORT)`, an available port is picked at random each time your test runs.

The `@LocalServerPort` annotation can be used to <<howto.adoc#howto-discover-the-http-port-at-runtime,inject the actual port used>> into your test.
For convenience, tests that need to make REST calls to the started server can additionally `@Autowire` a {spring-framework-docs}testing.html#webtestclient-tests[`WebTestClient`], which resolves relative links to the running server and comes with a dedicated API for verifying responses, as shown in the following example:

[source,java,indent=0]
----
include::{code-examples}/test/web/RandomPortWebTestClientExampleTests.java[tag=test-random-port]
----

This setup requires `spring-webflux` on the classpath.
If you can't or won't add webflux, Spring Boot also provides a `TestRestTemplate` facility:

[source,java,indent=0]
----
include::{code-examples}/test/web/RandomPortTestRestTemplateExampleTests.java[tag=test-random-port]
----



[[boot-features-testing-spring-boot-applications-customizing-web-test-client]]
==== Customizing WebTestClient
To customize the `WebTestClient` bean, configure a `WebTestClientBuilderCustomizer` bean.
Any such beans are called with the `WebTestClient.Builder` that is used to create the `WebTestClient`.



[[boot-features-testing-spring-boot-applications-jmx]]
==== Using JMX
As the test context framework caches context, JMX is disabled by default to prevent identical components to register on the same domain.
If such test needs access to an `MBeanServer`, consider marking it dirty as well:

[source,java,indent=0]
----
include::{test-examples}/jmx/SampleJmxTests.java[tag=test]
----



[[boot-features-testing-spring-boot-applications-mocking-beans]]
==== Mocking and Spying Beans
When running tests, it is sometimes necessary to mock certain components within your application context.
For example, you may have a facade over some remote service that is unavailable during development.
Mocking can also be useful when you want to simulate failures that might be hard to trigger in a real environment.

Spring Boot includes a `@MockBean` annotation that can be used to define a Mockito mock for a bean inside your `ApplicationContext`.
You can use the annotation to add new beans or replace a single existing bean definition.
The annotation can be used directly on test classes, on fields within your test, or on `@Configuration` classes and fields.
When used on a field, the instance of the created mock is also injected.
Mock beans are automatically reset after each test method.

[NOTE]
====
If your test uses one of Spring Boot's test annotations (such as `@SpringBootTest`), this feature is automatically enabled.
To use this feature with a different arrangement, a listener must be explicitly added, as shown in the following example:

[source,java,indent=0]
----
	@TestExecutionListeners(MockitoTestExecutionListener.class)
----

====

The following example replaces an existing `RemoteService` bean with a mock implementation:

[source,java,indent=0]
----
	import org.junit.jupiter.api.Test;
	import org.springframework.beans.factory.annotation.*;
	import org.springframework.boot.test.context.*;
	import org.springframework.boot.test.mock.mockito.*;

	import static org.assertj.core.api.Assertions.*;
	import static org.mockito.BDDMockito.*;

	@SpringBootTest
	class MyTests {

		@MockBean
		private RemoteService remoteService;

		@Autowired
		private Reverser reverser;

		@Test
		void exampleTest() {
			// RemoteService has been injected into the reverser bean
			given(this.remoteService.someCall()).willReturn("mock");
			String reverse = reverser.reverseSomeCall();
			assertThat(reverse).isEqualTo("kcom");
		}

	}
----

NOTE: `@MockBean` cannot be used to mock the behavior of a bean that's exercised during application context refresh.
By the time the test is executed, the application context refresh has completed and it is too late to configure the mocked behavior.
We recommend using a `@Bean` method to create and configure the mock in this situation.

Additionally, you can use `@SpyBean` to wrap any existing bean with a Mockito `spy`.
See the {spring-boot-test-module-api}/mock/mockito/SpyBean.html[Javadoc] for full details.

NOTE: CGLib proxies, such as those created for scoped beans, declare the proxied methods as `final`.
This stops Mockito from functioning correctly as it cannot mock or spy on `final` methods in its default configuration.
If you want to mock or spy on such a bean, configure Mockito to use its inline mock maker by adding `org.mockito:mockito-inline` to your application's test dependencies.
This allows Mockito to mock and spy on `final` methods.

NOTE: While Spring's test framework caches application contexts between tests and reuses a context for tests sharing the same configuration, the use of `@MockBean` or `@SpyBean` influences the cache key, which will most likely increase the number of contexts.

TIP: If you are using `@SpyBean` to spy on a bean with `@Cacheable` methods that refer to parameters by name, your application must be compiled with `-parameters`.
This ensures that the parameter names are available to the caching infrastructure once the bean has been spied upon.



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-tests]]
==== Auto-configured Tests
Spring Boot's auto-configuration system works well for applications but can sometimes be a little too much for tests.
It often helps to load only the parts of the configuration that are required to test a "`slice`" of your application.
For example, you might want to test that Spring MVC controllers are mapping URLs correctly, and you do not want to involve database calls in those tests, or you might want to test JPA entities, and you are not interested in the web layer when those tests run.

The `spring-boot-test-autoconfigure` module includes a number of annotations that can be used to automatically configure such "`slices`".
Each of them works in a similar way, providing a `@...Test` annotation that loads the `ApplicationContext` and one or more `@AutoConfigure...` annotations that can be used to customize auto-configuration settings.

NOTE: Each slice restricts component scan to appropriate components and loads a very restricted set of auto-configuration classes.
If you need to exclude one of them, most `@...Test` annotations provide an `excludeAutoConfiguration` attribute.
Alternatively, you can use `@ImportAutoConfiguration#exclude`.

NOTE: Including multiple "`slices`" by using several `@...Test` annotations in one test is not supported.
If you need multiple "`slices`", pick one of the `@...Test` annotations and include the `@AutoConfigure...` annotations of the other "`slices`" by hand.

TIP: It is also possible to use the `@AutoConfigure...` annotations with the standard `@SpringBootTest` annotation.
You can use this combination if you are not interested in "`slicing`" your application but you want some of the auto-configured test beans.



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-json-tests]]
==== Auto-configured JSON Tests
To test that object JSON serialization and deserialization is working as expected, you can use the `@JsonTest` annotation.
`@JsonTest` auto-configures the available supported JSON mapper, which can be one of the following libraries:

* Jackson `ObjectMapper`, any `@JsonComponent` beans and any Jackson ``Module``s
* `Gson`
* `Jsonb`

TIP: A list of the auto-configurations that are enabled by `@JsonTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

If you need to configure elements of the auto-configuration, you can use the `@AutoConfigureJsonTesters` annotation.

Spring Boot includes AssertJ-based helpers that work with the JSONAssert and JsonPath libraries to check that JSON appears as expected.
The `JacksonTester`, `GsonTester`, `JsonbTester`, and `BasicJsonTester` classes can be used for Jackson, Gson, Jsonb, and Strings respectively.
Any helper fields on the test class can be `@Autowired` when using `@JsonTest`.
The following example shows a test class for Jackson:

[source,java,indent=0]
----
	import org.junit.jupiter.api.Test;
	import org.springframework.beans.factory.annotation.*;
	import org.springframework.boot.test.autoconfigure.json.*;
	import org.springframework.boot.test.context.*;
	import org.springframework.boot.test.json.*;

	import static org.assertj.core.api.Assertions.*;

	@JsonTest
	class MyJsonTests {

		@Autowired
		private JacksonTester<VehicleDetails> json;

		@Test
		void testSerialize() throws Exception {
			VehicleDetails details = new VehicleDetails("Honda", "Civic");
			// Assert against a `.json` file in the same package as the test
			assertThat(this.json.write(details)).isEqualToJson("expected.json");
			// Or use JSON path based assertions
			assertThat(this.json.write(details)).hasJsonPathStringValue("@.make");
			assertThat(this.json.write(details)).extractingJsonPathStringValue("@.make")
					.isEqualTo("Honda");
		}

		@Test
		void testDeserialize() throws Exception {
			String content = "{\"make\":\"Ford\",\"model\":\"Focus\"}";
			assertThat(this.json.parse(content))
					.isEqualTo(new VehicleDetails("Ford", "Focus"));
			assertThat(this.json.parseObject(content).getMake()).isEqualTo("Ford");
		}

	}
----

NOTE: JSON helper classes can also be used directly in standard unit tests.
To do so, call the `initFields` method of the helper in your `@Before` method if you do not use `@JsonTest`.

If you're using Spring Boot's AssertJ-based helpers to assert on a number value at a given JSON path, you might not be able to use `isEqualTo` depending on the type.
Instead, you can use AssertJ's `satisfies` to assert that the value matches the given condition.
For instance, the following example asserts that the actual number is a float value close to `0.15` within an offset of `0.01`.

[source,java,indent=0]
----
assertThat(json.write(message))
    .extractingJsonPathNumberValue("@.test.numberValue")
    .satisfies((number) -> assertThat(number.floatValue()).isCloseTo(0.15f, within(0.01f)));
----



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-mvc-tests]]
==== Auto-configured Spring MVC Tests
To test whether Spring MVC controllers are working as expected, use the `@WebMvcTest` annotation.
`@WebMvcTest` auto-configures the Spring MVC infrastructure and limits scanned beans to `@Controller`, `@ControllerAdvice`, `@JsonComponent`, `Converter`, `GenericConverter`, `Filter`, `HandlerInterceptor`, `WebMvcConfigurer`, and `HandlerMethodArgumentResolver`.
Regular `@Component` beans are not scanned when using this annotation.

TIP: A list of the auto-configuration settings that are enabled by `@WebMvcTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

TIP: If you need to register extra components, such as the Jackson `Module`, you can import additional configuration classes by using `@Import` on your test.

Often, `@WebMvcTest` is limited to a single controller and is used in combination with `@MockBean` to provide mock implementations for required collaborators.

`@WebMvcTest` also auto-configures `MockMvc`.
Mock MVC offers a powerful way to quickly test MVC controllers without needing to start a full HTTP server.

TIP: You can also auto-configure `MockMvc` in a non-`@WebMvcTest` (such as `@SpringBootTest`) by annotating it with `@AutoConfigureMockMvc`.
The following example uses `MockMvc`:

[source,java,indent=0]
----
	import org.junit.jupiter.api.*;
	import org.springframework.beans.factory.annotation.*;
	import org.springframework.boot.test.autoconfigure.web.servlet.*;
	import org.springframework.boot.test.mock.mockito.*;

	import static org.assertj.core.api.Assertions.*;
	import static org.mockito.BDDMockito.*;
	import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
	import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

	@WebMvcTest(UserVehicleController.class)
	class MyControllerTests {

		@Autowired
		private MockMvc mvc;

		@MockBean
		private UserVehicleService userVehicleService;

		@Test
		void testExample() throws Exception {
			given(this.userVehicleService.getVehicleDetails("sboot"))
					.willReturn(new VehicleDetails("Honda", "Civic"));
			this.mvc.perform(get("/sboot/vehicle").accept(MediaType.TEXT_PLAIN))
					.andExpect(status().isOk()).andExpect(content().string("Honda Civic"));
		}

	}
----

TIP: If you need to configure elements of the auto-configuration (for example, when servlet filters should be applied) you can use attributes in the `@AutoConfigureMockMvc` annotation.

If you use HtmlUnit or Selenium, auto-configuration also provides an HtmlUnit `WebClient` bean and/or a Selenium `WebDriver` bean.
The following example uses HtmlUnit:

[source,java,indent=0]
----
	import com.gargoylesoftware.htmlunit.*;
	import org.junit.jupiter.api.*;
	import org.springframework.beans.factory.annotation.*;
	import org.springframework.boot.test.autoconfigure.web.servlet.*;
	import org.springframework.boot.test.mock.mockito.*;

	import static org.assertj.core.api.Assertions.*;
	import static org.mockito.BDDMockito.*;

	@WebMvcTest(UserVehicleController.class)
	class MyHtmlUnitTests {

		@Autowired
		private WebClient webClient;

		@MockBean
		private UserVehicleService userVehicleService;

		@Test
		void testExample() throws Exception {
			given(this.userVehicleService.getVehicleDetails("sboot"))
					.willReturn(new VehicleDetails("Honda", "Civic"));
			HtmlPage page = this.webClient.getPage("/sboot/vehicle.html");
			assertThat(page.getBody().getTextContent()).isEqualTo("Honda Civic");
		}

	}
----

NOTE: By default, Spring Boot puts `WebDriver` beans in a special "`scope`" to ensure that the driver exits after each test and that a new instance is injected.
If you do not want this behavior, you can add `@Scope("singleton")` to your `WebDriver` `@Bean` definition.

WARNING: The `webDriver` scope created by Spring Boot will replace any user defined scope of the same name.
If you define your own `webDriver` scope you may find it stops working when you use `@WebMvcTest`.

If you have Spring Security on the classpath, `@WebMvcTest` will also scan `WebSecurityConfigurer` beans.
Instead of disabling security completely for such tests, you can use Spring Security's test support.
More details on how to use Spring Security's `MockMvc` support can be found in this _<<howto.adoc#howto-use-test-with-spring-security>>_ how-to section.

TIP: Sometimes writing Spring MVC tests is not enough; Spring Boot can help you run <<boot-features-testing-spring-boot-applications-testing-with-running-server, full end-to-end tests with an actual server>>.



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-webflux-tests]]
==== Auto-configured Spring WebFlux Tests
To test that {spring-framework-docs}/web-reactive.html[Spring WebFlux] controllers are working as expected, you can use the `@WebFluxTest` annotation.
`@WebFluxTest` auto-configures the Spring WebFlux infrastructure and limits scanned beans to `@Controller`, `@ControllerAdvice`, `@JsonComponent`, `Converter`, `GenericConverter`, `WebFilter`, and `WebFluxConfigurer`.
Regular `@Component` beans are not scanned when the `@WebFluxTest` annotation is used.

TIP: A list of the auto-configurations that are enabled by `@WebFluxTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

TIP: If you need to register extra components, such as Jackson `Module`, you can import additional configuration classes using `@Import` on your test.

Often, `@WebFluxTest` is limited to a single controller and used in combination with the `@MockBean` annotation to provide mock implementations for required collaborators.

`@WebFluxTest` also auto-configures {spring-framework-docs}testing.html#webtestclient[`WebTestClient`], which offers a powerful way to quickly test WebFlux controllers without needing to start a full HTTP server.

TIP: You can also auto-configure `WebTestClient` in a non-`@WebFluxTest` (such as `@SpringBootTest`) by annotating it with `@AutoConfigureWebTestClient`.
The following example shows a class that uses both `@WebFluxTest` and a `WebTestClient`:

[source,java,indent=0]
----
	import org.junit.jupiter.api.Test;

	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest;
	import org.springframework.http.MediaType;
	import org.springframework.test.web.reactive.server.WebTestClient;

	@WebFluxTest(UserVehicleController.class)
	class MyControllerTests {

		@Autowired
		private WebTestClient webClient;

		@MockBean
		private UserVehicleService userVehicleService;

		@Test
		void testExample() throws Exception {
			given(this.userVehicleService.getVehicleDetails("sboot"))
					.willReturn(new VehicleDetails("Honda", "Civic"));
			this.webClient.get().uri("/sboot/vehicle").accept(MediaType.TEXT_PLAIN)
					.exchange()
					.expectStatus().isOk()
					.expectBody(String.class).isEqualTo("Honda Civic");
		}

	}
----

TIP: This setup is only supported by WebFlux applications as using `WebTestClient` in a mocked web application only works with WebFlux at the moment.

NOTE: `@WebFluxTest` cannot detect routes registered via the functional web framework.
For testing `RouterFunction` beans in the context, consider importing your `RouterFunction` yourself via `@Import` or using `@SpringBootTest`.

NOTE: `@WebFluxTest` cannot detect custom security configuration registered via a `@Bean` of type `SecurityWebFilterChain`.
To include that in your test, you will need to import the configuration that registers the bean via `@Import` or use `@SpringBootTest`.

TIP: Sometimes writing Spring WebFlux tests is not enough; Spring Boot can help you run <<boot-features-testing-spring-boot-applications-testing-with-running-server, full end-to-end tests with an actual server>>.



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-jpa-test]]
==== Auto-configured Data JPA Tests
You can use the `@DataJpaTest` annotation to test JPA applications.
By default, it scans for `@Entity` classes and configures Spring Data JPA repositories.
If an embedded database is available on the classpath, it configures one as well.
Regular `@Component` beans are not loaded into the `ApplicationContext`.

TIP: A list of the auto-configuration settings that are enabled by `@DataJpaTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

By default, data JPA tests are transactional and roll back at the end of each test.
See the {spring-framework-docs}testing.html#testcontext-tx-enabling-transactions[relevant section] in the Spring Framework Reference Documentation for more details.
If that is not what you want, you can disable transaction management for a test or for the whole class as follows:

[source,java,indent=0]
----
	import org.junit.jupiter.api.Test;
	import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
	import org.springframework.transaction.annotation.Propagation;
	import org.springframework.transaction.annotation.Transactional;

	@DataJpaTest
	@Transactional(propagation = Propagation.NOT_SUPPORTED)
	class ExampleNonTransactionalTests {

	}
----

Data JPA tests may also inject a {spring-boot-test-autoconfigure-module-code}/orm/jpa/TestEntityManager.java[`TestEntityManager`] bean, which provides an alternative to the standard JPA `EntityManager` that is specifically designed for tests.
If you want to use `TestEntityManager` outside of `@DataJpaTest` instances, you can also use the `@AutoConfigureTestEntityManager` annotation.
A `JdbcTemplate` is also available if you need that.
The following example shows the `@DataJpaTest` annotation in use:

[source,java,indent=0]
----
	import org.junit.jupiter.api.Test;
	import org.springframework.boot.test.autoconfigure.orm.jpa.*;

	import static org.assertj.core.api.Assertions.*;

	@DataJpaTest
	class ExampleRepositoryTests {

		@Autowired
		private TestEntityManager entityManager;

		@Autowired
		private UserRepository repository;

		@Test
		void testExample() throws Exception {
			this.entityManager.persist(new User("sboot", "1234"));
			User user = this.repository.findByUsername("sboot");
			assertThat(user.getUsername()).isEqualTo("sboot");
			assertThat(user.getVin()).isEqualTo("1234");
		}

	}
----

In-memory embedded databases generally work well for tests, since they are fast and do not require any installation.
If, however, you prefer to run tests against a real database you can use the `@AutoConfigureTestDatabase` annotation, as shown in the following example:

[source,java,indent=0]
----
	@DataJpaTest
	@AutoConfigureTestDatabase(replace=Replace.NONE)
	class ExampleRepositoryTests {

		// ...

	}
----



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-jdbc-test]]
==== Auto-configured JDBC Tests
`@JdbcTest` is similar to `@DataJpaTest` but is for tests that only require a `DataSource` and do not use Spring Data JDBC.
By default, it configures an in-memory embedded database and a `JdbcTemplate`.
Regular `@Component` beans are not loaded into the `ApplicationContext`.

TIP: A list of the auto-configurations that are enabled by `@JdbcTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

By default, JDBC tests are transactional and roll back at the end of each test.
See the {spring-framework-docs}testing.html#testcontext-tx-enabling-transactions[relevant section] in the Spring Framework Reference Documentation for more details.
If that is not what you want, you can disable transaction management for a test or for the whole class, as follows:

[source,java,indent=0]
----
	import org.junit.jupiter.api.Test;
	import org.springframework.boot.test.autoconfigure.jdbc.JdbcTest;
	import org.springframework.transaction.annotation.Propagation;
	import org.springframework.transaction.annotation.Transactional;

	@JdbcTest
	@Transactional(propagation = Propagation.NOT_SUPPORTED)
	class ExampleNonTransactionalTests {

	}
----

If you prefer your test to run against a real database, you can use the `@AutoConfigureTestDatabase` annotation in the same way as for `DataJpaTest`.
(See "<<boot-features-testing-spring-boot-applications-testing-autoconfigured-jpa-test>>".)



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-data-jdbc-test]]
==== Auto-configured Data JDBC Tests
`@DataJdbcTest` is similar to `@JdbcTest` but is for tests that use Spring Data JDBC repositories.
By default, it configures an in-memory embedded database, a `JdbcTemplate`, and Spring Data JDBC repositories.
Regular `@Component` beans are not loaded into the `ApplicationContext`.

TIP: A list of the auto-configurations that are enabled by `@DataJdbcTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

By default, Data JDBC tests are transactional and roll back at the end of each test.
See the {spring-framework-docs}testing.html#testcontext-tx-enabling-transactions[relevant section] in the Spring Framework Reference Documentation for more details.
If that is not what you want, you can disable transaction management for a test or for the whole test class as <<boot-features-testing-spring-boot-applications-testing-autoconfigured-jdbc-test,shown in the JDBC example>>.

If you prefer your test to run against a real database, you can use the `@AutoConfigureTestDatabase` annotation in the same way as for `DataJpaTest`.
(See "<<boot-features-testing-spring-boot-applications-testing-autoconfigured-jpa-test>>".)



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-jooq-test]]
==== Auto-configured jOOQ Tests
You can use `@JooqTest` in a similar fashion as `@JdbcTest` but for jOOQ-related tests.
As jOOQ relies heavily on a Java-based schema that corresponds with the database schema, the existing `DataSource` is used.
If you want to replace it with an in-memory database, you can use `@AutoConfigureTestDatabase` to override those settings.
(For more about using jOOQ with Spring Boot, see "<<boot-features-jooq>>", earlier in this chapter.)
Regular `@Component` beans are not loaded into the `ApplicationContext`.

TIP: A list of the auto-configurations that are enabled by `@JooqTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

`@JooqTest` configures a `DSLContext`.
Regular `@Component` beans are not loaded into the `ApplicationContext`.
The following example shows the `@JooqTest` annotation in use:

[source,java,indent=0]
----
	import org.jooq.DSLContext;
	import org.junit.jupiter.api.Test;
	import org.springframework.boot.test.autoconfigure.jooq.JooqTest;

	@JooqTest
	class ExampleJooqTests {

		@Autowired
		private DSLContext dslContext;
	}
----

JOOQ tests are transactional and roll back at the end of each test by default.
If that is not what you want, you can disable transaction management for a test or for the whole test class as <<boot-features-testing-spring-boot-applications-testing-autoconfigured-jdbc-test,shown in the JDBC example>>.



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-mongo-test]]
==== Auto-configured Data MongoDB Tests
You can use `@DataMongoTest` to test MongoDB applications.
By default, it configures an in-memory embedded MongoDB (if available), configures a `MongoTemplate`, scans for `@Document` classes, and configures Spring Data MongoDB repositories.
Regular `@Component` beans are not loaded into the `ApplicationContext`.
(For more about using MongoDB with Spring Boot, see "<<boot-features-mongodb>>", earlier in this chapter.)

TIP: A list of the auto-configuration settings that are enabled by `@DataMongoTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

The following class shows the `@DataMongoTest` annotation in use:

[source,java,indent=0]
----
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest;
	import org.springframework.data.mongodb.core.MongoTemplate;

	@DataMongoTest
	class ExampleDataMongoTests {

		@Autowired
		private MongoTemplate mongoTemplate;

		//
	}
----

In-memory embedded MongoDB generally works well for tests, since it is fast and does not require any developer installation.
If, however, you prefer to run tests against a real MongoDB server, you should exclude the embedded MongoDB auto-configuration, as shown in the following example:

[source,java,indent=0]
----
	import org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration;
	import org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest;

	@DataMongoTest(excludeAutoConfiguration = EmbeddedMongoAutoConfiguration.class)
	class ExampleDataMongoNonEmbeddedTests {

	}
----



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-neo4j-test]]
==== Auto-configured Data Neo4j Tests
You can use `@DataNeo4jTest` to test Neo4j applications.
By default, it uses an in-memory embedded Neo4j (if the embedded driver is available), scans for `@NodeEntity` classes, and configures Spring Data Neo4j repositories.
Regular `@Component` beans are not loaded into the `ApplicationContext`.
(For more about using Neo4J with Spring Boot, see "<<boot-features-neo4j>>", earlier in this chapter.)

TIP: A list of the auto-configuration settings that are enabled by `@DataNeo4jTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

The following example shows a typical setup for using Neo4J tests in Spring Boot:

[source,java,indent=0]
----
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest;

	@DataNeo4jTest
	class ExampleDataNeo4jTests {

		@Autowired
		private YourRepository repository;

		//
	}
----

By default, Data Neo4j tests are transactional and roll back at the end of each test.
See the {spring-framework-docs}testing.html#testcontext-tx-enabling-transactions[relevant section] in the Spring Framework Reference Documentation for more details.
If that is not what you want, you can disable transaction management for a test or for the whole class, as follows:

[source,java,indent=0]
----
	import org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest;
	import org.springframework.transaction.annotation.Propagation;
	import org.springframework.transaction.annotation.Transactional;

	@DataNeo4jTest
	@Transactional(propagation = Propagation.NOT_SUPPORTED)
	class ExampleNonTransactionalTests {

	}
----



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-redis-test]]
==== Auto-configured Data Redis Tests
You can use `@DataRedisTest` to test Redis applications.
By default, it scans for `@RedisHash` classes and configures Spring Data Redis repositories.
Regular `@Component` beans are not loaded into the `ApplicationContext`.
(For more about using Redis with Spring Boot, see "<<boot-features-redis>>", earlier in this chapter.)

TIP: A list of the auto-configuration settings that are enabled by `@DataRedisTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

The following example shows the `@DataRedisTest` annotation in use:

[source,java,indent=0]
----
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.boot.test.autoconfigure.data.redis.DataRedisTest;

	@DataRedisTest
	class ExampleDataRedisTests {

		@Autowired
		private YourRepository repository;

		//
	}
----



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-ldap-test]]
==== Auto-configured Data LDAP Tests
You can use `@DataLdapTest` to test LDAP applications.
By default, it configures an in-memory embedded LDAP (if available), configures an `LdapTemplate`, scans for `@Entry` classes, and configures Spring Data LDAP repositories.
Regular `@Component` beans are not loaded into the `ApplicationContext`.
(For more about using LDAP with Spring Boot, see "<<boot-features-ldap>>", earlier in this chapter.)

TIP: A list of the auto-configuration settings that are enabled by `@DataLdapTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

The following example shows the `@DataLdapTest` annotation in use:

[source,java,indent=0]
----
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest;
	import org.springframework.ldap.core.LdapTemplate;

	@DataLdapTest
	class ExampleDataLdapTests {

		@Autowired
		private LdapTemplate ldapTemplate;

		//
	}
----

In-memory embedded LDAP generally works well for tests, since it is fast and does not require any developer installation.
If, however, you prefer to run tests against a real LDAP server, you should exclude the embedded LDAP auto-configuration, as shown in the following example:

[source,java,indent=0]
----
	import org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration;
	import org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest;

	@DataLdapTest(excludeAutoConfiguration = EmbeddedLdapAutoConfiguration.class)
	class ExampleDataLdapNonEmbeddedTests {

	}
----



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-rest-client]]
==== Auto-configured REST Clients
You can use the `@RestClientTest` annotation to test REST clients.
By default, it auto-configures Jackson, GSON, and Jsonb support, configures a `RestTemplateBuilder`, and adds support for `MockRestServiceServer`.
Regular `@Component` beans are not loaded into the `ApplicationContext`.

TIP: A list of the auto-configuration settings that are enabled by `@RestClientTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

The specific beans that you want to test should be specified by using the `value` or `components` attribute of `@RestClientTest`, as shown in the following example:

[source,java,indent=0]
----
	@RestClientTest(RemoteVehicleDetailsService.class)
	class ExampleRestClientTest {

		@Autowired
		private RemoteVehicleDetailsService service;

		@Autowired
		private MockRestServiceServer server;

		@Test
		void getVehicleDetailsWhenResultIsSuccessShouldReturnDetails()
				throws Exception {
			this.server.expect(requestTo("/greet/details"))
					.andRespond(withSuccess("hello", MediaType.TEXT_PLAIN));
			String greeting = this.service.callRestService();
			assertThat(greeting).isEqualTo("hello");
		}

	}
----



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-rest-docs]]
==== Auto-configured Spring REST Docs Tests
You can use the `@AutoConfigureRestDocs` annotation to use {spring-restdocs}[Spring REST Docs] in your tests with Mock MVC, REST Assured, or WebTestClient.
It removes the need for the JUnit extension in Spring REST Docs.

`@AutoConfigureRestDocs` can be used to override the default output directory (`target/generated-snippets` if you are using Maven or `build/generated-snippets` if you are using Gradle).
It can also be used to configure the host, scheme, and port that appears in any documented URIs.



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-rest-docs-mock-mvc]]
===== Auto-configured Spring REST Docs Tests with Mock MVC
`@AutoConfigureRestDocs` customizes the `MockMvc` bean to use Spring REST Docs.
You can inject it by using `@Autowired` and use it in your tests as you normally would when using Mock MVC and Spring REST Docs, as shown in the following example:

[source,java,indent=0]
----
	import org.junit.jupiter.api.Test;

	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
	import org.springframework.http.MediaType;
	import org.springframework.test.web.servlet.MockMvc;

	import static org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.document;
	import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
	import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

	@WebMvcTest(UserController.class)
	@AutoConfigureRestDocs
	class UserDocumentationTests {

		@Autowired
		private MockMvc mvc;

		@Test
		void listUsers() throws Exception {
			this.mvc.perform(get("/users").accept(MediaType.TEXT_PLAIN))
					.andExpect(status().isOk())
					.andDo(document("list-users"));
		}

	}
----

If you require more control over Spring REST Docs configuration than offered by the attributes of `@AutoConfigureRestDocs`, you can use a `RestDocsMockMvcConfigurationCustomizer` bean, as shown in the following example:

[source,java,indent=0]
----
	@TestConfiguration
	static class CustomizationConfiguration
			implements RestDocsMockMvcConfigurationCustomizer {

		@Override
		public void customize(MockMvcRestDocumentationConfigurer configurer) {
			configurer.snippets().withTemplateFormat(TemplateFormats.markdown());
		}

	}
----

If you want to make use of Spring REST Docs support for a parameterized output directory, you can create a `RestDocumentationResultHandler` bean.
The auto-configuration calls `alwaysDo` with this result handler, thereby causing each `MockMvc` call to automatically generate the default snippets.
The following example shows a `RestDocumentationResultHandler` being defined:

[source,java,indent=0]
----
	@TestConfiguration(proxyBeanMethods = false)
	static class ResultHandlerConfiguration {

		@Bean
		public RestDocumentationResultHandler restDocumentation() {
			return MockMvcRestDocumentation.document("{method-name}");
		}

	}
----



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-rest-docs-web-test-client]]
===== Auto-configured Spring REST Docs Tests with WebTestClient
`@AutoConfigureRestDocs` can also be used with `WebTestClient`.
You can inject it by using `@Autowired` and use it in your tests as you normally would when using `@WebFluxTest` and Spring REST Docs, as shown in the following example:

[source,java,indent=0]
----
include::{code-examples}/test/autoconfigure/restdocs/webclient/UsersDocumentationTests.java[tag=source]
----

If you require more control over Spring REST Docs configuration than offered by the attributes of `@AutoConfigureRestDocs`, you can use a `RestDocsWebTestClientConfigurationCustomizer` bean, as shown in the following example:

[source,java,indent=0]
----
include::{code-examples}/test/autoconfigure/restdocs/webclient/AdvancedConfigurationExample.java[tag=configuration]
----



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-rest-docs-rest-assured]]
===== Auto-configured Spring REST Docs Tests with REST Assured
`@AutoConfigureRestDocs` makes a `RequestSpecification` bean, preconfigured to use Spring REST Docs, available to your tests.
You can inject it by using `@Autowired` and use it in your tests as you normally would when using REST Assured and Spring REST Docs, as shown in the following example:

[source,java,indent=0]
----
include::{code-examples}/test/autoconfigure/restdocs/restassured/UserDocumentationTests.java[tag=source]
----

If you require more control over Spring REST Docs configuration than offered by the attributes of `@AutoConfigureRestDocs`, a `RestDocsRestAssuredConfigurationCustomizer` bean can be used, as shown in the following example:

[source,java,indent=0]
----
include::{code-examples}/test/autoconfigure/restdocs/restassured/AdvancedConfigurationExample.java[tag=configuration]
----



[[boot-features-testing-spring-boot-applications-testing-auto-configured-additional-auto-config]]
==== Additional Auto-configuration and Slicing
Each slice provides one or more `@AutoConfigure...` annotations that namely defines the auto-configurations that should be included as part of a slice.
Additional auto-configurations can be added by creating a custom `@AutoConfigure...` annotation or simply by adding `@ImportAutoConfiguration` to the test as shown in the following example:

[source,java,indent=0]
----
	@JdbcTest
	@ImportAutoConfiguration(IntegrationAutoConfiguration.class)
	class ExampleJdbcTests {

	}
----

NOTE: Make sure to not use the regular `@Import` annotation to import auto-configurations as they are handled in a specific way by Spring Boot.



[[boot-features-testing-spring-boot-applications-testing-user-configuration]]
==== User Configuration and Slicing
If you <<using-boot-structuring-your-code, structure your code>> in a sensible way, your `@SpringBootApplication` class is <<boot-features-testing-spring-boot-applications-detecting-config, used by default>> as the configuration of your tests.

It then becomes important not to litter the application's main class with configuration settings that are specific to a particular area of its functionality.

Assume that you are using Spring Batch and you rely on the auto-configuration for it.
You could define your `@SpringBootApplication` as follows:

[source,java,indent=0]
----
	@SpringBootApplication
	@EnableBatchProcessing
	public class SampleApplication { ... }
----

Because this class is the source configuration for the test, any slice test actually tries to start Spring Batch, which is definitely not what you want to do.
A recommended approach is to move that area-specific configuration to a separate `@Configuration` class at the same level as your application, as shown in the following example:

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	@EnableBatchProcessing
	public class BatchConfiguration { ... }
----

NOTE: Depending on the complexity of your application, you may either have a single `@Configuration` class for your customizations or one class per domain area.
The latter approach lets you enable it in one of your tests, if necessary, with the `@Import` annotation.

Test slices exclude `@Configuration` classes from scanning.
For example, for a `@WebMvcTest`, the following configuration will not include the given `WebMvcConfigurer` bean in the application context loaded by the test slice:

[source,java,indent=0]
----
	@Configuration
	public class WebConfiguration {
		@Bean
		public WebMvcConfigurer testConfigurer() {
			return new WebMvcConfigurer() {
				...
			};
		}
	}
----

The configuration below will, however, cause the custom `WebMvcConfigurer` to be loaded by the test slice.

[source,java,indent=0]
----
	@Component
	public class TestWebMvcConfigurer implements WebMvcConfigurer {
		...
	}
----

Another source of confusion is classpath scanning.
Assume that, while you structured your code in a sensible way, you need to scan an additional package.
Your application may resemble the following code:

[source,java,indent=0]
----
	@SpringBootApplication
	@ComponentScan({ "com.example.app", "org.acme.another" })
	public class SampleApplication { ... }
----

Doing so effectively overrides the default component scan directive with the side effect of scanning those two packages regardless of the slice that you chose.
For instance, a `@DataJpaTest` seems to suddenly scan components and user configurations of your application.
Again, moving the custom directive to a separate class is a good way to fix this issue.

TIP: If this is not an option for you, you can create a `@SpringBootConfiguration` somewhere in the hierarchy of your test so that it is used instead.
Alternatively, you can specify a source for your test, which disables the behavior of finding a default one.



[[boot-features-testing-spring-boot-applications-with-spock]]
==== Using Spock to Test Spring Boot Applications
If you wish to use Spock to test a Spring Boot application, you should add a dependency on Spock's `spock-spring` module to your application's build.
`spock-spring` integrates Spring's test framework into Spock.
It is recommended that you use Spock 1.2 or later to benefit from a number of improvements to Spock's Spring Framework and Spring Boot integration.
See http://spockframework.org/spock/docs/1.2/modules.html#_spring_module[the documentation for Spock's Spring module] for further details.



[[boot-features-test-utilities]]
=== Test Utilities
A few test utility classes that are generally useful when testing your application are packaged as part of `spring-boot`.



[[boot-features-configfileapplicationcontextinitializer-test-utility]]
==== ConfigFileApplicationContextInitializer
`ConfigFileApplicationContextInitializer` is an `ApplicationContextInitializer` that you can apply to your tests to load Spring Boot `application.properties` files.
You can use it when you do not need the full set of features provided by `@SpringBootTest`, as shown in the following example:

[source,java,indent=0]
----
	@ContextConfiguration(classes = Config.class,
		initializers = ConfigFileApplicationContextInitializer.class)
----

NOTE: Using `ConfigFileApplicationContextInitializer` alone does not provide support for `@Value("${...}")` injection.
Its only job is to ensure that `application.properties` files are loaded into Spring's `Environment`.
For `@Value` support, you need to either additionally configure a `PropertySourcesPlaceholderConfigurer` or use `@SpringBootTest`, which auto-configures one for you.



[[boot-features-test-property-values]]
==== TestPropertyValues
`TestPropertyValues` lets you quickly add properties to a `ConfigurableEnvironment` or `ConfigurableApplicationContext`.
You can call it with `key=value` strings, as follows:

[source,java,indent=0]
----
	TestPropertyValues.of("org=Spring", "name=Boot").applyTo(env);
----



[[boot-features-output-capture-test-utility]]
==== OutputCapture
`OutputCapture` is a JUnit `Extension` that you can use to capture `System.out` and `System.err` output.
To use add `@ExtendWith(OutputCaptureExtension.class)` and inject `CapturedOutput` as an argument to your test class constructor or test method as follows:

[source,java,indent=0]
----
include::{test-examples}/test/system/OutputCaptureTests.java[tag=test]
----



[[boot-features-rest-templates-test-utility]]
==== TestRestTemplate
`TestRestTemplate` is a convenience alternative to Spring's `RestTemplate` that is useful in integration tests.
You can get a vanilla template or one that sends Basic HTTP authentication (with a username and password).
In either case, the template behaves in a test-friendly way by not throwing exceptions on server-side errors.

TIP: Spring Framework 5.0 provides a new `WebTestClient` that works for <<boot-features-testing-spring-boot-applications-testing-autoconfigured-webflux-tests, WebFlux integration tests>> and both <<boot-features-testing-spring-boot-applications-testing-with-running-server, WebFlux and MVC end-to-end testing>>.
It provides a fluent API for assertions, unlike `TestRestTemplate`.

It is recommended, but not mandatory, to use the Apache HTTP Client (version 4.3.2 or better).
If you have that on your classpath, the `TestRestTemplate` responds by configuring the client appropriately.
If you do use Apache's HTTP client, some additional test-friendly features are enabled:

* Redirects are not followed (so you can assert the response location).
* Cookies are ignored (so the template is stateless).

`TestRestTemplate` can be instantiated directly in your integration tests, as shown in the following example:

[source,java,indent=0]
----
	public class MyTest {

		private TestRestTemplate template = new TestRestTemplate();

		@Test
		public void testRequest() throws Exception {
			HttpHeaders headers = this.template.getForEntity(
					"https://myhost.example.com/example", String.class).getHeaders();
			assertThat(headers.getLocation()).hasHost("other.example.com");
		}

	}
----

Alternatively, if you use the `@SpringBootTest` annotation with `WebEnvironment.RANDOM_PORT` or `WebEnvironment.DEFINED_PORT`, you can inject a fully configured `TestRestTemplate` and start using it.
If necessary, additional customizations can be applied through the `RestTemplateBuilder` bean.
Any URLs that do not specify a host and port automatically connect to the embedded server, as shown in the following example:

[source,java,indent=0]
----
include::{test-examples}/web/client/SampleWebClientTests.java[tag=test]
----



[[boot-features-websockets]]
== WebSockets
Spring Boot provides WebSockets auto-configuration for embedded Tomcat, Jetty, and Undertow.
If you deploy a war file to a standalone container, Spring Boot assumes that the container is responsible for the configuration of its WebSocket support.

Spring Framework provides {spring-framework-docs}web.html#websocket[rich WebSocket support] for MVC web applications that can be easily accessed through the `spring-boot-starter-websocket` module.

WebSocket support is also available for {spring-framework-docs}web-reactive.html#webflux-websocket[reactive web applications] and requires to include the WebSocket API alongside `spring-boot-starter-webflux`:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<dependency>
		<groupId>javax.websocket</groupId>
		<artifactId>javax.websocket-api</artifactId>
	</dependency>
----



[[boot-features-webservices]]
== Web Services
Spring Boot provides Web Services auto-configuration so that all you must do is define your `Endpoints`.

The {spring-webservices-docs}[Spring Web Services features] can be easily accessed with the `spring-boot-starter-webservices` module.

`SimpleWsdl11Definition` and `SimpleXsdSchema` beans can be automatically created for your WSDLs and XSDs respectively.
To do so, configure their location, as shown in the following example:


[source,properties,indent=0,configprops]
----
	spring.webservices.wsdl-locations=classpath:/wsdl
----



[[boot-features-webservices-template]]
=== Calling Web Services with `WebServiceTemplate`
If you need to call remote Web services from your application, you can use the {spring-webservices-docs}#client-web-service-template[`WebServiceTemplate`] class.
Since `WebServiceTemplate` instances often need to be customized before being used, Spring Boot does not provide any single auto-configured `WebServiceTemplate` bean.
It does, however, auto-configure a `WebServiceTemplateBuilder`, which can be used to create `WebServiceTemplate` instances when needed.

The following code shows a typical example:

[source,java,indent=0]
----
	@Service
	public class MyService {

		private final WebServiceTemplate webServiceTemplate;

		public MyService(WebServiceTemplateBuilder webServiceTemplateBuilder) {
			this.webServiceTemplate = webServiceTemplateBuilder.build();
		}

		public DetailsResp someWsCall(DetailsReq detailsReq) {
			 return (DetailsResp) this.webServiceTemplate.marshalSendAndReceive(detailsReq, new SoapActionCallback(ACTION));
		}

	}
----

By default, `WebServiceTemplateBuilder` detects a suitable HTTP-based `WebServiceMessageSender` using the available HTTP client libraries on the classpath.
You can also customize read and connection timeouts as follows:

[source,java,indent=0]
----
	@Bean
	public WebServiceTemplate webServiceTemplate(WebServiceTemplateBuilder builder) {
		return builder.messageSenders(new HttpWebServiceMessageSenderBuilder()
				.setConnectTimeout(5000).setReadTimeout(2000).build()).build();
	}
----



[[boot-features-developing-auto-configuration]]
== Creating Your Own Auto-configuration
If you work in a company that develops shared libraries, or if you work on an open-source or commercial library, you might want to develop your own auto-configuration.
Auto-configuration classes can be bundled in external jars and still be picked-up by Spring Boot.

Auto-configuration can be associated to a "`starter`" that provides the auto-configuration code as well as the typical libraries that you would use with it.
We first cover what you need to know to build your own auto-configuration and then we move on to the <<boot-features-custom-starter,typical steps required to create a custom starter>>.

TIP: A https://github.com/snicoll-demos/spring-boot-master-auto-configuration[demo project] is available to showcase how you can create a starter step-by-step.



[[boot-features-understanding-auto-configured-beans]]
=== Understanding Auto-configured Beans
Under the hood, auto-configuration is implemented with standard `@Configuration` classes.
Additional `@Conditional` annotations are used to constrain when the auto-configuration should apply.
Usually, auto-configuration classes use `@ConditionalOnClass` and `@ConditionalOnMissingBean` annotations.
This ensures that auto-configuration applies only when relevant classes are found and when you have not declared your own `@Configuration`.

You can browse the source code of {spring-boot-autoconfigure-module-code}[`spring-boot-autoconfigure`] to see the `@Configuration` classes that Spring provides (see the {spring-boot-code}/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories[`META-INF/spring.factories`] file).



[[boot-features-locating-auto-configuration-candidates]]
=== Locating Auto-configuration Candidates
Spring Boot checks for the presence of a `META-INF/spring.factories` file within your published jar.
The file should list your configuration classes under the `EnableAutoConfiguration` key, as shown in the following example:

[indent=0]
----
	org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
	com.mycorp.libx.autoconfigure.LibXAutoConfiguration,\
	com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration
----

NOTE: Auto-configurations must be loaded that way _only_.
Make sure that they are defined in a specific package space and that they are never the target of component scanning.
Furthermore, auto-configuration classes should not enable component scanning to find additional components.
Specific ``@Import``s should be used instead.

You can use the {spring-boot-autoconfigure-module-code}/AutoConfigureAfter.java[`@AutoConfigureAfter`] or {spring-boot-autoconfigure-module-code}/AutoConfigureBefore.java[`@AutoConfigureBefore`] annotations if your configuration needs to be applied in a specific order.
For example, if you provide web-specific configuration, your class may need to be applied after `WebMvcAutoConfiguration`.

If you want to order certain auto-configurations that should not have any direct knowledge of each other, you can also use `@AutoConfigureOrder`.
That annotation has the same semantic as the regular `@Order` annotation but provides a dedicated order for auto-configuration classes.



[[boot-features-condition-annotations]]
=== Condition Annotations
You almost always want to include one or more `@Conditional` annotations on your auto-configuration class.
The `@ConditionalOnMissingBean` annotation is one common example that is used to allow developers to override auto-configuration if they are not happy with your defaults.

Spring Boot includes a number of `@Conditional` annotations that you can reuse in your own code by annotating `@Configuration` classes or individual `@Bean` methods.
These annotations include:

* <<boot-features-class-conditions>>
* <<boot-features-bean-conditions>>
* <<boot-features-property-conditions>>
* <<boot-features-resource-conditions>>
* <<boot-features-web-application-conditions>>
* <<boot-features-spel-conditions>>



[[boot-features-class-conditions]]
==== Class Conditions
The `@ConditionalOnClass` and `@ConditionalOnMissingClass` annotations let `@Configuration` classes be included based on the presence or absence of specific classes.
Due to the fact that annotation metadata is parsed by using https://asm.ow2.org/[ASM], you can use the `value` attribute to refer to the real class, even though that class might not actually appear on the running application classpath.
You can also use the `name` attribute if you prefer to specify the class name by using a `String` value.

This mechanism does not apply the same way to `@Bean` methods where typically the return type is the target of the condition: before the condition on the method applies, the JVM will have loaded the class and potentially processed method references which will fail if the class is not present.

To handle this scenario, a separate `@Configuration` class can be used to isolate the condition, as shown in the following example:

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	// Some conditions
	public class MyAutoConfiguration {

		// Auto-configured beans

		@Configuration(proxyBeanMethods = false)
		@ConditionalOnClass(EmbeddedAcmeService.class)
		static class EmbeddedConfiguration {

			@Bean
			@ConditionalOnMissingBean
			public EmbeddedAcmeService embeddedAcmeService() { ... }

		}

	}
----

TIP: If you use `@ConditionalOnClass` or `@ConditionalOnMissingClass` as a part of a meta-annotation to compose your own composed annotations, you must use `name` as referring to the class in such a case is not handled.



[[boot-features-bean-conditions]]
==== Bean Conditions
The `@ConditionalOnBean` and `@ConditionalOnMissingBean` annotations let a bean be included based on the presence or absence of specific beans.
You can use the `value` attribute to specify beans by type or `name` to specify beans by name.
The `search` attribute lets you limit the `ApplicationContext` hierarchy that should be considered when searching for beans.

When placed on a `@Bean` method, the target type defaults to the return type of the method, as shown in the following example:

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	public class MyAutoConfiguration {

		@Bean
		@ConditionalOnMissingBean
		public MyService myService() { ... }

	}
----

In the preceding example, the `myService` bean is going to be created if no bean of type `MyService` is already contained in the `ApplicationContext`.

TIP: You need to be very careful about the order in which bean definitions are added, as these conditions are evaluated based on what has been processed so far.
For this reason, we recommend using only `@ConditionalOnBean` and `@ConditionalOnMissingBean` annotations on auto-configuration classes (since these are guaranteed to load after any user-defined bean definitions have been added).

NOTE: `@ConditionalOnBean` and `@ConditionalOnMissingBean` do not prevent `@Configuration` classes from being created.
The only difference between using these conditions at the class level and marking each contained `@Bean` method with the annotation is that the former prevents registration of the `@Configuration` class as a bean if the condition does not match.



[[boot-features-property-conditions]]
==== Property Conditions
The `@ConditionalOnProperty` annotation lets configuration be included based on a Spring Environment property.
Use the `prefix` and `name` attributes to specify the property that should be checked.
By default, any property that exists and is not equal to `false` is matched.
You can also create more advanced checks by using the `havingValue` and `matchIfMissing` attributes.



[[boot-features-resource-conditions]]
==== Resource Conditions
The `@ConditionalOnResource` annotation lets configuration be included only when a specific resource is present.
Resources can be specified by using the usual Spring conventions, as shown in the following example: `file:/home/user/test.dat`.



[[boot-features-web-application-conditions]]
==== Web Application Conditions
The `@ConditionalOnWebApplication` and `@ConditionalOnNotWebApplication` annotations let configuration be included depending on whether the application is a "`web application`".
A servlet-based web application is any application that uses a Spring `WebApplicationContext`, defines a `session` scope, or has a `ConfigurableWebEnvironment`.
A reactive web application is any application that uses a `ReactiveWebApplicationContext`, or has a `ConfigurableReactiveWebEnvironment`.



[[boot-features-spel-conditions]]
==== SpEL Expression Conditions
The `@ConditionalOnExpression` annotation lets configuration be included based on the result of a {spring-framework-docs}core.html#expressions[SpEL expression].



[[boot-features-test-autoconfig]]
=== Testing your Auto-configuration
An auto-configuration can be affected by many factors: user configuration (`@Bean` definition and `Environment` customization), condition evaluation (presence of a particular library), and others.
Concretely, each test should create a well defined `ApplicationContext` that represents a combination of those customizations.
`ApplicationContextRunner` provides a great way to achieve that.

`ApplicationContextRunner` is usually defined as a field of the test class to gather the base, common configuration.
The following example makes sure that `UserServiceAutoConfiguration` is always invoked:

[source,java,indent=0]
----
include::{test-examples}/autoconfigure/UserServiceAutoConfigurationTests.java[tag=runner]
----

TIP: If multiple auto-configurations have to be defined, there is no need to order their declarations as they are invoked in the exact same order as when running the application.

Each test can use the runner to represent a particular use case.
For instance, the sample below invokes a user configuration (`UserConfiguration`) and checks that the auto-configuration backs off properly.
Invoking `run` provides a callback context that can be used with `Assert4J`.

[source,java,indent=0]
----
include::{test-examples}/autoconfigure/UserServiceAutoConfigurationTests.java[tag=test-user-config]
----

It is also possible to easily customize the `Environment`, as shown in the following example:

[source,java,indent=0]
----
include::{test-examples}/autoconfigure/UserServiceAutoConfigurationTests.java[tag=test-env]
----

The runner can also be used to display the `ConditionEvaluationReport`.
The report can be printed at `INFO` or `DEBUG` level.
The following example shows how to use the `ConditionEvaluationReportLoggingListener` to print the report in auto-configuration tests.

[source,java,indent=0]
----
	@Test
	public void autoConfigTest {
		ConditionEvaluationReportLoggingListener initializer = new ConditionEvaluationReportLoggingListener(
				LogLevel.INFO);
		ApplicationContextRunner contextRunner = new ApplicationContextRunner()
				.withInitializer(initializer).run((context) -> {
						// Do something...
				});
	}
----



==== Simulating a Web Context
If you need to test an auto-configuration that only operates in a Servlet or Reactive web application context, use the `WebApplicationContextRunner` or `ReactiveWebApplicationContextRunner` respectively.



==== Overriding the Classpath
It is also possible to test what happens when a particular class and/or package is not present at runtime.
Spring Boot ships with a `FilteredClassLoader` that can easily be used by the runner.
In the following example, we assert that if `UserService` is not present, the auto-configuration is properly disabled:

[source,java,indent=0]
----
include::{test-examples}/autoconfigure/UserServiceAutoConfigurationTests.java[tag=test-classloader]
----



[[boot-features-custom-starter]]
=== Creating Your Own Starter
A full Spring Boot starter for a library may contain the following components:

* The `autoconfigure` module that contains the auto-configuration code.
* The `starter` module that provides a dependency to the `autoconfigure` module as well as the library and any additional dependencies that are typically useful.
In a nutshell, adding the starter should provide everything needed to start using that library.

TIP: You may combine the auto-configuration code and the dependency management in a single module if you do not need to separate those two concerns.



[[boot-features-custom-starter-naming]]
==== Naming
You should make sure to provide a proper namespace for your starter.
Do not start your module names with `spring-boot`, even if you use a different Maven `groupId`.
We may offer official support for the thing you auto-configure in the future.

As a rule of thumb, you should name a combined module after the starter.
For example, assume that you are creating a starter for "acme" and that you name the auto-configure module `acme-spring-boot-autoconfigure` and the starter `acme-spring-boot-starter`.
If you only have one module that combines the two, name it `acme-spring-boot-starter`.



[[boot-features-custom-starter-configuration-keys]]
==== Configuration keys
If your starter provides configuration keys, use a unique namespace for them.
In particular, do not include your keys in the namespaces that Spring Boot uses (such as `server`, `management`, `spring`, and so on).
If you use the same namespace, we may modify these namespaces in the future in ways that break your modules.
As a rule of thumb, prefix all your keys with a namespace that you own (e.g. `acme`).

Make sure that configuration keys are documented by adding field javadoc for each property, as shown in the following example:

[source,java,indent=0]
----
	@ConfigurationProperties("acme")
	public class AcmeProperties {

		/**
		 * Whether to check the location of acme resources.
		 */
		private boolean checkLocation = true;

		/**
		 * Timeout for establishing a connection to the acme server.
		 */
		private Duration loginTimeout = Duration.ofSeconds(3);

		// getters & setters

	}
----

NOTE: You should only use simple text with `@ConfigurationProperties` field Javadoc, since they are not processed before being added to the JSON.

Here are some rules we follow internally to make sure descriptions are consistent:

* Do not start the description by "The" or "A".
* For `boolean` types, start the description with "Whether" or "Enable".
* For collection-based types, start the description with "Comma-separated list"
* Use `java.time.Duration` rather than `long` and describe the default unit if it differs from milliseconds, e.g. "If a duration suffix is not specified, seconds will be used".
* Do not provide the default value in the description unless it has to be determined at runtime.

Make sure to <<appendix-configuration-metadata.adoc#configuration-metadata-annotation-processor,trigger meta-data generation>> so that IDE assistance is available for your keys as well.
You may want to review the generated metadata (`META-INF/spring-configuration-metadata.json`) to make sure your keys are properly documented.
Using your own starter in a compatible IDE is also a good idea to validate that quality of the metadata.



[[boot-features-custom-starter-module-autoconfigure]]
==== `autoconfigure` Module
The `autoconfigure` module contains everything that is necessary to get started with the library.
It may also contain configuration key definitions (such as `@ConfigurationProperties`) and any callback interface that can be used to further customize how the components are initialized.

TIP: You should mark the dependencies to the library as optional so that you can include the `autoconfigure` module in your projects more easily.
If you do it that way, the library is not provided and, by default, Spring Boot backs off.

Spring Boot uses an annotation processor to collect the conditions on auto-configurations in a metadata file (`META-INF/spring-autoconfigure-metadata.properties`).
If that file is present, it is used to eagerly filter auto-configurations that do not match, which will improve startup time.
It is recommended to add the following dependency in a module that contains auto-configurations:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-autoconfigure-processor</artifactId>
		<optional>true</optional>
	</dependency>
----

With Gradle 4.5 and earlier, the dependency should be declared in the `compileOnly` configuration, as shown in the following example:

[source,groovy,indent=0,subs="verbatim,quotes,attributes"]
----
	dependencies {
		compileOnly "org.springframework.boot:spring-boot-autoconfigure-processor"
	}
----

With Gradle 4.6 and later, the dependency should be declared in the `annotationProcessor` configuration, as shown in the following example:

[source,groovy,indent=0,subs="verbatim,quotes,attributes"]
----
	dependencies {
		annotationProcessor "org.springframework.boot:spring-boot-autoconfigure-processor"
	}
----



[[boot-features-custom-starter-module-starter]]
==== Starter Module
The starter is really an empty jar.
Its only purpose is to provide the necessary dependencies to work with the library.
You can think of it as an opinionated view of what is required to get started.

Do not make assumptions about the project in which your starter is added.
If the library you are auto-configuring typically requires other starters, mention them as well.
Providing a proper set of _default_ dependencies may be hard if the number of optional dependencies is high, as you should avoid including dependencies that are unnecessary for a typical usage of the library.
In other words, you should not include optional dependencies.

NOTE: Either way, your starter must reference the core Spring Boot starter (`spring-boot-starter`) directly or indirectly (i.e. no need to add it if your starter relies on another starter).
If a project is created with only your custom starter, Spring Boot's core features will be honoured by the presence of the core starter.



[[boot-features-kotlin]]
== Kotlin support
https://kotlinlang.org[Kotlin] is a statically-typed language targeting the JVM (and other platforms) which allows writing concise and elegant code while providing {kotlin-docs}java-interop.html[interoperability] with existing libraries written in Java.

Spring Boot provides Kotlin support by leveraging the support in other Spring projects such as Spring Framework, Spring Data, and Reactor.
See the {spring-framework-docs}languages.html#kotlin[Spring Framework Kotlin support documentation] for more information.

The easiest way to start with Spring Boot and Kotlin is to follow https://spring.io/guides/tutorials/spring-boot-kotlin/[this comprehensive tutorial].
You can create new Kotlin projects via https://start.spring.io/#!language=kotlin[start.spring.io].
Feel free to join the #spring channel of https://slack.kotlinlang.org/[Kotlin Slack] or ask a question with the `spring` and `kotlin` tags on https://stackoverflow.com/questions/tagged/spring+kotlin[Stack Overflow] if you need support.



[[boot-features-kotlin-requirements]]
=== Requirements
Spring Boot supports Kotlin 1.3.x.
To use Kotlin, `org.jetbrains.kotlin:kotlin-stdlib` and `org.jetbrains.kotlin:kotlin-reflect` must be present on the classpath.
The `kotlin-stdlib` variants `kotlin-stdlib-jdk7` and `kotlin-stdlib-jdk8` can also be used.

Since https://discuss.kotlinlang.org/t/classes-final-by-default/166[Kotlin classes are final by default], you are likely to want to configure {kotlin-docs}compiler-plugins.html#spring-support[kotlin-spring] plugin in order to automatically open Spring-annotated classes so that they can be proxied.

https://github.com/FasterXML/jackson-module-kotlin[Jackson's Kotlin module] is required for serializing / deserializing JSON data in Kotlin.
It is automatically registered when found on the classpath.
A warning message is logged if Jackson and Kotlin are present but the Jackson Kotlin module is not.

TIP: These dependencies and plugins are provided by default if one bootstraps a Kotlin project on https://start.spring.io/#!language=kotlin[start.spring.io].



[[boot-features-kotlin-null-safety]]
=== Null-safety
One of Kotlin's key features is {kotlin-docs}null-safety.html[null-safety].
It deals with `null` values at compile time rather than deferring the problem to runtime and encountering a `NullPointerException`.
This helps to eliminate a common source of bugs without paying the cost of wrappers like `Optional`.
Kotlin also allows using functional constructs with nullable values as described in this https://www.baeldung.com/kotlin-null-safety[comprehensive guide to null-safety in Kotlin].

Although Java does not allow one to express null-safety in its type system, Spring Framework, Spring Data, and Reactor now provide null-safety of their API via tooling-friendly annotations.
By default, types from Java APIs used in Kotlin are recognized as {kotlin-docs}java-interop.html#null-safety-and-platform-types[platform types] for which null-checks are relaxed.
{kotlin-docs}java-interop.html#jsr-305-support[Kotlin's support for JSR 305 annotations] combined with nullability annotations provide null-safety for the related Spring API in Kotlin.

The JSR 305 checks can be configured by adding the `-Xjsr305` compiler flag with the following options: `-Xjsr305={strict|warn|ignore}`.
The default behavior is the same as `-Xjsr305=warn`.
The `strict` value is required to have null-safety taken in account in Kotlin types inferred from Spring API but should be used with the knowledge that Spring API nullability declaration could evolve even between minor releases and more checks may be added in the future).

WARNING: Generic type arguments, varargs and array elements nullability are not yet supported.
See https://jira.spring.io/browse/SPR-15942[SPR-15942] for up-to-date information.
Also be aware that Spring Boot's own API is {github-issues}10712[not yet annotated].



[[boot-features-kotlin-api]]
=== Kotlin API



[[boot-features-kotlin-api-runapplication]]
==== runApplication
Spring Boot provides an idiomatic way to run an application with `runApplication<MyApplication>(*args)` as shown in the following example:

[source,kotlin,indent=0]
----
	import org.springframework.boot.autoconfigure.SpringBootApplication
	import org.springframework.boot.runApplication

	@SpringBootApplication
	class MyApplication

	fun main(args: Array<String>) {
		runApplication<MyApplication>(*args)
	}
----

This is a drop-in replacement for `SpringApplication.run(MyApplication::class.java, *args)`.
It also allows customization of the application as shown in the following example:

[source,kotlin,indent=0]
----
	runApplication<MyApplication>(*args) {
		setBannerMode(OFF)
	}
----



[[boot-features-kotlin-api-extensions]]
==== Extensions
Kotlin {kotlin-docs}extensions.html[extensions] provide the ability to extend existing classes with additional functionality.
The Spring Boot Kotlin API makes use of these extensions to add new Kotlin specific conveniences to existing APIs.

`TestRestTemplate` extensions, similar to those provided by Spring Framework for `RestOperations` in Spring Framework, are provided.
Among other things, the extensions make it possible to take advantage of Kotlin reified type parameters.



[[boot-features-kotlin-dependency-management]]
=== Dependency management
In order to avoid mixing different versions of Kotlin dependencies on the classpath, Spring Boot imports the Kotlin BOM.

With Maven, the Kotlin version can be customized via the `kotlin.version` property and plugin management is provided for `kotlin-maven-plugin`.
With Gradle, the Spring Boot plugin automatically aligns the `kotlin.version` with the version of the Kotlin plugin.

Spring Boot also manages the version of Coroutines dependencies by importing the Kotlin Coroutines BOM.
The version can be customized via the `kotlin-coroutines.version` property.

TIP: `org.jetbrains.kotlinx:kotlinx-coroutines-reactor` dependency is provided by default if one bootstraps a Kotlin project with at least one reactive dependency on https://start.spring.io/#!language=kotlin[start.spring.io].


[[boot-features-kotlin-configuration-properties]]
=== `@ConfigurationProperties`
`@ConfigurationProperties` when used in combination with <<boot-features-external-config-constructor-binding,`@ConstructorBinding`>> supports classes with immutable `val` properties as shown in the following example:

[source,kotlin,indent=0]
----
@ConstructorBinding
@ConfigurationProperties("example.kotlin")
data class KotlinExampleProperties(
		val name: String,
		val description: String,
		val myService: MyService) {

	data class MyService(
			val apiToken: String,
			val uri: URI
	)
}
----

TIP: To generate <<appendix-configuration-metadata.adoc#configuration-metadata-annotation-processor,your own metadata>> using the annotation processor, {kotlin-docs}kapt.html[`kapt` should be configured] with the `spring-boot-configuration-processor` dependency.
Note that some features (such as detecting the default value or deprecated items) are not working due to limitations in the model kapt provides.



[[boot-features-kotlin-testing]]
=== Testing
While it is possible to use JUnit 4 to test Kotlin code, JUnit 5 is provided by default and is recommended.
JUnit 5 enables a test class to be instantiated once and reused for all of the class's tests.
This makes it possible to use `@BeforeClass` and `@AfterClass` annotations on non-static methods, which is a good fit for Kotlin.

JUnit 5 is the default and the vintage engine is provided for backward compatibility with JUnit 4.
If you don't use it, exclude `org.junit.vintange:junit-vintage-engine`.
You also need to {junit5-docs}/#writing-tests-test-instance-lifecycle-changing-default[switch test instance lifecycle to "per-class"].

To mock Kotlin classes, https://mockk.io/[MockK] is recommended.
If you need the `Mockk` equivalent of the Mockito specific <<boot-features-testing-spring-boot-applications-mocking-beans,`@MockBean` and `@SpyBean` annotations>>, you can use https://github.com/Ninja-Squad/springmockk[SpringMockK] which provides similar `@MockkBean` and `@SpykBean` annotations.



[[boot-features-kotlin-resources]]
=== Resources



[[boot-features-kotlin-resources-further-reading]]
==== Further reading
* {kotlin-docs}[Kotlin language reference]
* https://slack.kotlinlang.org/[Kotlin Slack] (with a dedicated #spring channel)
* https://stackoverflow.com/questions/tagged/spring+kotlin[Stackoverflow with `spring` and `kotlin` tags]
* https://try.kotlinlang.org/[Try Kotlin in your browser]
* https://blog.jetbrains.com/kotlin/[Kotlin blog]
* https://kotlin.link/[Awesome Kotlin]
* https://spring.io/guides/tutorials/spring-boot-kotlin/[Tutorial: building web applications with Spring Boot and Kotlin]
* https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin[Developing Spring Boot applications with Kotlin]
* https://spring.io/blog/2016/03/20/a-geospatial-messenger-with-kotlin-spring-boot-and-postgresql[A Geospatial Messenger with Kotlin, Spring Boot and PostgreSQL]
* https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0[Introducing Kotlin support in Spring Framework 5.0]
* https://spring.io/blog/2017/08/01/spring-framework-5-kotlin-apis-the-functional-way[Spring Framework 5 Kotlin APIs, the functional way]



[[boot-features-kotlin-resources-examples]]
==== Examples
* https://github.com/sdeleuze/spring-boot-kotlin-demo[spring-boot-kotlin-demo]: regular Spring Boot + Spring Data JPA project
* https://github.com/mixitconf/mixit[mixit]: Spring Boot 2 + WebFlux + Reactive Spring Data MongoDB
* https://github.com/sdeleuze/spring-kotlin-fullstack[spring-kotlin-fullstack]: WebFlux Kotlin fullstack example with Kotlin2js for frontend instead of JavaScript or TypeScript
* https://github.com/spring-petclinic/spring-petclinic-kotlin[spring-petclinic-kotlin]: Kotlin version of the Spring PetClinic Sample Application
* https://github.com/sdeleuze/spring-kotlin-deepdive[spring-kotlin-deepdive]: a step by step migration for Boot 1.0 + Java to Boot 2.0 + Kotlin
* https://github.com/sdeleuze/spring-boot-coroutines-demo[spring-boot-coroutines-demo]: Coroutines sample project



[[boot-features-whats-next]]
== What to Read Next
If you want to learn more about any of the classes discussed in this section, you can check out the {spring-boot-api}[Spring Boot API documentation] or you can browse the {spring-boot-code}[source code directly].
If you have specific questions, take a look at the <<howto.adoc#howto, how-to>> section.

If you are comfortable with Spring Boot's core features, you can continue on and read about <<production-ready-features.adoc#production-ready, production-ready features>>.
