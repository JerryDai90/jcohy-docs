[[spring-integration]]
= 集成
:doc-root: https://docs.spring.io
:api-spring-framework: {doc-root}/spring-framework/docs/{spring-version}/javadoc-api/org/springframework
:doc-spring-amqp: {doc-root}/spring-amqp/docs/current/reference
:doc-spring-gemfire: {doc-root}/spring-gemfire/docs/current/reference
:toc: left
:toclevels: 4
:tabsize: 4
:docinfo1:

这部分参考文档涵盖了Spring Framework与许多Java EE（及相关）技术的集成。

[[remoting]]
== 远程处理和Web服务

Spring为使用各种技术的远程支持的集成类提供了功能，远程处理支持可轻松使用常用(Spring)pojo实现的、由您提供的服务开发。目前，Spring支持以下远程技术：

* <<remoting-rmi,远程方法调用(RMI)>>: 通过使用 `RmiProxyFactoryBean` 和 `RmiServiceExporter`。Spring支持传统的 RMI（使用 `java.rmi.Remote` 接口和 `java.rmi.RemoteException`）以及通过RMI调用程序（使用任何Java接口）进行透明的远程处理。
* <<remoting-httpinvoker,Spring的 HTTP 调用>>: Spring提供了一种特殊的远程处理策略，允许通过HTTP进行Java序列化，支持任何Java接口（如RMI调用者所做的那样）。 相应的支持类是 `HttpInvokerProxyFactoryBean` 和 `HttpInvokerServiceExporter`.
* <<remoting-caucho-protocols-hessian,Hessian>>: 通过使用Spring的 `HessianProxyFactoryBean` 和 `HessianServiceExporter`，您可以使用Caucho提供的轻量级二进制http协议透明地公开您的服务。
* <<remoting-web-services,JAX-WS>>: Spring通过JAX-WS 为Web服务提供了远程处理支持(如Java EE 5和Java 6所介绍的那样， 它继承了JAX-RPC).
* <<remoting-jms,JMS>>: 通过 `spring-jms` 模块中的 `JmsInvokerServiceExporter` 和 `JmsInvokerProxyFactoryBean` 类支持使用JMS作为底层协议进行远程处理。
* <<remoting-amqp,>>: Spring AMQP项目支持使用AMQP作为底层协议进行远程处理。

在讨论Spring的远程处理功能时，我们使用以下域模型和相应的服务：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class Account implements Serializable{

		private String name;

		public String getName(){
			return name;
		}

		public void setName(String name) {
			this.name = name;
		}
	}
----

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public interface AccountService {

		public void insertAccount(Account account);

		public List<Account> getAccounts(String name);
	}
----

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	// the implementation doing nothing at the moment
	public class AccountServiceImpl implements AccountService {

		public void insertAccount(Account acc) {
			// do something...
		}

		public List<Account> getAccounts(String name) {
			// do something...
		}
	}
----

本节首先使用RMI将服务公开给远程客户端，然后再谈谈使用RMI的缺点。 然后继续使用Hessian作为协议的示例。

[[remoting-rmi]]
=== RMI

使用Spring对RMI的支持， 您可以通过RMI架构透明地公开服务。在用此设置之后， 您基本上拥有一个类似于远程EJB的配置， 但不存在安全上下文传播或远程事务传播的标准支持这一事实。
Spring在使用RMI调用器时提供了这样的附加调用上下文的钩子， 因此您可以在此处插入安全框架或自定义安全凭据。

[[remoting-rmi-server]]
==== 使用 `RmiServiceExporter` 暴露服务

使用 `RmiServiceExporter`，我们可以将 `AccountService` 对象的接口公开为RMI对象。可以使用 `RmiProxyFactoryBean` 访问该接口，或者在传统RMI服务的情况下通过普通RMI访问该接口。 `RmiServiceExporter` 明确支持通过RMI调用程序公开任何非RMI服务。

我们首先必须在Spring容器中设置我们的服务。 以下示例显示了如何执行此操作：:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="accountService" class="example.AccountServiceImpl">
		<!-- any additional properties, maybe a DAO? -->
	</bean>
----

接下来，我们必须使用 `RmiServiceExporter` 暴露我们的服务。 以下示例显示了如何执行此操作：

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean class="org.springframework.remoting.rmi.RmiServiceExporter">
		<!-- does not necessarily have to be the same name as the bean to be exported -->
		<property name="serviceName" value="AccountService"/>
		<property name="service" ref="accountService"/>
		<property name="serviceInterface" value="example.AccountService"/>
		<!-- defaults to 1099 -->
		<property name="registryPort" value="1199"/>
	</bean>
----

在前面的示例中，我们覆盖RMI注册表的端口。通常情况下， 您的应用服务器还维护一个RMI注册表， 因此最好不要干预它。此外， 服务名称用于绑定服务。因此，在前面的示例中，服务绑定在  `'rmi://HOST:1199/AccountService'`。 我们稍后使用此URL链接客户端的服务。

NOTE: `servicePort` 属性已被省略（默认为0）。这意味着将使用匿名端口与服务进行通信。

[[remoting-rmi-client]]
==== 连接客户端和服务

我们的客户端是一个使用 `AccountService` 管理帐户的简单对象，如以下示例所示：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class SimpleObject {

		private AccountService accountService;

		public void setAccountService(AccountService accountService) {
			this.accountService = accountService;
		}

		// additional methods using the accountService
	}
----

要在客户端上链接服务， 我们将创建一个单独的Spring容器， 其中包含简单对象和连接配置位的服务。

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean class="example.SimpleObject">
		<property name="accountService" ref="accountService"/>
	</bean>

	<bean id="accountService" class="org.springframework.remoting.rmi.RmiProxyFactoryBean">
		<property name="serviceUrl" value="rmi://HOST:1199/AccountService"/>
		<property name="serviceInterface" value="example.AccountService"/>
	</bean>
----

这就是支持客户端连接远程帐户服务所需做的全部工作，Spring将透明地创建一个调用， 并通过 `RmiServiceExporter` 远程启用帐户服务。在客户端， 我们在其链接中使用 `RmiProxyFactoryBean`。

[[remoting-caucho-protocols]]
=== 使用Hessian通过HTTP远程调用服务

Hessian提供基于HTTP的二进制远程协议。 它由Caucho开发，您可以在 https://www.caucho.com/[] 找到有关Hessian本身的更多信息。

[[remoting-caucho-protocols-hessian]]
==== Hessian

Hessian通过HTTP进行通信，并使用自定义servlet进行通信。通过使用Spring的 `DispatcherServlet` 原则（参见<<webmvc.adoc#mvc-servlet>>），我们可以连接这样的servlet以公开您的服务。
首先，我们必须在我们的应用程序中创建一个新的servlet，如以下摘自 `web.xml` 所示:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<servlet>
		<servlet-name>remoting</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<load-on-startup>1</load-on-startup>
	</servlet>

	<servlet-mapping>
		<servlet-name>remoting</servlet-name>
		<url-pattern>/remoting/*</url-pattern>
	</servlet-mapping>
----

如果您熟悉Spring的 `DispatcherServlet` 原则，您可能知道现在必须在 `WEB-INF` 目录中创建一个名为 `remoting-servlet.xml` 的Spring容器配置资源（在您的servlet名称之后）。 应用程序上下文将在下一节中使用。

或者， 考虑使用Spring更简单的 `HttpRequestHandlerServlet`。这使您可以在根应用程序上下文中嵌入远程公开定义(默认情况下为 `WEB-INF/applicationContext.xml`)， 并将单个Servlet定义指向特定的公开bean。
在这种情况下， 每个Servlet名称都需要匹配其目标公开的bean名称。

[[remoting-caucho-protocols-hessian-server]]
==== 使用 `HessianServiceExporter` 暴露您的Bean

在新创建的名为 `remoting-servlet.xml` 的应用程序上下文中，我们创建了一个 `HessianServiceExporter` 来暴露我们的服务，如下例所示:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="accountService" class="example.AccountServiceImpl">
		<!-- any additional properties, maybe a DAO? -->
	</bean>

	<bean name="/AccountService" class="org.springframework.remoting.caucho.HessianServiceExporter">
		<property name="service" ref="accountService"/>
		<property name="serviceInterface" value="example.AccountService"/>
	</bean>
----

现在, 我们已经准备好在客户端上链接服务了.未指定显式处理程序映射， 将请求URL映射到服务上， 因此将使用 `BeanNameUrlHandlerMapping`。 因此， 该服务将在包含 `DispatcherServlet` 映射(如上所述)的URL中通过其bean名称指示的网址公开: `http://HOST:8080/remoting/AccountService`

或者, 在您的根应用程序上下文中创建一个 `HessianServiceExporter` (例如在 `WEB-INF/applicationContext.xml`)。如下所示:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean name="accountExporter" class="org.springframework.remoting.caucho.HessianServiceExporter">
		<property name="service" ref="accountService"/>
		<property name="serviceInterface" value="example.AccountService"/>
	</bean>
----

在后一种情况下， 在web.xml中为该公开定义一个相应的Servlet， 并使用相同的最终结果： 公开程序被映射到请求路径 `/remoting/AccountService`。请注意， Servlet名称需要与目标公开方的bean名称匹配。

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<servlet>
		<servlet-name>accountExporter</servlet-name>
		<servlet-class>org.springframework.web.context.support.HttpRequestHandlerServlet</servlet-class>
	</servlet>

	<servlet-mapping>
		<servlet-name>accountExporter</servlet-name>
		<url-pattern>/remoting/AccountService</url-pattern>
	</servlet-mapping>
----


[[remoting-caucho-protocols-hessian-client]]
==== 在客户端的服务中链接

通过使用 `HessianProxyFactoryBean`，我们可以链接客户端的服务。同样的原则适用于RMI示例。我们创建一个单独的bean工厂或应用程序上下文，并提到以下bean，其中 `SimpleObject` 是通过使用 `AccountService` 来管理帐户，如以下示例所示：

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean class="example.SimpleObject">
		<property name="accountService" ref="accountService"/>
	</bean>

	<bean id="accountService" class="org.springframework.remoting.caucho.HessianProxyFactoryBean">
		<property name="serviceUrl" value="https://remotehost:8080/remoting/AccountService"/>
		<property name="serviceInterface" value="example.AccountService"/>
	</bean>
----


[[remoting-caucho-protocols-security]]
==== 通过Hessian公开的服务来应用HTTP基本的验证

Hessian的一个优点是我们可以轻松应用HTTP基本身份验证，因为这两种协议都是基于HTTP的。例如，可以通过使用 `web.xml` 安全功能来应用常规HTTP服务器安全性机制。 通常，您无需在此处使用每用户安全凭据。 相反，您可以使用在 `HessianProxyFactoryBean` 级别定义的共享凭证（类似于JDBC `DataSource`），如以下示例所示:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping">
		<property name="interceptors" ref="authorizationInterceptor"/>
	</bean>

	<bean id="authorizationInterceptor"
			class="org.springframework.web.servlet.handler.UserRoleAuthorizationInterceptor">
		<property name="authorizedRoles" value="administrator,operator"/>
	</bean>
----

在前面的示例中，我们明确提到了 `BeanNameUrlHandlerMapping` 并设置了一个拦截器，只允许管理员和操作员调用此应用程序上下文中提到的bean。

NOTE: 前面的示例并没有显示一种灵活的安全基础结构。有关安全性的更多选项，请查看 https://projects.spring.io/spring-security/ 上的Spring Security项目。

[[remoting-httpinvoker]]
=== Spring HTTP 调用

与Hessian相反，Spring HTTP调用者都是轻量级协议，Hessian使用自身序列化机制，而Spring HTTP调用者使用标准的Java序列化机制通过HTTP公开服务。如果您的参数和返回类型是使用Hessian使用的序列化机制无法序列化的复杂类型，那么这具有巨大的优势（当您选择远程处理技术时，请参阅下一节以了解更多注意事项）。

在底层，Spring使用JDK或Apache `HttpComponents` 提供的标准工具来执行HTTP调用。 如果您需要更高级且更易于使用的功能，请使用后者。 有关更多信息，请参阅 https://hc.apache.org/httpcomponents-client-ga/[hc.apache.org/httpcomponents-client-ga/]。

[WARNING]
====

由于不安全的Java反序列化而造成的漏洞:操作的输入流可能导致在反序列化步骤中在服务器上执行不需要的代码。因此， 不要将HTTP调用方终结点公开给不受信任的客户端， 而只应该在您自己的服务之间。通常， 我们强烈推荐任何其他消息格式(例如JSON)。

如果您担心由于Java序列化引起的安全漏洞， 请考虑核心JVM级别的generalpurpose序列化筛选器机制， 它最初是为JDK 9开发的。但同时又向后移植到JDK 8,7和6。
请参阅 https://blogs.oracle.com/java-platform-group/entry/incoming_filter_serialization_data_a 和 http://openjdk.java.net/jeps/290.
====


[[remoting-httpinvoker-server]]
==== 公开服务对象

为服务对象设置HTTP调用的架构类似于使用Hession，方式也是相同的。正如Hession支持提供 是 `HessianServiceExporter`。 Spring的 `HttpInvoker` 支持提供了 `org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter`。

要在Spring Web MVC `DispatcherServlet` 中暴露 `AccountService`（前面提到过），需要在调度程序的应用程序上下文中使用以下配置，如以下示例所示：:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean name="/AccountService" class="org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter">
		<property name="service" ref="accountService"/>
		<property name="serviceInterface" value="example.AccountService"/>
	</bean>
----

这样一个公开的定义将通过 `DispatcherServlet` 的标准映射设备， 如在关于 <<remoting-caucho-protocols, Hession的章节>>中解释。

或者，您可以在根应用程序上下文中创建 `HttpInvokerServiceExporter`（例如，在 `'WEB-INF/applicationContext.xml'` 中），如以下示例所示:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean name="accountExporter" class="org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter">
		<property name="service" ref="accountService"/>
		<property name="serviceInterface" value="example.AccountService"/>
	</bean>
----

此外，在 `web.xml` 中为该公开定义一个对应的Servlet， 其Servlet名称与目标公开的bean名称相匹配。如下所示:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<servlet>
		<servlet-name>accountExporter</servlet-name>
		<servlet-class>org.springframework.web.context.support.HttpRequestHandlerServlet</servlet-class>
	</servlet>

	<servlet-mapping>
		<servlet-name>accountExporter</servlet-name>
		<url-pattern>/remoting/AccountService</url-pattern>
	</servlet-mapping>
----


[[remoting-httpinvoker-client]]
==== 在客户端链接服务

同样，从客户端链接服务非常类似于使用Hessian时的方式。通过使用代理，Spring可以将对HTTP POST请求的调用转换为指向公开服务的URL。以下示例显示如何配置:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="httpInvokerProxy" class="org.springframework.remoting.httpinvoker.HttpInvokerProxyFactoryBean">
		<property name="serviceUrl" value="https://remotehost:8080/remoting/AccountService"/>
		<property name="serviceInterface" value="example.AccountService"/>
	</bean>
----

如前所述，您可以选择要使用的HTTP客户端。默认情况下，`HttpInvokerProxy` 使用JDK的HTTP功能，但您也可以通过设置 `httpInvokerRequestExecutor` 属性来使用Apache `HttpComponents` 客户端。以下示例显示了如何执行此操作:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<property name="httpInvokerRequestExecutor">
		<bean class="org.springframework.remoting.httpinvoker.HttpComponentsHttpInvokerRequestExecutor"/>
	</property>
----

[[remoting-web-services]]
=== Java Web Services

Spring提供对标准Java Web服务API的完全支持:

* 使用JAX-WS暴露服务
* 使用JAX-WS访问Web服务

除了在Spring的核心中支持JAX-WS外，Spring的portfolio也具有 http://www.springframework.org/spring-ws[Spring Web Services] 的特点。这是一种以文档驱动的Spring Web服务为基础的解决方案， 它极力推荐用于构建现代的、经得起未来考验的Web服务。

[[remoting-web-services-jaxws-export-servlet]]
==== 使用JAX-WS公开基于Servlet的Web服务

Spring为JAX-WS Servlet端实现提供了一个方便的基类- `SpringBeanAutowiringSupport`。为了公开我们的 `AccountService`， 我们继承了Spring的 `SpringBeanAutowiringSupport` 类并在这里实现我们的业务逻辑， 通常是将调用委托给业务层。
我们将简单地使用spring的 `@Autowired` 注解来表达对Spring管理bean的这种依赖性。以下示例显示了扩展 `SpringBeanAutowiringSupport` 的类:

[source,java,indent=0]
----
	/**
	 * JAX-WS compliant AccountService implementation that simply delegates
	 * to the AccountService implementation in the root web application context.
	 *
	 * This wrapper class is necessary because JAX-WS requires working with dedicated
	 * endpoint classes. If an existing service needs to be exported, a wrapper that
	 * extends SpringBeanAutowiringSupport for simple Spring bean autowiring (through
	 * the @Autowired annotation) is the simplest JAX-WS compliant way.
	 *
	 * This is the class registered with the server-side JAX-WS implementation.
	 * In the case of a Java EE server, this would simply be defined as a servlet
	 * in web.xml, with the server detecting that this is a JAX-WS endpoint and reacting
	 * accordingly. The servlet name usually needs to match the specified WS service name.
	 *
	 * The web service engine manages the lifecycle of instances of this class.
	 * Spring bean references will just be wired in here.
	 */
	import org.springframework.web.context.support.SpringBeanAutowiringSupport;

	@WebService(serviceName="AccountService")
	public class AccountServiceEndpoint extends SpringBeanAutowiringSupport {

		@Autowired
		private AccountService biz;

		@WebMethod
		public void insertAccount(Account acc) {
			biz.insertAccount(acc);
		}

		@WebMethod
		public Account[] getAccounts(String name) {
			return biz.getAccounts(name);
		}
	}
----

我们的 `AccountServiceEndpoint` 需要在与Spring上下文相同的Web应用程序中运行，以允许访问Spring的工具。 默认情况下，在Java EE 环境中使用JAX-WS servlet端点部署的标准协定就是这种情况。 有关详细信息，请参阅各种Java EE  Web服务教程。

[[remoting-web-services-jaxws-export-standalone]]
==== 使用JAX-WS公开独立Web服务

Oracle JDK附带的内置JAX-WS提供程序通过使用JDK中包含的内置HTTP服务器支持Web服务的公开。Spring的 `SimpleJaxWsServiceExporter` 在Spring应用程序上下文中检测所有 `@WebService` 注解的bean，并通过默认的JAX-WS服务器（JDK HTTP服务器）公开它们。

在这种情况下， 端实例被定义并作为Spring bean来管理。它们将在JAX-WS引擎中注册， 但它们的生命周期将由Spring应用程序上下文来实现。这意味着像显式依赖注入这样的Spring功能可以应用到端点实例。 当然， 通过 `@Autowired` 的注解驱动的注入也会起作用。以下示例显示了如何定义这些bean:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean class="org.springframework.remoting.jaxws.SimpleJaxWsServiceExporter">
		<property name="baseAddress" value="http://localhost:8080/"/>
	</bean>

	<bean id="accountServiceEndpoint" class="example.AccountServiceEndpoint">
		...
	</bean>

	...
----

`AccountServiceEndpoint` 可以不用继承Spring的 `SpringBeanAutowiringSupport`，因为此示例中的端点是完全由Spring管理的bean。 这意味着端点实现可以如下（没有声明任何超类 - 而且Spring的 `@Autowired` 配置注解仍然被可用）:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@WebService(serviceName="AccountService")
	public class AccountServiceEndpoint {

		@Autowired
		private AccountService biz;

		@WebMethod
		public void insertAccount(Account acc) {
			biz.insertAccount(acc);
		}

		@WebMethod
		public List<Account> getAccounts(String name) {
			return biz.getAccounts(name);
		}
	}
----


[[remoting-web-services-jaxws-export-ri]]
==== 使用JAX-WS RI的Spring支持公开Web服务

Oracle的JAX-WS RI, 作为GlassFish项目的一部分，通过Spring的支持也作为JAX-WS Commons项目的一部分。这允许将 JAX-WS端点定义为Spring管理bean， 类似于 <<remoting-web-services-jaxws-export-standalone, 上一节>> 中讨论的独立模式。 但这一次是在Servlet环境中进行的

NOTE: 这在Java EE 环境中不可移植。 它主要用于非EE环境，例如Tomcat，它将JAX-WS RI作为Web应用程序的一部分嵌入。

与Servlet端的标准样式的不同之处在于，端实例本身的生命周期将由Spring来管理，并且在 `web.xml` 中将只定义一个JAX-WS Servlet。使用标准的Java EE 样式 (如上所述)， 每个服务端都有一个Servlet定义， 每个端通常委派给Spring bean(通过使用 `@Autowired`，如上所示)。

有关设置和使用方式的详细信息，请参阅 https://jax-ws-commons.java.net/spring/[https://jax-ws-commons.java.net/spring/]。

[[remoting-web-services-jaxws-access]]
==== 使用JAX-WS访问Web服务

Spring提供了两个工厂bean来创建JAX-WS Web服务代理，即 `LocalJaxWsServiceFactoryBean` 和 `JaxWsPortProxyFactoryBean`。
前者只能返回一个JAX-WS服务类供我们使用。后者是完整版本，可以返回实现我们的业务服务接口的代理。在以下示例中，我们使用 `JaxWsPortProxyFactoryBean为AccountService` 为 `AccountService` 端点创建代理（再次）：:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="accountWebService" class="org.springframework.remoting.jaxws.JaxWsPortProxyFactoryBean">
		<property name="serviceInterface" value="example.AccountService"/> <1>
		<property name="wsdlDocumentUrl" value="http://localhost:8888/AccountServiceEndpoint?WSDL"/>
		<property name="namespaceUri" value="https://example/"/>
		<property name="serviceName" value="AccountService"/>
		<property name="portName" value="AccountServiceEndpointPort"/>
	</bean>
----
<1> 其中 `serviceInterface` 是客户端使用的业务接口。


`wsdlDocumentUrl` 是WSDL文件的URL。Spring需要这样的启动时间来创建 JAX-WS服务。`namespaceUri` 对应于 .wsdl文件中的 `targetNamespace` 。`serviceName` 对应于.wsdl文件中的服务名称。 `portName` 对应于.wsdl文件中的端口名称。

访问Web服务现在非常容易， 因为我们有一个bean工厂， 它将公开它作为 `AccountService` 接口。我们可以在Spring中配置:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="client" class="example.AccountClientImpl">
		...
		<property name="service" ref="accountWebService"/>
	</bean>
----

从客户端代码中， 我们可以访问Web服务，就好像它是一个普通类一样:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class AccountClientImpl {

		private AccountService service;

		public void setService(AccountService service) {
			this.service = service;
		}

		public void foo() {
			service.insertAccount(...);
		}
	}
----

NOTE: 	上述情况略有简化， 因为JAX-WS需要端点接口和实现类来注解 `@WebService`、`@SOAPBinding` 等注解。这意味着您不能(很容易)使用普通的Java接口和实现类作为JAX-WS端点工件；首先您需要相应地对它们进行注解。 有关这些要求的详细信息 请参阅JAX-WS文档。

[[remoting-jms]]
=== JMS

您还可以使用JMS作为底层通信协议透明地公开服务。 JMS的远程支持在Spring Framework中是非常基础。它在同一个线程和同一个非事务性会话中发送和接收。 并且这样的吞吐量将非常依赖于实现，
请注意， 这些单线程和非事务性约束仅适用于Spring的JMS远程处理支持。有关Spring对JMS消息传递的丰富支持的信息， 请参见<<jms,JM>> (Java Message Service)

以下接口用于服务器端和客户端:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	package com.foo;

	public interface CheckingAccountService {

		public void cancelAccount(Long accountId);
	}
----

在服务器端使用上述接口的以下简单实现:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	package com.foo;

	public class SimpleCheckingAccountService implements CheckingAccountService {

		public void cancelAccount(Long accountId) {
			System.out.println("Cancelling account [" + accountId + "]");
		}
	}
----

此配置文件包含在客户端和服务器上共享的JMS基础结构bean:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean id="connectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory">
			<property name="brokerURL" value="tcp://ep-t43:61616"/>
		</bean>

		<bean id="queue" class="org.apache.activemq.command.ActiveMQQueue">
			<constructor-arg value="mmm"/>
		</bean>

	</beans>
----


[[remoting-jms-server]]
==== 服务端的配置

在服务器上， 您只需使用 `JmsInvokerServiceExporter` 公开服务对象:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean id="checkingAccountService"
				class="org.springframework.jms.remoting.JmsInvokerServiceExporter">
			<property name="serviceInterface" value="com.foo.CheckingAccountService"/>
			<property name="service">
				<bean class="com.foo.SimpleCheckingAccountService"/>
			</property>
		</bean>

		<bean class="org.springframework.jms.listener.SimpleMessageListenerContainer">
			<property name="connectionFactory" ref="connectionFactory"/>
			<property name="destination" ref="queue"/>
			<property name="concurrentConsumers" value="3"/>
			<property name="messageListener" ref="checkingAccountService"/>
		</bean>

	</beans>
----

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	package com.foo;

	import org.springframework.context.support.ClassPathXmlApplicationContext;

	public class Server {

		public static void main(String[] args) throws Exception {
			new ClassPathXmlApplicationContext("com/foo/server.xml", "com/foo/jms.xml");
		}
	}
----


[[remoting-jms-client]]
==== 客户端的配置

客户端只需要创建一个实现约定接口（`CheckingAccountService`）的客户端代理。

以下示例定义了可以注入其他客户端对象的bean（代理负责通过JMS将调用转发到服务器端对象）:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean id="checkingAccountService"
				class="org.springframework.jms.remoting.JmsInvokerProxyFactoryBean">
			<property name="serviceInterface" value="com.foo.CheckingAccountService"/>
			<property name="connectionFactory" ref="connectionFactory"/>
			<property name="queue" ref="queue"/>
		</bean>

	</beans>
----

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	package com.foo;

	import org.springframework.context.ApplicationContext;
	import org.springframework.context.support.ClassPathXmlApplicationContext;

	public class Client {

		public static void main(String[] args) throws Exception {
			ApplicationContext ctx = new ClassPathXmlApplicationContext("com/foo/client.xml", "com/foo/jms.xml");
			CheckingAccountService service = (CheckingAccountService) ctx.getBean("checkingAccountService");
			service.cancelAccount(new Long(10));
		}
	}
----



[[remoting-amqp]]
=== AMQP
有关详细信息，请参阅Spring AMQP参考指南的“使用AMQP进行 {doc-spring-amqp}/html/#remoting[Spring Remoting] 部分 。

[[remoting-autodection-remote-interfaces]]
[NOTE]
====
远程接口未实现自动检测

远程接口不发生自动检测实现的接口的主要原因是避免向远程调用方打开太多的门，目标对象可能实现内部回调接口，例如 `InitializingBean或DisposableBean`，它们不希望向调用者公开。

在本地情况下， 向代理提供由目标实现的所有接口通常并不重要。但是， 当公开远程服务时， 应公开特定的服务接口， 并使用特定的操作来进行远程使用。 除内部回调接口外， 目标可能实现多个业务接口， 其中仅有一个用于远程公开。由于这些原因， 我们需要指定这样的服务接口。

这是配置方便和意外暴露内部方法风险之间的权衡，总是指定一个服务接口并不费劲， 并把你放在安全方面的控制公开的特定方法。
====



[[remoting-considerations]]
=== 选择技术时的注意事项

这里介绍的每项技术都有其缺点。 在选择技术时，您应该仔细考虑您的需求，您公开的服务以及通过网络发送的对象。

当使用RMI，不可能通过HTTP协议来访问到这些对象，除非你使用了RMI的隧道。RMI是一个重量级的协议，支持全功能的序列化策略，这在使用需要在线上进行序列化的复杂数据模型时非常重要。 但是， RMI-JRMP与Java客户端绑定在一起，它是一种Java-to-Java远程处理解决方案。

如果您需要基于HTTP的远程处理，而且还依赖于Java序列化，那么Spring的HTTP调用程序是一个不错的选择。它与RMI调用共享基本的基础结构， 只是使用HTTP作为传输。 请注意，HTTP调用程序不仅限于Java-to-Java远程处理，还包括客户端和服务器端的Spring。（后者也适用于Spring的非RMI接口的RMI调用程序。）

在跨平台中使用时，Hessian是很好的选择，因为它们明确允许非Java客户端。但是，非Java支持仍然有限。已知问题包括Hibernate对象的序列化以及延迟初始化的集合。如果您有这样的数据模型，请考虑使用RMI或HTTP调用程序而不是Hessian。

JMS可用于提供服务群集， 并允许JMS代理处理负载平衡、发现和自动故障转移。 默认情况下， 在使用JMS远程处理时使用Java序列化， 但JMS提供程序可以对格式使用不同的机制， 例如XStream以允许在其他技术中实现服务器。

最后但并非最不重要的是，EJB具有优于RMI的优势，因为它支持标准的基于角色的身份验证和授权以及远程事务传播。有可能让RMI调用者或HTTP调用者也支持安全上下文传播，尽管核心Spring没有提供。 Spring仅提供适当的挂钩，用于插入第三方或自定义解决方案。

[[rest-client-access]]
=== REST 端点

Spring Framework为调用REST端点提供了两种选择：

* <<rest-resttemplate,使用 RestTemplate>>: 原始的Spring REST客户端与在Spring中API相似于其他模板类，例如JdbcTemplate
* <<web-reactive.adoc#webflux-client, WebClient>>: a响应式替代方案，支持同步和异步以及流方案。

NOTE: 	从5.0开始，非阻塞，反应式 `WebClient` 提供了 `RestTemplate` 的现代替代方案，同时有效支持同步和异步以及流方案。 `RestTemplate` 将在未来版本中弃用，并且不会在未来添加主要的新功能。

[[rest-resttemplate]]
==== `RestTemplate`

`RestTemplate` 在HTTP客户端库上提供了更高级别的API，它使得在一行中调用REST端点变得容易。 它公开了以下重载方法组：

[[rest-overview-of-resttemplate-methods-tbl]]
.RestTemplate 方法
[cols="1,3"]
|===
| Method group | Description

| `getForObject`
| 通过GET获取响应。

| `getForEntity`
| 使用GET获取 `ResponseEntity` (即status, headers和body)

| `headForHeaders`
| 使用 HEAD 获取所有 headers

| `postForLocation`
| 使用POST创建新资源，并从响应中返回 `Location` 标头。

| `postForObject`
| 使用POST创建新资源并从响应中返回表示。

| `postForEntity`
| 使用POST创建新资源并从响应中返回表示。

| `put`
| 使用PUT创建或更新资源。

| `patchForObject`
| 使用PATCH更新资源并从响应中返回表示。 请注意，JDK `HttpURLConnection` 不支持 `PATCH`，但Apache `HttpComponents` 和其他一样。

| `delete`
| 使用DELETE删除指定URI处的资源。

| `optionsForAllow`
| 使用ALLOW检索资源的允许HTTP方法。

| `exchange`
| 上述方法的更通用（且不太固定）的版本，在需要时提供额外的灵活性。 它接受 `RequestEntity`（包括HTTP方法，URL，headers和正文作为输入）并返回 `ResponseEntity`。

这些方法允许使用 `ParameterizedTypeReference` 而不是 `Class` 来指定具有泛型的响应类型。

| `execute`
| 执行请求的最通用方式，通过回调接口完全控制请求准备和响应提取。
|===

[[rest-resttemplate-create]]
===== 初始化

默认构造函数使用 `java.net.HttpURLConnection` 来执行请求。 您可以使用 `ClientHttpRequestFactory` 的实现切换到不同的HTTP库。 内置支持以下内容：ation of `ClientHttpRequestFactory`.

* Apache HttpComponents
* Netty
* OkHttp

例如，要切换到Apache HttpComponents，您可以使用以下命令：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	RestTemplate template = new RestTemplate(new HttpComponentsClientHttpRequestFactory());
----

每个 `ClientHttpRequestFactory` 都公开特定于底层HTTP客户端库的配置选项 - 例如，用于凭据，连接池和其他详细信息。

TIP: 请注意，HTTP请求的 `java.net` 实现在访问表示错误的响应的状态（例如401）时可能引发异常。 如果这是一个问题，请切换到另一个HTTP客户端库。

[[rest-resttemplate-uri]]
===== URIs

许多 `RestTemplate` 方法接受URI模板和URI模板变量，可以是 `String` 变量参数，也可以是 `Map<String,String>`。

以下示例使用String变量参数：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	String result = restTemplate.getForObject(
			"https://example.com/hotels/{hotel}/bookings/{booking}", String.class, "42", "21");
----

以下示例使用 `Map<String, String>`:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	Map<String, String> vars = Collections.singletonMap("hotel", "42");

	String result = restTemplate.getForObject(
			"https://example.com/hotels/{hotel}/rooms/{hotel}", String.class, vars);
----

请记住，URI模板是自动编码的，如以下示例所示：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	restTemplate.getForObject("https://example.com/hotel list", String.class);

	// Results in request to "https://example.com/hotel%20list"
----

您可以使用 `RestTemplate` 的 `uriTemplateHandler` 属性来自定义URI的编码方式。 或者，您可以准备 `java.net.URI` 并将其传递给接受URI的 `RestTemplate` 方法之一。

有关使用和编码URI的更多详细信息，请参阅<<web.adoc#mvc-uri-building, URI Links>>。

[[rest-template-headers]]
===== Headers

您可以使用 `exchange()` 方法指定请求头，如以下示例所示：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	String uriTemplate = "https://example.com/hotels/{hotel}";
	URI uri = UriComponentsBuilder.fromUriString(uriTemplate).build(42);

	RequestEntity<Void> requestEntity = RequestEntity.get(uri)
			.header(("MyRequestHeader", "MyValue")
			.build();

	ResponseEntity<String> response = template.exchange(requestEntity, String.class);

	String responseHeader = response.getHeaders().getFirst("MyResponseHeader");
	String body = response.getBody();
----

您可以通过返回 `ResponseEntity` 的许多 `RestTemplate` 方法变体获取响应头。

[[rest-template-body]]
===== Body

传递到 `RestTemplate` 方法并从 `RestTemplate` 方法返回的对象在 `HttpMessageConverter` 的帮助下转换为原始内容和从原始内容转换。

在POST上，输入对象被序列化到请求主体，如以下示例所示：

----
URI location = template.postForLocation("https://example.com/people", person);
----

您无需显式设置请求的 `Content-Type` 头。在大多数情况下，您可以找到基于源对象类型的兼容消息转换器，并且所选消息转换器会相应地设置内容类型。 如有必要，您可以使用 `exchange` 方法显式提供 `Content-Type` 请求头，这反过来会影响选择的消息转换器。

在GET上，响应的主体被反序列化为输出 `Object`，如以下示例所示：

----
Person person = restTemplate.getForObject("https://example.com/people/{id}", Person.class, 42);
----

不需要显式设置请求的 `Accept` 头。在大多数情况下，可以根据预期的响应类型找到兼容的消息转换器，然后有助于填充Accept头。如有必要，可以使用 `exchange` 方法显式提供 `Accept` 头。

默认情况下， `RestTemplate` 会注册所有消息转换器，具体取决于有助于确定存在哪些可选转换库的类路径检查。 您还可以将<<rest-message-conversion, 消息转换>>器设置为显式使用。

[[rest-message-conversion]]
===== Message Conversion
[.small]#<<web-reactive.adoc#webflux-codecs, WebFlux>>#

`spring-web` 模块包含 `HttpMessageConverter`，用于通过 `InputStream` 和 `OutputStream` 读取和写入HTTP请求和响应的主体。 `HttpMessageConverter` 实例用于客户端（例如，在 `RestTemplate` 中）和服务器端（例如，在Spring MVC REST控制器中）。

框架中提供了主要媒体（MIME）类型的具体实现，默认情况下，它们在客户端注册 `RestTemplate` ，在服务器端注册 `RequestMethodHandlerAdapter`（请参阅<<web.adoc#mvc-config-message-converters, 配置消息转换器>>）。

`HttpMessageConverter` 的实现将在以下部分中介绍。 对于所有转换器，使用默认媒体类型，但您可以通过设置 `supportedMediaTypes` bean属性来覆盖它。 下表描述了每种实现：

[[rest-message-converters-tbl]]
.HttpMessageConverter 实现
[cols="1,3"]
|===
| MessageConverter | 描述

| `StringHttpMessageConverter`
| 一个 `HttpMessageConverter` 实现，可以从HTTP请求和响应中读取和写入 `String` 实例。 默认情况下，此转换器支持所有文本媒体类型（`text/*`），并使用 `Content-Type` 为 `text/plain` 进行写入。

| `FormHttpMessageConverter`
|
一个 `HttpMessageConverter` 实现，可以从HTTP请求和响应中读取和写入表单数据。 默认情况下，此转换器读取和写入 `application/x-www-form-urlencoded` 媒体类型。表单数据从 `MultiValueMap<String, String>` 读取并写入。
转换器还可以将 `MultiValueMap<String, String>` 写入 （但不能读）multipart 数据，
从“ MultiValueMap <String，Object>”读取的数据。 默认情况下， `multipart/form-data` 是支持的。 从Spring Framework 5.2开始，可以支持其他的多部分子类型。编写表格数据。 有关更多详细信息，请查阅Javadoc中的 `FormHttpMessageConverter`。

| `ByteArrayHttpMessageConverter`
| 一个 `HttpMessageConverter` 实现，可以从HTTP请求和响应中读取和写入字节数组。 默认情况下，此转换器支持所有媒体类型（`*/*`），并使用 `Content-Type` 为 `application/octet-stream` 进行写入。 您可以通过设置 `supportedMediaTypes` 属性并覆盖 `getContentType(byte[])` 来覆盖它。

| `MarshallingHttpMessageConverter`
|
一个 `HttpMessageConverter` 实现，可以使用 `org.springframework.oxm` 包中的Spring的 `Marshaller` 和 `Unmarshaller` 抽象来读写XML。 该转换器需要 `Marshaller` 和 `Unmarshaller` 才能使用。 您可以通过构造函数或bean属性注入这些。 默认情况下，此转换器支持 `text/xml` 和 `application/xml`。

| `MappingJackson2HttpMessageConverter`
|
一个 `HttpMessageConverter` 实现，可以使用Jackson的 `ObjectMapper` 读写JSON。您可以根据需要通过使用Jackson提供的注解来自定义JSON映射。
当您需要进一步控制时（对于需要为特定类型提供自定义JSON序列化器/反序列化器的情况），您可以通过 `ObjectMapper` 属性注入自定义 `ObjectMapper`。 默认情况下，此转换器支持 `application/json`。

| `MappingJackson2XmlHttpMessageConverter`
| 一个 `HttpMessageConverter` 实现，可以使用 https://github.com/FasterXML/jackson-dataformat-xml[Jackson XML] 扩展的 `XmlMapper` 读写XML。 您可以根据需要通过使用JAXB或Jackson提供的注解来自定义XML映射。
当您需要进一步控制时（对于需要为特定类型提供自定义XML序列化器/反序列化器的情况），您可以通过 `ObjectMapper` 属性注入自定义 `XmlMapper`。 默认情况下，此转换器支持 `application/xml`。

| `SourceHttpMessageConverter`
| 一个 `HttpMessageConverter` 实现，可以从HTTP请求和响应中读取和写入 `javax.xml.transform.Source`。 仅支持 `DOMSource`，`SAXSource` 和 `StreamSource`。 默认情况下，此转换器支持 `text/xml` 和 `application/xml`。

| `BufferedImageHttpMessageConverter`
| 一个 `HttpMessageConverter` 实现，可以从HTTP请求和响应中读取和写入 `java.awt.image.BufferedImage`。 此转换器读取和写入Java I/O API支持的媒体类型。

|===

[[rest-template-jsonview]]
===== Jackson JSON 视图

您可以指定 https://www.baeldung.com/jackson-json-view-annotation[Jackson JSON 视图]以仅序列化对象属性的子集，如以下示例所示：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	MappingJacksonValue value = new MappingJacksonValue(new User("eric", "7!jd#h23"));
	value.setSerializationView(User.WithoutPasswordView.class);

	RequestEntity<MappingJacksonValue> requestEntity =
		RequestEntity.post(new URI("https://example.com/user")).body(value);

	ResponseEntity<String> response = template.exchange(requestEntity, String.class);
----

[[rest-template-multipart]]
===== Multipart

要发送多部分数据，您需要提供 `MultiValueMap<String, ?>` ，其值是表示部件内容的 `Object` 实例或表示部件的内容和标头的 `HttpEntity` 实例。 `MultipartBodyBuilder` 提供了一个方便的API来准备多部分请求，如下例所示：

[source,java,intent=0]
[subs="verbatim,quotes"]
----
	MultiValueMap<String, Object> parts = new LinkedMultiValueMap<>();

	parts.add("fieldPart", "fieldValue");
	parts.add("filePart", new FileSystemResource("...logo.png"));
	parts.add("jsonPart", new Person("Jason"));

	HttpHeaders headers = new HttpHeaders();
	headers.setContentType(MediaType.APPLICATION_XML);
	parts.add("xmlPart", new HttpEntity<>(myBean, headers));
----

在大多数情况下，您不必为每个部件指定 `Content-Type` 。内容类型是根据选择用于序列化它的 `HttpMessageConverter` 自动确定的，或者在有资源的情况下，基于文件扩展名自动确定。
如有必要，您可以通过其中一个重载的构建器 part 方法显式提供要用于每个部件的 `MediaType`。

一旦 `MultiValueMap` 准备就绪，您可以将其传递给 `RestTemplate`，如以下示例所示：

[source,java,intent=0]
[subs="verbatim,quotes"]
----
	MultiValueMap<String, Object> parts = ...;
	template.postForObject("https://example.com/upload", parts, Void.class);
----

如果 `MultiValueMap` 包含至少一个非 `String` 值，该值也可以表示常规表单数据（即 `application/x-www-form-urlencoded`），则无需将 `Content-Type` 设置为 `multipart/form-data`。
当您使用确保 `HttpEntity` 包装器的 `MultipartBodyBuilder` 时，情况总是如此。

[[rest-async-resttemplate]]
==== 使用 `AsyncRestTemplate` (已废弃)

不推荐使用 `AsyncRestTemplate`。 对于您可能考虑使用 `AsyncRestTemplate` 的所有用例，请改用<<web-reactive.adoc#webflux-client, WebClient>>  。

[[ejb]]
==  企业级JavaBean(EJB) 集成

作为轻量级容器， Spring通常被视为EJB的替代者。我们确实认为， 对于许多应用程序和用例来说， Spring作为一个容器， 加上其在事务、ORM 和JDBC访问方面的丰富支持功能， 比通过EJB容器和EJB实现等效功能更有选择。

但是， 重要的是要注意， 使用Spring不会阻止您使用EJB。实际上， Spring使访问EJB和在其中实现EJB和功能变得更加容易。此外， 通过使用Spring来访问EJB提供的服务， 可以在本地EJB、远程EJB或POJO(普通的Java对象）变体之间切换这些服务的实现， 而无需更改客户端代码。

在本章中， 我们来看看Spring如何帮助您访问和实现EJB。Spring在访问无状态会话bean(SLSBs)时提供了特定的值， 因此我们将从讨论这个开始。

[[ejb-access]]
=== 访问 EJB

本节介绍如何访问EJB.

[[ejb-access-concepts]]
==== 概念

若要在本地或远程无状态会话bean上调用方法， 客户端代码通常必须执行JNDI查找以获取(本地或远程)EJB主对象， 然后对该对象使用 `create` 方法调用以获取实际(本地或远程)EJB对象，然后在EJB上调用一个或多个方法。

为避免重复的低级代码，许多EJB应用程序使用Service Locator（服务定位器模式）和Business Delegate（业务委托模式）。这些都比在整个客户端代码中充满JNDI查找更好，但它们通常的实现具有明显的缺点：

* 通常，使用EJB的代码依赖于Service Locator或Business Delegate单例，这使得很难进行测试。
* 对于没有业务代表使用的服务定位器模式，应用程序代码仍然必须在EJB主目录上调用create()方法并处理生成的异常。 因此，它仍然与EJB API和EJB编程模型的复杂性联系在一起。
* 实现业务委托模式通常会导致严重的代码重复，我们必须编写大量在EJB上调用相同方法的方法。

Spring方法是允许创建和使用代理对象， 通常在Spring容器中配置， 作为无需代码的业务委派。您不需要在手动编码的业务委派中编写另一个服务定位器、另一个JNDI查找或重复方法， 除非实际上在这些代码中添加了实际值。


[[ejb-access-local]]
==== 访问本地的SLSBs

假设我们有一个需要使用本地EJB的Web控制器。我们将遵循最佳实践并使用EJB业务方法接口模式， 以便EJB的本地接口继承非EJB特定的业务方法接口。我们将此业务方法称为 `MyComponent` 接口。 以下示例显示了这样的接口：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public interface MyComponent {
		...
	}
----

使用业务方法接口模式的主要原因之一是确保本地接口中的方法签名和bean实现类之间的同步是自动的。另一个原因是， 它后来使我们更容易切换到POJO(普通、旧的Java对象)的服务实现，如果它有意义的这样做。
当然， 我们还需要实现本地 `home` 接口， 并提供实现 `SessionBean` 和 `MyComponent` 业务方法接口的实现类。现在， 我们需要做的唯一的Java编码来将我们的Web层控制器与EJB实现挂钩， 就是在控制器上公开一个类型 `MyComponent` 的setter方法。这将将引用保存为控制器中的实例变量：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	private MyComponent myComponent;

	public void setMyComponent(MyComponent myComponent) {
		this.myComponent = myComponent;
	}
----

随后， 我们可以在控制器中的任何业务方法中使用此实例变量。现在假设我们从Spring容器中获取控制器对象， 我们可以 (在同一上下文中)配置一个 `LocalStatelessSessionProxyFactoryBean` 实例， 它将是EJB代理对象。 代理的配置以及控制器的 `myComponent` 属性的设置是通过配置项完成的， 例如：

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="myComponent"
			class="org.springframework.ejb.access.LocalStatelessSessionProxyFactoryBean">
		<property name="jndiName" value="ejb/myBean"/>
		<property name="businessInterface" value="com.mycom.MyComponent"/>
	</bean>

	<bean id="myController" class="com.mycom.myController">
		<property name="myComponent" ref="myComponent"/>
	</bean>
----

有很多工作发生在幕后， 这得益于Spring的AOP框架， 虽然你不被迫使用AOP的概念来享受结果。`myComponent` bean定义为EJB创建了一个代理， 它实现了业务方法接口。 EJB本地主页是在启动时缓存的， 因此只有一个JNDI查找。每次调用EJB 时， 代理都调用本地AOP上的classname 方法， 并调用AOP上相应的业务方法。

`myController` bean定义将控制器类的 `myComponent` 属性设置为EJB代理。

或者(最好是在许多这样的代理定义的情况下), 考虑使用Spring的 "`jee`" 命名空间中的  `<jee:local-slsb>`  配置元素。 以下示例说明了如何执行此操作:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<jee:local-slsb id="myComponent" jndi-name="ejb/myBean"
			business-interface="com.mycom.MyComponent"/>

	<bean id="myController" class="com.mycom.myController">
		<property name="myComponent" ref="myComponent"/>
	</bean>
----

此EJB访问机制提供了应用程序代码的巨大简化， Web层代码(或其他EJB客户端代码)不依赖于EJB的使用。如果要用POJO或mock对象或其他测试存根替换此EJB引用， 我们只需更改 `myComponent` bean定义， 而不更改一行Java代码。此外， 我们还不必编写一行JNDI查找或其他EJB管道代码作为应用程序的一部分。

在实际应用中的基准和经验表明， 这种方法(涉及对目标EJB的反射调用)的性能开销是最小的， 通常在典型的使用中是无法检测到的。请记住， 无论如何， 我们不希望对EJB进行fine-grained调用， 因为在应用程序服务器中存在与EJB基础结构相关的成本。

关于JNDI查找有一个警告。在bean容器中， 此类通常作为单一实例最好使用(根本没有理由使其成为原型)。但是， 如果该bean容器pre-instantiates单变量(与各种XML `ApplicationContext` 变体一样)，
则在EJB容器加载目标EJB之前装载 bean容器时可能会出现问题。这是因为JNDI查找将在该类的 `init()` 方法中执行, 然后缓存, 但EJB还没有被绑定到目标位置.解决方案是不pre-instantiate此工厂对象, 但允许它在首次使用时创建在XML容器中, 这是通过 `lazy-init` 属性来控制的。

虽然大多数Spring用户不感兴趣，但那些使用EJB编程AOP的人可能希望查看 `LocalSlsbInvokerInterceptor`。

[[ejb-access-remote]]
==== 访问远程的SLSBs

访问远程EJB与访问本地EJB基本相同， 只是使用了 `SimpleRemoteStatelessSessionProxyFactoryBean` 或 `<jee:remote-slsb>` 配置元素。当然， 无论有无Spring， 远程调用语义都适用。
在另一台计算机的另一个VM中对某个对象的方法的调用有时必须在使用方案和失败处理方面得到不同的处理。

Spring的EJB客户端支持在非Spring方法上增加了一个优势。通常， EJB客户端代码在本地或远程调用EJB之间很容易来回切换是有问题的。这是因为远程接口方法必须声明它们抛出 `RemoteException`， 而客户端代码必须处理此问题， 而本地接口方法则不这样做。
为本地EJB编写的客户端代码需要移动到远程EJB， 通常必须进行修改， 以便为远程异常添加处理， 为需要移动到本地EJB的远程EJB编写的客户端代码， 可以保持不变， 但会对远程异常进行大量不必要的处理， 或者需要修改以删除该代码。
使用Spring远程EJB代理， 您可以不在业务方法接口中声明任何抛出的 `RemoteException`， 也不能实现EJB代码， 它具有一个完全相同的远程接口， 但它确实抛出了 `RemoteException`， 并且依赖于代理来动态处理这两个接口， 就好像它们是相同的一样。
即 客户端代码不必处理已检查的 `RemoteException` 类。在EJB调用期间抛出的任何实际 `RemoteException` 都将引发为 non-checked `RemoteAccessException` 类， 这是 `RuntimeException` 的一个子类别。
然后， 可以将目标服务切换到本地EJB或远程EJB(甚至是普通Java对象) 实现之间， 而无需客户端代码知道或关心。当然， 这是可选的。没有什么能阻止您在业务界面中声明 `RemoteExceptions`。

[[ejb-access-ejb2-ejb3]]
==== 访问EJB 2.x SLSBs 和 EJB 3 SLSBs

通过Spring访问EJB 2.x 会话bean和EJB 3会话bean在很大程度上是透明的。Spring的EJB访问器(包括 `<jee:local-slsb>` 和 `<jee:remote-slsb>` 功能) 在运行时透明地适应实际组件。 如果找到了一个主接口(EJB 2.x 样式)， 或者如果没有可用的主接口(EJB 3 样式)， 则执行直接组件调用。

Note: 对于EJB 3会话bean， 您可以有效地使用 `JndiObjectFactoryBean/<jee:jndi-lookup>`， 因为完全可用的组件引用会在那里公开进行纯JNDI查找。 定义显式 `<jee:local-slsb>` 或 `<jee:remote-slsb>` 查找只是提供一致且更显式的EJB访问配置。

[[jms]]
== JMS (Java 消息服务)

Spring提供了一个JMS集成框架， 它简化了JMS API的使用， 就像Spring对JDBC API的集成一样。

JMS可以大致分为两个功能领域， 即消息的生产和消费。`JmsTemplate` 类用于消息生成和同步消息接收。对于类似于Java EE的消息驱动bean样式的异步接收， Spring提供了许多用于创建消息驱动的pojo(MDPs)的消息监听器容器。Spring还提供了一种创建消息监听器的声明方式。

`org.springframework.jms.core` 提供了使用JMS的核心功能。包含JMS模板类， 通过处理资源的创建和释放来简化JMS的使用， 就像 `JdbcTemplate` 对JDBC所做的那样。 Spring模板类的通用设计原则是提供帮助器方法来执行常见操作和更复杂的用法， 将处理任务的本质委托给用户实现的回调接口。JMS模板遵循相同的设计。这些类为发送消息提供了各种方便方法， 同步地使用消息， 并向用户公开JMS会话和消息生成器。

`org.springframework.jms.support` 提供 `JMSException` 的转换功能。转换将选中的 `JMSException` 层次结构转换为未选中的异常的镜像层次结构。如果已选中的 `javax.jms.JMSException` 有任何提供程序特定的子类， 则此异常将包装在未选中的 `UncategorizedJmsException` 中（选中：checked，未选中：unchecked）。

`org.springframework.jms.support.converter` 提供了一个 `MessageConverter` 的抽象， 用于在Java对象和JMS消息之间进行转换。

`org.springframework.jms.support.destination` 为管理JMS目的地提供了各种策略， 例如为存储在JNDI中的目的地提供服务定位器。

`org.springframework.jms.annotation` 提供了必要的基础架构， 以支持使用 `@JmsListener` 的注解驱动的监听器端点。

`org.springframework.jms.config` 为 `jms` 命名空间提供解析器实现， 以及Java配置支持来配置监听器容器和创建监听器端点。

最后, `org.springframework.jms.connection` 提供了适用于独立应用程序的 `ConnectionFactory` 的实现。它还包含一个 Spring的 `PlatformTransactionManager` JMS实现(命名为 `JmsTransactionManager`)。这允许将JMS作为事务性资源无缝集成到Spring的事务管理机制中。

[NOTE]
====
从Spring Framework 5开始，Spring的JMS软件包完全支持JMS 2.0，并要求在运行时提供JMS 2.0 API。 我们建议使用JMS 2.0兼容的提供程序。

如果您碰巧在系统中使用了较旧的消息代理，则可以尝试为现有的代理生成升级到JMS 2.0兼容驱动程序。 或者，您也可以尝试针对基于JMS 1.1的驱动程序运行，只需将JMS 2.0 API jar放在类路径上，而仅对驱动程序使用兼容JMS 1.1的API。
Spring的JMS支持默认情况下遵守JMS 1.1约定，因此通过相应的配置它确实支持这种情况。 但是，请仅在过渡方案中考虑这一点。
====

[[jms-using]]
=== 使用 Spring JMS

本章节主要介绍如何使用 Spring JMS 组件.


[[jms-jmstemplate]]
==== 使用 `JmsTemplate`

`JmsTemplate` 类 是JMS核心包中的中心类，它简化了JMS的使用， 因为它在发送或同步接收消息时处理资源的创建和释放。

使用 `JmsTemplate` 的代码只需实现回调接口， 就可以为它们提供明确定义的高级功能。`MessageCreator` 回调接口在 `JmsTemplate` 的调用代码提供的会话中创建一条消息。 为了允许更复杂地使用JMS API， 回调 `SessionCallback` 为用户提供了JMS会话， 回调 `ProducerCallback` 公开了一个会话和 `MessageProducer` 配对。

JMS API公开了两种类型的发送方法， 一种是将传递模式、优先级和生存作为服务质量 (Qos) 参数， 另一个不采用使用默认值的Qos参数。由于 `JmsTemplate` 中有许多发送方法， 所以QoS参数的设置已作为bean属性公开， 以避免发送方法的数量重复。同样， 使用属性 `setReceiveTimeout` 设置同步接收调用的超时值。

某些JMS提供程序允许通过 `ConnectionFactory` 的配置管理默认QoS值的设置。这会影响到对 `MessageProducer` 的send方法(`send(Destination destination, Message message)`)的调用将使用与JMS规范中指定的不同的QoS默认值。 为了提供对QoS值的一致管理，因此必须通过将布尔属性 `isExplicitQosEnabled` 设置为 `true` 来明确地启用 `JmsTemplate` 以使用其自身的QoS值。

为方便起见， `JmsTemplate` 还公开了一个基本的请求-答复操作， 允许发送消息并等待在作为操作一部分创建的临时队列上的答复。

IMPORTANT: `JmsTemplate` 类的实例在配置后是线程安全的。这很重要， 因为这意味着您可以配置 `JmsTemplate` 的单个实例， 然后将此共享引用安全地插入到多个协作者中。 要清楚， `JmsTemplate` 是有状态的， 因为它维护对 `ConnectionFactory` 的引用， 但此状态不是会话状态。

在Spring 4.1框架中, `JmsMessagingTemplate` 是在 `JmsTemplate` 之上构建的， 它提供了与消息抽象(即 `org.springframework.messaging.Message`)的集成.这使您可以创建以通用方式发送的消息.

[[jms-connections]]
==== Connections

`JmsTemplate` 需要 `ConnectionFactory` 的引用，`ConnectionFactory` 是JMS规范的一部分，是使用JMS的入口点。它由客户端应用程序用作工厂来创建与JMS提供程序的连接，并封装各种配置参数，其中许多是特定于供应商的，如SSL配置选项。

在 EJB 中使用JMS时， 供应商提供JMS接口的实现， 以便它们可以参与声明性事务管理并执行连接和会话池。为了使用此实现， Java EE容器通常要求您将JMS连接工厂声明为EJB或Servlet部署描述符内的 `resource-ref`。 为了确保将这些功能与EJB中的 `JmsTemplate` 一起使用， 客户端应用程序应确保它引用 `ConnectionFactory` 的托管实现。

[[jms-caching-resources]]
===== 缓存消息资源

标准API涉及创建许多中间对象，要发送消息， 请执行以 'API' 步骤：

[literal]
[subs="verbatim,quotes"]
----
ConnectionFactory->Connection->Session->MessageProducer->send
----

在 `ConnectionFactory` 和 `Send` 操作之间， 有三个中间对象被创建和销毁。为优化资源使用和提高性能， 提供了两个 `ConnectionFactory` 的实现。

[[jms-connection-factory]]
===== 使用 `SingleConnectionFactory`

Spring提供了 `ConnectionFactory` 接口的实现， `SingleConnectionFactory` 将在所有 `createConnection()` 调用中返回相同的 `Connection`， 并忽略 `close()` 的调用。
这对于测试和独立环境非常有用， 以便可以将相同的连接用于可能跨越任意数量事务的多个 `JmsTemplate` 调用，`SingleConnectionFactory` 引用的标准 `ConnectionFactory` 通常来自JNDI。

[[jdbc-connection-factory-caching]]
===== 使用 `CachingConnectionFactory`

`CachingConnectionFactory` 继承了 `SingleConnectionFactory` 的功能， 并添加了 `Session`, `MessageProducer`, 和 `MessageConsumer` 的缓存。初始缓存大小设置为 `1`， 使用属性 `sessionCacheSize` 增加缓存会话的数量。请注意， 实际缓存会话的数目将超过该数目，
因为会话是根据其确认模式缓存的， 因此， 当 `sessionCacheSize` 被设置为一个、每个确认模式为一个时， 最多可以有4个缓存会话实例。 `MessageProducer` 和 `MessageConsumer` 在其所属会话中被缓存， 并且在缓存时也考虑了生产者和使用者的独特属性。
`MessageProducers` 根据其目的地进行缓存，MessageConsumers是根据由目的地、选择器、noLocal传递标志和持久性订阅名称(如果创建耐用的使用者)组成的键进行缓存的。

[[jms-destinations]]
==== 目的地管理

目的地，如 `ConnectionFactory`，是JMS管理的对象，可以在JNDI中进行存储和检索。配置Spring应用程序上下文时，可以使用JNDI工厂类 `JndiObjectFactoryBean/<jee:jndi-lookup>` 对对象对JMS目标的引用执行依赖项注入。
但是，如果应用程序中有大量目的地，或者JMS提供程序具有唯一的高级目的地管理功能，则此策略通常很麻烦。此类高级目的地管理的示例包括创建动态目的地或支持目的地的分层命名空间.JmsTemplate将目标名称的解析委托给JMS目标对象，以实现接口 `DestinationResolver`。 `DynamicDestinationResolver` 是 `JmsTemplate` 使用的默认实现，可容纳解析动态目标。还提供了一个 `JndiDestinationResolver` ，它充当JNDI中包含的目标的服务定位器，并可选择退回到 `DynamicDestinationResolver` 中包含的行为。

在JMS应用程序中使用的目的地通常只在运行时才知道，因此在部署应用程序时无法进行管理创建。这通常是因为根据一个众所周知的命名约定，在运行时创建目的地的交互系统组件之间存在共享的应用程序逻辑。
尽管创建动态目的地不是JMS规范的一部分，但大多数供应商都提供了此功能。动态目的地是使用用户定义的名称来创建的，它们将它们与临时目的地区分开来，并且通常不在JNDI中注册。
由于与目的地关联的属性是特定于供应商的，因此用于创建动态目的地的API因提供程序而异。但是，供应商有时所做的简单实现选择是忽略JMS规范中的警告，
并使用 `TopicSession` 方法的 `createTopic(String topicName)` 字符串 `topicName` 或 `QueueSession` 方法的 `createQueue(String queueName)` 字符串 `queueName` 来创建具有默认目的地属性的新目的地。
根据供应商实施情况， `DynamicDestinationResolver` 可能还会创建物理目的地，而不是仅解析一个。

布尔属性 `pubSubDomain` 用于配置 `JmsTemplate`， 并了解所使用的JMS域。默认情况下， 此属性的值为 `false`， 表示将使用点到点域( `Queues`)。`JmsTemplate` 使用的此属性通过 `DestinationResolver` 接口的实现确定动态目的地解析的行为。

还可以通过属性 `defaultDestination` 将 `JmsTemplate` 配置为默认目的地，默认目的地将与不引用特定目的地的发送和接收操作一起使用。

[[jms-mdp]]
==== 消息监听容器

在EJB世界中，JMS消息最常见的一种用法是驱动消息驱动bean(mdb)。Spring提供了一种以不将用户与EJB容器绑定的方式创建消息驱动的pojo(mdp)的解决方案（请查看<<jms-receiving-async,异步接收>:消息驱动的 POJOs，用于详细报道Spring的MDP支持）。
在Spring 4.1框架后,端点方法可以简单地用 `@JmsListener` 注解，请参见 <<jms-annotated,注解驱动的监听器端点>>。

消息监听器容器用于接收来自JMS消息队列的消息，并驱动向其注入的 `MessageListener`。监听器容器负责消息接收的所有线程处理，并将其分派到监听器中以进行操作。消息监听器容器是MDP和消息传递提供程序之间的中介，它负责注册接收消息、参与事务、获取和释放资源、异常转换和类似的操作。 这样，您就可以作为应用程序开发人员编写与接收消息(可能响应)相关的(可能是复杂的)业务逻辑，并将样板JMS基础结构的关注委托给框架。

有两个标准的JMS消息监听器容器与Spring一起打包， 每个都有其专门的功能集

* <<jms-mdp-simple, `SimpleMessageListenerContainer`>>
* <<jms-mdp-default, `DefaultMessageListenerContainer`>>

[[jms-mdp-simple]]
===== 使用 `SimpleMessageListenerContainer`

`SimpleMessageListenerContainer` 消息监听器容器是两种标准中比较简单的一种，它在启动时创建一个固定数量的JMS会话和用户， 使用标准的JMS 的 `MessageConsumer.setMessageListener()` 方法注册监听器， 并将它留在JMS提供程序中以执行监听器回调。
此变量不允许动态适应运行时要求或参与外部托管事务。 兼容性方面，它非常接近独立JMS规范的精神，但通常与Java EE的JMS限制不兼容。

NOTE: 虽然 `SimpleMessageListenerContainer` 不允许参与外部管理的事务，它支持本机JMS事务：只需将 `sessionTransacted` 标志切换为 `true` ，或在命名空间中，将 `acknowledge` 属性设置为 `transacted`。从您的监听器抛出的异常然后导致回滚，并重新传递消息。或者，考虑使用 `CLIENT_ACKNOWLEDGE` 模式，该模式在异常的情况下也提供重新传递，但不使用事务会话实例，因此不包括事务协议中的任何其他会话操作（例如发送响应消息）。

IMPORTANT: 默认的 `AUTO_ACKNOWLEDGE` 模式不提供适当的可靠性保证。 当监听器执行失败时（由于提供程序在监听器调用后自动确认每条消息，没有异常传播到提供程序）或监听器容器关闭时（可以通过设置 `acceptMessagesWhileStopping` 标志来配置），消息可能会丢失。 确保在可靠性需求的情况下使用事务处理会话（例如，用于可靠的队列处理和持久主题订阅）。

[[jms-mdp-default]]
===== 使用 `DefaultMessageListenerContainer`

`DefaultMessageListenerContainer` 消息监听器容器是大多数情况下使用的。与 `SimpleMessageListenerContainer` 相比，此容器变量允许动态地适应运行时需求，并能够参与外部托管事务。 当配置了 `JtaTransactionManager` 时，每个收到的消息都在XA事务中注册。
因此，处理可以利用XA事务语义。此监听器容器在JMS提供程序的低需求、高级功能(如参与外部托管事务以及与Java EE环境的兼容性)之间取得了良好的平衡。

您可以自定义容器的缓存级别。 请注意，如果未启用缓存，则会为每个消息接收创建新连接和新会话。将其与具有高负载的非持久性订阅相结合可能会导致消息丢失。请确保在这种情况下使用适当的缓存级别。

当代理发生故障时，此容器还具有可恢复的功能。 默认情况下，简单的 `BackOff` 实现每五秒重试一次。 您可以为更细粒度的恢复选项指定自定义 `BackOff` 实现。 有关示例，请参阅 api-spring-framework/util/backoff/ExponentialBackOff.html[`ExponentialBackOff`]。

NOTE: 	与它的同级的<<jms-mdp-simple, `SimpleMessageListenerContainer`>>一样，`DefaultMessageListenerContainer` 支持本机JMS事务并允许自定义确认模式。如果您的方案可行，则强烈建议在外部管理的事务上进行此操作；即，如果您可以在JVM死亡的情况下使用偶尔重复的消息。 业务逻辑中的自定义重复消息检测步骤可能涵盖此类情况，例如以业务实体存在检查或协议表检查的形式。
任何此类安排都将比替代方案更有效。用XA事务包装您的整个处理(通过配置您的 `DefaultMessageListenerContainer` 与 `JtaTransactionManager`，涵盖JMS消息的接收以及消息监听器(包括数据库操作等)中业务逻辑的执行。

IMPORTANT: 默认的 `AUTO_ACKNOWLEDGE` 模式不提供适当的可靠性保证。 当监听器执行失败时（由于提供程序在监听器调用后自动确认每条消息，没有异常传播到提供程序）或监听器容器关闭时（可以通过设置 `acceptMessagesWhileStopping` 标志来配置），消息可能会丢失。 确保在可靠性需求的情况下使用事务处理会话（例如，用于可靠的队列处理和持久主题订阅）。

[[jms-tx]]
==== 事务管理

Spring提供了一个 `JmsTransactionManager`，用于管理单个JMS `ConnectionFactory` 事务。这使得JMS应用程序能够利用 如数据访问章节的<<data-access.adoc#transaction, 事务管理>>部分所述。`JmsTransactionManager` 执行本地资源事务，将 `JMSConnection/Session` 对从指定的 `ConnectionFactory` 绑定到线程。 `JmsTemplate` 自动检测此类事务性资源，并据此对其进行操作。

在Java EE环境中， `ConnectionFactory` 将建立连接池和会话池，因此这些资源可以在事务之间有效地重用。在独立的环境中，使用Spring的 `SingleConnectionFactory` 将导致共享的JMS `Connection`，每个事务都有自己的独立 `Session`。 或者，考虑使用提供程序特定的池适配器，如ActiveMQ的 `PooledConnectionFactory` 类。

`JmsTemplate` 还可以与 `JtaTransactionManager` 和具有XA能力的 `JMSConnectionFactory` 一起使用，用于执行分布式事务。 请注意，这需要使用JTA事务管理器以及正确配置XA的 `ConnectionFactory`。 （查看Java EE服务器或JMS提供程序的文档。）

使用JMS API从 `Connection` 创建 `Session` 时，在托管和非托管事务环境中重用代码可能会造成混淆。 这是因为JMS API只有一个工厂方法来创建 `Session`，它需要事务和确认模式的值。 在托管环境中，设置这些值是环境的事务基础结构的责任，因此供应商的JMS连接包装器会忽略这些值。 在非托管环境中使用 `JmsTemplate` 时，可以通过使用属性 `sessionTransacted` 和 `sessionAcknowledgeMode` 来指定这些值。 当您将 `PlatformTransactionManager` 与 `JmsTemplate` 一起使用时，模板始终会被赋予事务性JMS `Session`。

[[jms-sending]]
=== 发送消息

`JmsTemplate` 包含许多发送消息的便捷方法。 Send方法使用 `javax.jms.Destination` 对象指定目标，其他方法通过在JNDI查找中使用 `String` 指定目标。 不带目标参数的 `send` 方法使用默认目标。

以下示例使用 `MessageCreator` 回调从提供的 `Session` 对象创建文本消息：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	import javax.jms.ConnectionFactory;
	import javax.jms.JMSException;
	import javax.jms.Message;
	import javax.jms.Queue;
	import javax.jms.Session;

	import org.springframework.jms.core.MessageCreator;
	import org.springframework.jms.core.JmsTemplate;

	public class JmsQueueSender {

		private JmsTemplate jmsTemplate;
		private Queue queue;

		public void setConnectionFactory(ConnectionFactory cf) {
			this.jmsTemplate = new JmsTemplate(cf);
		}

		public void setQueue(Queue queue) {
			this.queue = queue;
		}

		public void simpleSend() {
			this.jmsTemplate.send(this.queue, new MessageCreator() {
				public Message createMessage(Session session) throws JMSException {
					return session.createTextMessage("hello queue world");
				}
			});
		}
	}
----

在前面的示例中，通过将引用传递给 `ConnectionFactory` 来构造 `JmsTemplate` 。作为替代方法，提供了无参数构造函数和 `connectionFactory`，可用于在JavaBean样式(使用 `BeanFactory` 或纯Java代码)中构造实例。或者，考虑从 Spring的 `JmsGatewaySupport` 方便基类派生，它为JMS配置提供了预构建的bean属性。

`send(String destinationName, MessageCreator creator)` 方法允许您使用目的地的字符串名称发送消息。如果这些名称是在JNDI中注册的，则应将该模板的 `destinationResolver` 属性设置为 `JndiDestinationResolver` 的实例。

如果创建了 `JmsTemplate` 并指定了默认目的地， 则 `send(MessageCreator c) `将向该目的地发送一条消息。

[[jms-msg-conversion]]
==== 使用消息转换器

为了便于发送域模型对象， `JmsTemplate` 有多种发送方法，它们将Java对象作为消息的数据内容的参数。`JmsTemplate` 中的重载方法 `convertAndSend()` 和 `receiveAndConvert()` 将转换过程委托给 `MessageConverter` 接口的实例。 此接口定义在Java对象和JMS消息之间转换的简单协定。默认实现 `SimpleMessageConverter` 支持 `String` 和 `TextMessage`, `byte[]` 和 `BytesMesssage`, 和 `java.util.Map` 和 `MapMessage`

沙箱当前包含一个 `MapMessageConverter`，它使用反射在JavaBean和 `MapMessage` 之间进行转换。 您可能自己实现的其他流行实现选择是使用现有XML编组包（例如JAXB，Castor或XStream）的转换器来创建表示对象的 `TextMessage`。

为了适应在转换器类中不能被全部封装的消息属性、报头和正文的设置，`MessagePostProcessor` 接口在转换后，即在发送消息之前，为您提供对该消息的访问权限。下面的示例演示如何在将 `java.util.Map` 转换为消息后修改消息头和属性。

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public void sendWithConversion() {
		Map map = new HashMap();
		map.put("Name", "Mark");
		map.put("Age", new Integer(47));
		jmsTemplate.convertAndSend("testQueue", map, new MessagePostProcessor() {
			public Message postProcessMessage(Message message) throws JMSException {
				message.setIntProperty("AccountID", 1234);
				message.setJMSCorrelationID("123-00001");
				return message;
			}
		});
	}
----

这会产生以下形式的消息：

[literal]
[subs="verbatim,quotes"]
----
MapMessage={
	Header={
		... standard headers ...
		CorrelationID={123-00001}
	}
	Properties={
		AccountID={Integer:1234}
	}
	Fields={
		Name={String:Mark}
		Age={Integer:47}
	}
}
----


[[jms-callbacks]]
==== 使用 `SessionCallback` 和 `ProducerCallback`

虽然发送操作涉及许多常见的使用方案，但在需要对JMS会话或 `MessageProducer` 执行多个操作时，也会出现这种情况。 `SessionCallback` 和 `ProducerCallback` 分别公开JMS `Session` 和 `Session` / `MessageProducer` 对。`JmsTemplate` 上的 `execute()` 方法执行这些回调方法。

[[jms-receiving]]
=== 接收消息

这描述了如何在Spring中使用JMS接收消息。


[[jms-receiving-sync]]
==== 同步接收

虽然JMS通常与异步处理相关联， 但可以同步使用消息。重载 `receive(..)` 方法可提供此功能。在同步接收过程中， 调用线程会一直阻塞， 直到消息变为可用。这可能是一个危险的操作， 因为调用线程可能会无限期地被阻塞。`receiveTimeout` 属性指定接收方在放弃等待消息之前应等待的时间。

[[jms-receiving-async]]
==== 异步接收：消息驱动的POJO

NOTE: Spring还通过使用 `@JmsListener` 注解支持带注解的监听器端点，并提供一个开放式基础架构以编程方式注册端。这是设置异步接收器的最方便的方法，有关更多详细信息，请参阅<<jms-annotated-support,启用监听器端点注解>> 。

以类似于EJB世界中的消息驱动Bean（MDB）的方式，消息驱动的POJO（MDP）充当JMS消息的接收器。 MDP上的一个限制（但请参阅 <<jms-receiving-async-message-listener-adapter,使用 `MessageListenerAdapter`>>）是它必须实现 `javax.jms.MessageListener` 接口。 请注意，如果您的POJO在多个线程上收到消息，请务必确保您的实现是线程安全的。

以下示例显示了MDP的简单实现：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	import javax.jms.JMSException;
	import javax.jms.Message;
	import javax.jms.MessageListener;
	import javax.jms.TextMessage;

	public class ExampleListener implements MessageListener {

		public void onMessage(Message message) {
			if (message instanceof TextMessage) {
				try {
					System.out.println(((TextMessage) message).getText());
				}
				catch (JMSException ex) {
					throw new RuntimeException(ex);
				}
			}
			else {
				throw new IllegalArgumentException("Message must be of type TextMessage");
			}
		}
	}
----

一旦实现了 `MessageListener`，就可以创建一个消息监听器容器了。

以下示例显示如何定义和配置Spring附带的消息监听器容器之一（在本例中为 `DefaultMessageListenerContainer`）：

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<!-- this is the Message Driven POJO (MDP) -->
	<bean id="messageListener" class="jmsexample.ExampleListener"/>

	<!-- and this is the message listener container -->
	<bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer">
		<property name="connectionFactory" ref="connectionFactory"/>
		<property name="destination" ref="destination"/>
		<property name="messageListener" ref="messageListener"/>
	</bean>
----

请参阅各种消息监听器容器的Spring javadoc（所有这些实现 {api-spring-framework}/jms/listener/MessageListenerContainer.html[MessageListenerContainer]）以获取每个实现支持的功能的完整描述。

[[jms-receiving-async-session-aware-message-listener]]
==== 使用 `SessionAwareMessageListener` 接口

`SessionAwareMessageListener` 接口是一个特定于Spring的接口，它提供与JMS `MessageListener` 接口类似的契约，但也提供消息处理方法访问接收消息的JMS会话。 以下清单显示了 `SessionAwareMessageListener` 接口的定义：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	package org.springframework.jms.listener;

	public interface SessionAwareMessageListener {

		void onMessage(Message message, Session session) throws JMSException;
	}
----

如果希望您的MDP能够响应任何收到的消息(通过使用 `onMessage(Message, Session)` 方法中提供的会话)，您可以选择让您的MDP实现此接口(优先于标准的JMS `MessageListener` 接口)。
与Spring一起发送的所有消息监听器容器实现都支持实现 `MessageListener` 或 `SessionAwareMessageListener` 接口的MDP。实现 `SessionAwareMessageListener` 的类随之而来的警告是，它们将通过接口绑定到Spring。
选择是否使用它完全由您作为应用程序开发人员或架构师来决定。

请注意，`SessionAwareMessageListener` 接口的 `onMessage(..)` 方法会抛出 `JMSException`。 与标准JMS `MessageListener` 接口相比，使用 `SessionAwareMessageListener` 接口时，客户端代码负责处理任何抛出的异常。

[[jms-receiving-async-message-listener-adapter]]
==== 使用 `MessageListenerAdapter`

`MessageListenerAdapter` 类是Spring的异步消息传递支持中的最后一个组件。 简而言之， 它允许您将几乎任何类作为 MDP(当然也有一些限制)。

请考虑以下接口定义：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public interface MessageDelegate {

		void handleMessage(String message);

		void handleMessage(Map message);

		void handleMessage(byte[] message);

		void handleMessage(Serializable message);
	}
----

请注意，虽然接口既不扩展 `MessageListener` 也不扩展 `SessionAwareMessageListener` 接口，但您仍可以使用 `MessageListenerAdapter` 类将其用作MDP。还请注意各种消息处理方法是如何根据它们可以接收和处理的各种消息类型的内容来强类型化的。

现在考虑 `MessageDelegate` 接口的以下实现：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class DefaultMessageDelegate implements MessageDelegate {
		// implementation elided for clarity...
	}
----

特别要注意 `MessageDelegate` 接口的前面实现（`DefaultMessageDelegate` 类）根本没有JMS依赖。 它真的是一个POJO，我们可以通过以下配置进入MDP：

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<!-- this is the Message Driven POJO (MDP) -->
	<bean id="messageListener" class="org.springframework.jms.listener.adapter.MessageListenerAdapter">
		<constructor-arg>
			<bean class="jmsexample.DefaultMessageDelegate"/>
		</constructor-arg>
	</bean>

	<!-- and this is the message listener container... -->
	<bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer">
		<property name="connectionFactory" ref="connectionFactory"/>
		<property name="destination" ref="destination"/>
		<property name="messageListener" ref="messageListener"/>
	</bean>
----

下面是另一个MDP的示例，它只能处理JMS `TextMessage` 消息的接收。请注意，消息处理方法实际上被称为 `receive` (`MessageListenerAdapter` 中的消息处理方法的名称默认为 `handleMessage`),但它是可配置的(如下所示)。还请注意， `receive(..)` 方法是如何强类型化的，以便只接收和响应JMS `TextMessage` 消息。以下清单显示了 `TextMessageDelegate` 接口的定义：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public interface TextMessageDelegate {

		void receive(TextMessage message);
	}
----

以下清单显示了一个实现 `TextMessageDelegate` 接口的类:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class DefaultTextMessageDelegate implements TextMessageDelegate {
		// implementation elided for clarity...
	}
----

随后 `MessageListenerAdapter` 的配置如下：

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="messageListener" class="org.springframework.jms.listener.adapter.MessageListenerAdapter">
		<constructor-arg>
			<bean class="jmsexample.DefaultTextMessageDelegate"/>
		</constructor-arg>
		<property name="defaultListenerMethod" value="receive"/>
		<!-- we don't want automatic message context extraction -->
		<property name="messageConverter">
			<null/>
		</property>
	</bean>
----

请注意，如果 `messageListener` 接收到 `TextMessage` 以外类型的JMS消息，则抛出 `IllegalStateException`（随后又消除了）。 `MessageListenerAdapter` 类的另一个功能是，如果处理程序方法返回非 `void` 值，则能够自动发回响应消息。 考虑以下接口和类：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public interface ResponsiveTextMessageDelegate {

		// notice the return type...
		String receive(TextMessage message);
	}
----

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class DefaultResponsiveTextMessageDelegate implements ResponsiveTextMessageDelegate {
		// implementation elided for clarity...
	}
----

如果上述 `DefaultResponsiveTextMessageDelegate` 与 `MessageListenerAdapter` 一起使用，则从执行 `'receive(..)'` 方法返回的任何非 `null` 值将(在默认配置中)转换为 `TextMessage`。
然后，生成的 `TextMessage` 将被发送到原始消息的JMS答复属性中定义的目标(如果存在)， 或 `MessageListenerAdapter` 上的默认 `Destination`(如果已配置)，
如果找不到 `Destination`，则会抛出 `InvalidDestinationException`(请注意，此异常将不会被消除，并将传播到调用堆栈)。

[[jms-tx-participation]]
==== 处理事务内的消息

在事务内调用消息监听器只需要重新配置监听器容器

本地资源事务可以简单地通过监听器容器定义上的 `sessionTransacted` 标志来激活。然后，每个消息监听器调用将在活动的JMS事务内运行，并在监听器执行失败时回滚消息接收。 发送响应消息(通过 `SessionAwareMessageListener`)将是同一本地事务的一部分，但任何其他资源操作(如数据库访问)都将独立运行。这通常需要监听器实现中的重复消息检测，包括数据库处理已提交但消息处理未能提交的情况。

考虑以下bean定义:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer">
		<property name="connectionFactory" ref="connectionFactory"/>
		<property name="destination" ref="destination"/>
		<property name="messageListener" ref="messageListener"/>
		<property name="sessionTransacted" value="true"/>
	</bean>
----

要参与外部托管事务，您需要配置事务管理器并使用支持外部托管事务的监听器容器（通常为 `DefaultMessageListenerContainer`）。

要为XA事务参与配置消息监听器容器，您需要配置一个 `JtaTransactionManager` (默认情况下，它集成到Java EE服务器的事务子系统)。请注意，底层JMS `ConnectionFactory` 需要具有XA能力，并在您的JTA事务协调器中正确注册。 (请检查您的Java EE服务器的JNDI资源配置)。这允许消息接收，犹如数据库访问是同一事务的一部分(使用统一的提交语义，代价是XA事务日志开销)。

以下bean定义创建了一个事务管理器：

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="transactionManager" class="org.springframework.transaction.jta.JtaTransactionManager"/>
----

然后我们需要将它添加到我们早期的容器配置中。 容器负责其余部分。 以下示例显示了如何执行此操作：

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer">
		<property name="connectionFactory" ref="connectionFactory"/>
		<property name="destination" ref="destination"/>
		<property name="messageListener" ref="messageListener"/>
		<property name="transactionManager" ref="transactionManager"/> <1>
	</bean>
----
<1> Our transaction manager.



[[jms-jca-message-endpoint-manager]]
=== 用于支持JCA消息端点

从版本2.5开始, Spring还提供对JCA-based `MessageListener` 容器的支持。`JmsMessageEndpointManager` 将尝试自动从提供程序的 `ResourceAdapter` 类名称中确定 `ActivationSpec` 类名。 因此，通常可以只提供Spring的通用 `JmsActivationSpecConfig`，如下面的示例所示：

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean class="org.springframework.jms.listener.endpoint.JmsMessageEndpointManager">
		<property name="resourceAdapter" ref="resourceAdapter"/>
		<property name="activationSpecConfig">
			<bean class="org.springframework.jms.listener.endpoint.JmsActivationSpecConfig">
				<property name="destinationName" value="myQueue"/>
			</bean>
		</property>
		<property name="messageListener" ref="myMessageListener"/>
	</bean>
----

或者，您可以用给定的 `ActivationSpec` 对象设置一个 `JmsMessageEndpointManager`。`ActivationSpec` 对象也可能来自JNDI查找（使用 `<jee:jndi-lookup>`）。 以下示例显示了如何执行此操作：

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean class="org.springframework.jms.listener.endpoint.JmsMessageEndpointManager">
		<property name="resourceAdapter" ref="resourceAdapter"/>
		<property name="activationSpec">
			<bean class="org.apache.activemq.ra.ActiveMQActivationSpec">
				<property name="destination" value="myQueue"/>
				<property name="destinationType" value="javax.jms.Queue"/>
			</bean>
		</property>
		<property name="messageListener" ref="myMessageListener"/>
	</bean>
----

使用Spring的 `ResourceAdapterFactoryBean`，您可以在本地配置目标 `ResourceAdapter`，如以下示例所示：

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="resourceAdapter" class="org.springframework.jca.support.ResourceAdapterFactoryBean">
		<property name="resourceAdapter">
			<bean class="org.apache.activemq.ra.ActiveMQResourceAdapter">
				<property name="serverUrl" value="tcp://localhost:61616"/>
			</bean>
		</property>
		<property name="workManager">
			<bean class="org.springframework.jca.work.SimpleTaskWorkManager"/>
		</property>
	</bean>
----

指定的 `WorkManager` 也可以指向特定于环境的线程池，通常是通过 `SimpleTaskWorkManager` 的 `asyncTaskExecutor` 属性。如果碰巧使用多个适配器，请考虑为所有 `ResourceAdapter` 实例定义一个共享线程池。

在某些环境(如WebLogic 9+)中，整个 `ResourceAdapter` 对象可以从JNDI获得，而不是使用 `<jee:jndi-lookup>`，然后，Spring消息监听器可与服务器托管的 `ResourceAdapter` 进行交互，也可以使用服务器的内置 `WorkManager`。

有关更多详细信息，请参阅javadoc以获取 {api-spring-framework}/jms/listener/endpoint/JmsMessageEndpointManager.html[`JmsMessageEndpointManager`], {api-spring-framework}/jms/listener/endpoint/JmsActivationSpecConfig.html[`JmsActivationSpecConfig`], 和 {api-spring-framework}/jca/support/ResourceAdapterFactoryBean.html[`ResourceAdapterFactoryBean`]

Spring还提供了一个通用的JCA消息端点管理器，它与JMS无关：`org.springframework.jca.endpoint.GenericMessageEndpointManager`。此组件允许使用任何消息监听器类型(如CCI `MessageListener`)和任何提供程序特定的 `ActivationSpec` 对象，查看您的JCA提供者的文档，了解连接的实际功能，并查阅 {api-spring-framework}/jca/endpoint/GenericMessageEndpointManager.html[`GenericMessageEndpointManager`] 的JavaDoc以了解Spring特定的配置详细信息。

NOTE: JCA-based 消息端点管理非常类似于EJB2.1 消息驱动的bean。它使用相同的基础资源提供程序协定，与EJB2.1 MDB一样，您的JCA提供程序支持的任何消息监听器接口也可以在Spring上下文中使用。 不过，Spring为JMS提供了明确的"方便"支持，这仅仅是因为JMS是与JCA端管理合同一起使用的最常见的端API。

[[jms-annotated]]
=== 注解驱动监听器端点

异步接收消息的最简单方法是使用带注解的监听器端点基础架构。简而言之， 它允许您将托管bean的方法作为JMS监听器端公开。以下示例显示了如何使用它：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Component
	public class MyService {

		@JmsListener(destination = "myDestination")
		public void processOrder(String data) { ... }
	}
----

前面示例的想法是，只要 `javax.jms.Destination myDestination` 上有消息可用，就会相应地调用 `processOrder` 方法（在这种情况下，使用JMS消息的内容，类似于 <<jms-receiving-async-message-listener-adapter, `MessageListenerAdapter`>> 提供的内容）。

带注解的端点基础架构使用 `JmsListenerContainerFactory` 为每个带注解的方法在幕后创建一个消息监听器容器。此类容器不是针对应用程序上下文注册的，但可以很容易地为使用 `JmsListenerEndpointRegistry` bean的管理目的而定位。

TIP: `@JmsListener` 是Java 8上的一个可重复的注解,因此可以通过向它添加附加的 `@JmsListener` 声明将多个JMS目标关联到同一方法。


[[jms-annotated-support]]
==== 启用监听器端点注解

要启用对 `@JmsListener` 注解的支持，请将 `@EnableJms` 添加到您其中一个 `@Configuration` 类中。

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	@EnableJms
	public class AppConfig {

		@Bean
		public DefaultJmsListenerContainerFactory jmsListenerContainerFactory() {
			DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
			factory.setConnectionFactory(connectionFactory());
			factory.setDestinationResolver(destinationResolver());
			factory.setSessionTransacted(true);
			factory.setConcurrency("3-10");
			return factory;
		}
	}
----

默认情况下， 基础架构将查找名为 `jmsListenerContainerFactory` 的bean作用于创建消息监听器工厂的容器来源。在这种情况下， 如果忽略JMS基础架构设置，`processOrder` 方法可以设置成3个核心线程和10个最大线程的调用。

可以使用注解自定义监听器容器工厂，或者通过实现 {api-spring-framework}/jms/annotation/JmsListenerConfigurer.html[`JmsListenerConfigurer`] 接口来配置显式的默认值。只有在没有特定容器工厂的情况下注册了至少一个端点时，才需要默认值。有关完整的详细信息和示例，请参考 `JmsListenerConfigurer`。

如果你倾向于使用  <<jms-namespace, XML 配置>>, 可以使用 `<jms:annotation-driven>`。如下：

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<jms:annotation-driven/>

	<bean id="jmsListenerContainerFactory"
			class="org.springframework.jms.config.DefaultJmsListenerContainerFactory">
		<property name="connectionFactory" ref="connectionFactory"/>
		<property name="destinationResolver" ref="destinationResolver"/>
		<property name="sessionTransacted" value="true"/>
		<property name="concurrency" value="3-10"/>
	</bean>
----


[[jms-annotated-programmatic-registration]]
==== 编程端点注册

`JmsListenerEndpoint` 提供了一个JMS端点的模型，并负责为该模型配置容器。该基础架构使您能够以编程方式配置端点，此外还可以通过 `JmsListener` 注解检测到的端点。以下示例说明了如何执行此操作：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	@EnableJms
	public class AppConfig implements JmsListenerConfigurer {

		@Override
		public void configureJmsListeners(JmsListenerEndpointRegistrar registrar) {
			SimpleJmsListenerEndpoint endpoint = new SimpleJmsListenerEndpoint();
			endpoint.setId("myJmsEndpoint");
			endpoint.setDestination("anotherQueue");
			endpoint.setMessageListener(message -> {
				// processing
			});
			registrar.registerEndpoint(endpoint);
		}
	}
----

在上面的示例中，我们使用了 `SimpleJmsListenerEndpoint`，它提供了实际的 `MessageListener` 调用，但您也可以构建自己的端变量来描述自定义调用机制。

请注意，您可以完全跳过对 `@JmsListener` 的使用， 并且只通过编程方式通过 `JmsListenerConfigurer` 来注册端点。

[[jms-annotated-method-signature]]
==== 注解端点方法签名

到目前为止， 我们已经在端点中注入了一个简单的 `String`， 但它实际上可以有一个非常灵活的方法签名。让我们重写它， 用一个自定义的标题注入 `Order`：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Component
	public class MyService {

		@JmsListener(destination = "myDestination")
		public void processOrder(Order order, @Header("order_type") String orderType) {
			...
		}
	}
----

这些是可以在JMS监听器端点中注入的主要元素：

* 原始 `javax.jms.Message` 或其任何子类（假设它与传入的消息类型匹配）。
* 用于对本机JMS API进行可选的 `javax.jms.Session`，例如发送自定义应答。
* 表示传入的JMS消息的 `org.springframework.messaging.Message` 。请注意，此消息包含自定义和标准标头(由 `JmsHeaders` 定义)。
* `@Header`-annotated 方法参数， 用于提取特定的标头值， 包括标准的JMS标头。
* `@Headers`-annotated 方法注解参数，它还必须可赋给 java.util.Map 以获得对所有标题的访问权限。
* 非注解元素类型（例如 `Message` 或 `Session`) 是支持的，可以被处理。您可以通过用 `@Payload` 注解参数来显式使用它，您还可以通过添加额外的 `@Valid` 来启用验证。

注入Spring消息抽象的能力对于从存储在特定于传输的消息中的所有信息中受益， 而不依赖于特定于传输的API，这是非常有用的。 以下示例显示了如何执行此操作：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@JmsListener(destination = "myDestination")
	public void processOrder(Message<Order> order) { ... }
----

`DefaultMessageHandlerMethodFactory` 提供了方法参数的处理，您可以进一步自定义它以支持其他方法参数。 您也可以在那里自定义转换和验证支持。

例如，如果我们想在处理之前确保 `Order` 有效，我们可以使用 `@Valid` 注解负载并配置必要的验证器，如下例所示：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	@EnableJms
	public class AppConfig implements JmsListenerConfigurer {

		@Override
		public void configureJmsListeners(JmsListenerEndpointRegistrar registrar) {
			registrar.setMessageHandlerMethodFactory(myJmsHandlerMethodFactory());
		}

		@Bean
		public DefaultMessageHandlerMethodFactory myHandlerMethodFactory() {
			DefaultMessageHandlerMethodFactory factory = new DefaultMessageHandlerMethodFactory();
			factory.setValidator(myValidator());
			return factory;
		}
	}
----

[[jms-annotated-response]]
==== 响应管理

<<jms-receiving-async-message-listener-adapter, `MessageListenerAdapter`>>中的现有支持已经允许您的方法具有 `void` 的返回类型。在这种情况下，调用的结果将封装在原始消息的 `JMSReplyTo` 标头中指定的目的地中， 或者在监听器上配置的默认目的地 `javax.jms.Message` 中发送。现在可以使用消息抽象的 `@SendTo` 注解设置该默认目的地。

假设我们的 `processOrder` 方法现在应该返回一个 `OrderStatus`， 那么可以按如下方式编写它以自动发送响应。

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@JmsListener(destination = "myDestination")
	@SendTo("status")
	public OrderStatus processOrder(Order order) {
		// order processing
		return status;
	}
----

TIP: 如果您有几个 `@JmsListener` 注解的方法， 还可以将 `@SendTo` 注解放在类级别以共享默认的答复目的地。

如果需要以与传输无关的方式设置其他管理， 则可以返回 `Message`。 如下所示:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@JmsListener(destination = "myDestination")
	@SendTo("status")
	public Message<OrderStatus> processOrder(Order order) {
		// order processing
		return MessageBuilder
				.withPayload(status)
				.setHeader("code", 1234)
				.build();
	}
----

如果需要在运行时计算响应目的地， 则可以将响应封装在 `JmsResponse` 实例中， 它还提供在运行时使用的目的地。前面的示例可以重写如下:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@JmsListener(destination = "myDestination")
	public JmsResponse<Message<OrderStatus>> processOrder(Order order) {
		// order processing
		Message<OrderStatus> response = MessageBuilder
				.withPayload(status)
				.setHeader("code", 1234)
				.build();
		return JmsResponse.forQueue(response, "status");
	}
----

最后，如果您需要为响应指定一些QoS值（例如优先级或生存时间），则可以相应地配置 `JmsListenerContainerFactory`，如以下示例所示：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	@EnableJms
	public class AppConfig {

		@Bean
		public DefaultJmsListenerContainerFactory jmsListenerContainerFactory() {
			DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
			factory.setConnectionFactory(connectionFactory());
			QosSettings replyQosSettings = new QosSettings();
			replyQosSettings.setPriority(2);
			replyQosSettings.setTimeToLive(10000);
			factory.setReplyQosSettings(replyQosSettings);
			return factory;
		}
	}
----



[[jms-namespace]]
=== JMS命名空间支持

Spring提供了一个用于简化JMS配置的XML命名空间。要使用JMS命名空间元素， 您需要引用JMS schema，如以下示例所示：

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			xmlns:jms="http://www.springframework.org/schema/jms" <1>
			xsi:schemaLocation="
				http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
				http://www.springframework.org/schema/jms https://www.springframework.org/schema/jms/spring-jms.xsd">

		<!-- bean definitions here -->

	</beans>
----
<1> Referencing the JMS schema.

命名空间包含三个顶级的元素: `<annotation-driven/>`, `<listener-container/>` 和 `<jca-listener-container/>`。 `<annotation-driven/>` 允许使用注解驱动的监听器端点,
`<listener-container/>` 和 `<jca-listener-container/>` 定义了共享的监听器容器配置，并且可能包含 `<listener/>` 子元素 。下面是两个监听器的基本配置示例：

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<jms:listener-container>

		<jms:listener destination="queue.orders" ref="orderService" method="placeOrder"/>

		<jms:listener destination="queue.confirmations" ref="confirmationLogger" method="log"/>

	</jms:listener-container>
----

上面的示例等效于创建两个不同的监听器容器bean和两个不同的 `MessageListenerAdapter` bean定义。，如<<jms-receiving-async-message-listener-adapter,使用 `MessageListenerAdapter` >> 中所示。 除了前面示例中显示的属性之外，`listener` 元素还可以包含几个可选的属性。 下表描述了所有可用属性：

[[jms-namespace-listener-tbl]]
.Attributes of the JMS <listener> element
[cols="1,6"]
|===
| 属性 | 描述

| `id`
| 监听器容器的Bean名称。 如果未指定，则自动生成bean名称。

| `destination` (required)
| 此监听器的目的地，通过 `DestinationResolver` 策略解析。

| `ref` (required)
| 处理程序对象的bean名称。

| `method`
| 要调用的处理程序方法的名称。 如果 `ref` 属性指向 `MessageListener` 或Spring `SessionAwareMessageListener`，则可以省略此属性。

| `response-destination`
| 要将响应消息发送到的默认响应目标的名称。 这适用于请求消息未携带 `JMSReplyTo` 字段的情况。 此目标的类型由监听器容器的 `response-destination-type` 属性确定。

| `subscription`
| 持久性订阅的名称（如果有）。

| `selector`
| 此监听器的可选消息选择器。

| `concurrency`
| 为此监听器启动的sessions 或consumers数量，可以是指示最大数量的一个简单的数字（例如，`5`），也可以是指示下限和上限的范围（例如， `3-5`）。 请注意，指定的最小值只是一个提示，可能在运行时被忽略。 默认值是容器提供的值。
|===

`<listener-container/>` 元素也接受几个可选属性。这允许自定义各种策略(例如 `taskExecutor` 和 `destinationResolver`)，以及基本的JMS设置和资源引用。使用这些属性，可以实现高度自定义的监听器容器，同时仍可从命名空间的方便性中获益。

通过指定要通过 `factory-id` 属性公开的bean id，可以自动将此类设置公开为 `JmsListenerContainerFactory`。如下所示：

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<jms:listener-container connection-factory="myConnectionFactory"
			task-executor="myTaskExecutor"
			destination-resolver="myDestinationResolver"
			transaction-manager="myTransactionManager"
			concurrency="10">

		<jms:listener destination="queue.orders" ref="orderService" method="placeOrder"/>

		<jms:listener destination="queue.confirmations" ref="confirmationLogger" method="log"/>

	</jms:listener-container>
----

下表描述了所有可用属性。有关各个属性的详细信息， 请参阅 {api-spring-framework}/jms/listener/AbstractMessageListenerContainer.html[`AbstractMessageListenerContainer`] 及其具体子类的 javadocs。javadocs还提供了有关事务选择和消息重整方案的讨论。

[[jms-namespace-listener-container-tbl]]
.JMS <listener-container> 元素属性
[cols="1,6"]
|===
| 属性 | 描述

| `container-type`
| 此监听器容器的类型。 可用选项为 `default`, `simple`, `default102`, 或 `simple102`（默认选项为 `default`）。

| `container-class`
| 自定义监听器容器实现类作为完全限定的类名。根据 `container-type` 属性，默认值为Spring的标准 `DefaultMessageListenerContainer` 或 `SimpleMessageListenerContainer`。

| `factory-id`
| 将此元素定义的设置公开为具有指定 `id` 的 `JmsListenerContainerFactory`，以便它们可以与其他端点一起使用。

| `connection-factory`
| 对JMS `ConnectionFactory` bean的引用（默认bean名称为 `connectionFactory`）。

| `task-executor`
| 对JMS监听器调用者的Spring `TaskExecutor` 的引用。

| `destination-resolver`
| 对 `DestinationResolver` 策略的引用，用于解析JMS `Destination` 实例。

| `message-converter`
| 对用于将JMS消息转换为监听器方法参数的 `MessageConverter` 策略的引用。 默认值为 `SimpleMessageConverter`。

| `error-handler`
| 对 `ErrorHandler` 策略的引用，用于处理在执行 `MessageListener` 期间可能发生的任何未捕获的异常。

| `destination-type`
| 此监听器的JMS目标类型：`queue`, `topic`, `durableTopic`, `sharedTopic` 或 `sharedDurableTopic`。 这可能会启用容器的 `pubSubDomain`, `subscriptionDurable` 和 `subscriptionShared` 属性。 默认值为 `queue`（禁用这三个属性）。

| `response-destination-type`
| 响应的JMS目标类型：`queue` or `topic`。 默认值是 `destination-type` 属性的值。

| `client-id`
| 此监听器容器的JMS客户端ID。 您必须在使用持久订阅时指定它。

| `cache`
| JMS资源的缓存级别：`none`, `connection`, `session`, `consumer` 或 `auto`。 默认情况下（`auto`），缓存级别实际上是 `consumer`，除非指定了外部事务管理器 - 在这种情况下，有效默认值为 `none` （假设Java EE样式的事务管理，其中给定的 `ConnectionFactory` 是XA感知的池）。

| `acknowledge`
| 本机JMS确认模式：`auto`, `client`, `dups-ok` 或 `transacted`。 `transacted` 激活本地 `transacted` 的会话。 作为替代方法，您可以指定 `transaction-manager` 属性，稍后将在表中进行说明。 默认为 `auto`。

| `transaction-manager`
| 对外部 `PlatformTransactionManager` 的引用（通常是基于XA的事务协调器，例如Spring的 `JtaTransactionManager`）。 如果未指定，则使用本机确认（请参阅 `acknowledge` 属性）。

| `concurrency`
| 为每个监听器启动的并发会话或使用者数。 它可以是指示最大数量的简单数字（例如，`5`），也可以是指示下限和上限的范围（例如，`3-5`）。 请注意，指定的最小值只是一个提示，可能在运行时被忽略。 默认值为 `1`.如果是主题监听器或队列排序很重要，则应将并发限制为 `1`。 考虑将其提升为一般队列。

| `prefetch`
| 要加载到单个会话中的最大消息数。 请注意，提高此数字可能会导致并发消费者的饥饿。

| `receive-timeout`
| 用于接收呼叫的超时（以毫秒为单位）。 默认值为 `1000`（一秒）。 `-1` 表示没有超时。

| `back-off`
| 指定用于计算恢复尝试之间间隔的 `BackOff` 实例。 如果 `BackOffExecution` 实现返回 `BackOffExecution#STOP`，则监听器容器不会进一步尝试恢复。 设置此属性时，将忽略 `recovery-interval` 值。 默认值为 `FixedBackOff`，间隔为5000毫秒（即5秒）。

| `recovery-interval`
| 指定恢复尝试之间的间隔（以毫秒为单位）。 它提供了一种使用指定间隔创建 `FixedBackOff` 的便捷方法。 有关更多恢复选项，请考虑指定 `BackOff` 实例。 默认值为5000毫秒（即5秒）。

| `phase`
| 此容器应开始和停止的生命周期阶段。 值越低，此容器启动越早，后者停止。 默认值为 `Integer.MAX_VALUE`，表示容器尽可能晚启动并尽快停止。
|===

使用 `jms` 模式支持配置基于JCA的监听器容器非常相似，如以下示例所示：

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<jms:jca-listener-container resource-adapter="myResourceAdapter"
			destination-resolver="myDestinationResolver"
			transaction-manager="myTransactionManager"
			concurrency="10">

		<jms:listener destination="queue.orders" ref="myMessageListener"/>

	</jms:jca-listener-container>
----

下表描述了JCA变量的可用配置选项:

[[jms-namespace-jca-listener-container-tbl]]
.JMS <jca-listener-container/> 元素属性
[cols="1,6"]
|===
| 属性 | 描述

| `factory-id`
| 将此元素定义的设置公开为具有指定 `id` 的 `JmsListenerContainerFactory`，以便它们可以与其他端点一起使用。

| `resource-adapter`
| 对JCA `ResourceAdapter` bean的引用（默认bean名称为 `resourceAdapter`）。

| `activation-spec-factory`
| 对 `JmsActivationSpecFactory` 的引用。 缺省情况是自动检测JMS提供程序及其 `ActivationSpec` 类（请参阅 {api-spring-framework}/jms/listener/endpoint/DefaultJmsActivationSpecFactory.html[`DefaultJmsActivationSpecFactory`]）。

| `destination-resolver`
| 对 `DestinationResolver` 策略的引用，用于解析JMS `Destinations`。

| `message-converter`
| 对用于将JMS消息转换为监听器方法参数的 `MessageConverter` 策略的引用。 默认值为 `SimpleMessageConverter`。

| `destination-type`
| 此监听器的JMS目标类型：`queue`, `topic`, `durableTopic`, `sharedTopic` 或 `sharedDurableTopic`。 这可能会启用容器的 `pubSubDomain`, `subscriptionDurable` 和 `subscriptionShared` 属性。 默认值为 `queue` （禁用这三个属性）。

| `response-destination-type`
| 响应的JMS目标类型：`queue` or `topic`。 默认值是 `destination-type` 属性的值。

| `client-id`
| 此监听器容器的JMS客户端ID。 在使用持久订阅时需要指定它。

| `acknowledge`
| 本机JMS确认模式：`auto`, `client`, `dups-ok`, 或 `transacted`。 `transacted` 激活本地 `transacted` 的会话。 或者，您可以指定稍后描述的 `transaction-manager` 属性。 默认为 `auto`。

| `transaction-manager`
| 对Spring `JtaTransactionManager` 或 `javax.transaction.TransactionManager` 的引用，用于为每个传入消息启动XA事务。 如果未指定，则使用本机确认（请参阅 `acknowledge` 属性）。

| `concurrency`
| 为每个监听器启动的并发会话或使用者数。 它可以是指示最大数量的简单数字（例如 `5`）或指示下限和上限的范围（例如，`3-5`）。 请注意，指定的最小值只是一个提示，在运行时通常会在使用JCA监听器容器时被忽略。 默认值为 `1`。

| `prefetch`
| 要加载到单个会话中的最大消息数。 请注意，提高此数字可能会导致并发消费者的饥饿。
|===




[[jmx]]
== JMX

The JMX (Java Management Extensions) support in Spring provides features that let you
easily and transparently integrate your Spring application into a JMX infrastructure.

.JMX?
****
This chapter is not an introduction to JMX. It does not try to explain why you might want
to use JMX. If you are new to JMX, see <<jmx-resources>> at the end of this chapter.
****

Specifically, Spring's JMX support provides four core features:

* The automatic registration of any Spring bean as a JMX MBean.
* A flexible mechanism for controlling the management interface of your beans.
* The declarative exposure of MBeans over remote, JSR-160 connectors.
* The simple proxying of both local and remote MBean resources.

These features are designed to work without coupling your application components to
either Spring or JMX interfaces and classes. Indeed, for the most part, your application
classes need not be aware of either Spring or JMX in order to take advantage of the
Spring JMX features.



[[jmx-exporting]]
=== Exporting Your Beans to JMX

The core class in Spring's JMX framework is the `MBeanExporter`. This class is
responsible for taking your Spring beans and registering them with a JMX `MBeanServer`.
For example, consider the following class:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	package org.springframework.jmx;

	public class JmxTestBean implements IJmxTestBean {

		private String name;
		private int age;
		private boolean isSuperman;

		public int getAge() {
			return age;
		}

		public void setAge(int age) {
			this.age = age;
		}

		public void setName(String name) {
			this.name = name;
		}

		public String getName() {
			return name;
		}

		public int add(int x, int y) {
			return x + y;
		}

		public void dontExposeMe() {
			throw new RuntimeException();
		}
	}
----

To expose the properties and methods of this bean as attributes and operations of an
MBean, you can configure an instance of the `MBeanExporter` class in your
configuration file and pass in the bean, as the following example shows:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>
		<!-- this bean must not be lazily initialized if the exporting is to happen -->
		<bean id="exporter" class="org.springframework.jmx.export.MBeanExporter" lazy-init="false">
			<property name="beans">
				<map>
					<entry key="bean:name=testBean1" value-ref="testBean"/>
				</map>
			</property>
		</bean>
		<bean id="testBean" class="org.springframework.jmx.JmxTestBean">
			<property name="name" value="TEST"/>
			<property name="age" value="100"/>
		</bean>
	</beans>
----

The pertinent bean definition from the preceding configuration snippet is the `exporter`
bean. The `beans` property tells the `MBeanExporter` exactly which of your beans must be
exported to the JMX `MBeanServer`. In the default configuration, the key of each entry
in the `beans` `Map` is used as the `ObjectName` for the bean referenced by the
corresponding entry value. You can change this behavior, as described in <<jmx-naming>>.

With this configuration, the `testBean` bean is exposed as an MBean under the
`ObjectName` `bean:name=testBean1`. By default, all `public` properties of the bean
are exposed as attributes and all `public` methods (except those inherited from the
`Object` class) are exposed as operations.

NOTE: `MBeanExporter` is a `Lifecycle` bean (see <<core.adoc#beans-factory-lifecycle-processor,
Startup and Shutdown Callbacks>>). By default, MBeans are exported as late as possible during
the application lifecycle. You can configure the `phase` at which
the export happens or disable automatic registration by setting the `autoStartup` flag.


[[jmx-exporting-mbeanserver]]
==== Creating an MBeanServer

The configuration shown in the <<jmx-exporting, preceding section>> assumes that the
application is running in an environment that has one (and only one) `MBeanServer`
already running. In this case, Spring tries to locate the running `MBeanServer` and
register your beans with that server (if any). This behavior is useful when your
application runs inside a container (such as Tomcat or IBM WebSphere) that has its
own `MBeanServer`.

However, this approach is of no use in a standalone environment or when running inside
a container that does not provide an `MBeanServer`. To address this, you can create an
`MBeanServer` instance declaratively by adding an instance of the
`org.springframework.jmx.support.MBeanServerFactoryBean` class to your configuration.
You can also ensure that a specific `MBeanServer` is used by setting the value of the
`MBeanExporter` instance's `server` property to the `MBeanServer` value returned by an
`MBeanServerFactoryBean`, as the following example shows:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>

		<bean id="mbeanServer" class="org.springframework.jmx.support.MBeanServerFactoryBean"/>

		<!--
		this bean needs to be eagerly pre-instantiated in order for the exporting to occur;
		this means that it must not be marked as lazily initialized
		-->
		<bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
			<property name="beans">
				<map>
					<entry key="bean:name=testBean1" value-ref="testBean"/>
				</map>
			</property>
			<property name="server" ref="mbeanServer"/>
		</bean>

		<bean id="testBean" class="org.springframework.jmx.JmxTestBean">
			<property name="name" value="TEST"/>
			<property name="age" value="100"/>
		</bean>

	</beans>
----

In the preceding example, an instance of `MBeanServer` is created by the `MBeanServerFactoryBean` and is
supplied to the `MBeanExporter` through the `server` property. When you supply your own
`MBeanServer` instance, the `MBeanExporter` does not try to locate a running
`MBeanServer` and uses the supplied `MBeanServer` instance. For this to work
correctly, you must have a JMX implementation on your classpath.


[[jmx-mbean-server]]
==== Reusing an Existing `MBeanServer`

If no server is specified, the `MBeanExporter` tries to automatically detect a running
`MBeanServer`. This works in most environments, where only one `MBeanServer` instance is
used. However, when multiple instances exist, the exporter might pick the wrong server.
In such cases, you should use the `MBeanServer` `agentId` to indicate which instance to
be used, as the following example shows:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>
		<bean id="mbeanServer" class="org.springframework.jmx.support.MBeanServerFactoryBean">
			<!-- indicate to first look for a server -->
			<property name="locateExistingServerIfPossible" value="true"/>
			<!-- search for the MBeanServer instance with the given agentId -->
			<property name="agentId" value="MBeanServer_instance_agentId>"/>
		</bean>
		<bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
			<property name="server" ref="mbeanServer"/>
			...
		</bean>
	</beans>
----

For platforms or cases where the existing `MBeanServer` has a dynamic (or unknown)
`agentId` that is retrieved through lookup methods, you should use
<<core.adoc#beans-factory-class-static-factory-method, factory-method>>,
as the following example shows:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>
		<bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
			<property name="server">
				<!-- Custom MBeanServerLocator -->
				<bean class="platform.package.MBeanServerLocator" factory-method="locateMBeanServer"/>
			</property>
		</bean>

		<!-- other beans here -->

	</beans>
----


[[jmx-exporting-lazy]]
==== Lazily Initialized MBeans

If you configure a bean with an `MBeanExporter` that is also configured for lazy
initialization, the `MBeanExporter` does not break this contract and avoids
instantiating the bean. Instead, it registers a proxy with the `MBeanServer` and
defers obtaining the bean from the container until the first invocation on the proxy
occurs.


[[jmx-exporting-auto]]
==== Automatic Registration of MBeans

Any beans that are exported through the `MBeanExporter` and are already valid MBeans are
registered as-is with the `MBeanServer` without further intervention from Spring. You can cause MBeans
to be automatically detected by the `MBeanExporter` by setting the `autodetect`
property to `true`, as the following example shows:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
		<property name="autodetect" value="true"/>
	</bean>

	<bean name="spring:mbean=true" class="org.springframework.jmx.export.TestDynamicMBean"/>
----

In the preceding example, the bean called `spring:mbean=true` is already a valid JMX MBean
and is automatically registered by Spring. By default, a bean that is autodetected for JMX
registration has its bean name used as the `ObjectName`. You can override this behavior,
as detailed in <<jmx-naming>>.


[[jmx-exporting-registration-behavior]]
==== Controlling the Registration Behavior

Consider the scenario where a Spring `MBeanExporter` attempts to register an `MBean`
with an `MBeanServer` by using the `ObjectName` `bean:name=testBean1`. If an `MBean`
instance has already been registered under that same `ObjectName`, the default behavior
is to fail (and throw an `InstanceAlreadyExistsException`).

You can control exactly what happens when an `MBean` is
registered with an `MBeanServer`. Spring's JMX support allows for three different
registration behaviors to control the registration behavior when the registration
process finds that an `MBean` has already been registered under the same `ObjectName`.
The following table summarizes these registration behaviors:

[[jmx-registration-behaviors]]
.Registration Behaviors
[cols="1,4"]
|===
| Registration behavior | Explanation

| `FAIL_ON_EXISTING`
| This is the default registration behavior. If an `MBean` instance has already been
  registered under the same `ObjectName`, the `MBean` that is being registered is not
  registered, and an `InstanceAlreadyExistsException` is thrown. The existing
  `MBean` is unaffected.

| `IGNORE_EXISTING`
| If an `MBean` instance has already been registered under the same `ObjectName`, the
  `MBean` that is being registered is not registered. The existing `MBean` is
  unaffected, and no `Exception` is thrown. This is useful in settings where
  multiple applications want to share a common `MBean` in a shared `MBeanServer`.

| `REPLACE_EXISTING`
| If an `MBean` instance has already been registered under the same `ObjectName`, the
  existing `MBean` that was previously registered is unregistered, and the new
  `MBean` is registered in its place (the new `MBean` effectively replaces the
  previous instance).
|===

The values in the preceding table are defined as enums on the `RegistrationPolicy` class.
If you want to change the default registration behavior, you need to set the value of the
`registrationPolicy` property on your `MBeanExporter` definition to one of those
values.

The following example shows how to change from the default registration
behavior to the `REPLACE_EXISTING` behavior:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>

		<bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
			<property name="beans">
				<map>
					<entry key="bean:name=testBean1" value-ref="testBean"/>
				</map>
			</property>
			<property name="registrationPolicy" value="REPLACE_EXISTING"/>
		</bean>

		<bean id="testBean" class="org.springframework.jmx.JmxTestBean">
			<property name="name" value="TEST"/>
			<property name="age" value="100"/>
		</bean>

	</beans>
----



[[jmx-interface]]
=== Controlling the Management Interface of Your Beans

In the example in the <<jmx-exporting-registration-behavior, preceding section>>,
you had little control over the management interface of your bean. All of the `public`
properties and methods of each exported bean were exposed as JMX attributes and
operations, respectively. To exercise finer-grained control over exactly which
properties and methods of your exported beans are actually exposed as JMX attributes
and operations, Spring JMX provides a comprehensive and extensible mechanism for
controlling the management interfaces of your beans.


[[jmx-interface-assembler]]
==== Using the `MBeanInfoAssembler` Interface

Behind the scenes, the `MBeanExporter` delegates to an implementation of the
`org.springframework.jmx.export.assembler.MBeanInfoAssembler` interface, which is
responsible for defining the management interface of each bean that is exposed.
The default implementation,
`org.springframework.jmx.export.assembler.SimpleReflectiveMBeanInfoAssembler`,
defines a management interface that exposes all public properties and methods
(as you saw in the examples in the preceding sections). Spring provides two
additional implementations of the `MBeanInfoAssembler` interface that let you
control the generated management interface by using either source-level metadata
or any arbitrary interface.


[[jmx-interface-metadata]]
==== Using Source-level Metadata: Java Annotations

By using the `MetadataMBeanInfoAssembler`, you can define the management interfaces
for your beans by using source-level metadata. The reading of metadata is encapsulated
by the `org.springframework.jmx.export.metadata.JmxAttributeSource` interface.
Spring JMX provides a default implementation that uses Java annotations, namely
`org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource`.
You must configure the `MetadataMBeanInfoAssembler` with an implementation instance of
the `JmxAttributeSource` interface for it to function correctly (there is no default).

To mark a bean for export to JMX, you should annotate the bean class with the
`ManagedResource` annotation. You must mark each method you wish to expose as an operation
with the `ManagedOperation` annotation and mark each property you wish to expose
with the `ManagedAttribute` annotation. When marking properties, you can omit
either the annotation of the getter or the setter to create a write-only or read-only
attribute, respectively.

NOTE: A `ManagedResource`-annotated bean must be public, as must the methods exposing
an operation or an attribute.

The following example shows the annotated version of the `JmxTestBean` class that we
used in <<jmx-exporting-mbeanserver>>:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	package org.springframework.jmx;

	import org.springframework.jmx.export.annotation.ManagedResource;
	import org.springframework.jmx.export.annotation.ManagedOperation;
	import org.springframework.jmx.export.annotation.ManagedAttribute;

	@ManagedResource(
			objectName="bean:name=testBean4",
			description="My Managed Bean",
			log=true,
			logFile="jmx.log",
			currencyTimeLimit=15,
			persistPolicy="OnUpdate",
			persistPeriod=200,
			persistLocation="foo",
			persistName="bar")
	public class AnnotationTestBean implements IJmxTestBean {

		private String name;
		private int age;

		@ManagedAttribute(description="The Age Attribute", currencyTimeLimit=15)
		public int getAge() {
			return age;
		}

		public void setAge(int age) {
			this.age = age;
		}

		@ManagedAttribute(description="The Name Attribute",
				currencyTimeLimit=20,
				defaultValue="bar",
				persistPolicy="OnUpdate")
		public void setName(String name) {
			this.name = name;
		}

		@ManagedAttribute(defaultValue="foo", persistPeriod=300)
		public String getName() {
			return name;
		}

		@ManagedOperation(description="Add two numbers")
		@ManagedOperationParameters({
			@ManagedOperationParameter(name = "x", description = "The first number"),
			@ManagedOperationParameter(name = "y", description = "The second number")})
		public int add(int x, int y) {
			return x + y;
		}

		public void dontExposeMe() {
			throw new RuntimeException();
		}

	}
----

In the preceding example, you can see that the `JmxTestBean` class is marked with the
`ManagedResource` annotation and that this `ManagedResource` annotation is configured
with a set of properties. These properties can be used to configure various aspects
of the MBean that is generated by the `MBeanExporter` and are explained in greater
detail later in <<jmx-interface-metadata-types>>.

Both the `age` and `name` properties are annotated with the `ManagedAttribute`
annotation, but, in the case of the `age` property, only the getter is marked.
This causes both of these properties to be included in the management interface
as attributes, but the `age` attribute is read-only.

Finally, the `add(int, int)` method is marked with the `ManagedOperation` attribute,
whereas the `dontExposeMe()` method is not. This causes the management interface to
contain only one operation (`add(int, int)`) when you use the `MetadataMBeanInfoAssembler`.

The following configuration shows how you can configure the `MBeanExporter` to use the
`MetadataMBeanInfoAssembler`:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>
		<bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
			<property name="assembler" ref="assembler"/>
			<property name="namingStrategy" ref="namingStrategy"/>
			<property name="autodetect" value="true"/>
		</bean>

		<bean id="jmxAttributeSource"
				class="org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource"/>

		<!-- will create management interface using annotation metadata -->
		<bean id="assembler"
				class="org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler">
			<property name="attributeSource" ref="jmxAttributeSource"/>
		</bean>

		<!-- will pick up the ObjectName from the annotation -->
		<bean id="namingStrategy"
				class="org.springframework.jmx.export.naming.MetadataNamingStrategy">
			<property name="attributeSource" ref="jmxAttributeSource"/>
		</bean>

		<bean id="testBean" class="org.springframework.jmx.AnnotationTestBean">
			<property name="name" value="TEST"/>
			<property name="age" value="100"/>
		</bean>
	</beans>
----

In the preceding example, an `MetadataMBeanInfoAssembler` bean has been configured with an
instance of the `AnnotationJmxAttributeSource` class and passed to the `MBeanExporter`
through the assembler property. This is all that is required to take advantage of
metadata-driven management interfaces for your Spring-exposed MBeans.


[[jmx-interface-metadata-types]]
==== Source-level Metadata Types

The following table describes the source-level metadata types that are available for use in Spring JMX:

[[jmx-metadata-types]]
.Source-level metadata types
|===
| Purpose| Annotation| Annotation Type

| Mark all instances of a `Class` as JMX managed resources.
| `@ManagedResource`
| Class

| Mark a method as a JMX operation.
| `@ManagedOperation`
| Method

| Mark a getter or setter as one half of a JMX attribute.
| `@ManagedAttribute`
| Method (only getters and setters)

| Define descriptions for operation parameters.
| `@ManagedOperationParameter` and `@ManagedOperationParameters`
| Method
|===

The following table describes the configuration parameters that are available for use on these source-level
metadata types:

[[jmx-metadata-parameters]]
.Source-level metadata parameters
[cols="1,3,1"]
|===
| Parameter | Description | Applies to

| `ObjectName`
| Used by `MetadataNamingStrategy` to determine the `ObjectName` of a managed resource.
| `ManagedResource`

| `description`
| Sets the friendly description of the resource, attribute or operation.
| `ManagedResource`, `ManagedAttribute`, `ManagedOperation`, or `ManagedOperationParameter`

| `currencyTimeLimit`
| Sets the value of the `currencyTimeLimit` descriptor field.
| `ManagedResource` or `ManagedAttribute`

| `defaultValue`
| Sets the value of the `defaultValue` descriptor field.
| `ManagedAttribute`

| `log`
| Sets the value of the `log` descriptor field.
| `ManagedResource`

| `logFile`
| Sets the value of the `logFile` descriptor field.
| `ManagedResource`

| `persistPolicy`
| Sets the value of the `persistPolicy` descriptor field.
| `ManagedResource`

| `persistPeriod`
| Sets the value of the `persistPeriod` descriptor field.
| `ManagedResource`

| `persistLocation`
| Sets the value of the `persistLocation` descriptor field.
| `ManagedResource`

| `persistName`
| Sets the value of the `persistName` descriptor field.
| `ManagedResource`

| `name`
| Sets the display name of an operation parameter.
| `ManagedOperationParameter`

| `index`
| Sets the index of an operation parameter.
| `ManagedOperationParameter`
|===


[[jmx-interface-autodetect]]
==== Using the `AutodetectCapableMBeanInfoAssembler` Interface

To simplify configuration even further, Spring includes the
`AutodetectCapableMBeanInfoAssembler` interface, which extends the `MBeanInfoAssembler`
interface to add support for autodetection of MBean resources. If you configure the
`MBeanExporter` with an instance of `AutodetectCapableMBeanInfoAssembler`, it is
allowed to "`vote`" on the inclusion of beans for exposure to JMX.

The only implementation of the `AutodetectCapableMBeanInfo` interface is
the `MetadataMBeanInfoAssembler`, which votes to include any bean that is marked
with the `ManagedResource` attribute. The default approach in this case is to use the
bean name as the `ObjectName`, which results in a configuration similar to the following:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>

		<bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
			<!-- notice how no 'beans' are explicitly configured here -->
			<property name="autodetect" value="true"/>
			<property name="assembler" ref="assembler"/>
		</bean>

		<bean id="testBean" class="org.springframework.jmx.JmxTestBean">
			<property name="name" value="TEST"/>
			<property name="age" value="100"/>
		</bean>

		<bean id="assembler" class="org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler">
			<property name="attributeSource">
				<bean class="org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource"/>
			</property>
		</bean>

	</beans>
----

Notice that, in the preceding configuration, no beans are passed to the `MBeanExporter`.
However, the `JmxTestBean` is still registered, since it is marked with the `ManagedResource`
attribute and the `MetadataMBeanInfoAssembler` detects this and votes to include it.
The only problem with this approach is that the name of the `JmxTestBean` now has business
meaning. You can address this issue by changing the default behavior for `ObjectName`
creation as defined in <<jmx-naming>>.


[[jmx-interface-java]]
==== Defining Management Interfaces by Using Java Interfaces

In addition to the `MetadataMBeanInfoAssembler`, Spring also includes the
`InterfaceBasedMBeanInfoAssembler`, which lets you constrain the methods and
properties that are exposed based on the set of methods defined in a collection of
interfaces.

Although the standard mechanism for exposing MBeans is to use interfaces and a simple
naming scheme, `InterfaceBasedMBeanInfoAssembler` extends this functionality by
removing the need for naming conventions, letting you use more than one interface
and removing the need for your beans to implement the MBean interfaces.

Consider the following interface, which is used to define a management interface for the
`JmxTestBean` class that we showed earlier:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public interface IJmxTestBean {

		public int add(int x, int y);

		public long myOperation();

		public int getAge();

		public void setAge(int age);

		public void setName(String name);

		public String getName();

	}
----

This interface defines the methods and properties that are exposed as operations and
attributes on the JMX MBean. The following code shows how to configure Spring JMX to use
this interface as the definition for the management interface:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>

		<bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
			<property name="beans">
				<map>
					<entry key="bean:name=testBean5" value-ref="testBean"/>
				</map>
			</property>
			<property name="assembler">
				<bean class="org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssembler">
					<property name="managedInterfaces">
						<value>org.springframework.jmx.IJmxTestBean</value>
					</property>
				</bean>
			</property>
		</bean>

		<bean id="testBean" class="org.springframework.jmx.JmxTestBean">
			<property name="name" value="TEST"/>
			<property name="age" value="100"/>
		</bean>

	</beans>
----

In the preceding example, the `InterfaceBasedMBeanInfoAssembler` is configured to use the
`IJmxTestBean` interface when constructing the management interface for any bean. It is
important to understand that beans processed by the `InterfaceBasedMBeanInfoAssembler`
are not required to implement the interface used to generate the JMX management
interface.

In the preceding case, the `IJmxTestBean` interface is used to construct all management
interfaces for all beans. In many cases, this is not the desired behavior, and you may
want to use different interfaces for different beans. In this case, you can pass
`InterfaceBasedMBeanInfoAssembler` a `Properties` instance through the `interfaceMappings`
property, where the key of each entry is the bean name and the value of each entry is a
comma-separated list of interface names to use for that bean.

If no management interface is specified through either the `managedInterfaces` or
`interfaceMappings` properties, the `InterfaceBasedMBeanInfoAssembler` reflects
on the bean and uses all of the interfaces implemented by that bean to create the
management interface.


[[jmx-interface-methodnames]]
==== Using `MethodNameBasedMBeanInfoAssembler`

`MethodNameBasedMBeanInfoAssembler` lets you specify a list of method names
that are exposed to JMX as attributes and operations. The following code shows a sample
configuration:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
		<property name="beans">
			<map>
				<entry key="bean:name=testBean5" value-ref="testBean"/>
			</map>
		</property>
		<property name="assembler">
			<bean class="org.springframework.jmx.export.assembler.MethodNameBasedMBeanInfoAssembler">
				<property name="managedMethods">
					<value>add,myOperation,getName,setName,getAge</value>
				</property>
			</bean>
		</property>
	</bean>
----

In the preceding example, you can see that the `add` and `myOperation` methods are exposed as JMX
operations, and `getName()`, `setName(String)`, and `getAge()` are exposed as the
appropriate half of a JMX attribute. In the preceding code, the method mappings apply to
beans that are exposed to JMX. To control method exposure on a bean-by-bean basis, you can use
the `methodMappings` property of `MethodNameMBeanInfoAssembler` to map bean names to
lists of method names.



[[jmx-naming]]
=== Controlling  `ObjectName` Instances for Your Beans

Behind the scenes, the `MBeanExporter` delegates to an implementation of the
`ObjectNamingStrategy` to obtain an `ObjectName` instance for each of the beans it registers.
By default, the default implementation, `KeyNamingStrategy` uses the key of the
`beans` `Map` as the `ObjectName`. In addition, the `KeyNamingStrategy` can map the key
of the `beans` `Map` to an entry in a `Properties` file (or files) to resolve the
`ObjectName`. In addition to the `KeyNamingStrategy`, Spring provides two additional
`ObjectNamingStrategy` implementations: the `IdentityNamingStrategy` (which builds an
`ObjectName` based on the JVM identity of the bean) and the `MetadataNamingStrategy` (which
uses source-level metadata to obtain the `ObjectName`).


[[jmx-naming-properties]]
==== Reading `ObjectName` Instances from Properties

You can configure your own `KeyNamingStrategy` instance and configure it to read
`ObjectName` instances from a `Properties` instance rather than use a bean key. The
`KeyNamingStrategy` tries to locate an entry in the `Properties` with a key
that corresponds to the bean key. If no entry is found or if the `Properties` instance is
`null`, the bean key itself is used.

The following code shows a sample configuration for the `KeyNamingStrategy`:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>

		<bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
			<property name="beans">
				<map>
					<entry key="testBean" value-ref="testBean"/>
				</map>
			</property>
			<property name="namingStrategy" ref="namingStrategy"/>
		</bean>

		<bean id="testBean" class="org.springframework.jmx.JmxTestBean">
			<property name="name" value="TEST"/>
			<property name="age" value="100"/>
		</bean>

		<bean id="namingStrategy" class="org.springframework.jmx.export.naming.KeyNamingStrategy">
			<property name="mappings">
				<props>
					<prop key="testBean">bean:name=testBean1</prop>
				</props>
			</property>
			<property name="mappingLocations">
				<value>names1.properties,names2.properties</value>
			</property>
		</bean>

	</beans>
----

The preceding example configures an instance of `KeyNamingStrategy` with a `Properties` instance that
is merged from the `Properties` instance defined by the mapping property and the
properties files located in the paths defined by the mappings property. In this
configuration, the `testBean` bean is given an `ObjectName` of `bean:name=testBean1`,
since this is the entry in the `Properties` instance that has a key corresponding to the
bean key.

If no entry in the `Properties` instance can be found, the bean key name is used as
the `ObjectName`.


[[jmx-naming-metadata]]
==== Using `MetadataNamingStrategy`

`MetadataNamingStrategy` uses the `objectName` property of the `ManagedResource`
attribute on each bean to create the `ObjectName`. The following code shows the
configuration for the `MetadataNamingStrategy`:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>

		<bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
			<property name="beans">
				<map>
					<entry key="testBean" value-ref="testBean"/>
				</map>
			</property>
			<property name="namingStrategy" ref="namingStrategy"/>
		</bean>

		<bean id="testBean" class="org.springframework.jmx.JmxTestBean">
			<property name="name" value="TEST"/>
			<property name="age" value="100"/>
		</bean>

		<bean id="namingStrategy" class="org.springframework.jmx.export.naming.MetadataNamingStrategy">
			<property name="attributeSource" ref="attributeSource"/>
		</bean>

		<bean id="attributeSource"
				class="org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource"/>

	</beans>
----

If no `objectName` has been provided for the `ManagedResource` attribute, an
`ObjectName` is created with the following
format: _[fully-qualified-package-name]:type=[short-classname],name=[bean-name]_. For
example, the generated `ObjectName` for the following bean would be
`com.example:type=MyClass,name=myBean`:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="myBean" class="com.example.MyClass"/>
----


[[jmx-context-mbeanexport]]
==== Configuring Annotation-based MBean Export

If you prefer to use <<jmx-interface-metadata, the annotation-based approach>> to define
your management interfaces, a convenience subclass of `MBeanExporter` is available:
`AnnotationMBeanExporter`. When defining an instance of this subclass, you no longer need the
`namingStrategy`, `assembler`, and `attributeSource` configuration,
since it always uses standard Java annotation-based metadata (autodetection is
always enabled as well). In fact, rather than defining an `MBeanExporter` bean, an even
simpler syntax is supported by the `@EnableMBeanExport` `@Configuration` annotation,
as the following example shows:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	@EnableMBeanExport
	public class AppConfig {

	}
----

If you prefer XML-based configuration, the `<context:mbean-export/>` element serves the
same purpose and is shown in the following listing:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<context:mbean-export/>
----

If necessary, you can provide a reference to a particular MBean `server`, and the
`defaultDomain` attribute (a property of `AnnotationMBeanExporter`) accepts an alternate
value for the generated MBean `ObjectName` domains. This is used in place of the
fully qualified package name as described in the previous section on
<<jmx-naming-metadata, MetadataNamingStrategy>>, as the following example shows:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@EnableMBeanExport(server="myMBeanServer", defaultDomain="myDomain")
	@Configuration
	ContextConfiguration {

	}
----

The following example shows the XML equivalent of the preceding annotation-based example:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<context:mbean-export server="myMBeanServer" default-domain="myDomain"/>
----

CAUTION: Do not use interface-based AOP proxies in combination with autodetection of JMX
annotations in your bean classes. Interface-based proxies "`hide`" the target class, which
also hides the JMX-managed resource annotations. Hence, you should use target-class proxies in that
case (through setting the 'proxy-target-class' flag on `<aop:config/>`,
`<tx:annotation-driven/>` and so on). Otherwise, your JMX beans might be silently ignored at
startup.



[[jmx-jsr160]]
=== Using JSR-160 Connectors

For remote access, Spring JMX module offers two `FactoryBean` implementations inside the
`org.springframework.jmx.support` package for creating both server- and client-side
connectors.


[[jmx-jsr160-server]]
==== Server-side Connectors

To have Spring JMX create, start, and expose a JSR-160 `JMXConnectorServer`, you can use the
following configuration:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="serverConnector" class="org.springframework.jmx.support.ConnectorServerFactoryBean"/>
----

By default, `ConnectorServerFactoryBean` creates a `JMXConnectorServer` bound to
`service:jmx:jmxmp://localhost:9875`. The `serverConnector` bean thus exposes the
local `MBeanServer` to clients through the JMXMP protocol on localhost, port 9875. Note
that the JMXMP protocol is marked as optional by the JSR 160 specification. Currently,
the main open-source JMX implementation, MX4J, and the one provided with the JDK
do not support JMXMP.

To specify another URL and register the `JMXConnectorServer` itself with the
`MBeanServer`, you can use the `serviceUrl` and `ObjectName` properties, respectively,
as the following example shows:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="serverConnector"
			class="org.springframework.jmx.support.ConnectorServerFactoryBean">
		<property name="objectName" value="connector:name=rmi"/>
		<property name="serviceUrl"
				value="service:jmx:rmi://localhost/jndi/rmi://localhost:1099/myconnector"/>
	</bean>
----

If the `ObjectName` property is set, Spring automatically registers your connector
with the `MBeanServer` under that `ObjectName`. The following example shows the full set of
parameters that you can pass to the `ConnectorServerFactoryBean` when creating a
`JMXConnector`:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="serverConnector"
			class="org.springframework.jmx.support.ConnectorServerFactoryBean">
		<property name="objectName" value="connector:name=iiop"/>
		<property name="serviceUrl"
			value="service:jmx:iiop://localhost/jndi/iiop://localhost:900/myconnector"/>
		<property name="threaded" value="true"/>
		<property name="daemon" value="true"/>
		<property name="environment">
			<map>
				<entry key="someKey" value="someValue"/>
			</map>
		</property>
	</bean>
----

Note that, when you use a RMI-based connector, you need the lookup service (`tnameserv` or
`rmiregistry`) to be started in order for the name registration to complete. If you
use Spring to export remote services for you through RMI, Spring has already
constructed an RMI registry. If not, you can easily start a registry by using the following
snippet of configuration:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="registry" class="org.springframework.remoting.rmi.RmiRegistryFactoryBean">
		<property name="port" value="1099"/>
	</bean>
----


[[jmx-jsr160-client]]
==== Client-side Connectors

To create an `MBeanServerConnection` to a remote JSR-160-enabled `MBeanServer`, you can use the
`MBeanServerConnectionFactoryBean`, as the following example shows:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="clientConnector" class="org.springframework.jmx.support.MBeanServerConnectionFactoryBean">
		<property name="serviceUrl" value="service:jmx:rmi://localhost/jndi/rmi://localhost:1099/jmxrmi"/>
	</bean>
----


[[jmx-jsr160-protocols]]
==== JMX over Hessian or SOAP

JSR-160 permits extensions to the way in which communication is done between the client
and the server. The examples shown in the preceding sections use the mandatory RMI-based implementation
required by the JSR-160 specification (IIOP and JRMP) and the (optional) JMXMP. By using
other providers or JMX implementations (such as http://mx4j.sourceforge.net[MX4J]) you
can take advantage of protocols such as SOAP or Hessian over simple HTTP or SSL and others,
as the following example shows:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="serverConnector" class="org.springframework.jmx.support.ConnectorServerFactoryBean">
		<property name="objectName" value="connector:name=burlap"/>
		<property name="serviceUrl" value="service:jmx:burlap://localhost:9874"/>
	</bean>
----

In the preceding example, we used MX4J 3.0.0. See the official MX4J
documentation for more information.



[[jmx-proxy]]
=== Accessing MBeans through Proxies

Spring JMX lets you create proxies that re-route calls to MBeans that are registered in a
local or remote `MBeanServer`. These proxies provide you with a standard Java interface,
through which you can interact with your MBeans. The following code shows how to configure a
proxy for an MBean running in a local `MBeanServer`:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="proxy" class="org.springframework.jmx.access.MBeanProxyFactoryBean">
		<property name="objectName" value="bean:name=testBean"/>
		<property name="proxyInterface" value="org.springframework.jmx.IJmxTestBean"/>
	</bean>
----

In the preceding example, you can see that a proxy is created for the MBean registered under the
`ObjectName` of `bean:name=testBean`. The set of interfaces that the proxy implements
is controlled by the `proxyInterfaces` property, and the rules for mapping methods and
properties on these interfaces to operations and attributes on the MBean are the same
rules used by the `InterfaceBasedMBeanInfoAssembler`.

The `MBeanProxyFactoryBean` can create a proxy to any MBean that is accessible through an
`MBeanServerConnection`. By default, the local `MBeanServer` is located and used, but
you can override this and provide an `MBeanServerConnection` that points to a remote
`MBeanServer` to cater for proxies that point to remote MBeans:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="clientConnector"
			class="org.springframework.jmx.support.MBeanServerConnectionFactoryBean">
		<property name="serviceUrl" value="service:jmx:rmi://remotehost:9875"/>
	</bean>

	<bean id="proxy" class="org.springframework.jmx.access.MBeanProxyFactoryBean">
		<property name="objectName" value="bean:name=testBean"/>
		<property name="proxyInterface" value="org.springframework.jmx.IJmxTestBean"/>
		<property name="server" ref="clientConnector"/>
	</bean>
----

In the preceding example, we create an `MBeanServerConnection` that points to a remote machine
that uses the `MBeanServerConnectionFactoryBean`. This `MBeanServerConnection` is then
passed to the `MBeanProxyFactoryBean` through the `server` property. The proxy that is
created forwards all invocations to the `MBeanServer` through this
`MBeanServerConnection`.



[[jmx-notifications]]
=== Notifications

Spring's JMX offering includes comprehensive support for JMX notifications.


[[jmx-notifications-listeners]]
==== Registering Listeners for Notifications

Spring's JMX support makes it easy to register any number of
`NotificationListeners` with any number of MBeans (this includes MBeans exported by
Spring's `MBeanExporter` and MBeans registered through some other mechanism). For
example, consider the scenario where one would like to be informed (through a
`Notification`) each and every time an attribute of a target MBean changes. The following
example writes notifications to the console:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	package com.example;

	import javax.management.AttributeChangeNotification;
	import javax.management.Notification;
	import javax.management.NotificationFilter;
	import javax.management.NotificationListener;

	public class ConsoleLoggingNotificationListener
			implements NotificationListener, NotificationFilter {

		public void handleNotification(Notification notification, Object handback) {
			System.out.println(notification);
			System.out.println(handback);
		}

		public boolean isNotificationEnabled(Notification notification) {
			return AttributeChangeNotification.class.isAssignableFrom(notification.getClass());
		}

	}
----

The following example adds `ConsoleLoggingNotificationListener` (defined in the preceding
example) to `notificationListenerMappings`:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>

		<bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
			<property name="beans">
				<map>
					<entry key="bean:name=testBean1" value-ref="testBean"/>
				</map>
			</property>
			<property name="notificationListenerMappings">
				<map>
					<entry key="bean:name=testBean1">
						<bean class="com.example.ConsoleLoggingNotificationListener"/>
					</entry>
				</map>
			</property>
		</bean>

		<bean id="testBean" class="org.springframework.jmx.JmxTestBean">
			<property name="name" value="TEST"/>
			<property name="age" value="100"/>
		</bean>

	</beans>
----

With the preceding configuration in place, every time a JMX `Notification` is broadcast from
the target MBean (`bean:name=testBean1`), the `ConsoleLoggingNotificationListener` bean
that was registered as a listener through the `notificationListenerMappings` property is
notified. The `ConsoleLoggingNotificationListener` bean can then take whatever action
it deems appropriate in response to the `Notification`.

You can also use straight bean names as the link between exported beans and listeners,
as the following example shows:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>

		<bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
			<property name="beans">
				<map>
					<entry key="bean:name=testBean1" value-ref="testBean"/>
				</map>
			</property>
			<property name="notificationListenerMappings">
				<map>
					<entry key="__testBean__">
						<bean class="com.example.ConsoleLoggingNotificationListener"/>
					</entry>
				</map>
			</property>
		</bean>

		<bean id="__testBean__" class="org.springframework.jmx.JmxTestBean">
			<property name="name" value="TEST"/>
			<property name="age" value="100"/>
		</bean>

	</beans>
----

If you want to register a single `NotificationListener` instance for all of the beans
that the enclosing `MBeanExporter` exports, you can use the special wildcard (`{asterisk}`)
as the key for an entry in the `notificationListenerMappings` property
map, as the following example shows:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<property name="notificationListenerMappings">
		<map>
			<entry key="*">
				<bean class="com.example.ConsoleLoggingNotificationListener"/>
			</entry>
		</map>
	</property>
----

If you need to do the inverse (that is, register a number of distinct listeners against
an MBean), you must instead use the `notificationListeners` list property (in
preference to the `notificationListenerMappings` property). This time, instead of
configuring a `NotificationListener` for a single MBean, we configure
`NotificationListenerBean` instances. A `NotificationListenerBean` encapsulates a
`NotificationListener` and the `ObjectName` (or `ObjectNames`) that it is to be
registered against in an `MBeanServer`. The `NotificationListenerBean` also encapsulates
a number of other properties, such as a `NotificationFilter` and an arbitrary handback
object that can be used in advanced JMX notification scenarios.

The configuration when using `NotificationListenerBean` instances is not wildly
different to what was presented previously, as the following example shows:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>

		<bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
			<property name="beans">
				<map>
					<entry key="bean:name=testBean1" value-ref="testBean"/>
				</map>
			</property>
			<property name="notificationListeners">
				<list>
					<bean class="org.springframework.jmx.export.NotificationListenerBean">
						<constructor-arg>
							<bean class="com.example.ConsoleLoggingNotificationListener"/>
						</constructor-arg>
						<property name="mappedObjectNames">
							<list>
								<value>bean:name=testBean1</value>
							</list>
						</property>
					</bean>
				</list>
			</property>
		</bean>

		<bean id="testBean" class="org.springframework.jmx.JmxTestBean">
			<property name="name" value="TEST"/>
			<property name="age" value="100"/>
		</bean>

	</beans>
----

The preceding example is equivalent to the first notification example. Assume, then, that
we want to be given a handback object every time a `Notification` is raised and that
we also want to filter out extraneous `Notifications` by supplying a
`NotificationFilter`. The following example accomplishes these goals:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>

		<bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
			<property name="beans">
				<map>
					<entry key="bean:name=testBean1" value-ref="testBean1"/>
					<entry key="bean:name=testBean2" value-ref="testBean2"/>
				</map>
			</property>
			<property name="notificationListeners">
				<list>
					<bean class="org.springframework.jmx.export.NotificationListenerBean">
						<constructor-arg ref="customerNotificationListener"/>
						<property name="mappedObjectNames">
							<list>
								<!-- handles notifications from two distinct MBeans -->
								<value>bean:name=testBean1</value>
								<value>bean:name=testBean2</value>
							</list>
						</property>
						<property name="handback">
							<bean class="java.lang.String">
								<constructor-arg value="This could be anything..."/>
							</bean>
						</property>
						<property name="notificationFilter" ref="customerNotificationListener"/>
					</bean>
				</list>
			</property>
		</bean>

		<!-- implements both the NotificationListener and NotificationFilter interfaces -->
		<bean id="customerNotificationListener" class="com.example.ConsoleLoggingNotificationListener"/>

		<bean id="testBean1" class="org.springframework.jmx.JmxTestBean">
			<property name="name" value="TEST"/>
			<property name="age" value="100"/>
		</bean>

		<bean id="testBean2" class="org.springframework.jmx.JmxTestBean">
			<property name="name" value="ANOTHER TEST"/>
			<property name="age" value="200"/>
		</bean>

	</beans>
----

(For a full discussion of what a handback object is and,
indeed, what a `NotificationFilter` is, see the section of the JMX
specification (1.2) entitled 'The JMX Notification Model'.)


[[jmx-notifications-publishing]]
==== Publishing Notifications

Spring provides support not only for registering to receive `Notifications` but also
for publishing `Notifications`.

NOTE: This section is really only relevant to Spring-managed beans that have
been exposed as MBeans through an `MBeanExporter`. Any existing user-defined MBeans should
use the standard JMX APIs for notification publication.

The key interface in Spring's JMX notification publication support is the
`NotificationPublisher` interface (defined in the
`org.springframework.jmx.export.notification` package). Any bean that is going to be
exported as an MBean through an `MBeanExporter` instance can implement the related
`NotificationPublisherAware` interface to gain access to a `NotificationPublisher`
instance. The `NotificationPublisherAware` interface supplies an instance of a
`NotificationPublisher` to the implementing bean through a simple setter method,
which the bean can then use to publish `Notifications`.

As stated in the javadoc of the
{api-spring-framework}/jmx/export/notification/NotificationPublisher.html[`NotificationPublisher`]
interface, managed beans that publish events through the `NotificationPublisher`
mechanism are not responsible for the state management of notification listeners.
Spring's JMX support takes care of handling all the JMX infrastructure issues.
All you need to do, as an application developer, is implement the
`NotificationPublisherAware` interface and start publishing events by using the
supplied `NotificationPublisher` instance. Note that the `NotificationPublisher`
is set after the managed bean has been registered with an `MBeanServer`.

Using a `NotificationPublisher` instance is quite straightforward. You create a JMX
`Notification` instance (or an instance of an appropriate `Notification` subclass),
populate the notification with the data pertinent to the event that is to be
published, and invoke the `sendNotification(Notification)` on the
`NotificationPublisher` instance, passing in the `Notification`.

In the following example, exported instances of the `JmxTestBean` publish a
`NotificationEvent` every time the `add(int, int)` operation is invoked:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	package org.springframework.jmx;

	import org.springframework.jmx.export.notification.NotificationPublisherAware;
	import org.springframework.jmx.export.notification.NotificationPublisher;
	import javax.management.Notification;

	public class JmxTestBean implements IJmxTestBean, NotificationPublisherAware {

		private String name;
		private int age;
		private boolean isSuperman;
		private NotificationPublisher publisher;

		// other getters and setters omitted for clarity

		public int add(int x, int y) {
			int answer = x + y;
			this.publisher.sendNotification(new Notification("add", this, 0));
			return answer;
		}

		public void dontExposeMe() {
			throw new RuntimeException();
		}

		public void setNotificationPublisher(NotificationPublisher notificationPublisher) {
			this.publisher = notificationPublisher;
		}

	}
----

The `NotificationPublisher` interface and the machinery to get it all working is one of
the nicer features of Spring's JMX support. It does, however, come with the price tag of
coupling your classes to both Spring and JMX. As always, the advice here is to be
pragmatic. If you need the functionality offered by the `NotificationPublisher` and
you can accept the coupling to both Spring and JMX, then do so.



[[jmx-resources]]
=== Further Resources

This section contains links to further resources about JMX:

* The https://www.oracle.com/technetwork/java/javase/tech/javamanagement-140525.html[JMX
homepage] at Oracle.
* The https://jcp.org/aboutJava/communityprocess/final/jsr003/index3.html[JMX
  specification] (JSR-000003).
* The https://jcp.org/aboutJava/communityprocess/final/jsr160/index.html[JMX Remote API
  specification] (JSR-000160).
* The http://mx4j.sourceforge.net/[MX4J homepage]. (MX4J is an open-source implementation of
  various JMX specs.)




[[cci]]
== JCA CCI

Java EE provides a specification to standardize access to enterprise information systems
(EIS): the JCA (Java EE Connector Architecture). This specification is divided into
two different parts:

* SPI (Service Provider Interfaces) that the connector provider must implement. These
  interfaces constitute a resource adapter that can be deployed on a Java EE
  application server. In such a scenario, the server manages connection pooling,
  transactions, and security (managed mode). The application server is also responsible
  for managing the configuration, which is held outside the client application. A
  connector can be used without an application server as well. In this case, the
  application must configure it directly (non-managed mode).
* CCI (Common Client Interface) that an application can use to interact with the
  connector and, thus, communicate with an EIS. An API for local transaction demarcation
  is provided as well.

The aim of the Spring CCI support is to provide classes to access a CCI connector in
typical Spring style, using the Spring Framework's general resource and transaction
management facilities.

NOTE: The client side of connectors does not always use CCI. Some connectors expose their own
APIs, providing a JCA resource adapter to use the system contracts of a Java EE container
(connection pooling, global transactions, and security). Spring does not offer special
support for such connector-specific APIs.



[[cci-config]]
=== Configuring CCI

This section covers how to configure a Common Client Interface (CCI). It includes the
following topics:

* <<cci-config-connector>>
* <<cci-config-connectionfactory>>
* <<cci-config-cci-connections>>
* <<cci-config-single-connection>>


[[cci-config-connector]]
==== Connector Configuration

The base resource to use JCA CCI is the `ConnectionFactory` interface. The connector
you use must provide an implementation of this interface.

To use your connector, you can deploy it on your application server and fetch the
`ConnectionFactory` from the server's JNDI environment (managed mode). The connector
must be packaged as a RAR file (resource adapter archive) and contain a `ra.xml` file to
describe its deployment characteristics. The actual name of the resource is specified
when you deploy it. To access it within Spring, you can use Spring's
`JndiObjectFactoryBean` or `<jee:jndi-lookup>` to fetch the factory by its JNDI name.

Another way to use a connector is to embed it in your application (non-managed mode) and
not use an application server to deploy and configure it. Spring offers the
possibility to configure a connector as a bean, through a `FactoryBean` implementation called
(`LocalConnectionFactoryBean`). In this manner, you only need the connector library in
the classpath (no RAR file and no `ra.xml` descriptor needed). The library must be
extracted from the connector's RAR file, if necessary.

Once you have access to your `ConnectionFactory` instance, you can inject it into
your components. These components can either be coded against the plain CCI API or
use Spring's support classes for CCI access (e.g. `CciTemplate`).

NOTE: When you use a connector in non-managed mode, you cannot use global transactions, because
the resource is never enlisted or delisted in the current global transaction of the
current thread. The resource is not aware of any global Java EE transactions that
might be running.


[[cci-config-connectionfactory]]
==== `ConnectionFactory` Configuration in Spring

To make connections to the EIS, you need to obtain a `ConnectionFactory` from
the application server (if you are in a managed mode) or directly from Spring (if you are
in a non-managed mode).

In managed mode, you can access a `ConnectionFactory` from JNDI. Its properties are
configured in the application server. The following example shows how to do so:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<jee:jndi-lookup id="eciConnectionFactory" jndi-name="eis/cicseci"/>
----

In non-managed mode, you must configure the `ConnectionFactory` you want to use in the
configuration of Spring as a JavaBean. The `LocalConnectionFactoryBean` class offers
this setup style, passing in the `ManagedConnectionFactory` implementation of your
connector, exposing the application-level CCI `ConnectionFactory`. The following example
shows how to do so:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="eciManagedConnectionFactory" class="com.ibm.connector2.cics.ECIManagedConnectionFactory">
		<property name="serverName" value="TXSERIES"/>
		<property name="connectionURL" value="tcp://localhost/"/>
		<property name="portNumber" value="2006"/>
	</bean>

	<bean id="eciConnectionFactory" class="org.springframework.jca.support.LocalConnectionFactoryBean">
		<property name="managedConnectionFactory" ref="eciManagedConnectionFactory"/>
	</bean>
----

NOTE: You cannot directly instantiate a specific `ConnectionFactory`. You need to go through
the corresponding implementation of the `ManagedConnectionFactory` interface for your
connector. This interface is part of the JCA SPI specification.


[[cci-config-cci-connections]]
==== Configuring CCI Connections

JCA CCI lets you configure the connections to the EIS by using the
`ConnectionSpec` implementation of your connector. To configure its properties,
you need to wrap the target connection factory with a dedicated adapter,
`ConnectionSpecConnectionFactoryAdapter`. You can configure the dedicated `ConnectionSpec`
with the `connectionSpec` property (as an inner bean).

This property is not mandatory, because the CCI `ConnectionFactory` interface defines two
different methods to obtain a CCI connection. You can often configure some of the `ConnectionSpec` properties
in the application server (in managed mode) or on the
corresponding local `ManagedConnectionFactory` implementation. The following listing
shows the relevant parts of the `ConnectionFactory` interface definition:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public interface ConnectionFactory implements Serializable, Referenceable {
		...
		Connection getConnection() throws ResourceException;
		Connection getConnection(ConnectionSpec connectionSpec) throws ResourceException;
		...
	}
----

Spring provides a `ConnectionSpecConnectionFactoryAdapter` that lets you specify a
`ConnectionSpec` instance to use for all operations on a given factory. If the adapter's
`connectionSpec` property is specified, the adapter uses the `getConnection` variant
with the `ConnectionSpec` argument. Otherwise, the adapter uses the variant without that argument.
The following example shows how to configure a `ConnectionSpecConnectionFactoryAdapter`:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="managedConnectionFactory"
			class="com.sun.connector.cciblackbox.CciLocalTxManagedConnectionFactory">
		<property name="connectionURL" value="jdbc:hsqldb:hsql://localhost:9001"/>
		<property name="driverName" value="org.hsqldb.jdbcDriver"/>
	</bean>

	<bean id="targetConnectionFactory"
			class="org.springframework.jca.support.LocalConnectionFactoryBean">
		<property name="managedConnectionFactory" ref="managedConnectionFactory"/>
	</bean>

	<bean id="connectionFactory"
			class="org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter">
		<property name="targetConnectionFactory" ref="targetConnectionFactory"/>
		<property name="connectionSpec">
			<bean class="com.sun.connector.cciblackbox.CciConnectionSpec">
				<property name="user" value="sa"/>
				<property name="password" value=""/>
			</bean>
		</property>
	</bean>
----


[[cci-config-single-connection]]
==== Using a Single CCI Connection

If you want to use a single CCI connection, Spring provides a further
`ConnectionFactory` adapter to manage this. The `SingleConnectionFactory` adapter class
lazily opens a single connection and closes it when this bean is destroyed at
application shutdown. This class exposes special `Connection` proxies that behave
accordingly, all sharing the same underlying physical connection. The following example
shows how to use the `SingleConnectionFactory` adapter class:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="eciManagedConnectionFactory"
			class="com.ibm.connector2.cics.ECIManagedConnectionFactory">
		<property name="serverName" value="TEST"/>
		<property name="connectionURL" value="tcp://localhost/"/>
		<property name="portNumber" value="2006"/>
	</bean>

	<bean id="targetEciConnectionFactory"
			class="org.springframework.jca.support.LocalConnectionFactoryBean">
		<property name="managedConnectionFactory" ref="eciManagedConnectionFactory"/>
	</bean>

	<bean id="eciConnectionFactory"
			class="org.springframework.jca.cci.connection.SingleConnectionFactory">
		<property name="targetConnectionFactory" ref="targetEciConnectionFactory"/>
	</bean>
----

NOTE: This `ConnectionFactory` adapter cannot directly be configured with a `ConnectionSpec`.
You can use an intermediary `ConnectionSpecConnectionFactoryAdapter` that the
`SingleConnectionFactory` talks to if you require a single connection for a specific
`ConnectionSpec`.



[[cci-using]]
=== Using Spring's CCI Access Support

This section describes how to use Spring's support for CCI to achieve various purposes.
It includes the following topics:

* <<cci-record-creator>>
* <<cci-using-template>>
* <<cci-using-dao>>
* <<automatic-output-generation>>
* <<template-summary>>
* <<cci-straight>>
* <<cci-template-example>>


[[cci-record-creator]]
==== Record Conversion

One of the aims of Spring's JCA CCI support is to provide convenient facilities for
manipulating CCI records. You can specify the strategy to create records and extract
data from records, for use with Spring's `CciTemplate`. The interfaces described in
this section configure the strategy to use input and output records if you do not want
to work with records directly in your application.

To create an input `Record`, you can use a dedicated implementation of the `RecordCreator`
interface. The following listing shows the `RecordCreator` interface definition:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public interface RecordCreator {

		Record createRecord(RecordFactory recordFactory) throws ResourceException, DataAccessException;

	}
----

The `createRecord(..)` method receives a `RecordFactory` instance as a
parameter, which corresponds to the `RecordFactory` of the `ConnectionFactory` used.
You can use this reference to create `IndexedRecord` or `MappedRecord` instances. The
following sample shows how to use the `RecordCreator` interface and indexed or mapped
records:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class MyRecordCreator implements RecordCreator {

		public Record createRecord(RecordFactory recordFactory) throws ResourceException {
			IndexedRecord input = recordFactory.createIndexedRecord("input");
			input.add(new Integer(id));
			return input;
		}

	}
----

You can use an output `Record` to receive data back from the EIS. Hence, you can pass a specific
implementation of the `RecordExtractor` interface to Spring's
`CciTemplate` to extract data from the output `Record`. The following listing shows the
`RecordExtractor` interface definition:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public interface RecordExtractor {

		Object extractData(Record record) throws ResourceException, SQLException, DataAccessException;

	}
----

The following example shows how to use the `RecordExtractor` interface:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class MyRecordExtractor implements RecordExtractor {

		public Object extractData(Record record) throws ResourceException {
			CommAreaRecord commAreaRecord = (CommAreaRecord) record;
			String str = new String(commAreaRecord.toByteArray());
			String field1 = string.substring(0,6);
			String field2 = string.substring(6,1);
			return new OutputObject(Long.parseLong(field1), field2);
		}

	}
----


[[cci-using-template]]
==== Using `CciTemplate`

The `CciTemplate` is the central class of the core CCI support package (
`org.springframework.jca.cci.core`). It simplifies the use of CCI, since it handles the
creation and release of resources. This helps to avoid common errors, such as forgetting to
always close the connection. It cares for the lifecycle of connection and interaction
objects, letting application code focus on generating input records from application
data and extracting application data from output records.

The JCA CCI specification defines two distinct methods to call operations on an EIS. The
CCI `Interaction` interface provides two execute method signatures, as the following
listing shows:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public interface javax.resource.cci.Interaction {

		...

		boolean execute(InteractionSpec spec, Record input, Record output) throws ResourceException;

		Record execute(InteractionSpec spec, Record input) throws ResourceException;

		...

	}
----

Depending on the template method called, `CciTemplate` knows which `execute` method
to call on the interaction. In any case, a correctly initialized `InteractionSpec`
instance is mandatory.

You can use `CciTemplate.execute(..)` in two ways:

* With direct `Record` arguments. In this case, you need to pass in the CCI input
  record, and the returned object is the corresponding CCI output record.
* With application objects, by using record mapping. In this case, you need to provide
  corresponding `RecordCreator` and `RecordExtractor` instances.

With the first approach, the following methods (which directly correspond to those on the
`Interaction` interface) of the template are used:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class CciTemplate implements CciOperations {

		public Record execute(InteractionSpec spec, Record inputRecord)
				throws DataAccessException { ... }

		public void execute(InteractionSpec spec, Record inputRecord, Record outputRecord)
				throws DataAccessException { ... }

	}
----

With the second approach, we need to specify the record creation and record
extraction strategies as arguments. The interfaces used are those describe in the
<<cci-record-creator, previous section on record conversion>>. The following
listing shows the corresponding `CciTemplate` methods:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class CciTemplate implements CciOperations {

		public Record execute(InteractionSpec spec,
				RecordCreator inputCreator) throws DataAccessException {
			// ...
		}

		public Object execute(InteractionSpec spec, Record inputRecord,
				RecordExtractor outputExtractor) throws DataAccessException {
			// ...
		}

		public Object execute(InteractionSpec spec, RecordCreator creator,
				RecordExtractor extractor) throws DataAccessException {
			// ...
		}

	}
----

Unless the `outputRecordCreator` property is set on the template (see the following
section), every method calls the corresponding `execute` method of the CCI
`Interaction` with two parameters: `InteractionSpec` and an input `Record`. It receives an
output `Record` as its return value.

`CciTemplate` also provides methods to create `IndexRecord` and `MappedRecord` outside of a
`RecordCreator` implementation, through its `createIndexRecord(..)` and
`createMappedRecord(..)` methods. You can use this within DAO implementations to create
`Record` instances to pass into corresponding `CciTemplate.execute(..)` methods.
The following listing shows the `CciTemplate` interface definition:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class CciTemplate implements CciOperations {

		public IndexedRecord createIndexedRecord(String name) throws DataAccessException { ... }

		public MappedRecord createMappedRecord(String name) throws DataAccessException { ... }

	}
----


[[cci-using-dao]]
==== Using DAO Support

Spring's CCI support provides an abstract class for DAOs, supporting injection of a
`ConnectionFactory` or a `CciTemplate` instance. The name of the class is
`CciDaoSupport`. It provides simple `setConnectionFactory` and `setCciTemplate` methods.
Internally, this class creates a `CciTemplate` instance for a passed-in
`ConnectionFactory`, exposing it to concrete data access implementations in subclasses.
The following example shows how to use `CciDaoSupport`:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public abstract class CciDaoSupport {

		public void setConnectionFactory(ConnectionFactory connectionFactory) {
			// ...
		}

		public ConnectionFactory getConnectionFactory() {
			// ...
		}

		public void setCciTemplate(CciTemplate cciTemplate) {
			// ...
		}

		public CciTemplate getCciTemplate() {
			// ...
		}

	}
----


[[automatic-output-generation]]
==== Automatic Output Record Generation

If the connector you use supports only the `Interaction.execute(..)` method with input and
output records as parameters (that is, it requires the desired output record to be passed
in instead of returning an appropriate output record), you can set the `outputRecordCreator`
property of the `CciTemplate` to automatically generate an output record to be filled by
the JCA connector when the response is received. This record is then returned to the caller
of the template.

This property holds an implementation of the <<cci-record-creator, `RecordCreator` interface>>,
to be used for that purpose. You must directly specify the `outputRecordCreator` property on
the `CciTemplate`. The following example shows how to do so:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	cciTemplate.setOutputRecordCreator(new EciOutputRecordCreator());
----

Alternatively (and we recommend this approach), in the Spring configuration, if the
`CciTemplate` is configured as a dedicated bean instance, you can define beans in the
following fashion:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="eciOutputRecordCreator" class="eci.EciOutputRecordCreator"/>

	<bean id="cciTemplate" class="org.springframework.jca.cci.core.CciTemplate">
		<property name="connectionFactory" ref="eciConnectionFactory"/>
		<property name="outputRecordCreator" ref="eciOutputRecordCreator"/>
	</bean>
----

NOTE: As the `CciTemplate` class is thread-safe, it is usually configured as a shared
instance.


[[template-summary]]
==== `CciTemplate` `Interaction` Summary

The following table summarizes the mechanisms of the `CciTemplate` class and the
corresponding methods called on the CCI `Interaction` interface:

[[cci-interaction-execute-methods]]
.Usage of Interaction execute methods
[cols="3,1,3"]
|===
| `CciTemplate` method signature | `CciTemplate` `outputRecordCreator` property | `execute` method called on the CCI Interaction

| `Record execute(InteractionSpec, Record)`
| Not set
| `Record execute(InteractionSpec, Record)`

| `Record execute(InteractionSpec, Record)`
| Set
| `boolean execute(InteractionSpec, Record, Record)`

| void execute(InteractionSpec, Record, Record)
| Not set
| void execute(InteractionSpec, Record, Record)

| `void execute(InteractionSpec, Record, Record)`
| Set
| `void execute(InteractionSpec, Record, Record)`

| `Record execute(InteractionSpec, RecordCreator)`
| Not set
| `Record execute(InteractionSpec, Record)`

| `Record execute(InteractionSpec, RecordCreator)`
| Set
| `void execute(InteractionSpec, Record, Record)`

| `Record execute(InteractionSpec, Record, RecordExtractor)`
| Not set
| `Record execute(InteractionSpec, Record)`

| `Record execute(InteractionSpec, Record, RecordExtractor)`
| Set
| `void execute(InteractionSpec, Record, Record)`

| `Record execute(InteractionSpec, RecordCreator, RecordExtractor)`
| Not set
| `Record execute(InteractionSpec, Record)`

| `Record execute(InteractionSpec, RecordCreator, RecordExtractor)`
| Set
| `void execute(InteractionSpec, Record, Record)`
|===


[[cci-straight]]
==== Using a CCI Connection and an Interaction Directly

`CciTemplate` also lets you work directly with CCI connections and
interactions, in the same manner as `JdbcTemplate` and `JmsTemplate`. This is useful
when you want to perform multiple operations on a CCI connection or interaction, for
example.

The `ConnectionCallback` interface provides a CCI `Connection` as an argument (to
perform custom operations on it) plus the CCI `ConnectionFactory` with which the `Connection`
was created. The latter can be useful (for example, to get an associated
`RecordFactory` instance and create indexed/mapped records).
The following listing shows the `ConnectionCallback` interface definition:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public interface ConnectionCallback {

		Object doInConnection(Connection connection, ConnectionFactory connectionFactory)
				throws ResourceException, SQLException, DataAccessException;

	}
----

The `InteractionCallback` interface provides the CCI `Interaction` (to perform
custom operations on it) plus the corresponding CCI `ConnectionFactory`.
The following listing shows the `InteractionCallback` interface definition:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public interface InteractionCallback {

		Object doInInteraction(Interaction interaction, ConnectionFactory connectionFactory)
			throws ResourceException, SQLException, DataAccessException;

	}
----

NOTE: `InteractionSpec` objects can either be shared across multiple template calls or be newly
created inside every callback method. This is completely up to the DAO implementation.


[[cci-template-example]]
==== Example of `CciTemplate` Usage

In this section, we show the usage of the `CciTemplate` to access a CICS with
ECI mode, with the IBM CICS ECI connector.

First, we must do some initializations on the CCI `InteractionSpec` to specify which
CICS program to access and how to interact with it, as the following example shows:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	ECIInteractionSpec interactionSpec = new ECIInteractionSpec();
	interactionSpec.setFunctionName("MYPROG");
	interactionSpec.setInteractionVerb(ECIInteractionSpec.SYNC_SEND_RECEIVE);
----

Then the program can use CCI through Spring's template and specify mappings between custom
objects and CCI `Records`, as the following example shows:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class MyDaoImpl extends CciDaoSupport implements MyDao {

		public OutputObject getData(InputObject input) {
			ECIInteractionSpec interactionSpec = ...;

		OutputObject output = (ObjectOutput) getCciTemplate().execute(interactionSpec,
			new RecordCreator() {
				public Record createRecord(RecordFactory recordFactory) throws ResourceException {
					return new CommAreaRecord(input.toString().getBytes());
				}
			},
			new RecordExtractor() {
				public Object extractData(Record record) throws ResourceException {
					CommAreaRecord commAreaRecord = (CommAreaRecord)record;
					String str = new String(commAreaRecord.toByteArray());
					String field1 = string.substring(0,6);
					String field2 = string.substring(6,1);
					return new OutputObject(Long.parseLong(field1), field2);
				}
			});

			return output;
		}
	}
----

As discussed previously, you can use callbacks to work directly on CCI connections or
interactions. The following example shows how to do so:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class MyDaoImpl extends CciDaoSupport implements MyDao {

		public OutputObject getData(InputObject input) {
			ObjectOutput output = (ObjectOutput) getCciTemplate().execute(
				new ConnectionCallback() {
					public Object doInConnection(Connection connection,
							ConnectionFactory factory) throws ResourceException {

						// do something...

					}
				});
			}
			return output;
		}

	}
----

NOTE: With a `ConnectionCallback`, the `Connection` used is managed and closed by the
`CciTemplate`, but the callback implementation must manage any interactions created on the
connection.

For a more specific callback, you can implement an `InteractionCallback`. If you do so, the passed-in
`Interaction` is managed and closed by the `CciTemplate`. The following example shows how to do so:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class MyDaoImpl extends CciDaoSupport implements MyDao {

		public String getData(String input) {
			ECIInteractionSpec interactionSpec = ...;
			String output = (String) getCciTemplate().execute(interactionSpec,
				new InteractionCallback() {
					public Object doInInteraction(Interaction interaction,
							ConnectionFactory factory) throws ResourceException {
						Record input = new CommAreaRecord(inputString.getBytes());
						Record output = new CommAreaRecord();
						interaction.execute(holder.getInteractionSpec(), input, output);
						return new String(output.toByteArray());
					}
				});
			return output;
		}

	}
----

For the preceding examples, the corresponding configuration of the involved Spring beans
could resemble the following example in non-managed mode:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="managedConnectionFactory" class="com.ibm.connector2.cics.ECIManagedConnectionFactory">
		<property name="serverName" value="TXSERIES"/>
		<property name="connectionURL" value="local:"/>
		<property name="userName" value="CICSUSER"/>
		<property name="password" value="CICS"/>
	</bean>

	<bean id="connectionFactory" class="org.springframework.jca.support.LocalConnectionFactoryBean">
		<property name="managedConnectionFactory" ref="managedConnectionFactory"/>
	</bean>

	<bean id="component" class="mypackage.MyDaoImpl">
		<property name="connectionFactory" ref="connectionFactory"/>
	</bean>
----

In managed mode (that is, in a Java EE environment), the configuration could resemble
the following example:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<jee:jndi-lookup id="connectionFactory" jndi-name="eis/cicseci"/>

	<bean id="component" class="MyDaoImpl">
		<property name="connectionFactory" ref="connectionFactory"/>
	</bean>
----



[[cci-object]]
=== Modeling CCI Access as Operation Objects

The `org.springframework.jca.cci.object` package contains support classes that let you
access the EIS in a different style: through reusable operation objects, analogous to
Spring's JDBC operation objects (see the <<data-access.adoc#jdbc, JDBC section of the
Data Access chapter>>). This usually encapsulates the CCI API. An application-level
input object is passed to the operation object, so it can construct the input record and
then convert the received record data to an application-level output object and return it.

NOTE: This approach is internally based on the `CciTemplate` class and the `RecordCreator`
or `RecordExtractor` interfaces, reusing the machinery of Spring's core CCI support.


[[cci-object-mapping-record]]
==== Using `MappingRecordOperation`

`MappingRecordOperation` essentially performs the same work as `CciTemplate` but
represents a specific, pre-configured operation as an object. It provides two template
methods to specify how to convert an input object to an input record and how to convert
an output record to an output object (record mapping):

* `createInputRecord(..)`: to specify how to convert an input object to an input `Record`
* `extractOutputData(..)`: to specify how to extract an output object from an output `Record`

The following listing shows the signatures of these methods:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public abstract class MappingRecordOperation extends EisOperation {

		...

		protected abstract Record createInputRecord(RecordFactory recordFactory,
				Object inputObject) throws ResourceException, DataAccessException {
			// ...
		}

		protected abstract Object extractOutputData(Record outputRecord)
				throws ResourceException, SQLException, DataAccessException {
			// ...
		}

		...

	}
----

Thereafter, ito execute an EIS operation, you need to use a single `execute`
method, passing in an application-level input object and receiving an application-level
output object as the result. The following example shows how to do so:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public abstract class MappingRecordOperation extends EisOperation {

		...

		public Object execute(Object inputObject) throws DataAccessException {
		}

		...
	}
----

Contrary to the `CciTemplate` class, this `execute(..)` method does not
have an `InteractionSpec` as an argument. Instead, the `InteractionSpec` is global to the
operation. You must use the following constructor to instantiate an operation object
with a specific `InteractionSpec`. The following example shows how to do so:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	InteractionSpec spec = ...;
	MyMappingRecordOperation eisOperation = new MyMappingRecordOperation(getConnectionFactory(), spec);
	...
----


[[cci-object-mapping-comm-area]]
==== Using `MappingCommAreaOperation`

Some connectors use records based on a COMMAREA, which represents an array of bytes
that contain parameters to send to the EIS and the data returned by it. Spring provides a
special operation class for working directly on COMMAREA rather than on records. The
`MappingCommAreaOperation` class extends the `MappingRecordOperation` class to provide
this special COMMAREA support. It implicitly uses the `CommAreaRecord` class as the input
and output record type and provides two new methods to convert an input object into an
input COMMAREA and convert the output COMMAREA into an output object. The following
listing shows the relevant method signatures:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public abstract class MappingCommAreaOperation extends MappingRecordOperation {

		...

		protected abstract byte[] objectToBytes(Object inObject)
				throws IOException, DataAccessException;

		protected abstract Object bytesToObject(byte[] bytes)
			throws IOException, DataAccessException;

		...

	}
----


[[cci-automatic-record-gen]]
==== Automatic Output Record Generation

As every `MappingRecordOperation` subclass is based on CciTemplate internally, the same
way to automatically generate output records as with `CciTemplate` is available.
Every operation object provides a corresponding `setOutputRecordCreator(..)` method.
For further information, see <<automatic-output-generation>>.


[[cci-object-summary]]
==== Summary

The operation object approach uses records in the same manner as the `CciTemplate` class.

[[cci-interaction-methods]]
.Usage of Interaction execute methods
[cols="3,1,3"]
|===
| `MappingRecordOperation` method signature | `MappingRecordOperation` `outputRecordCreator` property | `execute` method called on the CCI Interaction

| `Object execute(Object)`
| Not set
| `Record execute(InteractionSpec, Record)`

| `Object execute(Object)`
| Set
| `boolean execute(InteractionSpec, Record, Record)`
|===


[[cci-objects-mappring-record-example]]
==== Example of `MappingRecordOperation` Usage

In this section, we show how to use `MappingRecordOperation` to access a
database with the Blackbox CCI connector.

NOTE: The original version of this connector is provided by the Java EE SDK (version 1.3),
which is available from Oracle.

First, you must do some initializations on the CCI `InteractionSpec` to specify which
SQL request to execute. In the following example, we directly define the way to convert the
parameters of the request to a CCI record and the way to convert the CCI result record
to an instance of the `Person` class:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class PersonMappingOperation extends MappingRecordOperation {

		public PersonMappingOperation(ConnectionFactory connectionFactory) {
			setConnectionFactory(connectionFactory);
			CciInteractionSpec interactionSpec = new CciConnectionSpec();
			interactionSpec.setSql("select * from person where person_id=?");
			setInteractionSpec(interactionSpec);
		}

		protected Record createInputRecord(RecordFactory recordFactory,
				Object inputObject) throws ResourceException {
			Integer id = (Integer) inputObject;
			IndexedRecord input = recordFactory.createIndexedRecord("input");
			input.add(new Integer(id));
			return input;
		}

		protected Object extractOutputData(Record outputRecord)
				throws ResourceException, SQLException {
			ResultSet rs = (ResultSet) outputRecord;
			Person person = null;
			if (rs.next()) {
				Person person = new Person();
				person.setId(rs.getInt("person_id"));
				person.setLastName(rs.getString("person_last_name"));
				person.setFirstName(rs.getString("person_first_name"));
			}
			return person;
		}
	}
----

Then the application can execute the operation object, with the person identifier as an
argument. Note that you could set up the operation object as a shared instance, as it is
thread-safe. The following executes the operation object with the person identifier as an
argument:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class MyDaoImpl extends CciDaoSupport implements MyDao {

		public Person getPerson(int id) {
			PersonMappingOperation query = new PersonMappingOperation(getConnectionFactory());
			Person person = (Person) query.execute(new Integer(id));
			return person;
		}
	}
----

The corresponding configuration of Spring beans could be as follows in non-managed mode:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="managedConnectionFactory"
			class="com.sun.connector.cciblackbox.CciLocalTxManagedConnectionFactory">
		<property name="connectionURL" value="jdbc:hsqldb:hsql://localhost:9001"/>
		<property name="driverName" value="org.hsqldb.jdbcDriver"/>
	</bean>

	<bean id="targetConnectionFactory"
			class="org.springframework.jca.support.LocalConnectionFactoryBean">
		<property name="managedConnectionFactory" ref="managedConnectionFactory"/>
	</bean>

	<bean id="connectionFactory"
			class="org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter">
		<property name="targetConnectionFactory" ref="targetConnectionFactory"/>
		<property name="connectionSpec">
			<bean class="com.sun.connector.cciblackbox.CciConnectionSpec">
				<property name="user" value="sa"/>
				<property name="password" value=""/>
			</bean>
		</property>
	</bean>

	<bean id="component" class="MyDaoImpl">
		<property name="connectionFactory" ref="connectionFactory"/>
	</bean>
----

In managed mode (that is, in a Java EE environment), the configuration could be as
follows:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<jee:jndi-lookup id="targetConnectionFactory" jndi-name="eis/blackbox"/>

	<bean id="connectionFactory"
			class="org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter">
		<property name="targetConnectionFactory" ref="targetConnectionFactory"/>
		<property name="connectionSpec">
			<bean class="com.sun.connector.cciblackbox.CciConnectionSpec">
				<property name="user" value="sa"/>
				<property name="password" value=""/>
			</bean>
		</property>
	</bean>

	<bean id="component" class="MyDaoImpl">
		<property name="connectionFactory" ref="connectionFactory"/>
	</bean>
----


[[cci-objects-mapping-comm-area-example]]
==== Example of `MappingCommAreaOperation` Usage

In this section, we show how to use the usage of the `MappingCommAreaOperation` to access a
CICS with ECI mode with the IBM CICS ECI connector.

First, we need to initialize the CCI `InteractionSpec` to specify which CICS program
to access and how to interact with it, as the following example shows:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public abstract class EciMappingOperation extends MappingCommAreaOperation {

		public EciMappingOperation(ConnectionFactory connectionFactory, String programName) {
			setConnectionFactory(connectionFactory);
			ECIInteractionSpec interactionSpec = new ECIInteractionSpec(),
			interactionSpec.setFunctionName(programName);
			interactionSpec.setInteractionVerb(ECIInteractionSpec.SYNC_SEND_RECEIVE);
			interactionSpec.setCommareaLength(30);
			setInteractionSpec(interactionSpec);
			setOutputRecordCreator(new EciOutputRecordCreator());
		}

		private static class EciOutputRecordCreator implements RecordCreator {
			public Record createRecord(RecordFactory recordFactory) throws ResourceException {
				return new CommAreaRecord();
			}
		}

	}
----

We can then subclass the abstract `EciMappingOperation` class to specify mappings
between custom objects and `Records`, as the following example shows:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class MyDaoImpl extends CciDaoSupport implements MyDao {

		public OutputObject getData(Integer id) {
			EciMappingOperation query = new EciMappingOperation(getConnectionFactory(), "MYPROG") {

				protected abstract byte[] objectToBytes(Object inObject) throws IOException {
					Integer id = (Integer) inObject;
					return String.valueOf(id);
				}

				protected abstract Object bytesToObject(byte[] bytes) throws IOException;
					String str = new String(bytes);
					String field1 = str.substring(0,6);
					String field2 = str.substring(6,1);
					String field3 = str.substring(7,1);
					return new OutputObject(field1, field2, field3);
				}
			});

			return (OutputObject) query.execute(new Integer(id));
		}

	}
----

The corresponding configuration of Spring beans could be as follows in non-managed mode:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="managedConnectionFactory" class="com.ibm.connector2.cics.ECIManagedConnectionFactory">
		<property name="serverName" value="TXSERIES"/>
		<property name="connectionURL" value="local:"/>
		<property name="userName" value="CICSUSER"/>
		<property name="password" value="CICS"/>
	</bean>

	<bean id="connectionFactory" class="org.springframework.jca.support.LocalConnectionFactoryBean">
		<property name="managedConnectionFactory" ref="managedConnectionFactory"/>
	</bean>

	<bean id="component" class="MyDaoImpl">
		<property name="connectionFactory" ref="connectionFactory"/>
	</bean>
----

In managed mode (that is, in a Java EE environment), the configuration could be as
follows:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<jee:jndi-lookup id="connectionFactory" jndi-name="eis/cicseci"/>

	<bean id="component" class="MyDaoImpl">
		<property name="connectionFactory" ref="connectionFactory"/>
	</bean>
----



[[cci-tx]]
=== Transactions

JCA specifies several levels of transaction support for resource adapters. The kind of
transactions that your resource adapter supports is specified in its `ra.xml` file.
There are essentially three options: none (for example, with the CICS EPI connector), local
transactions (for example, with a CICS ECI connector), and global transactions (for example,
with an IMS connector). The following example configures the global option:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<connector>
		<resourceadapter>
			<!-- <transaction-support>NoTransaction</transaction-support> -->
			<!-- <transaction-support>LocalTransaction</transaction-support> -->
			<transaction-support>XATransaction</transaction-support>
		<resourceadapter>
	<connector>
----

For global transactions, you can use Spring's generic transaction infrastructure to
demarcate transactions, with `JtaTransactionManager` as the backend (delegating to the Java
EE server's distributed transaction coordinator underneath).

For local transactions on a single CCI `ConnectionFactory`, Spring provides a specific
transaction-management strategy for CCI, analogous to the `DataSourceTransactionManager`
for JDBC. The CCI API defines a local transaction object and corresponding local
transaction demarcation methods. Spring's `CciLocalTransactionManager` executes such
local CCI transactions in a fashion that is fully compliant with Spring's generic
`PlatformTransactionManager` abstraction. The following example configures a `CciLocalTransactionManager`:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<jee:jndi-lookup id="eciConnectionFactory" jndi-name="eis/cicseci"/>

	<bean id="eciTransactionManager"
			class="org.springframework.jca.cci.connection.CciLocalTransactionManager">
		<property name="connectionFactory" ref="eciConnectionFactory"/>
	</bean>
----

You can use both transaction strategies with any of Spring's transaction demarcation
facilities, be it declarative or programmatic. This is a consequence of Spring's generic
`PlatformTransactionManager` abstraction, which decouples transaction demarcation from
the actual execution strategy. You can switch between `JtaTransactionManager` and
`CciLocalTransactionManager` as needed, keeping your transaction demarcation as-is.

For more information on Spring's transaction facilities, see
<<data-access.adoc#transaction, Transaction Management>>.




[[mail]]
== Email

This section describes how to send email with the Spring Framework.

.Library dependencies
****
The following JAR needs to be on the classpath of your application in order to use
the Spring Framework's email library:

* The https://javaee.github.io/javamail/[JavaMail] library

This library is freely available on the web -- for example, in Maven Central as
`com.sun.mail:javax.mail`.
****

The Spring Framework provides a helpful utility library for sending email that shields
you from the specifics of the underlying mailing system and is responsible for
low-level resource handling on behalf of the client.

The `org.springframework.mail` package is the root level package for the Spring
Framework's email support. The central interface for sending emails is the `MailSender`
interface. A simple value object that encapsulates the properties of a simple mail such
as `from` and `to` (plus many others) is the `SimpleMailMessage` class. This package
also contains a hierarchy of checked exceptions that provide a higher level of
abstraction over the lower level mail system exceptions, with the root exception being
`MailException`. See the {api-spring-framework}/mail/MailException.html[javadoc]
for more information on the rich mail exception hierarchy.

The `org.springframework.mail.javamail.JavaMailSender` interface adds specialized
JavaMail features, such as MIME message support to the `MailSender` interface
(from which it inherits). `JavaMailSender` also provides a callback interface called
`org.springframework.mail.javamail.MimeMessagePreparator` for preparing a `MimeMessage`.



[[mail-usage]]
=== Usage

Assume that we have a business interface called `OrderManager`, as the following example shows:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public interface OrderManager {

		void placeOrder(Order order);

	}
----

Further assume that we have a requirement stating that an email message with an
order number needs to be generated and sent to a customer who placed the relevant order.


[[mail-usage-simple]]
==== Basic `MailSender` and `SimpleMailMessage` Usage

The following example shows how to use `MailSender` and `SimpleMailMessage` to send an
email when someone places an order:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	import org.springframework.mail.MailException;
	import org.springframework.mail.MailSender;
	import org.springframework.mail.SimpleMailMessage;

	public class SimpleOrderManager implements OrderManager {

		private MailSender mailSender;
		private SimpleMailMessage templateMessage;

		public void setMailSender(MailSender mailSender) {
			this.mailSender = mailSender;
		}

		public void setTemplateMessage(SimpleMailMessage templateMessage) {
			this.templateMessage = templateMessage;
		}

		public void placeOrder(Order order) {

			// Do the business calculations...

			// Call the collaborators to persist the order...

			// Create a thread safe "copy" of the template message and customize it
			SimpleMailMessage msg = new SimpleMailMessage(this.templateMessage);
			msg.setTo(order.getCustomer().getEmailAddress());
			msg.setText(
				"Dear " + order.getCustomer().getFirstName()
					+ order.getCustomer().getLastName()
					+ ", thank you for placing order. Your order number is "
					+ order.getOrderNumber());
			try{
				this.mailSender.send(msg);
			}
			catch (MailException ex) {
				// simply log it and go on...
				System.err.println(ex.getMessage());
			}
		}

	}
----

The following example shows the bean definitions for the preceding code:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="mailSender" class="org.springframework.mail.javamail.JavaMailSenderImpl">
		<property name="host" value="mail.mycompany.example"/>
	</bean>

	<!-- this is a template message that we can pre-load with default state -->
	<bean id="templateMessage" class="org.springframework.mail.SimpleMailMessage">
		<property name="from" value="customerservice@mycompany.example"/>
		<property name="subject" value="Your order"/>
	</bean>

	<bean id="orderManager" class="com.mycompany.businessapp.support.SimpleOrderManager">
		<property name="mailSender" ref="mailSender"/>
		<property name="templateMessage" ref="templateMessage"/>
	</bean>
----


[[mail-usage-mime]]
==== Using `JavaMailSender` and `MimeMessagePreparator`

This section describes another implementation of `OrderManager` that uses the `MimeMessagePreparator`
callback interface. In the following example, the `mailSender` property is of type
`JavaMailSender` so that we are able to use the JavaMail `MimeMessage` class:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	import javax.mail.Message;
	import javax.mail.MessagingException;
	import javax.mail.internet.InternetAddress;
	import javax.mail.internet.MimeMessage;

	import javax.mail.internet.MimeMessage;
	import org.springframework.mail.MailException;
	import org.springframework.mail.javamail.JavaMailSender;
	import org.springframework.mail.javamail.MimeMessagePreparator;

	public class SimpleOrderManager implements OrderManager {

		private JavaMailSender mailSender;

		public void setMailSender(JavaMailSender mailSender) {
			this.mailSender = mailSender;
		}

		public void placeOrder(final Order order) {
			// Do the business calculations...
			// Call the collaborators to persist the order...

			MimeMessagePreparator preparator = new MimeMessagePreparator() {
				public void prepare(MimeMessage mimeMessage) throws Exception {
					mimeMessage.setRecipient(Message.RecipientType.TO,
							new InternetAddress(order.getCustomer().getEmailAddress()));
					mimeMessage.setFrom(new InternetAddress("mail@mycompany.example"));
					mimeMessage.setText("Dear " + order.getCustomer().getFirstName() + " " +
							order.getCustomer().getLastName() + ", thanks for your order. " +
							"Your order number is " + order.getOrderNumber() + ".");
				}
			};

			try {
				this.mailSender.send(preparator);
			}
			catch (MailException ex) {
				// simply log it and go on...
				System.err.println(ex.getMessage());
			}
		}

	}
----

NOTE: The mail code is a crosscutting concern and could well be a candidate for
refactoring into a <<core.adoc#aop, custom Spring AOP aspect>>, which then could
be executed at appropriate joinpoints on the `OrderManager` target.

The Spring Framework's mail support ships with the standard JavaMail implementation.
See the relevant javadoc for more information.



[[mail-javamail-mime]]
=== Using the JavaMail `MimeMessageHelper`

A class that comes in pretty handy when dealing with JavaMail messages is
`org.springframework.mail.javamail.MimeMessageHelper`, which shields you from
having to use the verbose JavaMail API. Using the `MimeMessageHelper`, it is
pretty easy to create a `MimeMessage`, as the following example shows:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	// of course you would use DI in any real-world cases
	JavaMailSenderImpl sender = new JavaMailSenderImpl();
	sender.setHost("mail.host.com");

	MimeMessage message = sender.createMimeMessage();
	MimeMessageHelper helper = new MimeMessageHelper(message);
	helper.setTo("test@host.com");
	helper.setText("Thank you for ordering!");

	sender.send(message);
----


[[mail-javamail-mime-attachments]]
==== Sending Attachments and Inline Resources

Multipart email messages allow for both attachments and inline resources. Examples of
inline resources include an image or a stylesheet that you want to use in your message but
that you do not want displayed as an attachment.

[[mail-javamail-mime-attachments-attachment]]
===== Attachments

The following example shows you how to use the `MimeMessageHelper` to send an email
with a single JPEG image attachment:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	JavaMailSenderImpl sender = new JavaMailSenderImpl();
	sender.setHost("mail.host.com");

	MimeMessage message = sender.createMimeMessage();

	// use the true flag to indicate you need a multipart message
	MimeMessageHelper helper = new MimeMessageHelper(message, true);
	helper.setTo("test@host.com");

	helper.setText("Check out this image!");

	// let's attach the infamous windows Sample file (this time copied to c:/)
	FileSystemResource file = new FileSystemResource(new File("c:/Sample.jpg"));
	helper.addAttachment("CoolImage.jpg", file);

	sender.send(message);
----

[[mail-javamail-mime-attachments-inline]]
===== Inline Resources

The following example shows you how to use the `MimeMessageHelper` to send an email
with an inline image:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	JavaMailSenderImpl sender = new JavaMailSenderImpl();
	sender.setHost("mail.host.com");

	MimeMessage message = sender.createMimeMessage();

	// use the true flag to indicate you need a multipart message
	MimeMessageHelper helper = new MimeMessageHelper(message, true);
	helper.setTo("test@host.com");

	// use the true flag to indicate the text included is HTML
	helper.setText("<html><body><img src='cid:identifier1234'></body></html>", true);

	// let's include the infamous windows Sample file (this time copied to c:/)
	FileSystemResource res = new FileSystemResource(new File("c:/Sample.jpg"));
	helper.addInline("identifier1234", res);

	sender.send(message);
----

WARNING: Inline resources are added to the `MimeMessage` by using the specified `Content-ID`
(`identifier1234` in the above example). The order in which you add the text
and the resource are very important. Be sure to first add the text and then
the resources. If you are doing it the other way around, it does not work.


[[mail-templates]]
==== Creating Email Content by Using a Templating Library

The code in the examples shown in the previous sections explicitly created the content of the email message,
by using methods calls such as `message.setText(..)`. This is fine for simple cases, and it
is okay in the context of the aforementioned examples, where the intent was to show you
the very basics of the API.

In your typical enterprise application, though, developers often do not create the content
of email messages by using the previously shown approach for a number of reasons:

* Creating HTML-based email content in Java code is tedious and error prone.
* There is no clear separation between display logic and business logic.
* Changing the display structure of the email content requires writing Java code,
  recompiling, redeploying, and so on.

Typically, the approach taken to address these issues is to use a template library (such
as FreeMarker) to define the display structure of email content. This leaves your code
tasked only with creating the data that is to be rendered in the email template and
sending the email. It is definitely a best practice when the content of your email messages
becomes even moderately complex, and, with the Spring Framework's support classes for
FreeMarker, it becomes quite easy to do.




[[scheduling]]
== Task Execution and Scheduling

The Spring Framework provides abstractions for the asynchronous execution and scheduling of
tasks with the `TaskExecutor` and `TaskScheduler` interfaces, respectively. Spring also
features implementations of those interfaces that support thread pools or delegation to
CommonJ within an application server environment. Ultimately, the use of these
implementations behind the common interfaces abstracts away the differences between Java
SE 5, Java SE 6, and Java EE environments.

Spring also features integration classes to support scheduling with the `Timer`
(part of the JDK since 1.3) and the Quartz Scheduler ( https://www.quartz-scheduler.org/[]).
You can set up both of those schedulers by using a `FactoryBean` with optional references to
`Timer` or `Trigger` instances, respectively. Furthermore, a convenience class for both
the Quartz Scheduler and the `Timer` is available that lets you invoke a method of
an existing target object (analogous to the normal `MethodInvokingFactoryBean`
operation).



[[scheduling-task-executor]]
=== The Spring `TaskExecutor` Abstraction

Executors are the JDK name for the concept of thread pools. The "`executor`" naming is
due to the fact that there is no guarantee that the underlying implementation is
actually a pool. An executor may be single-threaded or even synchronous. Spring's
abstraction hides implementation details between the Java SE and Java EE environments.

Spring's `TaskExecutor` interface is identical to the `java.util.concurrent.Executor`
interface. In fact, originally, its primary reason for existence was to abstract away
the need for Java 5 when using thread pools. The interface has a single method
(`execute(Runnable task)`) that accepts a task for execution based on the semantics
and configuration of the thread pool.

The `TaskExecutor` was originally created to give other Spring components an abstraction
for thread pooling where needed. Components such as the `ApplicationEventMulticaster`,
JMS's `AbstractMessageListenerContainer`, and Quartz integration all use the
`TaskExecutor` abstraction to pool threads. However, if your beans need thread pooling
behavior, you can also use this abstraction for your own needs.


[[scheduling-task-executor-types]]
==== `TaskExecutor` Types

Spring includes a number of pre-built implementations of `TaskExecutor`.
In all likelihood, you should never need to implement your own.
The variants that Spring provides are as follows:

* `SyncTaskExecutor`:
  This implementation does not execute invocations asynchronously. Instead, each
  invocation takes place in the calling thread. It is primarily used in situations
  where multi-threading is not necessary, such as in simple test cases.
* `SimpleAsyncTaskExecutor`:
  This implementation does not reuse any threads. Rather, it starts up a new thread
  for each invocation. However, it does support a concurrency limit that blocks
  any invocations that are over the limit until a slot has been freed up. If you
  are looking for true pooling, see `ThreadPoolTaskExecutor`, later in this list.
* `ConcurrentTaskExecutor`:
  This implementation is an adapter for a `java.util.concurrent.Executor` instance.
  There is an alternative (`ThreadPoolTaskExecutor`) that exposes the `Executor`
  configuration parameters as bean properties. There is rarely a need to use
  `ConcurrentTaskExecutor` directly. However, if the `ThreadPoolTaskExecutor` is not
  flexible enough for your needs, `ConcurrentTaskExecutor` is an alternative.
* `ThreadPoolTaskExecutor`:
  This implementation is most commonly used. It exposes bean properties for
  configuring a `java.util.concurrent.ThreadPoolExecutor` and wraps it in a `TaskExecutor`.
  If you need to adapt to a different kind of `java.util.concurrent.Executor`, we
  recommend that you use a `ConcurrentTaskExecutor` instead.
* `WorkManagerTaskExecutor`:
  This implementation uses a CommonJ `WorkManager` as its backing service provider
  and is the central convenience class for setting up CommonJ-based thread pool
  integration on WebLogic or WebSphere within a Spring application context.
* `DefaultManagedTaskExecutor`:
  This implementation uses a JNDI-obtained `ManagedExecutorService` in a JSR-236
  compatible runtime environment (such as a Java EE 7+ application server),
  replacing a CommonJ WorkManager for that purpose.


[[scheduling-task-executor-usage]]
==== Using a `TaskExecutor`

Spring's `TaskExecutor` implementations are used as simple JavaBeans. In the following example,
we define a bean that uses the `ThreadPoolTaskExecutor` to asynchronously print
out a set of messages:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	import org.springframework.core.task.TaskExecutor;

	public class TaskExecutorExample {

		private class MessagePrinterTask implements Runnable {

			private String message;

			public MessagePrinterTask(String message) {
				this.message = message;
			}

			public void run() {
				System.out.println(message);
			}
		}

		private TaskExecutor taskExecutor;

		public TaskExecutorExample(TaskExecutor taskExecutor) {
			this.taskExecutor = taskExecutor;
		}

		public void printMessages() {
			for(int i = 0; i < 25; i++) {
				taskExecutor.execute(new MessagePrinterTask("Message" + i));
			}
		}
	}
----

As you can see, rather than retrieving a thread from the pool and executing it yourself,
you add your `Runnable` to the queue. Then the `TaskExecutor` uses its internal rules to
decide when the task gets executed.

To configure the rules that the `TaskExecutor` uses, we expose simple bean properties:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="taskExecutor" class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor">
		<property name="corePoolSize" value="5"/>
		<property name="maxPoolSize" value="10"/>
		<property name="queueCapacity" value="25"/>
	</bean>

	<bean id="taskExecutorExample" class="TaskExecutorExample">
		<constructor-arg ref="taskExecutor"/>
	</bean>
----



[[scheduling-task-scheduler]]
=== The Spring `TaskScheduler` Abstraction

In addition to the `TaskExecutor` abstraction, Spring 3.0 introduced a `TaskScheduler`
with a variety of methods for scheduling tasks to run at some point in the future.
The following listing shows the `TaskScheduler` interface definition:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public interface TaskScheduler {

		ScheduledFuture schedule(Runnable task, Trigger trigger);

		ScheduledFuture schedule(Runnable task, Instant startTime);

		ScheduledFuture schedule(Runnable task, Date startTime);

		ScheduledFuture scheduleAtFixedRate(Runnable task, Instant startTime, Duration period);

		ScheduledFuture scheduleAtFixedRate(Runnable task, Date startTime, long period);

		ScheduledFuture scheduleAtFixedRate(Runnable task, Duration period);

		ScheduledFuture scheduleAtFixedRate(Runnable task, long period);

		ScheduledFuture scheduleWithFixedDelay(Runnable task, Instant startTime, Duration delay);

		ScheduledFuture scheduleWithFixedDelay(Runnable task, Date startTime, long delay);

		ScheduledFuture scheduleWithFixedDelay(Runnable task, Duration delay);

		ScheduledFuture scheduleWithFixedDelay(Runnable task, long delay);
	}
----

The simplest method is the one named `schedule` that takes only a `Runnable` and a `Date`.
That causes the task to run once after the specified time. All of the other methods
are capable of scheduling tasks to run repeatedly. The fixed-rate and fixed-delay
methods are for simple, periodic execution, but the method that accepts a `Trigger` is
much more flexible.


[[scheduling-trigger-interface]]
==== `Trigger` Interface

The `Trigger` interface is essentially inspired by JSR-236 which, as of Spring 3.0,
was not yet officially implemented. The basic idea of the `Trigger` is that execution
times may be determined based on past execution outcomes or even arbitrary conditions.
If these determinations do take into account the outcome of the preceding execution,
that information is available within a `TriggerContext`. The `Trigger` interface itself
is quite simple, as the following listing shows:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public interface Trigger {

		Date nextExecutionTime(TriggerContext triggerContext);
	}
----

The `TriggerContext` is the most important part. It encapsulates all of
the relevant data and is open for extension in the future, if necessary. The
`TriggerContext` is an interface (a `SimpleTriggerContext` implementation is used by
default). The following listing shows the available methods for `Trigger` implementations.

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public interface TriggerContext {

		Date lastScheduledExecutionTime();

		Date lastActualExecutionTime();

		Date lastCompletionTime();
	}
----


[[scheduling-trigger-implementations]]
==== `Trigger` Implementations

Spring provides two implementations of the `Trigger` interface. The most interesting one
is the `CronTrigger`. It enables the scheduling of tasks based on cron expressions. For
example, the following task is scheduled to run 15 minutes past each hour but only
during the 9-to-5 "`business hours`" on weekdays:

[source,java,indent=0]
[subs="verbatim"]
----
	scheduler.schedule(task, new CronTrigger("0 15 9-17 * * MON-FRI"));
----

The other implementation is a `PeriodicTrigger` that accepts a fixed
period, an optional initial delay value, and a boolean to indicate whether the period
should be interpreted as a fixed-rate or a fixed-delay. Since the `TaskScheduler`
interface already defines methods for scheduling tasks at a fixed rate or with a
fixed delay, those methods should be used directly whenever possible. The value of the
`PeriodicTrigger` implementation is that you can use it within components that rely on
the `Trigger` abstraction. For example, it may be convenient to allow periodic triggers,
cron-based triggers, and even custom trigger implementations to be used interchangeably.
Such a component could take advantage of dependency injection so that you can configure such `Triggers`
externally and, therefore, easily modify or extend them.


[[scheduling-task-scheduler-implementations]]
==== `TaskScheduler` implementations

As with Spring's `TaskExecutor` abstraction, the primary benefit of the `TaskScheduler`
arrangement is that an application's scheduling needs are decoupled from the deployment
environment. This abstraction level is particularly relevant when deploying to an
application server environment where threads should not be created directly by the
application itself. For such scenarios, Spring provides a `TimerManagerTaskScheduler`
that delegates to a CommonJ `TimerManager` on WebLogic or WebSphere as well as a more recent
`DefaultManagedTaskScheduler` that delegates to a JSR-236 `ManagedScheduledExecutorService`
in a Java EE 7+ environment. Both are typically configured with a JNDI lookup.

Whenever external thread management is not a requirement, a simpler alternative is
a local `ScheduledExecutorService` setup within the application, which can be adapted
through Spring's `ConcurrentTaskScheduler`. As a convenience, Spring also provides a
`ThreadPoolTaskScheduler`, which internally delegates to a `ScheduledExecutorService`
to provide common bean-style configuration along the lines of `ThreadPoolTaskExecutor`.
These variants work perfectly fine for locally embedded thread pool setups in lenient
application server environments, as well -- in particular on Tomcat and Jetty.



[[scheduling-annotation-support]]
=== Annotation Support for Scheduling and Asynchronous Execution

Spring provides annotation support for both task scheduling and asynchronous method
execution.


[[scheduling-enable-annotation-support]]
==== Enable Scheduling Annotations

To enable support for `@Scheduled` and `@Async` annotations, you can add `@EnableScheduling` and
`@EnableAsync` to one of your `@Configuration` classes, as the following example shows:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	@EnableAsync
	@EnableScheduling
	public class AppConfig {
	}
----

You can pick and choose the relevant annotations for your application. For example,
if you need only support for `@Scheduled`, you can omit `@EnableAsync`. For more
fine-grained control, you can additionally implement the `SchedulingConfigurer`
interface, the `AsyncConfigurer` interface, or both. See the
{api-spring-framework}/scheduling/annotation/SchedulingConfigurer.html[`SchedulingConfigurer`]
and {api-spring-framework}/scheduling/annotation/AsyncConfigurer.html[`AsyncConfigurer`]
javadoc for full details.

If you prefer XML configuration, you can use the `<task:annotation-driven>` element,
as the following example shows:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<task:annotation-driven executor="myExecutor" scheduler="myScheduler"/>
	<task:executor id="myExecutor" pool-size="5"/>
	<task:scheduler id="myScheduler" pool-size="10"/>
----

Note that, with the preceding XML, an executor reference is provided for handling those
tasks that correspond to methods with the `@Async` annotation, and the scheduler
reference is provided for managing those methods annotated with `@Scheduled`.

NOTE: The default advice mode for processing `@Async` annotations is `proxy` which allows
for interception of calls through the proxy only. Local calls within the same class
cannot get intercepted that way. For a more advanced mode of interception, consider
switching to `aspectj` mode in combination with compile-time or load-time weaving.


[[scheduling-annotation-support-scheduled]]
==== The `@Scheduled` annotation

You can add the `@Scheduled` annotation to a method, along with trigger metadata. For
example, the following method is invoked every five seconds with a fixed delay,
meaning that the period is measured from the completion time of each preceding
invocation:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Scheduled(fixedDelay=5000)
	public void doSomething() {
		// something that should execute periodically
	}
----

If you need a fixed-rate execution, you can change the property name specified within
the annotation. The following method is invoked every five seconds (measured between the
successive start times of each invocation):

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Scheduled(fixedRate=5000)
	public void doSomething() {
		// something that should execute periodically
	}
----

For fixed-delay and fixed-rate tasks, you can specify an initial delay by indicating the
number of milliseconds to wait before the first execution of the method, as the following
`fixedRate` example shows:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Scheduled(initialDelay=1000, fixedRate=5000)
	public void doSomething() {
		// something that should execute periodically
	}
----

If simple periodic scheduling is not expressive enough, you can provide a cron expression.
For example, the following executes only on weekdays:

[source,java,indent=0]
[subs="verbatim"]
----
	@Scheduled(cron="*/5 * * * * MON-FRI")
	public void doSomething() {
		// something that should execute on weekdays only
	}
----

TIP: You can also use the `zone` attribute to specify the time zone in which the cron
expression is resolved.

Notice that the methods to be scheduled must have void returns and must not expect any
arguments. If the method needs to interact with other objects from the application
context, those would typically have been provided through dependency injection.

[NOTE]
====
As of Spring Framework 4.3, `@Scheduled` methods are supported on beans of any scope.

Make sure that you are not initializing multiple instances of the same `@Scheduled`
annotation class at runtime, unless you do want to schedule callbacks to each such
instance. Related to this, make sure that you do not use `@Configurable` on bean
classes that are annotated with `@Scheduled` and registered as regular Spring beans
with the container. Otherwise, you would get double initialization (once through the
container and once through the `@Configurable` aspect), with the consequence of each
`@Scheduled` method being invoked twice.
====


[[scheduling-annotation-support-async]]
==== The `@Async` annotation

You can provide the `@Async` annotation on a method so that invocation of that method
occurs asynchronously. In other words, the caller returns immediately upon
invocation, while the actual execution of the method occurs in a task that has been
submitted to a Spring `TaskExecutor`. In the simplest case, you can apply the annotation
to a method that returns `void`, as the following example shows:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Async
	void doSomething() {
		// this will be executed asynchronously
	}
----

Unlike the methods annotated with the `@Scheduled` annotation, these methods can expect
arguments, because they are invoked in the "`normal`" way by callers at runtime rather
than from a scheduled task being managed by the container. For example, the following code is
a legitimate application of the `@Async` annotation:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Async
	void doSomething(String s) {
		// this will be executed asynchronously
	}
----

Even methods that return a value can be invoked asynchronously. However, such methods
are required to have a `Future`-typed return value. This still provides the benefit of
asynchronous execution so that the caller can perform other tasks prior to calling
`get()` on that `Future`. The following example shows how to use `@Async` on a method
that returns a value:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Async
	Future<String> returnSomething(int i) {
		// this will be executed asynchronously
	}
----

TIP: `@Async` methods may not only declare a regular `java.util.concurrent.Future` return type
but also Spring's `org.springframework.util.concurrent.ListenableFuture` or, as of Spring
4.2, JDK 8's `java.util.concurrent.CompletableFuture`, for richer interaction with the
asynchronous task and for immediate composition with further processing steps.

You can not use `@Async` in conjunction with lifecycle callbacks such as
`@PostConstruct`. To asynchronously initialize Spring beans, you currently have to use
a separate initializing Spring bean that then invokes the `@Async` annotated method on the
target, as the following example shows:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class SampleBeanImpl implements SampleBean {

		@Async
		void doSomething() {
			// ...
		}

	}

	public class SampleBeanInitializer {

		private final SampleBean bean;

		public SampleBeanInitializer(SampleBean bean) {
			this.bean = bean;
		}

		@PostConstruct
		public void initialize() {
			bean.doSomething();
		}

	}
----

NOTE: There is no direct XML equivalent for `@Async`, since such methods should be designed
for asynchronous execution in the first place, not externally re-declared to be asynchronous.
However, you can manually set up Spring's `AsyncExecutionInterceptor` with Spring AOP,
in combination with a custom pointcut.


[[scheduling-annotation-support-qualification]]
==== Executor Qualification with `@Async`

By default, when specifying `@Async` on a method, the executor that is used is the
one <<scheduling-enable-annotation-support, configured when enabling async support>>,
i.e. the "`annotation-driven`" element if you are using XML or your `AsyncConfigurer`
implementation, if any. However, you can use the `value` attribute of the `@Async`
annotation when you need to indicate that an executor other than the default should be
used when executing a given method. The following example shows how to do so:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Async("otherExecutor")
	void doSomething(String s) {
		// this will be executed asynchronously by "otherExecutor"
	}
----

In this case, `"otherExecutor"` can be the name of any `Executor` bean in the Spring
container, or it may be the name of a qualifier associated with any `Executor` (for example, as
specified with the `<qualifier>` element or Spring's `@Qualifier` annotation).


[[scheduling-annotation-support-exception]]
==== Exception Management with `@Async`

When an `@Async` method has a `Future`-typed return value, it is easy to manage
an exception that was thrown during the method execution, as this exception is
thrown when calling `get` on the `Future` result. With a `void` return type,
however, the exception is uncaught and cannot be transmitted. You can provide an
`AsyncUncaughtExceptionHandler` to handle such exceptions. The following example shows
how to do so:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class MyAsyncUncaughtExceptionHandler implements AsyncUncaughtExceptionHandler {

		@Override
		public void handleUncaughtException(Throwable ex, Method method, Object... params) {
			// handle exception
		}
	}
----

By default, the exception is merely logged. You can define a custom `AsyncUncaughtExceptionHandler`
by using `AsyncConfigurer` or the `<task:annotation-driven/>` XML element.



[[scheduling-task-namespace]]
=== The `task` Namespace

As of version 3.0, Spring includes an XML namespace for configuring `TaskExecutor` and
`TaskScheduler` instances. It also provides a convenient way to configure tasks to be
scheduled with a trigger.


[[scheduling-task-namespace-scheduler]]
==== The 'scheduler' Element

The following element creates a `ThreadPoolTaskScheduler` instance with the
specified thread pool size:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<task:scheduler id="scheduler" pool-size="10"/>
----

The value provided for the `id` attribute is used as the prefix for thread names
within the pool. The `scheduler` element is relatively straightforward. If you do not
provide a `pool-size` attribute, the default thread pool has only a single thread.
There are no other configuration options for the scheduler.


[[scheduling-task-namespace-executor]]
==== The `executor` Element

The following creates a `ThreadPoolTaskExecutor` instance:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<task:executor id="executor" pool-size="10"/>
----

As with the scheduler shown in the <<scheduling-task-namespace-scheduler, previous section>>,
the value provided for the `id` attribute is used as the prefix for thread names within
the pool. As far as the pool size is concerned, the `executor` element supports more
configuration options than the `scheduler` element. For one thing, the thread pool for
a `ThreadPoolTaskExecutor` is itself more configurable. Rather than only a single size,
an executor's thread pool can have different values for the core and the max size.
If you provide a single value, the executor has a fixed-size thread pool (the core and
max sizes are the same). However, the `executor` element's `pool-size` attribute also
accepts a range in the form of `min-max`. The following example sets a minimum value of
`5` and a maximum value of `25`:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<task:executor
			id="executorWithPoolSizeRange"
			pool-size="5-25"
			queue-capacity="100"/>
----

In the preceding configuration, a `queue-capacity` value has also been provided.
The configuration of the thread pool should also be considered in light of the
executor's queue capacity. For the full description of the relationship between pool
size and queue capacity, see the documentation for
https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html[`ThreadPoolExecutor`].
The main idea is that, when a task is submitted, the executor first tries to use a
free thread if the number of active threads is currently less than the core size.
If the core size has been reached, the task is added to the queue, as long as its
capacity has not yet been reached. Only then, if the queue's capacity has been
reached, does the executor create a new thread beyond the core size. If the max size
has also been reached, then the executor rejects the task.

By default, the queue is unbounded, but this is rarely the desired configuration,
because it can lead to `OutOfMemoryErrors` if enough tasks are added to that queue while
all pool threads are busy. Furthermore, if the queue is unbounded, the max size has
no effect at all. Since the executor always tries the queue before creating a new
thread beyond the core size, a queue must have a finite capacity for the thread pool to
grow beyond the core size (this is why a fixed-size pool is the only sensible case
when using an unbounded queue).

Consider the case, as mentioned above, when a task is rejected. By default, when a
task is rejected, a thread pool executor throws a `TaskRejectedException`. However,
the rejection policy is actually configurable. The exception is thrown when using
the default rejection policy, which is the `AbortPolicy` implementation.
For applications where some tasks can be skipped under heavy load, you can instead
configure either `DiscardPolicy` or `DiscardOldestPolicy`. Another option that works
well for applications that need to throttle the submitted tasks under heavy load is
the `CallerRunsPolicy`. Instead of throwing an exception or discarding tasks,
that policy forces the thread that is calling the submit method to run the task itself.
The idea is that such a caller is busy while running that task and not able to submit
other tasks immediately. Therefore, it provides a simple way to throttle the incoming
load while maintaining the limits of the thread pool and queue. Typically, this allows
the executor to "`catch up`" on the tasks it is handling and thereby frees up some
capacity on the queue, in the pool, or both. You can choose any of these options from an
enumeration of values available for the `rejection-policy` attribute on the `executor`
element.

The following example shows an `executor` element with a number of attributes to specify
various behaviors:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<task:executor
			id="executorWithCallerRunsPolicy"
			pool-size="5-25"
			queue-capacity="100"
			rejection-policy="CALLER_RUNS"/>
----

Finally, the `keep-alive` setting determines the time limit (in seconds) for which threads
may remain idle before being terminated. If there are more than the core number of threads
currently in the pool, after waiting this amount of time without processing a task, excess
threads get terminated. A time value of zero causes excess threads to terminate
immediately after executing a task without remaining follow-up work in the task queue.
The following example sets the `keep-alive` value to two minutes:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<task:executor
			id="executorWithKeepAlive"
			pool-size="5-25"
			keep-alive="120"/>
----


[[scheduling-task-namespace-scheduled-tasks]]
==== The 'scheduled-tasks' Element

The most powerful feature of Spring's task namespace is the support for configuring
tasks to be scheduled within a Spring Application Context. This follows an approach
similar to other "`method-invokers`" in Spring, such as that provided by the JMS namespace
for configuring message-driven POJOs. Basically, a `ref` attribute can point to any
Spring-managed object, and the `method` attribute provides the name of a method to be
invoked on that object. The following listing shows a simple example:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<task:scheduled-tasks scheduler="myScheduler">
		<task:scheduled ref="beanA" method="methodA" fixed-delay="5000"/>
	</task:scheduled-tasks>

	<task:scheduler id="myScheduler" pool-size="10"/>
----

The scheduler is referenced by the outer element, and each individual
task includes the configuration of its trigger metadata. In the preceding example, that
metadata defines a periodic trigger with a fixed delay indicating the number of
milliseconds to wait after each task execution has completed. Another option is
`fixed-rate`, indicating how often the method should be executed regardless of how long
any previous execution takes. Additionally, for both `fixed-delay` and `fixed-rate` tasks, you can specify an
'initial-delay' parameter, indicating the number of milliseconds to wait
before the first execution of the method. For more control, you can instead provide a `cron` attribute.
The following example shows these other options:

[source,xml,indent=0]
[subs="verbatim"]
----
	<task:scheduled-tasks scheduler="myScheduler">
		<task:scheduled ref="beanA" method="methodA" fixed-delay="5000" initial-delay="1000"/>
		<task:scheduled ref="beanB" method="methodB" fixed-rate="5000"/>
		<task:scheduled ref="beanC" method="methodC" cron="*/5 * * * * MON-FRI"/>
	</task:scheduled-tasks>

	<task:scheduler id="myScheduler" pool-size="10"/>
----



[[scheduling-quartz]]
=== Using the Quartz Scheduler

Quartz uses `Trigger`, `Job`, and `JobDetail` objects to realize scheduling of all kinds
of jobs. For the basic concepts behind Quartz, see
https://www.quartz-scheduler.org/[]. For convenience purposes, Spring offers a couple of
classes that simplify using Quartz within Spring-based applications.


[[scheduling-quartz-jobdetail]]
==== Using the `JobDetailFactoryBean`

Quartz `JobDetail` objects contain all the information needed to run a job. Spring provides a
`JobDetailFactoryBean`, which provides bean-style properties for XML configuration purposes.
Consider the following example:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean name="exampleJob" class="org.springframework.scheduling.quartz.JobDetailFactoryBean">
		<property name="jobClass" value="example.ExampleJob"/>
		<property name="jobDataAsMap">
			<map>
				<entry key="timeout" value="5"/>
			</map>
		</property>
	</bean>
----

The job detail configuration has all the information it needs to run the job (`ExampleJob`).
The timeout is specified in the job data map. The job data map is available through the
`JobExecutionContext` (passed to you at execution time), but the `JobDetail` also gets
its properties from the job data mapped to properties of the job instance. So, in the following example,
the `ExampleJob` contains a bean property named `timeout`, and the `JobDetail`
has it applied automatically:

[source,java,indent=0]
[subs="verbatim"]
----
	package example;

	public class ExampleJob extends QuartzJobBean {

		private int timeout;

		/**
		 * Setter called after the ExampleJob is instantiated
		 * with the value from the JobDetailFactoryBean (5)
		 */
		public void setTimeout(int timeout) {
			this.timeout = timeout;
		}

		protected void executeInternal(JobExecutionContext ctx) throws JobExecutionException {
			// do the actual work
		}

	}
----

All additional properties from the job data map are available to you as well.

NOTE: By using the `name` and `group` properties, you can modify the name and the group
of the job, respectively. By default, the name of the job matches the bean name
of the `JobDetailFactoryBean` (`exampleJob` in the preceding example above).


[[scheduling-quartz-method-invoking-job]]
==== Using the `MethodInvokingJobDetailFactoryBean`

Often you merely need to invoke a method on a specific object. By using the
`MethodInvokingJobDetailFactoryBean`, you can do exactly this, as the following example shows:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="jobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean">
		<property name="targetObject" ref="exampleBusinessObject"/>
		<property name="targetMethod" value="doIt"/>
	</bean>
----

The preceding example results in the `doIt` method being called on the
`exampleBusinessObject` method, as the following example shows:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class ExampleBusinessObject {

		// properties and collaborators

		public void doIt() {
			// do the actual work
		}
	}
----

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="exampleBusinessObject" class="examples.ExampleBusinessObject"/>
----

By using the `MethodInvokingJobDetailFactoryBean`, you need not create one-line jobs
that merely invoke a method. You need only create the actual business object and
wire up the detail object.

By default, Quartz Jobs are stateless, resulting in the possibility of jobs interfering
with each other. If you specify two triggers for the same `JobDetail`, it is
possible that, before the first job has finished, the second one starts. If
`JobDetail` classes implement the `Stateful` interface, this does not happen. The second
job does not start before the first one has finished. To make jobs resulting from the
`MethodInvokingJobDetailFactoryBean` be non-concurrent, set the `concurrent` flag to
`false`, as the following example shows:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="jobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean">
		<property name="targetObject" ref="exampleBusinessObject"/>
		<property name="targetMethod" value="doIt"/>
		<property name="concurrent" value="false"/>
	</bean>
----

NOTE: By default, jobs will run in a concurrent fashion.


[[scheduling-quartz-cron]]
==== Wiring up Jobs by Using Triggers and `SchedulerFactoryBean`

We have created job details and jobs. We have also reviewed the convenience bean that lets
you invoke a method on a specific object. Of course, we still need to schedule the
jobs themselves. This is done by using triggers and a `SchedulerFactoryBean`. Several
triggers are available within Quartz, and Spring offers two Quartz `FactoryBean`
implementations with convenient defaults: `CronTriggerFactoryBean` and
`SimpleTriggerFactoryBean`.

Triggers need to be scheduled. Spring offers a `SchedulerFactoryBean` that exposes
triggers to be set as properties. `SchedulerFactoryBean` schedules the actual jobs with
those triggers.

The following listing uses both a `SimpleTriggerFactoryBean` and a `CronTriggerFactoryBean`:

[source,xml,indent=0]
[subs="verbatim"]
----
	<bean id="simpleTrigger" class="org.springframework.scheduling.quartz.SimpleTriggerFactoryBean">
		<!-- see the example of method invoking job above -->
		<property name="jobDetail" ref="jobDetail"/>
		<!-- 10 seconds -->
		<property name="startDelay" value="10000"/>
		<!-- repeat every 50 seconds -->
		<property name="repeatInterval" value="50000"/>
	</bean>

	<bean id="cronTrigger" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean">
		<property name="jobDetail" ref="exampleJob"/>
		<!-- run every morning at 6 AM -->
		<property name="cronExpression" value="0 0 6 * * ?"/>
	</bean>
----

The preceding example sets up two triggers, one running every 50 seconds with a starting delay of 10
seconds and one running every morning at 6 AM. To finalize everything, we need to set up the
`SchedulerFactoryBean`, as the following example shows:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean">
		<property name="triggers">
			<list>
				<ref bean="cronTrigger"/>
				<ref bean="simpleTrigger"/>
			</list>
		</property>
	</bean>
----

More properties are available for the `SchedulerFactoryBean`, such as the calendars
used by the job details, properties to customize Quartz with, and others. See the
{api-spring-framework}/scheduling/quartz/SchedulerFactoryBean.html[`SchedulerFactoryBean`]
javadoc for more information.




[[cache]]
== Cache Abstraction

Since version 3.1, the Spring Framework provides support for transparently adding caching to
an existing Spring application. Similar to the <<data-access.adoc#transaction, transaction>>
support, the caching abstraction allows consistent use of various caching solutions with
minimal impact on the code.

As from Spring 4.1, the cache abstraction has been significantly extended with the
support of <<cache-jsr-107,JSR-107 annotations>> and more customization options.



[[cache-strategies]]
=== Understanding the Cache Abstraction

.Cache vs Buffer
****

The terms, "`buffer`" and "`cache,`" tend to be used interchangeably. Note, however,
that they represent different things. Traditionally, a buffer is used as an intermediate
temporary store for data between a fast and a slow entity. As one party would have to wait
for the other (which affects performance), the buffer alleviates this by allowing entire
blocks of data to move at once rather than in small chunks. The data is written and read
only once from the buffer. Furthermore, the buffers are visible to at least one party
that is aware of it.

A cache, on the other hand, is, by definition, hidden, and neither party is aware that
caching occurs. It also improves performance but does so by letting the same data be
read multiple times in a fast fashion.

You can find a further explanation of the differences between a buffer and a cache
https://en.wikipedia.org/wiki/Cache_(computing)#The_difference_between_buffer_and_cache[here].
****

At its core, the cache abstraction applies caching to Java methods, thus reducing the
number of executions based on the information available in the cache. That is, each time
a targeted method is invoked, the abstraction applies a caching behavior that checks
whether the method has been already executed for the given arguments. If it has been
executed, the cached result is returned without having to execute the actual method.
If the method has not been executed, then it is executed, and the result is cached and
returned to the user so that, the next time the method is invoked, the cached result is
returned. This way, expensive methods (whether CPU- or IO-bound) can be executed only
once for a given set of parameters and the result reused without having to actually
execute the method again. The caching logic is applied transparently without any
interference to the invoker.

IMPORTANT: This approach works only for methods that are guaranteed to return the same
output (result) for a given input (or arguments) no matter how many times it is executed.

The caching abstraction provides other cache-related operations, such as the ability
to update the content of the cache or to remove one or all entries. These are useful if
the cache deals with data that can change during the course of the application.

As with other services in the Spring Framework, the caching service is an abstraction
(not a cache implementation) and requires the use of actual storage to store the cache data --
that is, the abstraction frees you from having to write the caching logic but does not
provide the actual data store. This abstraction is materialized by the
`org.springframework.cache.Cache` and `org.springframework.cache.CacheManager` interfaces.

Spring provides <<cache-store-configuration, a few implementations>> of that abstraction:
JDK `java.util.concurrent.ConcurrentMap` based caches, https://www.ehcache.org/[Ehcache 2.x],
Gemfire cache, https://github.com/ben-manes/caffeine/wiki[Caffeine], and JSR-107
compliant caches (such as Ehcache 3.x). See <<cache-plug>> for more information on
plugging in other cache stores and providers.

IMPORTANT: The caching abstraction has no special handling for multi-threaded and
multi-process environments, as such features are handled by the cache implementation. .

If you have a multi-process environment (that is, an application deployed on several nodes),
you need to configure your cache provider accordingly. Depending on your use cases, a copy
of the same data on several nodes can be enough. However, if you change the data during
the course of the application, you may need to enable other propagation mechanisms.

Caching a particular item is a direct equivalent of the typical get-if-not-found-then-
proceed-and-put-eventually code blocks found with programmatic cache interaction.
No locks are applied, and several threads may try to load the same item concurrently.
The same applies to eviction. If several threads are trying to update or evict data
concurrently, you may use stale data. Certain cache providers offer advanced features
in that area. See the documentation of your cache provider for more details.

To use the cache abstraction, you need to take care of two aspects:

* Caching declaration: Identify the methods that need to be cached and their policy.
* Cache configuration: The backing cache where the data is stored and from which it is read.



[[cache-annotations]]
=== Declarative Annotation-based Caching

For caching declaration, Spring's caching abstraction provides a set of Java annotations:

* `@Cacheable`: Triggers cache population.
* `@CacheEvict`: Triggers cache eviction.
* `@CachePut`: Updates the cache without interfering with the method execution.
* `@Caching`: Regroups multiple cache operations to be applied on a method.
* `@CacheConfig`: Shares some common cache-related settings at class-level.


[[cache-annotations-cacheable]]
==== The `@Cacheable` Annotation

As the name implies, you can use `@Cacheable` to demarcate methods that are cacheable --
that is, methods for which the result is stored in the cache so that, on subsequent
invocations (with the same arguments), the value in the cache is returned without
having to actually execute the method. In its simplest form, the annotation declaration
requires the name of the cache associated with the annotated method, as the following
example shows:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Cacheable("books")
	public Book findBook(ISBN isbn) {...}
----

In the preceding snippet, the `findBook` method is associated with the cache named `books`.
Each time the method is called, the cache is checked to see whether the invocation has
already been executed and does not have to be repeated. While in most cases, only one
cache is declared, the annotation lets multiple names be specified so that more than one
cache is being used. In this case, each of the caches is checked before executing the
method -- if at least one cache is hit, the associated value is returned.

NOTE: All the other caches that do not contain the value are also updated, even though
the cached method was not actually executed.

The following example uses `@Cacheable` on the `findBook` method:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Cacheable({"books", "isbns"})
	public Book findBook(ISBN isbn) {...}
----

[[cache-annotations-cacheable-default-key]]
===== Default Key Generation

Since caches are essentially key-value stores, each invocation of a cached method
needs to be translated into a suitable key for cache access. The caching abstraction
uses a simple `KeyGenerator` based on the following algorithm:

* If no params are given, return `SimpleKey.EMPTY`.
* If only one param is given, return that instance.
* If more than one param is given, return a `SimpleKey` that contains all parameters.

This approach works well for most use-cases, as long as parameters have natural keys
and implement valid `hashCode()` and `equals()` methods. If that is not the case,
you need to change the strategy.

To provide a different default key generator, you need to implement the
`org.springframework.cache.interceptor.KeyGenerator` interface.

[NOTE]
====
The default key generation strategy changed with the release of Spring 4.0. Earlier
versions of Spring used a key generation strategy that, for multiple key parameters,
considered only the `hashCode()` of parameters and not `equals()`. This could cause
unexpected key collisions (see https://jira.spring.io/browse/SPR-10237[SPR-10237]
for background). The new `SimpleKeyGenerator` uses a compound key for such scenarios.

If you want to keep using the previous key strategy, you can configure the deprecated
`org.springframework.cache.interceptor.DefaultKeyGenerator` class or create a custom
hash-based `KeyGenerator` implementation.
====

[[cache-annotations-cacheable-key]]
===== Custom Key Generation Declaration

Since caching is generic, the target methods are quite likely to have various signatures
that cannot be readily mapped on top of the cache structure. This tends to become obvious
when the target method has multiple arguments out of which only some are suitable for
caching (while the rest are used only by the method logic). Consider the following example:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Cacheable("books")
	public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)
----

At first glance, while the two `boolean` arguments influence the way the book is found,
they are no use for the cache. Furthermore, what if only one of the two is important
while the other is not?

For such cases, the `@Cacheable` annotation lets you specify how the key is generated
through its `key` attribute. You can use <<core.adoc#expressions, SpEL>> to pick the
arguments of interest (or their nested properties), perform operations, or even
invoke arbitrary methods without having to write any code or implement any interface.
This is the recommended approach over the
<<cache-annotations-cacheable-default-key, default generator>>, since methods tend to be
quite different in signatures as the code base grows. While the default strategy might
work for some methods, it rarely works for all methods.

The following examples ise various SpEL declarations (if you are not familiar with SpEL,
do yourself a favor and read <<core.adoc#expressions, Spring Expression Language>>):

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Cacheable(cacheNames="books", key="#isbn")
	public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)

	@Cacheable(cacheNames="books", key="#isbn.rawNumber")
	public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)

	@Cacheable(cacheNames="books", key="T(someType).hash(#isbn)")
	public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)
----

The preceding snippets show how easy it is to select a certain argument, one of its
properties, or even an arbitrary (static) method.

If the algorithm responsible for generating the key is too specific or if it needs
to be shared, you can define a custom `keyGenerator` on the operation. To do so,
specify the name of the `KeyGenerator` bean implementation to use, as the following
example shows:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Cacheable(cacheNames="books", keyGenerator="myKeyGenerator")
	public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)
----

NOTE: The `key` and `keyGenerator` parameters are mutually exclusive and an operation
that specifies both results in an exception.

[[cache-annotations-cacheable-default-cache-resolver]]
===== Default Cache Resolution

The caching abstraction uses a simple `CacheResolver` that
retrieves the caches defined at the operation level by using the configured
`CacheManager`.

To provide a different default cache resolver, you need to implement the
`org.springframework.cache.interceptor.CacheResolver` interface.

[[cache-annotations-cacheable-cache-resolver]]
===== Custom Cache Resolution

The default cache resolution fits well for applications that work with a
single `CacheManager` and have no complex cache resolution requirements.

For applications that work with several cache managers, you can set the
`cacheManager` to use for each operation, as the following example shows:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Cacheable(cacheNames="books", cacheManager="anotherCacheManager") <1>
	public Book findBook(ISBN isbn) {...}
----
<1> Specifying `anotherCacheManager`.


You can also replace the `CacheResolver` entirely in a fashion similar to that of
replacing <<cache-annotations-cacheable-key, key generation>>. The resolution is
requested for every cache operation, letting the implementation actually resolve
the caches to use based on runtime arguments. The following example shows how to
specify a `CacheResolver`:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Cacheable(cacheResolver="runtimeCacheResolver") <1>
	public Book findBook(ISBN isbn) {...}
----
<1> Specifying the `CacheResolver`.


[NOTE]
====
Since Spring 4.1, the `value` attribute of the cache annotations are no longer
mandatory, since this particular information can be provided by the `CacheResolver`
regardless of the content of the annotation.

Similarly to `key` and `keyGenerator`, the `cacheManager` and `cacheResolver`
parameters are mutually exclusive, and an operation specifying both
results in an exception. as a custom `CacheManager` is ignored by the
`CacheResolver` implementation. This is probably not what you expect.
====

[[cache-annotations-cacheable-synchronized]]
===== Synchronized Caching

In a multi-threaded environment, certain operations might be concurrently invoked for
the same argument (typically on startup). By default, the cache abstraction does not
lock anything, and the same value may be computed several times, defeating the purpose
of caching.

For those particular cases, you can use the `sync` attribute to instruct the underlying
cache provider to lock the cache entry while the value is being computed. As a result,
only one thread is busy computing the value, while the others are blocked until the entry
is updated in the cache. The following example shows how to use the `sync` attribute:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Cacheable(cacheNames="foos", sync=true) <1>
	public Foo executeExpensiveOperation(String id) {...}
----
<1> Using the `sync` attribute.


NOTE: This is an optional feature, and your favorite cache library may not support it.
All `CacheManager` implementations provided by the core framework support it. See the
documentation of your cache provider for more details.

[[cache-annotations-cacheable-condition]]
===== Conditional Caching

Sometimes, a method might not be suitable for caching all the time (for example, it
might depend on the given arguments). The cache annotations support such functionality
through the `condition` parameter, which takes a `SpEL` expression that is evaluated to
either `true` or `false`. If `true`, the method is cached. If not, it behaves as if the
method is not cached (that is, the method is executed every time no matter what values are in the cache
or what arguments are used). For example, the following method is cached only
if the argument `name` has a length shorter than 32:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Cacheable(cacheNames="book", condition="#name.length() < 32") <1>
	public Book findBook(String name)
----
<1> Setting a condition on `@Cacheable`.


In addition to the `condition` parameter, you can use the `unless` parameter to veto the
adding of a value to the cache. Unlike `condition`, `unless` expressions are evaluated
after the method has been called. To expand on the previous example, perhaps we
only want to cache paperback books, as the following example does:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Cacheable(cacheNames="book", condition="#name.length() < 32", unless="#result.hardback") <1>
	public Book findBook(String name)
----
<1> Using the `unless` attribute to block hardbacks.


The cache abstraction supports `java.util.Optional`, using its content as the cached value
only if it is present. `#result` always refers to the business entity and never a
supported wrapper, so the previous example can be rewritten as follows:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Cacheable(cacheNames="book", condition="#name.length() < 32", unless="#result?.hardback")
	public Optional<Book> findBook(String name)
----

Note that `result` still refers to `Book` and not `Optional`. As it might be `null`, we
should use the safe navigation operator.

[[cache-spel-context]]
===== Available Caching SpEL Evaluation Context

Each `SpEL` expression evaluates against a dedicated <<core.adoc#expressions-language-ref, `context`>>.
In addition to the built-in parameters, the framework provides dedicated caching-related
metadata, such as the argument names. The following table describes the items made
available to the context so that you can use them for key and conditional computations:

[[cache-spel-context-tbl]]
.Cache SpEL available metadata
|===
| Name| Location| Description| Example

| `methodName`
| Root object
| The name of the method being invoked
| `#root.methodName`

| `method`
| Root object
| The method being invoked
| `#root.method.name`

| `target`
| Root object
| The target object being invoked
| `#root.target`

| `targetClass`
| Root object
| The class of the target being invoked
| `#root.targetClass`

| `args`
| Root object
| The arguments (as array) used for invoking the target
| `#root.args[0]`

| `caches`
| Root object
| Collection of caches against which the current method is executed
| `#root.caches[0].name`

| Argument name
| Evaluation context
| Name of any of the method arguments. If the names are not available
  (perhaps due to having no debug information), the argument names are also available under the `#a<#arg>`
  where `#arg` stands for the argument index (starting from `0`).
| `#iban` or `#a0` (you can also use `#p0` or `#p<#arg>` notation as an alias).

| `result`
| Evaluation context
| The result of the method call (the value to be cached). Only available in `unless`
  expressions, `cache put` expressions (to compute the `key`), or `cache evict`
  expressions (when `beforeInvocation` is `false`). For supported wrappers (such as
  `Optional`), `#result` refers to the actual object, not the wrapper.
| `#result`
|===


[[cache-annotations-put]]
==== The `@CachePut` Annotation

When the cache needs to be updated without interfering with the method execution,
you can use the `@CachePut` annotation. That is, the method is always executed and its
result is placed into the cache (according to the `@CachePut` options). It supports
the same options as `@Cacheable` and should be used for cache population rather than
method flow optimization. The following example uses the `@CachePut` annotation:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@CachePut(cacheNames="book", key="#isbn")
	public Book updateBook(ISBN isbn, BookDescriptor descriptor)
----

IMPORTANT: Using `@CachePut` and `@Cacheable` annotations on the same method is generally
strongly discouraged because they have different behaviors. While the latter causes the
method execution to be skipped by using the cache, the former forces the execution in
order to execute a cache update. This leads to unexpected behavior and, with the exception
of specific corner-cases (such as annotations having conditions that exclude them from each
other), such declarations should be avoided. Note also that such conditions should not rely
on the result object (that is, the `#result` variable), as these are validated up-front to
confirm the exclusion.


[[cache-annotations-evict]]
==== The `@CacheEvict` annotation

The cache abstraction allows not just population of a cache store but also eviction.
This process is useful for removing stale or unused data from the cache. As opposed to
`@Cacheable`, `@CacheEvict` demarcates methods that perform cache
eviction (that is, methods that act as triggers for removing data from the cache).
Similarly to its sibling, `@CacheEvict` requires specifying one or more caches
that are affected by the action, allows a custom cache and key resolution or a
condition to be specified, and features an extra parameter
(`allEntries`) that indicates whether a cache-wide eviction needs to be performed
rather than just an entry eviction (based on the key). The following example evicts
all entries from the `books` cache:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@CacheEvict(cacheNames="books", allEntries=true) <1>
	public void loadBooks(InputStream batch)
----
<1> Using the `allEntries` attribute to evict all entries from the cache.


This option comes in handy when an entire cache region needs to be cleared out.
Rather than evicting each entry (which would take a long time, since it is inefficient),
all the entries are removed in one operation, as the preceding example shows.
Note that the framework ignores any key specified in this scenario as it does not apply
(the entire cache is evicted, not only one entry).

You can also indicate whether the eviction should occur after (the default) or before
the method executes by using the `beforeInvocation` attribute. The former provides the
same semantics as the rest of the annotations: Once the method completes successfully,
an action (in this case, eviction) on the cache is executed. If the method does not
execute (as it might be cached) or an exception is thrown, the eviction does not occur.
The latter (`beforeInvocation=true`) causes the eviction to always occur before the
method is invoked. This is useful in cases where the eviction does not need to be tied
to the method outcome.

Note that `void` methods can be used with `@CacheEvict` - as the methods act as a trigger,
the return values are ignored (as they do not interact with the cache). This is not the case
with `@Cacheable` which adds or updates data into the cache and, thus, requires a result.


[[cache-annotations-caching]]
==== The `@Caching` Annotation

Sometimes, multiple annotations of the same type (such as `@CacheEvict` or
`@CachePut`) need to be specified -- for example, because the condition or the key
expression is different between different caches. `@Caching` lets multiple nested
`@Cacheable`, `@CachePut`, and `@CacheEvict` annotations be used on the same method.
The following example uses two `@CacheEvict` annotations:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Caching(evict = { @CacheEvict("primary"), @CacheEvict(cacheNames="secondary", key="#p0") })
	public Book importBooks(String deposit, Date date)
----


[[cache-annotations-config]]
==== The `@CacheConfig` annotation

So far, we have seen that caching operations offer many customization options and that
you can set these options for each operation. However, some of the customization options
can be tedious to configure if they apply to all operations of the class. For
instance, specifying the name of the cache to use for every cache operation of the
class can be replaced by a single class-level definition. This is where `@CacheConfig`
comes into play. The following examples uses `@CacheConfig` to set the name of the cache:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@CacheConfig("books") <1>
	public class BookRepositoryImpl implements BookRepository {

		@Cacheable
		public Book findBook(ISBN isbn) {...}
	}
----
<1> Using `@CacheConfig` to set the name of the cache.


`@CacheConfig` is a class-level annotation that allows sharing the cache names,
the custom `KeyGenerator`, the custom `CacheManager`, and the custom `CacheResolver`.
Placing this annotation on the class does not turn on any caching operation.

An operation-level customization always overrides a customization set on `@CacheConfig`.
Therefore, this gives three levels of customizations for each cache operation:

* Globally configured, available for `CacheManager`, `KeyGenerator`.
* At the class level, using `@CacheConfig`.
* At the operation level.


[[cache-annotation-enable]]
==== Enabling Caching Annotations

It is important to note that even though declaring the cache annotations does not
automatically trigger their actions - like many things in Spring, the feature has to be
declaratively enabled (which means if you ever suspect caching is to blame, you can
disable it by removing only one configuration line rather than all the annotations in
your code).

To enable caching annotations add the annotation `@EnableCaching` to one of your
`@Configuration` classes:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	@EnableCaching
	public class AppConfig {
	}
----

Alternatively, for XML configuration you can use the `cache:annotation-driven` element:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:cache="http://www.springframework.org/schema/cache"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/cache https://www.springframework.org/schema/cache/spring-cache.xsd">

			<cache:annotation-driven/>
	</beans>
----

Both the `cache:annotation-driven` element and the `@EnableCaching` annotation let you
specify various options that influence the way the caching behavior is added to the
application through AOP. The configuration is intentionally similar with that of
<<data-access.adoc#tx-annotation-driven-settings, `@Transactional`>>.

NOTE: The default advice mode for processing caching annotations is `proxy`, which allows
for interception of calls through the proxy only. Local calls within the same class
cannot get intercepted that way. For a more advanced mode of interception, consider
switching to `aspectj` mode in combination with compile-time or load-time weaving.

NOTE: For more detail about advanced customizations (using Java configuration) that are
required to implement `CachingConfigurer`, see the
{api-spring-framework}/cache/annotation/CachingConfigurer.html[javadoc].

[[cache-annotation-driven-settings]]
.Cache annotation settings
[cols="1,1,1,3"]
|===
| XML Attribute | Annotation Attribute | Default | Description

| `cache-manager`
| N/A (see the {api-spring-framework}/cache/annotation/CachingConfigurer.html[`CachingConfigurer`] javadoc)
| `cacheManager`
| The name of the cache manager to use. A default `CacheResolver` is initialized behind
  the scenes with this cache manager (or `cacheManager` if not set). For more
  fine-grained management of the cache resolution, consider setting the 'cache-resolver'
  attribute.

| `cache-resolver`
| N/A (see the {api-spring-framework}/cache/annotation/CachingConfigurer.html[`CachingConfigurer`] javadoc)
| A `SimpleCacheResolver` using the configured `cacheManager`.
| The bean name of the CacheResolver that is to be used to resolve the backing caches.
  This attribute is not required and needs to be specified only as an alternative to
  the 'cache-manager' attribute.

| `key-generator`
| N/A (see the {api-spring-framework}/cache/annotation/CachingConfigurer.html[`CachingConfigurer`] javadoc)
| `SimpleKeyGenerator`
| Name of the custom key generator to use.

| `error-handler`
| N/A (see the {api-spring-framework}/cache/annotation/CachingConfigurer.html[`CachingConfigurer`] javadoc)
| `SimpleCacheErrorHandler`
| The name of the custom cache error handler to use. By default, any exception thrown during
  a cache related operation is thrown back at the client.

| `mode`
| `mode`
| `proxy`
| The default mode (`proxy`) processes annotated beans to be proxied by using Spring's AOP
  framework (following proxy semantics, as discussed earlier, applying to method calls
  coming in through the proxy only). The alternative mode (`aspectj`) instead weaves the
  affected classes with Spring's AspectJ caching aspect, modifying the target class byte
  code to apply to any kind of method call. AspectJ weaving requires `spring-aspects.jar`
  in the classpath as well as load-time weaving (or compile-time weaving) enabled. (See
  <<core.adoc#aop-aj-ltw-spring, Spring configuration>> for details on how to set up
  load-time weaving.)

| `proxy-target-class`
| `proxyTargetClass`
| `false`
| Applies to proxy mode only. Controls what type of caching proxies are created for
  classes annotated with the `@Cacheable` or `@CacheEvict` annotations. If the
  `proxy-target-class` attribute is set to `true`, class-based proxies are created.
  If `proxy-target-class` is `false` or if the attribute is omitted, standard JDK
  interface-based proxies are created. (See <<core.adoc#aop-proxying, Proxying Mechanisms>>
  for a detailed examination of the different proxy types.)

| `order`
| `order`
| Ordered.LOWEST_PRECEDENCE
| Defines the order of the cache advice that is applied to beans annotated with
  `@Cacheable` or `@CacheEvict`. (For more information about the rules related to
  ordering AOP advice, see <<core.adoc#aop-ataspectj-advice-ordering, Advice Ordering>>.)
  No specified ordering means that the AOP subsystem determines the order of the advice.
|===

NOTE: `<cache:annotation-driven/>` looks for `@Cacheable/@CachePut/@CacheEvict/@Caching`
only on beans in the same application context in which it is defined. This means that,
if you put `<cache:annotation-driven/>` in a `WebApplicationContext` for a
`DispatcherServlet`, it checks for beans only in your controllers, not your services.
See <<web.adoc#mvc-servlet, the MVC section>> for more information.

.Method visibility and cache annotations
****
When you use proxies, you should apply the cache annotations only to methods with
public visibility. If you do annotate protected, private, or package-visible methods
with these annotations, no error is raised, but the annotated method does not exhibit
the configured caching settings. Consider using AspectJ (see the rest of this section)
if you need to annotate non-public methods, as it changes the bytecode itself.
****

TIP: Spring recommends that you only annotate concrete classes (and methods of concrete
classes) with the `@Cache{asterisk}` annotation, as opposed to annotating interfaces.
You certainly can place the `@Cache{asterisk}` annotation on an interface (or an interface
method), but this works only as you would expect it to if you use interface-based proxies.
The fact that Java annotations are not inherited from interfaces means that, if you use
class-based proxies (`proxy-target-class="true"`) or the weaving-based aspect
(`mode="aspectj"`), the caching settings are not recognized by the proxying and weaving
infrastructure, and the object is not wrapped in a caching proxy.

NOTE: In proxy mode (the default), only external method calls coming in through the
proxy are intercepted. This means that self-invocation (in effect, a method within the
target object that calls another method of the target object) does not lead to actual
caching at runtime even if the invoked method is marked with `@Cacheable`. Consider
using the `aspectj` mode in this case. Also, the proxy must be fully initialized to
provide the expected behavior, so you should not rely on this feature in your
initialization code (that is, `@PostConstruct`).


[[cache-annotation-stereotype]]
==== Using Custom Annotations

.Custom annotation and AspectJ
****
This feature works only with the proxy-based approach but can be enabled
with a bit of extra effort by using AspectJ.

The `spring-aspects` module defines an aspect for the standard annotations only.
If you have defined your own annotations, you also need to define an aspect for
those. Check `AnnotationCacheAspect` for an example.
****

The caching abstraction lets you use your own annotations to identify what method
triggers cache population or eviction. This is quite handy as a template mechanism,
as it eliminates the need to duplicate cache annotation declarations, which is
especially useful if the key or condition are specified or if the foreign imports
(`org.springframework`) are not allowed in your code base. Similarly to the rest
of the <<core.adoc#beans-stereotype-annotations, stereotype>> annotations, you can
use `@Cacheable`, `@CachePut`, `@CacheEvict`, and `@CacheConfig` as
<<core.adoc#beans-meta-annotations, meta-annotations>> (that is, annotations that
can annotate other annotations). In the following example, we replace a common
`@Cacheable` declaration with our own custom annotation:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Retention(RetentionPolicy.RUNTIME)
	@Target({ElementType.METHOD})
	@Cacheable(cacheNames="books", key="#isbn")
	public @interface SlowService {
	}
----

In the preceding example, we have defined our own `SlowService` annotation,
which itself is annotated with `@Cacheable`. Now we can replace the following code:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Cacheable(cacheNames="books", key="#isbn")
	public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)
----

The following example shows the custom annotation with which we can replace the
preceding code:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@SlowService
	public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)
----

Even though `@SlowService` is not a Spring annotation, the container automatically picks
up its declaration at runtime and understands its meaning. Note that, as mentioned
<<cache-annotation-enable, earlier>>, annotation-driven behavior needs to be enabled.



[[cache-jsr-107]]
=== JCache (JSR-107) Annotations

Since version 4.1, Spring's caching abstraction fully supports the JCache standard
annotations: `@CacheResult`, `@CachePut`, `@CacheRemove`, and `@CacheRemoveAll`
as well as the `@CacheDefaults`, `@CacheKey`, and `@CacheValue` companions.
You can use these annotations even without migrating your cache store to JSR-107.
The internal implementation uses Spring's caching abstraction and provides default
`CacheResolver` and `KeyGenerator` implementations that are compliant with the
specification. In other words, if you are already using Spring's caching abstraction,
you can switch to these standard annotations without changing your cache storage
(or configuration, for that matter).


[[cache-jsr-107-summary]]
==== Feature Summary

For those who are familiar with Spring's caching annotations, the following table
describes the main differences between the Spring annotations and the JSR-107
counterpart:

.Spring vs. JSR-107 caching annotations
[cols="1,1,3"]
|===
| Spring | JSR-107 | Remark

| `@Cacheable`
| `@CacheResult`
| Fairly similar. `@CacheResult` can cache specific exceptions and force the
  execution of the method regardless of the content of the cache.

| `@CachePut`
| `@CachePut`
| While Spring updates the cache with the result of the method invocation, JCache
  requires that it be passed it as an argument that is annotated with `@CacheValue`.
  Due to this difference, JCache allows updating the cache before or after the
  actual method invocation.

| `@CacheEvict`
| `@CacheRemove`
| Fairly similar. `@CacheRemove` supports conditional eviction when the
  method invocation results in an exception.

| `@CacheEvict(allEntries=true)`
| `@CacheRemoveAll`
| See `@CacheRemove`.

| `@CacheConfig`
| `@CacheDefaults`
| Lets you configure the same concepts, in a similar fashion.
|===

JCache has the notion of `javax.cache.annotation.CacheResolver`, which is identical
to the Spring's `CacheResolver` interface, except that JCache supports only a single
cache. By default, a simple implementation retrieves the cache to use based on the
name declared on the annotation. It should be noted that, if no cache name is
specified on the annotation, a default is automatically generated. See the javadoc
of `@CacheResult#cacheName()` for more information.

`CacheResolver` instances are retrieved by a `CacheResolverFactory`. It is possible
to customize the factory for each cache operation, as the following example shows:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@CacheResult(cacheNames="books", cacheResolverFactory=MyCacheResolverFactory.class) <1>
	public Book findBook(ISBN isbn)
----
<1> Customizing the factory for this operation.


NOTE: For all referenced classes, Spring tries to locate a bean with the given type.
If more than one match exists, a new instance is created and can use the regular
bean lifecycle callbacks, such as dependency injection.

Keys are generated by a `javax.cache.annotation.CacheKeyGenerator` that serves the
same purpose as Spring's `KeyGenerator`. By default, all method arguments are taken
into account, unless at least one parameter is annotated with `@CacheKey`. This is
similar to Spring's <<cache-annotations-cacheable-key, custom key generation
declaration>>. For instance, the following are identical operations, one using
Spring's abstraction and the other using JCache:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Cacheable(cacheNames="books", key="#isbn")
	public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)

	@CacheResult(cacheName="books")
	public Book findBook(@CacheKey ISBN isbn, boolean checkWarehouse, boolean includeUsed)
----

You can also specify the `CacheKeyResolver` on the operation, similar to how you can
specify the `CacheResolverFactory`.

JCache can manage exceptions thrown by annotated methods. This can prevent an update of
the cache, but it can also cache the exception as an indicator of the failure instead of
calling the method again. Assume that `InvalidIsbnNotFoundException` is thrown if the
structure of the ISBN is invalid. This is a permanent failure (no book could ever be
retrieved with such a parameter). The following caches the exception so that further
calls with the same, invalid, ISBN throw the cached exception directly instead of
invoking the method again:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@CacheResult(cacheName="books", exceptionCacheName="failures"
				cachedExceptions = InvalidIsbnNotFoundException.class)
	public Book findBook(ISBN isbn)
----


==== Enabling JSR-107 Support

You need do nothing specific to enable the JSR-107 support alongside Spring's
declarative annotation support. Both `@EnableCaching` and the
`cache:annotation-driven` element automatically enable the JCache support
if both the JSR-107 API and the `spring-context-support` module are present
in the classpath.

NOTE: Depending on your use case, the choice is basically yours. You can even
mix and match services by using the JSR-107 API on some and using Spring's own
annotations on others. However, if these services impact the same caches,
you should use a consistent and identical key generation implementation.



[[cache-declarative-xml]]
=== Declarative XML-based Caching

If annotations are not an option (perhaps due to having no access to the sources
or no external code), you can use XML for declarative caching. So, instead of
annotating the methods for caching, you can specify the target method and the
caching directives externally (similar to the declarative transaction management
<<data-access.adoc#transaction-declarative-first-example, advice>>). The example
from the previous section can be translated into the following example:

[source,xml,indent=0]
[subs="verbatim"]
----
	<!-- the service we want to make cacheable -->
	<bean id="bookService" class="x.y.service.DefaultBookService"/>

	<!-- cache definitions -->
	<cache:advice id="cacheAdvice" cache-manager="cacheManager">
		<cache:caching cache="books">
			<cache:cacheable method="findBook" key="#isbn"/>
			<cache:cache-evict method="loadBooks" all-entries="true"/>
		</cache:caching>
	</cache:advice>

	<!-- apply the cacheable behavior to all BookService interfaces -->
	<aop:config>
		<aop:advisor advice-ref="cacheAdvice" pointcut="execution(* x.y.BookService.*(..))"/>
	</aop:config>

	<!-- cache manager definition omitted -->
----

In the preceding configuration, the `bookService` is made cacheable. The caching semantics
to apply are encapsulated in the `cache:advice` definition, which causes the `findBooks`
method to be used for putting data into the cache and the `loadBooks` method for evicting
data. Both definitions work against the `books` cache.

The `aop:config` definition applies the cache advice to the appropriate points in the
program by using the AspectJ pointcut expression (more information is available in
<<core.adoc#aop, Aspect Oriented Programming with Spring>>). In the preceding example,
all methods from the `BookService` are considered and the cache advice is applied to them.

The declarative XML caching supports all of the annotation-based model, so moving between
the two should be fairly easy. Furthermore, both can be used inside the same application.
The XML-based approach does not touch the target code. However, it is inherently more
verbose. When dealing with classes that have overloaded methods that are targeted for
caching, identifying the proper methods does take an extra effort, since the `method`
argument is not a good discriminator. In these cases, you can use the AspectJ pointcut
to cherry pick the target methods and apply the appropriate caching functionality.
However, through XML, it is easier to apply package or group or interface-wide caching
(again, due to the AspectJ pointcut) and to create template-like definitions (as we did
in the preceding example by defining the target cache through the `cache:definitions`
`cache` attribute).



[[cache-store-configuration]]
=== Configuring the Cache Storage

The cache abstraction provides several storage integration options. To use them, you need
to declare an appropriate `CacheManager` (an entity that controls and manages `Cache`
instances and that can be used to retrieve these for storage).


[[cache-store-configuration-jdk]]
==== JDK `ConcurrentMap`-based Cache

The JDK-based `Cache` implementation resides under
`org.springframework.cache.concurrent` package. It lets you use `ConcurrentHashMap`
as a backing `Cache` store. The following example shows how to configure two caches:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<!-- simple cache manager -->
	<bean id="cacheManager" class="org.springframework.cache.support.SimpleCacheManager">
		<property name="caches">
			<set>
				<bean class="org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean" p:name="default"/>
				<bean class="org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean" p:name="books"/>
			</set>
		</property>
	</bean>
----

The preceding snippet uses the `SimpleCacheManager` to create a `CacheManager` for the
two nested `ConcurrentMapCache` instances named `default` and `books`. Note that the
names are configured directly for each cache.

As the cache is created by the application, it is bound to its lifecycle, making it
suitable for basic use cases, tests, or simple applications. The cache scales well
and is very fast, but it does not provide any management, persistence capabilities,
or eviction contracts.


[[cache-store-configuration-ehcache]]
==== Ehcache-based Cache

NOTE: Ehcache 3.x is fully JSR-107 compliant and no dedicated support is required for it.

The Ehcache 2.x implementation is located in the `org.springframework.cache.ehcache`
package. Again, to use it, you need to declare the appropriate `CacheManager`.
The following example shows how to do so:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="cacheManager"
			class="org.springframework.cache.ehcache.EhCacheCacheManager" p:cache-manager-ref="ehcache"/>

	<!-- EhCache library setup -->
	<bean id="ehcache"
			class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean" p:config-location="ehcache.xml"/>
----

This setup bootstraps the ehcache library inside the Spring IoC (through the `ehcache`
bean), which is then wired into the dedicated `CacheManager` implementation. Note that
the entire Ehcache-specific configuration is read from `ehcache.xml`.


[[cache-store-configuration-caffeine]]
==== Caffeine Cache

Caffeine is a Java 8 rewrite of Guava's cache, and its implementation is located in the
`org.springframework.cache.caffeine` package and provides access to several features
of Caffeine.

The following example configures a `CacheManager` that creates the cache on demand:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="cacheManager"
			class="org.springframework.cache.caffeine.CaffeineCacheManager"/>
----

You can also provide the caches to use explicitly. In that case, only those
are made available by the manager. The following example shows how to do so:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="cacheManager" class="org.springframework.cache.caffeine.CaffeineCacheManager">
		<property name="caches">
			<set>
				<value>default</value>
				<value>books</value>
			</set>
		</property>
	</bean>
----

The Caffeine `CacheManager` also supports custom `Caffeine` and `CacheLoader`.
See the https://github.com/ben-manes/caffeine/wiki[Caffeine documentation]
for more information about those.


[[cache-store-configuration-gemfire]]
==== GemFire-based Cache

GemFire is a memory-oriented, disk-backed, elastically scalable, continuously available,
active (with built-in pattern-based subscription notifications), globally replicated
database and provides fully-featured edge caching. For further information on how to
use GemFire as a `CacheManager` (and more), see the
{doc-spring-gemfire}/html/[Spring Data GemFire reference documentation].


[[cache-store-configuration-jsr107]]
==== JSR-107 Cache

Spring's caching abstraction can also use JSR-107-compliant caches. The JCache
implementation is located in the `org.springframework.cache.jcache` package.

Again, to use it, you need to declare the appropriate `CacheManager`.
The following example shows how to do so:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="cacheManager"
			class="org.springframework.cache.jcache.JCacheCacheManager"
			p:cache-manager-ref="jCacheManager"/>

	<!-- JSR-107 cache manager setup  -->
	<bean id="jCacheManager" .../>
----


[[cache-store-configuration-noop]]
==== Dealing with Caches without a Backing Store

Sometimes, when switching environments or doing testing, you might have cache
declarations without having an actual backing cache configured. As this is an invalid
configuration, an exception is thrown at runtime, since the caching infrastructure
is unable to find a suitable store. In situations like this, rather than removing the
cache declarations (which can prove tedious), you can wire in a simple dummy cache that
performs no caching -- that is, it forces the cached methods to be executed every time.
The following example shows how to do so:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="cacheManager" class="org.springframework.cache.support.CompositeCacheManager">
		<property name="cacheManagers">
			<list>
				<ref bean="jdkCache"/>
				<ref bean="gemfireCache"/>
			</list>
		</property>
		<property name="fallbackToNoOpCache" value="true"/>
	</bean>
----

The `CompositeCacheManager` in the preceding chains multiple `CacheManager` instances and,
through the `fallbackToNoOpCache` flag, adds a no-op cache for all the definitions not
handled by the configured cache managers. That is, every cache definition not found in
either `jdkCache` or `gemfireCache` (configured earlier in the example) is handled by
the no-op cache, which does not store any information, causing the target method to be
executed every time.



[[cache-plug]]
=== Plugging-in Different Back-end Caches

Clearly, there are plenty of caching products out there that you can use as a backing
store. To plug them in, you need to provide a `CacheManager` and a `Cache` implementation,
since, unfortunately, there is no available standard that we can use instead.
This may sound harder than it is, since, in practice, the classes tend to be simple
https://en.wikipedia.org/wiki/Adapter_pattern[adapters] that map the caching abstraction
framework on top of the storage API, as the `ehcache` classes do. Most `CacheManager`
classes can use the classes in the `org.springframework.cache.support` package
(such as `AbstractCacheManager` which takes care of the boiler-plate code,
leaving only the actual mapping to be completed). We hope that, in time, the libraries
that provide integration with Spring can fill in this small configuration gap.



[[cache-specific-config]]
=== How can I Set the TTL/TTI/Eviction policy/XXX feature?

Directly through your cache provider. The cache abstraction is an abstraction,
not a cache implementation. The solution you use might support various data
policies and different topologies that other solutions do not support (for example,
the JDK `ConcurrentHashMap` -- exposing that in the cache abstraction would be useless
because there would no backing support). Such functionality should be controlled
directly through the backing cache (when configuring it) or through its native API.




include::integration-appendix.adoc[leveloffset=+1]
