[[beans]]
= IOC 容器

本章介绍了 Spring 的 IoC 容器。


[[beans-introduction]]
==  Spring IoC容器和bean的介绍

本章介绍Spring框架中控制反转 IOC 的实现.
IOC与大家熟知的依赖注入同理，. 这是一个通过依赖注入对象的过程 也就是说，它们所使用的对象，是通过构造函数参数，工厂方法的参数或这是从工厂方法的构造函数或返回值的对象实例设置的属性，
然后容器在创建bean时注入这些需要的依赖。 这个过程相对普通创建对象的过程是反向的（因此称之为IoC），bean本身通过直接构造类来控制依赖关系的实例化或位置，或提供诸如服务定位器模式之类的机制。

`org.springframework.beans` 和 `org.springframework.context` 包是实现Spring IOC容器框架的基础 The
{api-spring-framework}/beans/factory/BeanFactory.html[`BeanFactory`] 接口提供了一种更先进的配置机制来管理任意类型的对象.
{api-spring-framework}/context/ApplicationContext.html[`ApplicationContext`]是 `BeanFactory` 的子接口. 他提供了:

* 更容易与Spring的AOP特性集成
* 消息资源处理(用于国际化)
* 事件发布
* 应用层特定的上下文，如用于web应用程序的 `WebApplicationContext`

简而言之， `BeanFactory` 提供了配置框架的基本功能，`ApplicationContext` 添加了更多特定于企业的功能。
`ApplicationContext` 完全扩展了 `BeanFactory` 的功能，这些内容将在介绍Spring IoC容器的章节专门讲解。
有关使用 `BeanFactory`  代替 `ApplicationContext,` 的更多信息，请参考 <<beans-beanfactory>>.

在Spring中，由Spring IOC容器管理的，构成程序的骨架的对象成为Bean。bean对象是指经过IoC容器实例化，组装和管理的对象。此外，bean就是应用程序中众多对象之一 。bean和bean的依赖由容器所使用的配置元数据反射而来。




[[beans-basics]]
== 容器概述

`org.springframework.context.ApplicationContext` 是Spring IoC容器实现的代表，它负责实例化，配置和组装Bean。容器通过读取配置元数据获取有关实例化、配置和组装哪些对象的说明 。配置元数据可以使用XML、Java注解或Java代码来呈现。它允许你处理应用程序的对象与其他对象之间的互相依赖关系。


Spring提供了 `ApplicationContext` 接口的几个实现。 在独立应用程序中，通常创建
{api-spring-framework}/context/support/ClassPathXmlApplicationContext.html[`ClassPathXmlApplicationContext`]
或 {api-spring-framework}/context/support/FileSystemXmlApplicationContext.html[`FileSystemXmlApplicationContext`] 的实例。虽然XML一直是定义配置元数据的传统格式， 但是您可以指定容器使用Java注解或编程的方式编写元数据格式，并通过提供少量的XML配置以声明对某些额外元数据的支持。

在大多数应用场景中，不需要用户显式的编写代码来实例化IOC容器的一个或者多个实例。例如，在Web应用场景中，只需要在 `web.xml` 中添加大概8行简单的web描述样板就行了(see <<context-create>>).
如果你使用的是基于Eclipse的 https://spring.io/tools/sts[Spring Tool Suite] 开发环境，该样板配置只需点击几下鼠标或按几下键盘就能创建了。

下图展示了Spring工作方式的高级视图，应用程序的类与元数据配置相互配合，这样，在 `ApplicationContext`  创建和初始化后，你立即拥有一个可配置的，可执行的系统或应用程序。


. IOC容器
image::images/container-magic.png[]



[[beans-factory-metadata]]
=== 配置元数据

如上图所示，Spring IOC容器使用元数据配置这种形式，这个配置元数据表示了应用开发人员告诉Spring容器以何种方式实例化、配置和组装应用程序中的对象。

配置元数据通常以简单、直观的XML格式提供，本章的大部分内容都使用这种格式来说明Spring IoC容器的关键概念和特性。

NOTE: XML并不是配置元数据的唯一方式，Spring IoC容器本身是完全与元数据配置的实际格式分离的。现在，许多开发人员选择 <<beans-java, 基于 Java 配置>> 来开发应用程序。

更多其他格式的元数据见:

* <<beans-annotation-config,基于注解的配置>>: Spring 2.5 支持基于注解的元数据配置.
* <<beans-java, 基于 Java的配置 >>: 从 Spring 3.0开始, 由Spring JavaConfig项目提供的功能已经成为Spring核心框架的一部分。因此，你可以使用Java配置来代替XML配置定义外部bean 。要使用这些新功能，请参阅
  https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html[`@Configuration`],
  https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html[`@Bean`],
  https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Import.html[`@Import`],
  和 https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/DependsOn.html[`@DependsOn`] 注解.

Spring 的 Bean（至少一个） 由容器来管理，基于XML的元数据配置将这些bean配置为 `<beans/>` 元素.并放置于 `<beans/>` 元素内部. 基于 Java 的配置通常是使用 `@Configuration` 注解过的类中，在它的方法上使用 `@Bean` 注解。

这些bean定义会对应到构成应用程序的实际对象。通常你会定义服务层对象，数据访问对象（DAOs）,表示对象(如Struts `Action`的实例)，基础对象（如 Hibernate 的 `SessionFactories`, JMS `Queues`,）。
通常，不会在容器中配置细粒度的域对象，因为创建和加载域对象通常是DAO和业务逻辑的职责。
但是，你可以使用Spring与AspectJ 集成独立于 IoC 容器来创建的对象，请参阅  <<aop-atconfigurable,Spring 使用 AspectJ 进行依赖注入域对象>>.

下面的示例显示了基于XML元数据配置的基本结构:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean id="..." class="..."> <1> <2>
			<!-- collaborators and configuration for this bean go here -->
		</bean>

		<bean id="..." class="...">
			<!-- collaborators and configuration for this bean go here -->
		</bean>

		<!-- more bean definitions go here -->

	</beans>
----

<1>  `id` 属性是字符串 ，用来识别唯一的bean定义.

<2>  `class` 属性定义了bean的类型，使用全类名.

`id` 属性的值是指引用协作对象（在这个例子没有显示用于引用协作对象的XML）。请参阅 <<beans-dependencies,依赖>> 获取更多信息



[[beans-factory-instantiation]]
=== 实例化容器

提供给 `ApplicationContext` 构造函数的路径就是实际的资源字符串，使容器能从各种外部资源(如本地文件系统、Java `CLASSPATH`等)装载元数据配置。

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");
----
.Kotlin
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
    val context = ClassPathXmlApplicationContext("services.xml", "daos.xml")
----

[NOTE]
====
当你了解Spring IoC容器之后，你可能想知道更多关于Spring的 `Resource`(as described in <<resources>>)。它提供了一种方便的，由URI语法定义的位置读取InputStream描述的方式 ，资源路径被用于构建应用程序上下文应用环境和资源路径
====

下面的例子显示了服务层对象 `(services.xml)` 配置文件:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<!-- services -->

		<bean id="petStore" class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl">
			<property name="accountDao" ref="accountDao"/>
			<property name="itemDao" ref="itemDao"/>
			<!-- additional collaborators and configuration for this bean go here -->
		</bean>

		<!-- more bean definitions for services go here -->

	</beans>
----

下面的示例显示了数据访问对象 `daos.xml` 配置文件:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean id="accountDao"
			class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao">
			<!-- additional collaborators and configuration for this bean go here -->
		</bean>

		<bean id="itemDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaItemDao">
			<!-- additional collaborators and configuration for this bean go here -->
		</bean>

		<!-- more bean definitions for data access objects go here -->

	</beans>
----

在上面的例子中，服务层由 `PetStoreServiceImpl` 类和两个数据访问对象 `JpaAccountDao` and `JpaItemDao` (基于JPA对象/关系映射标准).
组成 `property name` 元素是指 JavaBean 属性的名称，而 `ref` 元素引用另一个bean定义的名称。`id` and `ref` 元素之间的这种联系表达了组合对象之间的相互依赖关系。有关对象间的依赖关系，请参阅 <<beans-dependencies,依赖>>.

[[beans-factory-xml-import]]
==== 组合基于XML的元数据配置

使用XML配置，可以让bean定义分布在多个XML文件上，这种方法直观优雅清晰明显。通常，每个单独的XML配置文件代表架构中的一个逻辑层或模块。

你可以使用应用程序上下文构造函数从所有这些XML片段加载bean定义，这个构造函数可以输入多个 `Resource` 位置，<<beans-factory-instantiation, 如上一节所示>>。 或者，使用<import/>元素也可以从另一个（或多个）文件加载bean定义。例如：


[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<import resource="services.xml"/>
		<import resource="resources/messageSource.xml"/>
		<import resource="/resources/themeSource.xml"/>

		<bean id="bean1" class="..."/>
		<bean id="bean2" class="..."/>
	</beans>
----

上面的例子中，使用了3个文件：`services.xml`, `messageSource.xml`, 和 `themeSource.xml` 来加载外部Bean的定义. 导入文件采用的都是相对路径，因此  `services.xml` 必须和导入文件位于同一目录或类路径中，
而 `messageSource.xml` 和 `themeSource.xml` 必须在导入文件的资源位置中。正如你所看到的，前面的斜线将会被忽略，但考虑到这些路径是相对的，最佳的使用是不用斜线的。 这个XML文件的内容都会被导入，包括顶级的
`<beans/>` 元素, 但必须遵循Spring Schema定义XML bean定义的规则。

[NOTE]
====
这种相对路径的配置是可行的，但不推荐这样做。引用在使用相对于 "../" 路径. 路径的父目录文件中，这样做会对当前应用程序之外的文件产生依赖关系。
特别是对于 `classpath:` URLs (例如, `classpath:../services.xml`), ，不建议使用此引用，因为在该引用中，运行时解析过程选择 "`最近的`" classpath 根目录，然后查看其父目录。 类路径的变化或者选择了不正确的目录都会导致此配置不可用。

您可以使用完全限定的资源位置而不是相对路径:例如, `file:C:/config/services.xml` 或 `classpath:/config/services.xml`. 但是，请注意，您正在将应用程序的配置与特定的绝对位置耦合。通常会选取间接的方式应对这种绝对路径，例如使用占位符 "${…}" 来解决对JVM系统属性的引用。
====

import 是由bean命名空间本身提供的功能。在Spring提供的XML命名空间中，如 `context` 和 `util` 命名空间，可以用于对普通bean定义进行更高级的功能配置。


[[groovy-bean-definition-dsl]]
==== DSL定义Groovy Bean

作为从外部配置元数据的另一个示例，bean定义也可以使用Spring的Groovy DSL来定义。Grails框架有此配置实例，通常， 可以在具有以下结构的".groovy"文件中配置bean定义。例如：

[source,groovy,indent=0,subs="verbatim,quotes"]
----
	beans {
		dataSource(BasicDataSource) {
			driverClassName = "org.hsqldb.jdbcDriver"
			url = "jdbc:hsqldb:mem:grailsDB"
			username = "sa"
			password = ""
			settings = [mynew:"setting"]
		}
		sessionFactory(SessionFactory) {
			dataSource = dataSource
		}
		myService(MyService) {
			nestedBean = { AnotherBean bean ->
				dataSource = dataSource
			}
		}
	}
----

这种配置风格在很大程度上等价于XML bean定义，甚至支持Spring的XML配置名称空间。它还允许通过 `importBeans` 指令导入XML bean定义文件.



[[beans-factory-client]]
=== 使用容器

`ApplicationContext` 是能够创建bean定义以及处理相互依赖关系的高级工厂接口，使用方法 `T getBean(String
name, Class<T> requiredType)`, 获取容器实例。

`ApplicationContext` 可以读取bean定义并访问它们 如下:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// create and configure beans
	ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");

	// retrieve configured instance
	PetStoreService service = context.getBean("petStore", PetStoreService.class);

	// use configured instance
	List<String> userList = service.getUsernameList();
----
.Kotlin
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
    import org.springframework.beans.factory.getBean

	// create and configure beans
    val context = ClassPathXmlApplicationContext("services.xml", "daos.xml")

    // retrieve configured instance
    val service = context.getBean<PetStoreService>("petStore")

    // use configured instance
    var userList = service.getUsernameList()
----

使用Groovy配置引导看起来非常相似，只是用到不同的上下文实现类：它是Groovy感知的（但也需理解XML bean定义） 如下:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	ApplicationContext context = new GenericGroovyApplicationContext("services.groovy", "daos.groovy");
----
.Kotlin
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
val context = GenericGroovyApplicationContext("services.groovy", "daos.groovy")
----

最灵活的变体是 `GenericApplicationContext` ， 例如读取XML文件的 `XmlBeanDefinitionReader` 如下面的示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	GenericApplicationContext context = new GenericApplicationContext();
	new XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml", "daos.xml");
	context.refresh();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val context = GenericApplicationContext()
	XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml", "daos.xml")
	context.refresh()
----

您还可以为Groovy文件使用 `GroovyBeanDefinitionReader` 如下面的示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	GenericApplicationContext context = new GenericApplicationContext();
	new GroovyBeanDefinitionReader(context).loadBeanDefinitions("services.groovy", "daos.groovy");
	context.refresh();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val context = GenericApplicationContext()
	GroovyBeanDefinitionReader(context).loadBeanDefinitions("services.groovy", "daos.groovy")
	context.refresh()
----

这一类的读取可以在同一个 `ApplicationContext`,上混合使用，也可以自动匹配，如果需要可以从不同的配置源读取bean定义。

您可以使用  `getBean` 来获取bean实例，  `ApplicationContext` 接口也可以使用其他的方法来获取bean。但是在理想情况下，应用程序代码永远不应该使用它们。 事实上，你的应用程序代码也不应该调用
`getBean()` 方法，因此对Spring API没有依赖。例如，Spring与Web框架的集成为各种Web框架组件(如控制器和JSF管理bean） 提供了依赖项注入功能，从而允许开发者通过元数据声明对特定bean的依赖(例如，自动注解）。




[[beans-definition]]
== Bean 的概述

Spring IoC容器管理一个或多个bean。这些bean是由您提供给容器的元数据配置创建的(例如，XML `<bean/>` 定义的形式)。

在容器内部，这些bean定义表示为 `BeanDefinition` 对象，其中包含（其他信息）以下元数据

* 限定包类名称: 通常，定义的bean的实际实现类。
* bean行为配置元素, 定义Bean的行为约束(例如作用域，生命周期回调等等）
* bean需要引用其他bean来完成工作. 这些引用也称为协作或依赖关系.
* 其他配置用于新对象的创建，例如使用bean的数量来管理连接池，或者限制池的大小。

以下是每个bean定义的属性:

[[beans-factory-bean-definition-tbl]]
.Bean的定义
|===
| 属性| 对应章节介绍...

| Class
| <<beans-factory-class>>

| Name
| <<beans-beanname>>

| Scope
| <<beans-factory-scopes>>

| Constructor arguments
| <<beans-factory-collaborators>>

| Properties
| <<beans-factory-collaborators>>

| Autowiring mode
| <<beans-factory-autowire>>

| Lazy initialization mode
| <<beans-factory-lazy-init>>

| Initialization method
| <<beans-factory-lifecycle-initializingbean>>

| Destruction method
| <<beans-factory-lifecycle-disposablebean>>
|===

除了bean定义包含如何创建特定的bean的信息外， `ApplicationContext` 实现还允许用户在容器中注册现有的、已创建的对象。这是通过通过 `getBeanFactory()` 方法访问 `ApplicationContext` 的 `BeanFactory` 来完成的，
该方法返回 BeanFactory `DefaultListableBeanFactory` 实现。`DefaultListableBeanFactory` 支持通过 `registerSingleton(..)` 和
`registerBeanDefinition(..)` 方法来注册对象。 然而，典型的应用程序只能通过元数据配置来定义bean。

[NOTE]
====
为了让容器正确推断它们在自动装配和其它内置步骤，需要尽早注册Bean的元数据和手动使用单例的实例。虽然覆盖现有的元数据和现有的单例实例在某种程度上是支持的， 但是新bean在运行时(同时访问动态工厂）注册官方并不支持，可能会导致并发访问异常、bean容器中的不一致状态，或者两者兼有。
====



[[beans-beanname]]
=== Bean的命名

每个bean都有一个或多个标识符，这些标识符在容器托管时必须是唯一的。bean通常只有一个标识符，但如果需要到的标识不止一个时，可以考虑使用别名。

在基于XML的配置中，开发者可以使用 `id` 属性,  `name` 属性, 或两者都指定bean的标识符  `id` 属性 允许您指定一个 `id`. 通常这些名字使用字母和数字的组合('myBean',
'someService', 等.), 但也可以包含特殊字符。 如果你想使用bean别名，您可以在 `name` 属性上定义，使用逗号  (`,`), 分好 (`;`), 或空白符. 由于历史因素， 请注意，在Spring 3.1之前的版本中，
 `id` 属性被定义为 `xsd:ID` 类型, 它会限制某些字符。从3.1开始，它被定义为 `xsd:string` 类型. 请注意，由于 bean `id` 的唯一性，他仍然由容器执行，不再由XML解析器执行。

您也无需提供bean的 `name` 或 `id` 如果没有显式地提供 `name` 或 `id` 容器会给bean生成唯一的名称。 然而，如果你想引用bean的名字，可以使用 `ref` 元素或使用 <<beans-servicelocator,Service Locator>>
来进行查找（此时必须提供名称）。 不使用名称的情况有：<<beans-inner-beans,内部 bean>> 和 <<beans-factory-autowire,autowiring collaborators>>.

.Bean 的命名约定
****
bean的命名是按照标准的Java字段名称命名来进行的。也就是说，bean名称开始需要以小写字母开头，后面采用 "驼峰式" 的方法。 例如 `accountManager`,
`accountService`, `userDao`, `loginController`.

一致的beans命名能够让配置更方便阅读和理解，如果你正在使用Spring AOP，当你通过bean名称应用到通知时，这种命名方式会有很大的帮助。
****

NOTE: 在类路径中进行组件扫描时， Spring 会根据上面的规则为未命名的组件生成 bean 名称，规则是：采用简单的类名，并将其初始字符转化为小写字母。 然而，在特殊情况下，当有一个以上的字符，同时第一个和第二个字符都是大写时，原来的规则仍然应该保留。这些规则与Java中定义实例的相同。
例如Spring使用的 `java.beans.Introspector.decapitalize` 类.


[[beans-beanname-alias]]
==== 定义外部Bean的别名

在对bean定义时，除了使用 `id` 属性指定唯一的名称外，还可以提供多个别名，这需要通过 `name` 属性指定。 所有这个名称都会指向同一个bean，在某些情况下提供别名非常有用，例如为了让应用每一个组件都能更容易的对公共组件进行引用。

然而，在定义bean时就指定所有的别名并不是很恰当的。有时期望能够在当前位置为那些在别处定义的bean引入别名。在XML配置文件中， 可以通过 `<alias/>` 元素来定义bean别名，例如：


[source,xml,indent=0,subs="verbatim,quotes"]
----
	<alias name="fromName" alias="toName"/>
----

上面示例中，在同一个容器中名为 `fromName` 的bean定义，在增加别名定义后，也可以使用 `toName` 来引用。.

例如，在子系统A中通过名字 `subsystemA-dataSource` 配置的数据源。在子系统B中可能通过名字 `subsystemB-dataSource` 来引用。.当两个子系统构成主应用的时候，主应用可能通过名字 `myApp-dataSource` 引用数据源，将全部三个名字引用同一个对象，你可以将下面的别名定义添加到应用配置中：


[source,xml,indent=0,subs="verbatim,quotes"]
----
	<alias name="myApp-dataSource" alias="subsystemA-dataSource"/>
	<alias name="myApp-dataSource" alias="subsystemB-dataSource"/>
----

现在，每个组件和主应用程序都可以通过一个唯一的名称引用dataSource，并保证不与任何其他定义冲突（有效地创建命名空间），但它们引用相同的bean。 .

.Java 配置
****
如果你使用 Javaconfiguration,  `@Bean` 可以用来提供别名，详情见  <<beans-java-bean-annotation>>
****



[[beans-factory-class]]
=== 实例化Bean

bean定义基本上就是用来创建一个或多个对象的配置，当需要bean的时候，容器会查找配置并且根据bean定义封装的元数据来创建（或获取）实际对象。

如果你使用基于XML的配置，那么可以在 `<bean/>` 元素中通过 `class` 属性来指定对象类型。 `class` 属性实际上就是  `BeanDefinition` 实例中的 `class` 属性.
他通常是必需的（一些例外情况，<<beans-factory-class-instance-factory-method>> 和 <<beans-child-bean-definitions>>)。有两种方式使用 `Class` 属性


* 通常情况下，会直接通过反射调用构造方法来创建bean，这种方式与Java代码的new创建相似。
* 通过静态工厂方法创建，类中包含静态方法。通过调用静态方法返回对象的类型可能和Class一样，也可能完全不一样。

****
.内部类的名
如果你想配置静态内部类，那么必须使用内部类的二进制名称。

例如，在 `com.example` 包下 有一个名为 `SomeThing` 的类, 这个类里面有个静态内部类 `OtherThing`, 这种情况下bean定义的 `class` 属性应该写作 `com.example.SomeThing$OtherThing`.

使用 `$` 字符来分隔外部类和内部类的名称
****


[[beans-factory-class-ctor]]
==== 通过构造器实例化

当通过构造器创建Bean时，Spring兼容所有可以使用的普通类，也就是说，正在开发的类不需要实现任何特定接口或以特定方式编码。只要指定bean类就足够了。
但是，根据您为该特定bean使用的IoC类型，您可能需要一个默认（空）构造函数。

Spring IoC容器几乎可以管理您希望它管理的任何类。它不仅限于管理真正的JavaBeans。大多数Spring用户更喜欢管理那些只有一个默认构造函数（无参数） 和有合适的setter和getter方法的真实的JavaBeans，还可以在容器中放置更多的外部非bean形式（non-bean-style)类，例如：如果需要使用一个绝对违反JavaBean规范的遗留连接池时 Spring也是可以管理它的。

使用基于XML的配置元数据，您可以按如下方式指定bean类：:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleBean" class="examples.ExampleBean"/>

	<bean name="anotherExample" class="examples.ExampleBeanTwo"/>
----

给构造方法指定参数以及为bean实例化设置属性将在后面的 <<beans-factory-collaborators,Injecting Dependencies>> 中说明。


[[beans-factory-class-static-factory-method]]
==== 通过静态工厂方法实例化

当采用静态工厂方法创建bean时，除了需要指定class属性外，还需要通过 `factory-method` 属性来指定创建bean实例的工厂方法。 Spring将会调用此方法（其可选参数接下来会介绍）返回实例对象。从这样看来，它与通过普通构造器创建类实例没什么两样。

下面的bean定义展示了如何通过工厂方法来创建bean实例。注意，此定义并未指定对象的返回类型，只是指定了该类包含的工厂方法，在这个例中， `createInstance()`
必须是一个静态（static）的方法:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="clientService"
		class="examples.ClientService"
		factory-method="createInstance"/>
----

以下示例显示了一个可以使用前面的bean定义的类:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class ClientService {
		private static ClientService clientService = new ClientService();
		private ClientService() {}

		public static ClientService createInstance() {
			return clientService;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class ClientService private constructor() {
		companion object {
			private val clientService = ClientService()
			fun createInstance() = clientService
		}
	}
----

给工厂方法指定参数以及为bean实例设置属性的详细内容请查阅 <<beans-factory-properties-detailed,依赖和配置细节>>.


[[beans-factory-class-instance-factory-method]]
==== 通过实例工厂方法实例化

通过调用工厂实例的非静态方法进行实例化与 <<beans-factory-class-static-factory-method,通过静态工厂方法实例化类似>>, 请将 `class` 属性保留为空，并在 `factory-bean`，
属性中指定当前（或父级或祖先）容器中bean的名称，该容器包含要调用以创建对象的实例方法。 使用 `factory-method`,属性设置工厂方法本身的名称。以下示例显示如何配置此类bean：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<!-- the factory bean, which contains a method called createInstance() -->
	<bean id="serviceLocator" class="examples.DefaultServiceLocator">
		<!-- inject any dependencies required by this locator bean -->
	</bean>

	<!-- the bean to be created via the factory bean -->
	<bean id="clientService"
		factory-bean="serviceLocator"
		factory-method="createClientServiceInstance"/>
----

以下示例显示了相应的Java类:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class DefaultServiceLocator {

		private static ClientService clientService = new ClientServiceImpl();

		public ClientService createClientServiceInstance() {
			return clientService;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class DefaultServiceLocator {
		companion object {
			private val clientService = ClientServiceImpl()
		}
		fun createClientServiceInstance(): ClientService {
			return clientService
		}
	}
----

一个工厂类也可以包含多个工厂方法，如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="serviceLocator" class="examples.DefaultServiceLocator">
		<!-- inject any dependencies required by this locator bean -->
	</bean>

	<bean id="clientService"
		factory-bean="serviceLocator"
		factory-method="createClientServiceInstance"/>

	<bean id="accountService"
		factory-bean="serviceLocator"
		factory-method="createAccountServiceInstance"/>
----

以下示例显示了相应的Java类:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class DefaultServiceLocator {

		private static ClientService clientService = new ClientServiceImpl();

		private static AccountService accountService = new AccountServiceImpl();

		public ClientService createClientServiceInstance() {
			return clientService;
		}

		public AccountService createAccountServiceInstance() {
			return accountService;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class DefaultServiceLocator {
		companion object {
			private val clientService = ClientServiceImpl()
			private val accountService = AccountServiceImpl()
		}

		fun createClientServiceInstance(): ClientService {
			return clientService
		}

		fun createAccountServiceInstance(): AccountService {
			return accountService
		}
	}
----

这种方法表明可以通过依赖注入（DI）来管理和配置工厂bean本身。请参阅详细信息中的 <<beans-factory-properties-detailed,依赖和配置细节>>.

NOTE: 在Spring文档中, "`factory bean`" 是指在Spring容器中配置并通过
<<beans-factory-class-instance-factory-method,instance>> 或
<<beans-factory-class-static-factory-method,static>> 工厂方法 创建对象的bean
相比之下，`FactoryBean` （注意大小写）是指Spring特定的 <<beans-factory-extension-factorybean, `FactoryBean` >>.




[[beans-dependencies]]
== 依赖

一般情况下企业应用不会只有一个对象（Spring Bean），甚至最简单的应用都需要多个对象协同工作。下一部分将解释如何从定义单个Bean到让多个Bean协同工作。

[[beans-factory-collaborators]]
=== 依赖注入

依赖注入 (DI) 是让对象只通过构造参数、工厂方法的参数或者配置的属性来定义他们的依赖的过程。这些依赖也是其他对象所需要协同工作的对象， 容器会在创建Bean的时候注入这些依赖。整个过程完全反转了由Bean自己控制实例化或者依赖引用，所以这个过程也称之为 "控制反转"

当使用了依赖注入的特性以后，会让开发者更容易管理和解耦对象之间的依赖，使代码变得更加简单。对象之间不再关注依赖，也不需要知道依赖类的位置。如此一来，开发的类更易于测试 尤其是当开发者的依赖是接口或者抽象类的情况时，开发者可以轻易地在单元测试中mock对象。

依赖注入主要使用两种方式: <<beans-constructor-injection,基于构造函数的注入>> and <<beans-setter-injection,基于Setter方法的依赖注入>>.


[[beans-constructor-injection]]
==== 基于构造函数的注入

基于构造函数的依赖注入是由IoC容器来调用类的构造函数，构造函数的参数代表这个Bean所依赖的对象。构造函数的依赖注入与调用带参数的静态工厂方法基本一样。
调用具有特定参数的静态工厂方法来构造bean几乎是等效的，本讨论同样处理构造函数和静态工厂方法的参数。下面的例子展示了一个通过构造函数来实现依赖注入的类。:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SimpleMovieLister {

		// the SimpleMovieLister has a dependency on a MovieFinder
		private MovieFinder movieFinder;

		// a constructor so that the Spring container can inject a MovieFinder
		public SimpleMovieLister(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
		}

		// business logic that actually uses the injected MovieFinder is omitted...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// a constructor so that the Spring container can inject a MovieFinder
	class SimpleMovieLister(private val movieFinder: MovieFinder) {
		// business logic that actually uses the injected MovieFinder is omitted...
	}
----

请注意，这个类没有什么特别之处。 它是一个POJO，它不依赖于容器特定的接口，父类或注解。

[[beans-factory-ctor-arguments-resolution]]
===== 解析构造器参数

构造函数的参数解析是通过参数的类型来匹配的。如果在Bean的构造函数参数不存在歧义，那么构造器参数的顺序也就是就是这些参数实例化以及装载的顺序。参考如下代码：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package x.y;

	public class ThingOne {

		public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package x.y

	class ThingOne(thingTwo: ThingTwo, thingThree: ThingThree)
----

假设  `ThingTwo` 和 `ThingThree` 不存在继承关系 也没有什么歧义。下面的配置完全可以工作正常。开发者无需再到 `<constructor-arg/>` 元素中指定构造函数参数的 `index` 或 `type`
[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<bean id="beanOne" class="x.y.ThingOne">
			<constructor-arg ref="beanTwo"/>
			<constructor-arg ref="beanThree"/>
		</bean>

		<bean id="beanTwo" class="x.y.ThingTwo"/>

		<bean id="beanThree" class="x.y.ThingThree"/>
	</beans>
----

当引用另一个bean时，如果类型是已知的，匹配就会工作正常（与前面的示例一样）。当使用简单类型的时候, 例如：`<value>true</value>`, Spring IoC容器无法判断值的类型，所以也是无法匹配的，考虑代码：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package examples;

	public class ExampleBean {

		// Number of years to calculate the Ultimate Answer
		private int years;

		// The Answer to Life, the Universe, and Everything
		private String ultimateAnswer;

		public ExampleBean(int years, String ultimateAnswer) {
			this.years = years;
			this.ultimateAnswer = ultimateAnswer;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package examples

	class ExampleBean(
		private val years: Int, // Number of years to calculate the Ultimate Answer
		private val ultimateAnswer: String// The Answer to Life, the Universe, and Everything
	)
----

.[[beans-factory-ctor-arguments-type]]构造函数参数类型匹配
--
在前面的场景中，如果使用  `type`  属性显式指定构造函数参数的类型，则容器可以使用与简单类型的类型匹配。如下例所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleBean" class="examples.ExampleBean">
		<constructor-arg type="int" value="7500000"/>
		<constructor-arg type="java.lang.String" value="42"/>
	</bean>
----
--

.[[beans-factory-ctor-arguments-index]]构造函数参数索引
--
您可以使用 `index` 属性显式指定构造函数参数的索引，如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleBean" class="examples.ExampleBean">
		<constructor-arg index="0" value="7500000"/>
		<constructor-arg index="1" value="42"/>
	</bean>
----

除了解决多个简单值的歧义之外，指定索引还可以解决构造函数具有相同类型的两个参数的歧义。

NOTE: index 从0开始。
--

.[[beans-factory-ctor-arguments-name]]构造函数参数名称
--
您还可以使用构造函数参数名称消除歧义，如以下示例所示：:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleBean" class="examples.ExampleBean">
		<constructor-arg name="years" value="7500000"/>
		<constructor-arg name="ultimateAnswer" value="42"/>
	</bean>
----

需要注意的是，解析这个配置的代码必须启用了 debug 来编译，这样Spring才可以从构造函数查找参数名称。开发者也可以使用
https://download.oracle.com/javase/8/docs/api/java/beans/ConstructorProperties.html[@ConstructorProperties]
注解来显式声明构造函数的名称。 例如下面代码:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package examples;

	public class ExampleBean {

		// Fields omitted

		@ConstructorProperties({"years", "ultimateAnswer"})
		public ExampleBean(int years, String ultimateAnswer) {
			this.years = years;
			this.ultimateAnswer = ultimateAnswer;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package examples

	class ExampleBean
	@ConstructorProperties("years", "ultimateAnswer")
	constructor(val years: Int, val ultimateAnswer: String)
----
--


[[beans-setter-injection]]
==== 基于Setter方法的依赖注入

基于setter函数的依赖注入是让容器调用Bean的无参构造函数，或者无参静态工厂方法，然后再来调用setter方法来实现依赖注入。

下面的例子展示了使用setter方法进行的依赖注入的过程。其中类对象只是简单的POJO，它不依赖于容器特定的接口，父类或注解。

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SimpleMovieLister {

		// the SimpleMovieLister has a dependency on the MovieFinder
		private MovieFinder movieFinder;

		// a setter method so that the Spring container can inject a MovieFinder
		public void setMovieFinder(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
		}

		// business logic that actually uses the injected MovieFinder is omitted...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
class SimpleMovieLister {

	// a late-initialized property so that the Spring container can inject a MovieFinder
	lateinit var movieFinder: MovieFinder

	// business logic that actually uses the injected MovieFinder is omitted...
}
----


`ApplicationContext` 所管理Bean同时支持基于构造函数和基于setter方法的依赖注入，同时也支持使用setter方法在通过构造函数注入依赖之后再次注入依赖。 开发者在 `BeanDefinition`
中可以使用 `PropertyEditor` 实例来自由选择注入方式。然而，大多数的开发者并不直接使用这些类，而是更喜欢使用XML配置来进行 `bean` 定义， 或者基于注解的组件 (例如使用 `@Component`,
`@Controller`), 或者在配置了 `@Configuration` 类中使用 `@Bean` 的方法。 然后，这些会在Spring内部转换为 `BeanDefinition` 实例，并用于加载整个Spring IoC容器实例。

[[beans-constructor-vs-setter-injection]]
.如何选择基于构造器和基于setter方法?
****
因为开发者可以混用两种依赖注入方式，两种方式用于处理不同的情况：必要的依赖通常通过构造函数注入，而可选的依赖则通过setter方法注入。
其中，在setter方法上添加 <<beans-required-annotation, @Required>> 注解可用于构造必要的依赖。但是，最好使用带有参数验证的构造函数注入。


Spring团队推荐使用基于构造函数的注入，因为这种方式会促使开发者将组件开发成不可变对象并且确保注入的依赖不为null。另外，基于构造函数的注入的组件被客户端调用的时候也已经是完全构造好的 。当然，从另一方面来说，过多的构造函数参数也是非常糟糕的代码方式，这种方式说明类附带了太多的功能，最好重构将不同职能分离。


基于setter的注入只用于可选的依赖，但是也最好配置一些合理的默认值。否则，只能对代码的依赖进行非null值检查了。基于setter方法的注入有一个便利之处是：对象可以重新配置和重新注入。 因此，使用setter注入管理 <<integration.adoc#jmx,JMX MBeans>> 是很方便的

依赖注入的两种风格适合大多数的情况，但是在使用第三方库的时候，开发者可能并没有源码，那么就只能使用基于构造函数的依赖注入了。
****


[[beans-dependency-resolution]]
==== 决定依赖的过程

容器解析Bean的过程如下:

*  创建并根据描述的元数据来实例化 `ApplicationContext` 元数据配置可以是XML文件、Java代码或者注解。
*  每一个Bean的依赖都通过构造函数参数或属性，或者静态工厂方法的参数等等来表示。这些依赖会在Bean创建的时候装载和注入
* 每一个属性或者构造函数的参数都是真实定义的值或者引用容器其他的Bean.
* 每一个属性或者构造参数可以根据指定的类型转换为所需的类型。Spring也可以将String转成默认的Java内置类型。例如 `int`,`long`, `String`, `boolean`,等.

Spring容器会在容器创建的时候针对每一个Bean进行校验。但是Bean的属性在Bean没有真正创建之前是不会进行配置的，单例类型的Bean是容器创建的时候配置成预实例状态的。<<beans-factory-scopes,Bean 的作用域>> 后面再说，
其他的Bean都只有在请求的时候，才会创建，显然创建Bean对象会有一个依赖顺序图，这个图表示Bean之间的依赖关系。 容器根据此来决定创建和配置Bean的顺序。

.循环依赖
****
如果开发者主要使用基于构造函数的依赖注入，那么很有可能出现循环依赖的情况。

例如：类A在构造函数中依赖于类B的实例，而类B的构造函数又依赖类A的实例。如果这样配置类A和类B相互注入的话，Spring IoC容器会发现这个运行时的循环依赖， 并且抛出 `BeanCurrentlyInCreationException` 异常.

开发者可以选择setter方法来配置依赖注入，这样就不会出现循环依赖的情况。或者根本就不使用基于构造函数的依赖注入，而仅仅使用基于setter方法的依赖注入。 换言之，但是开发者可以将循环依赖配置为基于Setter方法的依赖注入（尽管不推荐这样做）

与典型情况（没有循环依赖关系）不同，Bean A和Bean B之间的循环依赖关系迫使其中一个Bean在完全完全初始化之前被注入另一个Bean（经典的"鸡与蛋"场景）。
****

你可以信任Spring做正确的事。它在容器加载时检测配置问题，例如对不存在的bean和循环依赖的引用。 当实际创建bean时，Spring会尽可能晚地设置属性并解析依赖项。这也意味着Spring容器加载正确后会在bean注入依赖出错的时候抛出异常。例如，bean抛出缺少属性或者属性不合法的异常 ，这种延迟的解析也是
`ApplicationContext`  的实现会令单例Bean处于预实例化状态的原因。这样，通过创建bean，可以在真正使用bean之前消耗一些内存代价而发现配置的问题 。开发者也可以覆盖默认的行为让单例bean延迟加载，而不总是处于预实例化状态。

如果不存在循环依赖的话，bean所引用的依赖会预先全部构造。举例来说，如果bean A依赖于bean B，那么Spring IoC容器会先配置bean B，然后调用bean A的setter方法来构造bean A。
换言之，bean先会实例化，然后再注入依赖，最后才是相关生命周期方法的调用（就像 <<beans-factory-lifecycle-initializingbean, 配置文件的 init 方法>> 或者<<beans-factory-lifecycle-initializingbean,InitializingBean的回调函数>>）。


[[beans-some-examples]]
==== 依赖注入的例子

下面的例子使用基于XML的元数据配置，然后使用setter方式进行依赖注入。下面是Spring中使用XML文件声明bean定义的片段：:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleBean" class="examples.ExampleBean">
		<!-- setter injection using the nested ref element -->
		<property name="beanOne">
			<ref bean="anotherExampleBean"/>
		</property>

		<!-- setter injection using the neater ref attribute -->
		<property name="beanTwo" ref="yetAnotherBean"/>
		<property name="integerProperty" value="1"/>
	</bean>

	<bean id="anotherExampleBean" class="examples.AnotherBean"/>
	<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
----

以下示例显示了相应的 `ExampleBean` 类:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class ExampleBean {

		private AnotherBean beanOne;

		private YetAnotherBean beanTwo;

		private int i;

		public void setBeanOne(AnotherBean beanOne) {
			this.beanOne = beanOne;
		}

		public void setBeanTwo(YetAnotherBean beanTwo) {
			this.beanTwo = beanTwo;
		}

		public void setIntegerProperty(int i) {
			this.i = i;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
class ExampleBean {
	lateinit var beanOne: AnotherBean
	lateinit var beanTwo: YetAnotherBean
	var i: Int = 0
}
----

在前面的示例中，setter被声明为与XML文件中指定的属性匹配。以下示例使用基于构造函数的DI：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleBean" class="examples.ExampleBean">
		<!-- constructor injection using the nested ref element -->
		<constructor-arg>
			<ref bean="anotherExampleBean"/>
		</constructor-arg>

		<!-- constructor injection using the neater ref attribute -->
		<constructor-arg ref="yetAnotherBean"/>

		<constructor-arg type="int" value="1"/>
	</bean>

	<bean id="anotherExampleBean" class="examples.AnotherBean"/>
	<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
----

以下示例显示了相应的 `ExampleBean` 类:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class ExampleBean {

		private AnotherBean beanOne;

		private YetAnotherBean beanTwo;

		private int i;

		public ExampleBean(
			AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
			this.beanOne = anotherBean;
			this.beanTwo = yetAnotherBean;
			this.i = i;
		}
	}
----
[source,java,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
class ExampleBean(
		private val beanOne: AnotherBean,
		private val beanTwo: YetAnotherBean,
		private val i: Int)
----

bean定义中指定的构造函数参数用作 `ExampleBean` 的构造函数的参数。.

现在考虑这个示例的变体，其中，不使用构造函数，而是告诉Spring调用静态工厂方法来返回对象的实例：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleBean" class="examples.ExampleBean" factory-method="createInstance">
		<constructor-arg ref="anotherExampleBean"/>
		<constructor-arg ref="yetAnotherBean"/>
		<constructor-arg value="1"/>
	</bean>

	<bean id="anotherExampleBean" class="examples.AnotherBean"/>
	<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
----

以下示例显示了相应的 `ExampleBean` 类:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class ExampleBean {

		// a private constructor
		private ExampleBean(...) {
			...
		}

		// a static factory method; the arguments to this method can be
		// considered the dependencies of the bean that is returned,
		// regardless of how those arguments are actually used.
		public static ExampleBean createInstance (
			AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {

			ExampleBean eb = new ExampleBean (...);
			// some other operations...
			return eb;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class ExampleBean private constructor() {
		companion object {
			// a static factory method; the arguments to this method can be
			// considered the dependencies of the bean that is returned,
			// regardless of how those arguments are actually used.
			fun createInstance(anotherBean: AnotherBean, yetAnotherBean: YetAnotherBean, i: Int): ExampleBean {
				val eb = ExampleBean (...)
				// some other operations...
				return eb
			}
		}
	}
----

静态工厂方法的参数由 `<constructor-arg/>` 元素提供，与实际使用的构造函数完全相同。工厂方法返回类的类型不必与包含静态工厂方法 的类完全相同，
尽管在本例中是这样。实例（非静态）工厂方法的使用方式也是相似的（除了使用 `factory-bean` 属性而不是 `class` 属性。因此此处不在展开讨论。



[[beans-factory-properties-detailed]]
=== 依赖和配置细节

<<beans-factory-collaborators, 如上一节所述>>, 您可以将bean的属性和构造函数参数定义为对其他bean的引用，或者作为其内联定义的值。Spring可以允许您在基于XML的配置元数据（定义Bean）中使用子元素 `<property/>` 和 `<constructor-arg/>` 来达到这种目的。


[[beans-value-element]]
==== 直接值（基本类型，String 等等）

`<property/>` 元素的 `value` 属性 将属性或构造函数参数指定为人类可读的字符串表示形式， Spring的 <<core-convert-ConversionService-API, conversion service>> 用于将这些值从String 转换为属性或参数的实际类型。 以下示例显示了要设置的各种值：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
		<!-- results in a setDriverClassName(String) call -->
		<property name="driverClassName" value="com.mysql.jdbc.Driver"/>
		<property name="url" value="jdbc:mysql://localhost:3306/mydb"/>
		<property name="username" value="root"/>
		<property name="password" value="masterkaoli"/>
	</bean>
----

以下示例使用 <<beans-p-namespace,p-namespace>> 进行更简洁的XML配置：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:p="http://www.springframework.org/schema/p"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource"
			destroy-method="close"
			p:driverClassName="com.mysql.jdbc.Driver"
			p:url="jdbc:mysql://localhost:3306/mydb"
			p:username="root"
			p:password="masterkaoli"/>

	</beans>
----

前面的XML更简洁。 但是因为属性的类型是在运行时确定的，而非设计时确定的。所有有可能在运行时发现拼写错误。，除非您在创建bean定义时使用支持自动属性完成的IDE（例如 https://www.jetbrains.com/idea/[IntelliJ
IDEA] or the https://spring.io/tools/sts[Spring Tool Suite]）。 所以，强烈建议使用此类IDE帮助。

你也可以配置一个 `java.util.Properties` 的实例，如下：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="mappings"
		class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer">

		<!-- typed as a java.util.Properties -->
		<property name="properties">
			<value>
				jdbc.driver.className=com.mysql.jdbc.Driver
				jdbc.url=jdbc:mysql://localhost:3306/mydb
			</value>
		</property>
	</bean>
----

Spring的容器会将 `<value/>` 里面的文本通过JavaBean的 `PropertyEditor` 机制转换成 `java.util.Properties`  实例， 这种嵌套 `<value/>` 元素的快捷方式也是Spring团队推荐使用的。

[[beans-idref-element]]
=====  `idref` 元素

`idref` 元素只是一种防错方法，可以将容器中另一个bean的 `id` （字符串值 - 而不是引用）传递给 `<constructor-arg/>` 或 `<property/>`
元素.

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="theTargetBean" class="..."/>

	<bean id="theClientBean" class="...">
		<property name="targetName">
			<idref bean="theTargetBean"/>
		</property>
	</bean>
----

前面的bean定义代码段运行时与以下代码段完全等效：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="theTargetBean" class="..." />

	<bean id="client" class="...">
		<property name="targetName" value="theTargetBean"/>
	</bean>
----

Spring团队更推荐第一种方式，因为使用了 `idref` 标签，它会让容器在部署阶段就对bean进行校验，以确保bean一定存在。而使用第二种方式的话，是没有任何校验的。只有实际上引用了 `client` bean的 `targetName` 属性
不对其值进行校验。在实例化client的时候才会被发现。如果 `client` 是 <<beans-factory-scopes,prototype>> 类型的Bean的话，那么类似拼写之类的错误会在容器部署以后很久才能发现。

NOTE: `idref`  元素的 `local` 属性 属性在Spring 4.0以后的xsd中已经不再支持了，而是使用了 `bean` 引用。如果更新了版本的话，只要将 `idref local` 引用都转换成  `idref bean` 即可。

在 Spring 2.0之前的版本中，`<idref/>` 在 `ProxyFactoryBean` bean定义中的 <<aop-pfb-1,AOP interceptors>>  的配置中 常见，指定拦截器名称时使用 `<idref/>` 元素可防止您拼写错误的拦截器ID。



[[beans-ref-element]]
==== 引用其他的Bean（装配）

`ref` 元素是  `<constructor-arg/>` or `<property/>` 定义元素中的最后一个元素。 你可以通过这个标签配置一个bean来引用另一个bean。当需要引用一个bean的时候，被引用的bean会先实例化，
然后配置属性，也就是引用的依赖。如果该bean是单例bean的话 ，那么该bean会早由容器初始化。最终会引用另一个对象的所有引用，bean的范围以及校验取决于你是否有通过  `bean`, `local,` 或 `parent` 这些属性来指定对象的 `id` 或者 `name` 属性。.

通过指定 bean属性中的 `<ref/>` 元素来指定依赖是最常见的一种方式，可以引用容器或者父容器中的bean，不在同一个XML文件定义也可以引用。 其中bean 属性中的值可以和其他引用bean 中的 `id` 属性一致，或者和其中的某个 `name` 属性一致，以下示例显示如何使用 `ref` 元素：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<ref bean="someBean"/>
----

通过指定bean的 `parent` 属性可以创建一个引用到当前容器的父容器之中。`parent` 属性的值可以与目标bean的 `id` 属性一致，或者和目标bean的 `name` 属性中的某个一致，目标bean必须是当前引用目标bean容器的父容器 。
开发者一般只有在存在层次化容器，并且希望通过代理来包裹父容器中一个存在的bean的时候才会用到这个属性。 以下一对列表显示了如何使用 `parent` 属性:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<!-- in the parent context -->
	<bean id="accountService" class="com.something.SimpleAccountService">
		<!-- insert dependencies as required as here -->
	</bean>
----

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<!-- in the child (descendant) context -->
	<bean id="accountService" <!-- bean name is the same as the parent bean -->
		class="org.springframework.aop.framework.ProxyFactoryBean">
		<property name="target">
			<ref parent="accountService"/> <!-- notice how we refer to the parent bean -->
		</property>
		<!-- insert other configuration and dependencies as required here -->
	</bean>
----

NOTE:  `ref` 元素中的 `local` 标签在xsd 4.0，以后已经不再支持了，开发者可以通过将已存在的 `ref local` 改为  `ref bean` 来完成Spring版本升级。


[[beans-inner-beans]]
==== 内部bean

定义在 `<bean/>` 元素的 `<property/>` 或者 `<constructor-arg/>` 元素之内的bean叫做内部bean，如下例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="outer" class="...">
		<!-- instead of using a reference to a target bean, simply define the target bean inline -->
		<property name="target">
			<bean class="com.example.Person"> <!-- this is the inner bean -->
				<property name="name" value="Fiona Apple"/>
				<property name="age" value="25"/>
			</bean>
		</property>
	</bean>
----

内部bean定义不需要定义的ID或名称。如果指定，则容器不使用此类值作为标识符。容器还会在创建时忽略 `scope` 标签，因为内部bean始终是匿名的，并且始终使用外部bean创建。 开发者是无法将内部bean注入到外部bean以外的其他bean中的。


作为一个极端情况，可以从自定义范围接收销毁回调，例如：请求范围的内部bean包含了单例bean，那么内部bean实例会绑定到包含的bean，而包含的bean允许访问request的scope生命周期。 这种场景并不常见，内部bean通常只是供给它的外部bean使用。


[[beans-collection-elements]]
==== 集合

在 `<list/>`, `<set/>`, `<map/>`, 和 `<props/>` 元素中，您可以分别配置Java `Collection` 类型 `List`, `Set`, `Map`, 和 `Properties` 的属性和参数。 以下示例显示了如何使用它们:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="moreComplexObject" class="example.ComplexObject">
		<!-- results in a setAdminEmails(java.util.Properties) call -->
		<property name="adminEmails">
			<props>
				<prop key="administrator">administrator@example.org</prop>
				<prop key="support">support@example.org</prop>
				<prop key="development">development@example.org</prop>
			</props>
		</property>
		<!-- results in a setSomeList(java.util.List) call -->
		<property name="someList">
			<list>
				<value>a list element followed by a reference</value>
				<ref bean="myDataSource" />
			</list>
		</property>
		<!-- results in a setSomeMap(java.util.Map) call -->
		<property name="someMap">
			<map>
				<entry key="an entry" value="just some string"/>
				<entry key ="a ref" value-ref="myDataSource"/>
			</map>
		</property>
		<!-- results in a setSomeSet(java.util.Set) call -->
		<property name="someSet">
			<set>
				<value>just some string</value>
				<ref bean="myDataSource" />
			</set>
		</property>
	</bean>
----

当然，map的key或者value，或者集合的value都可以配置为下列元素之一:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	bean | ref | idref | list | set | map | props | value | null
----

[[beans-collection-elements-merging]]
===== 集合的合并

Spring的容器也支持集合合并，开发者可以定义父样式的 `<list/>`, `<map/>`, `<set/>` 或 `<props/>` 元素，
同时有子样式的 `<list/>`, `<map/>`, `<set/>` 或 `<props/>` 元素。也就是说，子集合的值是父元素和子元素集合的合并值。

有关合并的这一节讨论父子bean机制，不熟悉父和子bean定义的读者可能希望在继续之前阅读<<beans-child-bean-definitions,相关部分>>

以下示例演示了集合合并:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<bean id="parent" abstract="true" class="example.ComplexObject">
			<property name="adminEmails">
				<props>
					<prop key="administrator">administrator@example.com</prop>
					<prop key="support">support@example.com</prop>
				</props>
			</property>
		</bean>
		<bean id="child" parent="parent">
			<property name="adminEmails">
				<!-- the merge is specified on the child collection definition -->
				<props merge="true">
					<prop key="sales">sales@example.com</prop>
					<prop key="support">support@example.co.uk</prop>
				</props>
			</property>
		</bean>
	<beans>
----

请注意，在 `child` bean 定义的 `adminEmails` 中的 `<props/>` 使用 `merge=true`  属性。 当容器解析并实例化 `child` bean时，
生成的实例有一个 `adminEmails` 属性集合， 其实例中包含的 `adminEmails` 集合就是child的 `adminEmails` 以及parent的 `adminEmails` 集合。以下清单显示了结果:


[literal,subs="verbatim,quotes"]
----
administrator=administrator@example.com
sales=sales@example.com
support=support@example.co.uk
----

子属性集合的 `Properties` 集合继承父 `<props/>` 的所有属性元素，子值的支持值覆盖父集合中的值。


这个合并的行为和 `<list/>`, `<map/>`, 和 `<set/>` 之类的集合类型的行为是类似的。 `<list/>` 在特定例子中，与  `List` 集合类型类似， 有着隐含的 `ordered` 概念。所有的父元素里面的值，是在所有子元素的值之前配置的。
但是像 `Map`, `Set`, 和 `Properties` 的集合类型，是不存在顺序的。

[[beans-collection-merge-limitations]]
===== 集合合并的限制

您不能合并不同类型的集合（例如要将 `Map` 和 `List` 合并是不可能的）。如果开发者硬要这样做就会抛出异常， `merge` 的属性是必须特指到更低级或者继承的子节点定义上， 特指 `merge` 属性到父集合的定义上是冗余的，而且在合并上也没有任何效果。



[[beans-collection-elements-strongly-typed]]
===== 强类型的集合

在Java 5以后，开发者可以使用强类型的集合了。也就是，开发者可以声明 `Collection` 类型，然后这个集合只包含 `String` 元素（举例来说）。 如果开发者通过Spring来注入强类型的 `Collection` 到bean中，开发者就可以利用Spring的类型转换支持来做到 以下Java类和bean定义显示了如何执行此操作:


[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SomeClass {

		private Map<String, Float> accounts;

		public void setAccounts(Map<String, Float> accounts) {
			this.accounts = accounts;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
class SomeClass {
	lateinit var accounts: Map<String, Float>
}
----

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<bean id="something" class="x.y.SomeClass">
			<property name="accounts">
				<map>
					<entry key="one" value="9.99"/>
					<entry key="two" value="2.75"/>
					<entry key="six" value="3.99"/>
				</map>
			</property>
		</bean>
	</beans>
----

当 `something` 的属性 `accounts` 准备注入的时候，`accounts` 的泛型信息 `MapMap<String, Float>` 就会通过反射拿到。 这样，Spring的类型转换系统能够识别不同的类型，如上面的例子 `Float` 然后会将字符串的值 `9.99, 2.75`, 和 `3.99` 转换成对应的 `Float` 类型。



[[beans-null-element]]
==== Null 和 空字符串

`Strings` 将属性的空参数视为空字符串。下面基于XML的元数据配置就会将email 属性配置 `String` 值("")。

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean class="ExampleBean">
		<property name="email" value=""/>
	</bean>
----

上面的示例等效于以下Java代码:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	exampleBean.setEmail("");
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	exampleBean.email = ""
----


 `<null/>` 将被处理为 `null` 值。以下清单显示了一个示例:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean class="ExampleBean">
		<property name="email">
			<null/>
		</property>
	</bean>
----

上述配置等同于以下Java代码：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	exampleBean.setEmail(null);
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	exampleBean.email = null
----


[[beans-p-namespace]]
==== 使用p命名空间简化XML配置

p命名空间让开发者可以使用 `bean`  的属性，而不必使用嵌套的 `<property/>` 元素。

Spring是支持基于XML的格式化 <<core.adoc#xsd-schemas,命名空间>>扩展的。本节讨论的 `beans` 配置都是基于XML的，p命名空间是定义在Spring Core中的（不是在XSD文件）。

以下示例显示了两个XML片段（第一个使用标准XML格式，第二个使用p命名空间），它们解析为相同的结果：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:p="http://www.springframework.org/schema/p"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean name="classic" class="com.example.ExampleBean">
			<property name="email" value="someone@somewhere.com"/>
		</bean>

		<bean name="p-namespace" class="com.example.ExampleBean"
			p:email="someone@somewhere.com"/>
	</beans>
----

上面的例子在bean中定义了 `email` 的属性。这种定义告知Spring这是一个属性声明。如前面所描述的，p命名空间并没有标准的定义模式，所以开发者可以将属性的名称配置为依赖名称。

下一个示例包括另外两个bean定义，它们都引用了另一个bean:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:p="http://www.springframework.org/schema/p"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean name="john-classic" class="com.example.Person">
			<property name="name" value="John Doe"/>
			<property name="spouse" ref="jane"/>
		</bean>

		<bean name="john-modern"
			class="com.example.Person"
			p:name="John Doe"
			p:spouse-ref="jane"/>

		<bean name="jane" class="com.example.Person">
			<property name="name" value="Jane Doe"/>
		</bean>
	</beans>
----

此示例不仅包含使用p命名空间的属性值，还使用特殊格式来声明属性引用。第一个bean定义使用  `<property name="spouse" ref="jane"/>` 来创建从bean `john` 到bean `jane` 的引用，
而第二个bean定义使用 `p:spouse-ref="jane"` 来作为指向bean的引用。在这个例子中 `spouse` 是属性的名字，而 `-ref` 部分表名这个依赖不是直接的类型，而是引用另一个bean。


NOTE: p命名空间并不如标准XML格式灵活。例如，声明属性的引用可能和一些以 `Ref` 结尾的属性相冲突，而标准的XML格式就不会。Spring团队推荐开发者能够和团队商量一下，协商使用哪一种方式，而不要同时使用三种方法。

[[beans-c-namespace]]
==== 使用c命名空间简化XML

与 <<beans-p-namespace>> p命名空间类似，c命名空间是在Spring 3.1首次引入的，c命名空间允许使用内联的属性来配置构造参数而不必使用 `constructor-arg` 。

以下示例使用 `c:` 命名空间的例子来执行与 <<beans-constructor-injection>> 基于Constructor的依赖注入相同的操作：
:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:c="http://www.springframework.org/schema/c"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean id="beanTwo" class="x.y.ThingTwo"/>
		<bean id="beanThree" class="x.y.ThingThree"/>

		<!-- traditional declaration with optional argument names -->
		<bean id="beanOne" class="x.y.ThingOne">
			<constructor-arg name="thingTwo" ref="beanTwo"/>
			<constructor-arg name="thingThree" ref="beanThree"/>
			<constructor-arg name="email" value="something@somewhere.com"/>
		</bean>

		<!-- c-namespace declaration with argument names -->
		<bean id="beanOne" class="x.y.ThingOne" c:thingTwo-ref="beanTwo"
			c:thingThree-ref="beanThree" c:email="something@somewhere.com"/>

	</beans>
----

 `c:` 命名空间使用了和 `p:` 命名空间相类似的方式（使用了-ref 来配置引用).而且,同样的,c命名空间也是定义在Spring Core中的（不是XSD模式)。

在少数的例子之中,构造函数的参数名字并不可用（通常,如果字节码没有debug信息的编译),你可以使用回调参数的索引，如下面的例子:


[source,xml,indent=0,subs="verbatim,quotes"]
----
	<!-- c-namespace index declaration -->
	<bean id="beanOne" class="x.y.ThingOne" c:_0-ref="beanTwo" c:_1-ref="beanThree"
		c:_2="something@somewhere.com"/>
----

NOTE: 由于XML语法，索引表示法需要使用 `_` 作为属性名字的前缀，因为XML属性名称不能以数字开头（即使某些IDE允许它）。相应的索引符号也可用于 `<constructor-arg>` 元素，但并不常用，因为声明的普通顺序在那里就足够了。


实际上,<<beans-factory-ctor-arguments-resolution,机制>> 在匹配参数方面非常有效，因此除非您确实需要，否则我们建议在整个配置中使用名称表示法。


[[beans-compound-property-names]]
==== 组合属性名

开发者可以配置混合的属性，只需所有的组件路径（除了最后一个属性名字）不能为 `null` 即可。参考如下定义：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="something" class="things.ThingOne">
		<property name="fred.bob.sammy" value="123" />
	</bean>
----

`something` 有 `fred` 属性, 而其中 `fred` 属性有 `bob` 属性，而 `bob` 属性之中有 `sammy` 属性，那么最后这个 `sammy` 属性会配置为 `123` 。 想要上述的配置能够生效，`fred` 属性需要有 `bob` 属性而且在 `fred` 构造之后不为 `null` 即可。



[[beans-factory-dependson]]
=== 使用 `depends-on`

如果一个bean是另一个bean的依赖，通常这个bean也就是另一个bean的属性之一。多数情况下，开发者可以在配置XML元数据的时候使用 <<beans-ref-element, `<ref/>` 元素>>  然而，有时bean之间的依赖不是直接关联的。例如：需要调用类的静态实例化器来触发依赖，类似数据库驱动注册。`depends-on` 属性可以显式强制初始化一个或多个bean。 以下示例使用 `depends-on` 属性表示对单个bean的依赖关系:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="beanOne" class="ExampleBean" depends-on="manager"/>
	<bean id="manager" class="ManagerBean" />
----

如果想要依赖多个bean，可以提供多个名字作为 `depends-on` 的值。以逗号、空格或者分号分割:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="beanOne" class="ExampleBean" depends-on="manager,accountDao">
		<property name="manager" ref="manager" />
	</bean>

	<bean id="manager" class="ManagerBean" />
	<bean id="accountDao" class="x.y.jdbc.JdbcAccountDao" />
----

NOTE:  `depends-on` 属性既可以指定初始化时间依赖性，也可以仅在 <<beans-factory-scopes-singleton,singleton>> bean的情况下指定相应的销毁时间依赖性。独立定义了 `depends-on` 属性的bean会优先销毁 （相对于 `depends-on` 的bean销毁，这样 `depends-on` 可以控制销毁的顺序。


[[beans-factory-lazy-init]]
=== 懒加载Bean

默认情况下, `ApplicationContext` 会在实例化的过程中创建和配置所有的单例<<beans-factory-scopes-singleton,singleton>> bean。总的来说， 这个预初始化是很不错的。因为这样能及时发现环境上的一些配置错误，而不是系统运行了很久之后才发现。
如果这个行为不是迫切需要的，开发者可以通过将Bean标记为延迟加载就能阻止这个预初始化 懒加载bean会通知IoC不要让bean预初始化而是在被引用的时候才会实例化。

在XML中，此行为由 `<bean/>` 元素上的 `lazy-init` 属性控制，如以下示例所示：


[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="lazy" class="com.something.ExpensiveToCreateBean" lazy-init="true"/>
	<bean name="not.lazy" class="com.something.AnotherBean"/>
----

当将bean配置为上述XML的时候，  `ApplicationContext` 之中的 `lazy` bean是不会随着 `ApplicationContext` 的启动而进入到预初始化状态的。 只有那些 `not.lazy` 加载的bean是处于预初始化的状态的。

然而，如果延迟加载的类是作为单例非延迟加载的bean的依赖而存在的话，`ApplicationContext` 仍然会在 `ApplicationContext` 启动的时候加载。 因为作为单例bean的依赖，会随着单例bean的实例化而实例化。

您还可以使用 `<beans/>` 元素上的 `default-lazy-init` 属性在容器级别控制延迟初始化，如下：


[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans default-lazy-init="true">
		<!-- no beans will be pre-instantiated... -->
	</beans>
----



[[beans-factory-autowire]]
=== 自动装配

Spring容器可以根据bean之间的依赖关系自动装配，开发者可以让Spring通过 `ApplicationContext` 来自动解析这些关联，自动装载有很多优点:

* 自动装载能够明显的减少指定的属性或者是构造参数。（在 <<beans-child-bean-definitions,本章其他地方讨论>> 的其他机制，如bean模板，在这方面也很有价值。）
* 自动装载可以扩展开发者的对象，比如说，如果开发者需要加一个依赖，只需关心如何更改配置即可自动满足依赖关联。这样，自动装载在开发过程中是极其高效的，无需明确选择装载的依赖会使系统更加稳定

使用基于XML的配置元数据(see <<beans-factory-collaborators>>), 可以使用 `<bean/>` 元素的 `autowire` 属性 为bean定义指定autowire模式。 自动装配功能有四种方式。开发者可以指定每个bean的装配方式，这样bean就知道如何加载自己的依赖。下表描述了四种自动装配模式：


[[beans-factory-autowiring-modes-tbl]]
.Autowiring modes
[cols="20%,80%"]
|===
| Mode| Explanation

| `no`
| (默认) 不自动装配。Bean引用必须由 `ref` 元素定义，对于比较大的项目的部署，不建议修改默认的配置 ，因为明确指定协作者可以提供更好的控制和清晰度。在某种程度上，它记录了系统的结构。

| `byName`
| 按属性名称自动装配。 Spring查找与需要自动装配的属性同名的bean。 例如，如果bean配置为根据名字装配，他包含 的属性名字为 `master`（即，它具有 `setMaster(..)` 方法），则Spring会查找名为 `master` 的bean定义并使用它来设置属性。

| `byType`
| 如果需要自动装配的属性的类型在容器中只存在一个的话，他允许自动装配。如果存在多个，则抛出致命异常，这表示您不能对该bean使用 `byType` 自动装配。 如果没有匹配的bean，则不会发生任何事情（未设置该属性）。

| `constructor`
| 类似于 `byType` ，但应用于构造函数参数。 如果容器中没有一个Bean的类型和构造函数参数类型一致的话，则会引发致命错误。
|===

通过 `byType` 或者 `constructor` 的自动装配方式，开发者可以装载数组和强类型集合。在这样的例子中，所有容器中的匹配了指定类型的bean都会自动装配到bean上来完成依赖注入。 开发者可以自动装配key为 `String` 强类型的 `Map` 。自动装配的 `Map` 值会包含所有的bean实例值来匹配指定的类型，`Map` 的 `key` 会包含关联的bean的名字。



[[beans-autowired-exceptions]]
==== 自动装配的局限和缺点

自动装配在项目中一致使用时效果最佳。如果一般不使用自动装配，那么开发人员使用它来装配一个或两个bean定义可能会让人感到困惑。

Consider the limitations and disadvantages of autowiring:

*  `property` 和 `constructor-arg` 设置中的显式依赖项始终覆盖自动装配。开发者不能自动装配一些简单属性，您不能自动装配简单属性，例如基本类型 ，`Strings`, 和 `Classes`（以及此类简单属性的数组）。这种限制是按设计的。
*  自动装配比显式的配置更容易歧义，尽管上表表明了不同自动配置的特点，Spring也会尽可能避免不必要的装配错误。但是Spring管理的对象关系仍然不如显式配置那样明确。
* 从Spring容器生成文档的工具可能无法有效的提供装配信息。
* 容器中的多个bean定义可能与setter方法或构造函数参数所指定的类型相匹配， 这有利于自动装配。对于arrays, collections, 或者 Map实例来说这不是问题。但是如果是对只有一个依赖项的值是有歧义的话，那么这个项是无法解析的。如果没有唯一的bean，则会抛出异常。
在后面的场景，你可有如下的选择：

* 放弃自动装配，改用显式的配置。
* 通过将 `autowire-candidate` 属性设置为 `false`, 避免对bean定义进行自动装配， <<beans-factory-autowire-candidate, 如下一节所述>>.
* 通过将其 `<bean/>` 元素的 `primary` 属性设置为 `true`.将单个bean定义指定为主要候选项。
* 使用基于注解的配置实现更细粒度的控制，如<<beans-annotation-config,基于注解的容器配置中>>所述。



[[beans-factory-autowire-candidate]]
==== 将bean从自动装配中排除

在每个bean的基础上，您可以从自动装配中排除bean。 在Spring的XML格式中，将 `<bean/>` 元素的 `autowire-candidate`  属性设置为 `false`. 容器使特定的bean定义对自动装配基础结构不可用（包括注解样式配置，如<<beans-autowired-annotation,`@Autowired`>>）。


NOTE: `autowire-candidate` a 属性旨在仅影响基于类型的自动装配。 它不会影响名称的显式引用，即使指定的bean未标记为autowire候选，也会解析它。 因此，如果名称匹配，则按名称自动装配会注入bean。

开发者可以通过模式匹配而不是Bean的名字来限制自动装配的候选者。最上层的 `<beans/>` 元素会在 `default-autowire-candidates`  属性中来配置多种模式。 例如，限制自动装配候选者的名字以 `Repository` 结尾，可以配置成 `*Repository`。
如果需要配置多种模式，只需要用逗号分隔开即可。 bean定义的 `autowire-candidate` 属性的显式值 `true` 或 `false` 始终优先。 对于此类bean，模式匹配规则不适用。

上面的这些技术在配置那些无需自动装配的bean是相当有效的，当然这并不是说这类bean本身无法自动装配其他的bean。而是说这些bean不再作为自动装配的依赖候选者。



[[beans-factory-method-injection]]
=== 方法注入

在大多数的应用场景下，多数的bean都是<<beans-factory-scopes-singleton,singletons>>的。当这个单例的bean需要和另一个单例的或者非单例的bean协作使用的时候，开发者只需要配置依赖bean为这个bean的属性即可。 但是有时会因为bean具有不同的生命周期而产生问题。
假设单例的bean A在每个方法调用中使用了非单例的bean B。容器只会创建bean A一次，而只有一个机会来配置属性。 那么容器就无法为每一次创建bean A时都提供新的bean B实例。

一种解决方案就是放弃IoC，开发者可以通过实现 `ApplicationContextAware`  接口 <<beans-factory-aware,让bean A对 `ApplicationContextAware` 可见>> 。 <<beans-factory-client,从容器中调用 `getBean("B")` >>调用来使bean A知道该容器，以便每次bean A需要它时都请求一个（通常是新的）bean B实例。。参考下面例子。


[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// a class that uses a stateful Command-style class to perform some processing
	package fiona.apple;

	// Spring-API imports
	import org.springframework.beans.BeansException;
	import org.springframework.context.ApplicationContext;
	import org.springframework.context.ApplicationContextAware;

	public class CommandManager implements ApplicationContextAware {

		private ApplicationContext applicationContext;

		public Object process(Map commandState) {
			// grab a new instance of the appropriate Command
			Command command = createCommand();
			// set the state on the (hopefully brand new) Command instance
			command.setState(commandState);
			return command.execute();
		}

		protected Command createCommand() {
			// notice the Spring API dependency!
			return this.applicationContext.getBean("command", Command.class);
		}

		public void setApplicationContext(
				ApplicationContext applicationContext) throws BeansException {
			this.applicationContext = applicationContext;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// a class that uses a stateful Command-style class to perform some processing
	package fiona.apple

	// Spring-API imports
	import org.springframework.context.ApplicationContext
	import org.springframework.context.ApplicationContextAware

	class CommandManager : ApplicationContextAware {

		private lateinit var applicationContext: ApplicationContext

		fun process(commandState: Map<*, *>): Any {
			// grab a new instance of the appropriate Command
			val command = createCommand()
			// set the state on the (hopefully brand new) Command instance
			command.state = commandState
			return command.execute()
		}

		// notice the Spring API dependency!
		protected fun createCommand() =
				applicationContext.getBean("command", Command::class.java)

		override fun setApplicationContext(applicationContext: ApplicationContext) {
			this.applicationContext = applicationContext
		}
	}
----

上面的代码并不让人十分满意，因为业务的代码已经与Spring框架耦合在一起。方法注入是Spring IoC容器的一个高级功能，可以让您处理这种问题。 Spring提供了一个稍微高级的注入方式来处理这种问题

****
您可以在此https://spring.io/blog/2004/08/06/method-injection/[this blog entry]中阅读有关方法注入的更多信息。
****



[[beans-factory-lookup-method-injection]]
==== 查找方法注入

查找方法注入是容器覆盖管理bean上的方法的能力，以便返回容器中另一个命名bean的查找结果。查找方法通常涉及原型bean，如<<beans-factory-method-injection, 前面描述的场景>>。 Spring框架通过使用CGLIB库生成的字节码来生成动态子类重写的方法实现此注入。

[NOTE]
====
* 如果想让这个动态子类正常工作，那么Spring容器所继承的Bean不能是 `final` 的，而覆盖的方法也不能是 `final` 的。
* 对具有抽象方法的类进行单元测试时，需要开发者对类进行子类化，并提供抽象方法的具体实现。
* 组件扫描也需要具体的方法，因为它需要获取具体的类。
* 另一个关键限制是查找方法不适用于工厂方法，特别是在配置类中不使用 `@Bean` 的方法。因为在这种情况下，容器不负责创建实例，因此不能在运行时创建运行时生成的子类。
====

对于前面代码片段中的 `CommandManager` 类，Spring容器动态地覆盖 `createCommand()` 方法的实现。 `CommandManager` 类不再拥有任何的Spring依赖，如下：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package fiona.apple;

	// no more Spring imports!

	public abstract class CommandManager {

		public Object process(Object commandState) {
			// grab a new instance of the appropriate Command interface
			Command command = createCommand();
			// set the state on the (hopefully brand new) Command instance
			command.setState(commandState);
			return command.execute();
		}

		// okay... but where is the implementation of this method?
		protected abstract Command createCommand();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package fiona.apple

	// no more Spring imports!

	abstract class CommandManager {

		fun process(commandState: Any): Any {
			// grab a new instance of the appropriate Command interface
			val command = createCommand()
			// set the state on the (hopefully brand new) Command instance
			command.state = commandState
			return command.execute()
		}

		// okay... but where is the implementation of this method?
		protected abstract fun createCommand(): Command
	}
----

在包含需要注入方法的客户端类中 (在本例中为 `CommandManager` ）注入方法的签名需要如下形式：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<public|protected> [abstract] <return-type> theMethodName(no-arguments);
----

如果方法是abstract的， 那么动态生成的子类会实现该方法。否则，动态生成的子类将覆盖原始类定义的具体方法。例如：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<!-- a stateful bean deployed as a prototype (non-singleton) -->
	<bean id="myCommand" class="fiona.apple.AsyncCommand" scope="prototype">
		<!-- inject dependencies here as required -->
	</bean>

	<!-- commandProcessor uses statefulCommandHelper -->
	<bean id="commandManager" class="fiona.apple.CommandManager">
		<lookup-method name="createCommand" bean="myCommand"/>
	</bean>
----

当需要新的 `myCommand` bean实例时，标识为 `commandManager` 的bean会调用自身的 `createCommand()` 方法.开发者必须小心部署 `myCommand` bean为<<beans-factory-scopes-singleton,singleton>>bean. 如果所需的bean是单例的,那么每次都会返回相同的 `myCommand` bean实例.

另外,如果是基于注解的配置模式,你可以在查找方法上定义 `@Lookup` 注解,如下:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public abstract class CommandManager {

		public Object process(Object commandState) {
			Command command = createCommand();
			command.setState(commandState);
			return command.execute();
		}

		@Lookup("myCommand")
		protected abstract Command createCommand();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	abstract class CommandManager {

		fun process(commandState: Any): Any {
			val command = createCommand()
			command.state = commandState
			return command.execute()
		}

		@Lookup("myCommand")
		protected abstract fun createCommand(): Command
	}
----

或者，更常见的是，开发者也可以根据查找方法的返回类型来查找匹配的bean，如下

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public abstract class CommandManager {

		public Object process(Object commandState) {
			MyCommand command = createCommand();
			command.setState(commandState);
			return command.execute();
		}

		@Lookup
		protected abstract MyCommand createCommand();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	abstract class CommandManager {

		fun process(commandState: Any): Any {
			val command = createCommand()
			command.state = commandState
			return command.execute()
		}

		@Lookup
		protected abstract fun createCommand(): Command
	}
----

注意开发者可以通过创建子类实现lookup方法，以便使它们与Spring的组件扫描规则兼容，同时抽象类会在默认情况下被忽略。这种限制不适用于显式注册bean或明确导入bean的情况。

[TIP]
====
另一种可以访问不同生命周期的方法是 `ObjectFactory`/`Provider` 注入，具体参看 <<beans-factory-scopes-other-injection,bean的作用域的注入>>

您可能还会发现 `ServiceLocatorFactoryBean` (在
`org.springframework.beans.factory.config` 包中) 很有用.
====



[[beans-factory-arbitrary-method-replacement]]
==== 替换任意方法

从前面的描述中，我们知道查找方法是有能力来覆盖任何由容器管理的bean方法的。开发者最好跳过这一部分，除非一定需要用到这个功能。

通过基于XML的元数据配置，开发者可以使用 `replaced-method` 元素来替换已存在方法的实现。考虑以下类，它有一个我们想要覆盖的名为 `computeValue` 的方法：


[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MyValueCalculator {

		public String computeValue(String input) {
			// some real code...
		}

		// some other methods...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MyValueCalculator {

		fun computeValue(input: String): String {
			// some real code...
		}

		// some other methods...
	}
----

实现 `org.springframework.beans.factory.support.MethodReplacer` 接口的类提供了新的方法定义，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	/**
	 * meant to be used to override the existing computeValue(String)
	 * implementation in MyValueCalculator
	 */
	public class ReplacementComputeValue implements MethodReplacer {

		public Object reimplement(Object o, Method m, Object[] args) throws Throwable {
			// get the input value, work with it, and return a computed result
			String input = (String) args[0];
			...
			return ...;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	/**
	* meant to be used to override the existing computeValue(String)
	* implementation in MyValueCalculator
	*/
	class ReplacementComputeValue : MethodReplacer {

		override fun reimplement(obj: Any, method: Method, args: Array<out Any>): Any {
			// get the input value, work with it, and return a computed result
			val input = args[0] as String;
			...
			return ...;
		}
	}
----



如果需要覆盖bean方法的XML配置如下类似于以下示例：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="myValueCalculator" class="x.y.z.MyValueCalculator">
		<!-- arbitrary method replacement -->
		<replaced-method name="computeValue" replacer="replacementComputeValue">
			<arg-type>String</arg-type>
		</replaced-method>
	</bean>

	<bean id="replacementComputeValue" class="a.b.c.ReplacementComputeValue"/>
----

您可以在 `<replaced-method/>` 元素中使用一个或多个  `<arg-type/>`  元素来指示被覆盖的方法的方法。当需要覆盖的方法存在重载方法时，必须指定所需参数。 为了方便起见，字符串的类型会匹配以下类型，它完全等同于 `java.lang.String`:


[source,java,indent=0,subs="verbatim,quotes"]
----
	java.lang.String
	String
	Str
----

因为，通常来说参数的个数已经足够区别不同的方法，这种快捷的写法可以省去很多的代码。



[[beans-factory-scopes]]
== Bean Scopes

When you create a bean definition, you create a recipe for creating actual instances
of the class defined by that bean definition. The idea that a bean definition is a
recipe is important, because it means that, as with a class, you can create many object
instances from a single recipe.

You can control not only the various dependencies and configuration values that are to
be plugged into an object that is created from a particular bean definition but also control
the scope of the objects created from a particular bean definition. This approach is
powerful and flexible, because you can choose the scope of the objects you create
through configuration instead of having to bake in the scope of an object at the Java
class level. Beans can be defined to be deployed in one of a number of scopes.
The Spring Framework supports six scopes, four of which are available only if
you use a web-aware `ApplicationContext`. You can also create
<<beans-factory-scopes-custom,a custom scope.>>

The following table describes the supported scopes:

[[beans-factory-scopes-tbl]]
.Bean scopes
[cols="20%,80%"]
|===
| Scope| Description

| <<beans-factory-scopes-singleton,singleton>>
| (Default) Scopes a single bean definition to a single object instance for each Spring IoC
  container.

| <<beans-factory-scopes-prototype,prototype>>
| Scopes a single bean definition to any number of object instances.

| <<beans-factory-scopes-request,request>>
| Scopes a single bean definition to the lifecycle of a single HTTP request. That is,
  each HTTP request has its own instance of a bean created off the back of a single bean
  definition. Only valid in the context of a web-aware Spring `ApplicationContext`.

| <<beans-factory-scopes-session,session>>
| Scopes a single bean definition to the lifecycle of an HTTP `Session`. Only valid in
  the context of a web-aware Spring `ApplicationContext`.

| <<beans-factory-scopes-application,application>>
| Scopes a single bean definition to the lifecycle of a `ServletContext`. Only valid in
  the context of a web-aware Spring `ApplicationContext`.

| <<web.adoc#websocket-stomp-websocket-scope,websocket>>
| Scopes a single bean definition to the lifecycle of a `WebSocket`. Only valid in
  the context of a web-aware Spring `ApplicationContext`.
|===

NOTE: As of Spring 3.0, a thread scope is available but is not registered by default. For
more information, see the documentation for
{api-spring-framework}/context/support/SimpleThreadScope.html[`SimpleThreadScope`].
For instructions on how to register this or any other custom scope, see
<<beans-factory-scopes-custom-using>>.



[[beans-factory-scopes-singleton]]
=== The Singleton Scope

Only one shared instance of a singleton bean is managed, and all requests for beans
with an ID or IDs that match that bean definition result in that one specific bean
instance being returned by the Spring container.

To put it another way, when you define a bean definition and it is scoped as a
singleton, the Spring IoC container creates exactly one instance of the object
defined by that bean definition. This single instance is stored in a cache of such
singleton beans, and all subsequent requests and references for that named bean
return the cached object. The following image shows how the singleton scope works:

image::images/singleton.png[]

Spring's concept of a singleton bean differs from the singleton pattern as defined in
the Gang of Four (GoF) patterns book. The GoF singleton hard-codes the scope of an
object such that one and only one instance of a particular class is created per
ClassLoader. The scope of the Spring singleton is best described as being per-container
and per-bean. This means that, if you define one bean for a particular class in a
single Spring container, the Spring container creates one and only one instance
of the class defined by that bean definition. The singleton scope is the default scope
in Spring. To define a bean as a singleton in XML, you can define a bean as shown in the
following example:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="accountService" class="com.something.DefaultAccountService"/>

	<!-- the following is equivalent, though redundant (singleton scope is the default) -->
	<bean id="accountService" class="com.something.DefaultAccountService" scope="singleton"/>
----



[[beans-factory-scopes-prototype]]
=== The Prototype Scope

The non-singleton prototype scope of bean deployment results in the creation of a new
bean instance every time a request for that specific bean is made. That is, the bean
is injected into another bean or you request it through a `getBean()` method call on the
container. As a rule, you should use the prototype scope for all stateful beans and the
singleton scope for stateless beans.

The following diagram illustrates the Spring prototype scope:

image::images/prototype.png[]

(A data access object
(DAO) is not typically configured as a prototype, because a typical DAO does not hold
any conversational state. It was easier for us to reuse the core of the
singleton diagram.)

The following example defines a bean as a prototype in XML:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="accountService" class="com.something.DefaultAccountService" scope="prototype"/>
----

In contrast to the other scopes, Spring does not manage the complete lifecycle of a
prototype bean. The container instantiates, configures, and otherwise assembles a
prototype object and hands it to the client, with no further record of that prototype
instance. Thus, although initialization lifecycle callback methods are called on all
objects regardless of scope, in the case of prototypes, configured destruction
lifecycle callbacks are not called. The client code must clean up prototype-scoped
objects and release expensive resources that the prototype beans hold. To get
the Spring container to release resources held by prototype-scoped beans, try using a
custom <<beans-factory-extension-bpp,bean post-processor>>, which holds a reference to
beans that need to be cleaned up.

In some respects, the Spring container's role in regard to a prototype-scoped bean is a
replacement for the Java `new` operator. All lifecycle management past that point must
be handled by the client. (For details on the lifecycle of a bean in the Spring
container, see <<beans-factory-lifecycle>>.)



[[beans-factory-scopes-sing-prot-interaction]]
=== Singleton Beans with Prototype-bean Dependencies

When you use singleton-scoped beans with dependencies on prototype beans, be aware that
dependencies are resolved at instantiation time. Thus, if you dependency-inject a
prototype-scoped bean into a singleton-scoped bean, a new prototype bean is instantiated
and then dependency-injected into the singleton bean. The prototype instance is the sole
instance that is ever supplied to the singleton-scoped bean.

However, suppose you want the singleton-scoped bean to acquire a new instance of the
prototype-scoped bean repeatedly at runtime. You cannot dependency-inject a
prototype-scoped bean into your singleton bean, because that injection occurs only
once, when the Spring container instantiates the singleton bean and resolves
and injects its dependencies. If you need a new instance of a prototype bean at
runtime more than once, see <<beans-factory-method-injection>>



[[beans-factory-scopes-other]]
=== Request, Session, Application, and WebSocket Scopes

The `request`, `session`, `application`, and `websocket` scopes are available only
if you use a web-aware Spring `ApplicationContext` implementation (such as
`XmlWebApplicationContext`). If you use these scopes with regular Spring IoC containers,
such as the `ClassPathXmlApplicationContext`, an `IllegalStateException` that complains
about an unknown bean scope is thrown.



[[beans-factory-scopes-other-web-configuration]]
==== Initial Web Configuration

To support the scoping of beans at the `request`, `session`, `application`, and
`websocket` levels (web-scoped beans), some minor initial configuration is
required before you define your beans. (This initial setup is not required
for the standard scopes: `singleton` and `prototype`.)

How you accomplish this initial setup depends on your particular Servlet environment.

If you access scoped beans within Spring Web MVC, in effect, within a request that is
processed by the Spring `DispatcherServlet`, no special setup is necessary.
`DispatcherServlet` already exposes all relevant state.

If you use a Servlet 2.5 web container, with requests processed outside of Spring's
`DispatcherServlet` (for example, when using JSF or Struts), you need to register the
`org.springframework.web.context.request.RequestContextListener` `ServletRequestListener`.
For Servlet 3.0+, this can be done programmatically by using the `WebApplicationInitializer`
interface. Alternatively, or for older containers, add the following declaration to
your web application's `web.xml` file:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<web-app>
		...
		<listener>
			<listener-class>
				org.springframework.web.context.request.RequestContextListener
			</listener-class>
		</listener>
		...
	</web-app>
----

Alternatively, if there are issues with your listener setup, consider using Spring's
`RequestContextFilter`. The filter mapping depends on the surrounding web
application configuration, so you have to change it as appropriate. The following listing
shows the filter part of a web application:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<web-app>
		...
		<filter>
			<filter-name>requestContextFilter</filter-name>
			<filter-class>org.springframework.web.filter.RequestContextFilter</filter-class>
		</filter>
		<filter-mapping>
			<filter-name>requestContextFilter</filter-name>
			<url-pattern>/*</url-pattern>
		</filter-mapping>
		...
	</web-app>
----

`DispatcherServlet`, `RequestContextListener`, and `RequestContextFilter` all do exactly
the same thing, namely bind the HTTP request object to the `Thread` that is servicing
that request. This makes beans that are request- and session-scoped available further
down the call chain.



[[beans-factory-scopes-request]]
==== Request scope

Consider the following XML configuration for a bean definition:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="loginAction" class="com.something.LoginAction" scope="request"/>
----

The Spring container creates a new instance of the `LoginAction` bean by using the
`loginAction` bean definition for each and every HTTP request. That is, the
`loginAction` bean is scoped at the HTTP request level. You can change the internal
state of the instance that is created as much as you want, because other instances
created from the same `loginAction` bean definition do not see these changes in state.
They are particular to an individual request. When the request completes processing, the
bean that is scoped to the request is discarded.

When using annotation-driven components or Java configuration, the `@RequestScope` annotation
can be used to assign a component to the `request` scope. The following example shows how
to do so:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RequestScope
	@Component
	public class LoginAction {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RequestScope
	@Component
	class LoginAction {
		// ...
	}
----



[[beans-factory-scopes-session]]
==== Session Scope

Consider the following XML configuration for a bean definition:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="userPreferences" class="com.something.UserPreferences" scope="session"/>
----

The Spring container creates a new instance of the `UserPreferences` bean by using the
`userPreferences` bean definition for the lifetime of a single HTTP `Session`. In other
words, the `userPreferences` bean is effectively scoped at the HTTP `Session` level. As
with request-scoped beans, you can change the internal state of the instance that is
created as much as you want, knowing that other HTTP `Session` instances that are also
using instances created from the same `userPreferences` bean definition do not see these
changes in state, because they are particular to an individual HTTP `Session`. When the
HTTP `Session` is eventually discarded, the bean that is scoped to that particular HTTP
`Session` is also discarded.

When using annotation-driven components or Java configuration, you can use the
`@SessionScope` annotation to assign a component to the `session` scope.

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@SessionScope
	@Component
	public class UserPreferences {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@SessionScope
	@Component
	class UserPreferences {
		// ...
	}
----


[[beans-factory-scopes-application]]
==== Application Scope

Consider the following XML configuration for a bean definition:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="appPreferences" class="com.something.AppPreferences" scope="application"/>
----

The Spring container creates a new instance of the `AppPreferences` bean by using the
`appPreferences` bean definition once for the entire web application. That is, the
`appPreferences` bean is scoped at the `ServletContext` level and stored as a regular
`ServletContext` attribute. This is somewhat similar to a Spring singleton bean but
differs in two important ways: It is a singleton per `ServletContext`, not per Spring
'ApplicationContext' (for which there may be several in any given web application),
and it is actually exposed and therefore visible as a `ServletContext` attribute.

When using annotation-driven components or Java configuration, you can use the
`@ApplicationScope` annotation to assign a component to the `application` scope. The
following example shows how to do so:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ApplicationScope
	@Component
	public class AppPreferences {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ApplicationScope
	@Component
	class AppPreferences {
		// ...
	}
----



[[beans-factory-scopes-other-injection]]
==== Scoped Beans as Dependencies

The Spring IoC container manages not only the instantiation of your objects (beans),
but also the wiring up of collaborators (or dependencies). If you want to inject (for
example) an HTTP request-scoped bean into another bean of a longer-lived scope, you may
choose to inject an AOP proxy in place of the scoped bean. That is, you need to inject
a proxy object that exposes the same public interface as the scoped object but that can
also retrieve the real target object from the relevant scope (such as an HTTP request)
and delegate method calls onto the real object.

[NOTE]
====
You may also use `<aop:scoped-proxy/>` between beans that are scoped as `singleton`,
with the reference then going through an intermediate proxy that is serializable
and therefore able to re-obtain the target singleton bean on deserialization.

When declaring `<aop:scoped-proxy/>` against a bean of scope `prototype`, every method
call on the shared proxy leads to the creation of a new target instance to which the
call is then being forwarded.

Also, scoped proxies are not the only way to access beans from shorter scopes in a
lifecycle-safe fashion. You may also declare your injection point (that is, the
constructor or setter argument or autowired field) as `ObjectFactory<MyTargetBean>`,
allowing for a `getObject()` call to retrieve the current instance on demand every
time it is needed -- without holding on to the instance or storing it separately.

As an extended variant, you may declare `ObjectProvider<MyTargetBean>`, which delivers
several additional access variants, including `getIfAvailable` and `getIfUnique`.

The JSR-330 variant of this is called `Provider` and is used with a `Provider<MyTargetBean>`
declaration and a corresponding `get()` call for every retrieval attempt.
See <<beans-standard-annotations,here>> for more details on JSR-330 overall.
====

The configuration in the following example is only one line, but it is important to
understand the "`why`" as well as the "`how`" behind it:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/aop
			https://www.springframework.org/schema/aop/spring-aop.xsd">

		<!-- an HTTP Session-scoped bean exposed as a proxy -->
		<bean id="userPreferences" class="com.something.UserPreferences" scope="session">
			<!-- instructs the container to proxy the surrounding bean -->
			<aop:scoped-proxy/> <1>
		</bean>

		<!-- a singleton-scoped bean injected with a proxy to the above bean -->
		<bean id="userService" class="com.something.SimpleUserService">
			<!-- a reference to the proxied userPreferences bean -->
			<property name="userPreferences" ref="userPreferences"/>
		</bean>
	</beans>
----
<1> The line that defines the proxy.


To create such a proxy, you insert a child `<aop:scoped-proxy/>` element into a scoped
bean definition (see <<beans-factory-scopes-other-injection-proxies>> and
<<core.adoc#xsd-schemas, XML Schema-based configuration>>).
Why do definitions of beans scoped at the `request`, `session` and custom-scope
levels require the `<aop:scoped-proxy/>` element?
Consider the following singleton bean definition and contrast it with
what you need to define for the aforementioned scopes (note that the following
`userPreferences` bean definition as it stands is incomplete):

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="userPreferences" class="com.something.UserPreferences" scope="session"/>

	<bean id="userManager" class="com.something.UserManager">
		<property name="userPreferences" ref="userPreferences"/>
	</bean>
----

In the preceding example, the singleton bean (`userManager`) is injected with a reference
to the HTTP `Session`-scoped bean (`userPreferences`). The salient point here is that the
`userManager` bean is a singleton: it is instantiated exactly once per
container, and its dependencies (in this case only one, the `userPreferences` bean) are
also injected only once. This means that the `userManager` bean operates only on the
exact same `userPreferences` object (that is, the one with which it was originally injected.

This is not the behavior you want when injecting a shorter-lived scoped bean into a
longer-lived scoped bean (for example, injecting an HTTP `Session`-scoped collaborating
bean as a dependency into singleton bean). Rather, you need a single `userManager`
object, and, for the lifetime of an HTTP `Session`, you need a `userPreferences` object
that is specific to the HTTP `Session`. Thus, the container creates an object that
exposes the exact same public interface as the `UserPreferences` class (ideally an
object that is a `UserPreferences` instance), which can fetch the real
`UserPreferences` object from the scoping mechanism (HTTP request, `Session`, and so
forth). The container injects this proxy object into the `userManager` bean, which is
unaware that this `UserPreferences` reference is a proxy. In this example, when a
`UserManager` instance invokes a method on the dependency-injected `UserPreferences`
object, it is actually invoking a method on the proxy. The proxy then fetches the real
`UserPreferences` object from (in this case) the HTTP `Session` and delegates the
method invocation onto the retrieved real `UserPreferences` object.

Thus, you need the following (correct and complete) configuration when injecting
`request-` and `session-scoped` beans into collaborating objects, as the following example
shows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="userPreferences" class="com.something.UserPreferences" scope="session">
		<aop:scoped-proxy/>
	</bean>

	<bean id="userManager" class="com.something.UserManager">
		<property name="userPreferences" ref="userPreferences"/>
	</bean>
----

[[beans-factory-scopes-other-injection-proxies]]
===== Choosing the Type of Proxy to Create

By default, when the Spring container creates a proxy for a bean that is marked up with
the `<aop:scoped-proxy/>` element, a CGLIB-based class proxy is created.

[NOTE]
====
CGLIB proxies intercept only public method calls! Do not call non-public methods
on such a proxy. They are not delegated to the actual scoped target object.
====

Alternatively, you can configure the Spring container to create standard JDK
interface-based proxies for such scoped beans, by specifying `false` for the value of
the `proxy-target-class` attribute of the `<aop:scoped-proxy/>` element. Using JDK
interface-based proxies means that you do not need additional libraries in your
application classpath to affect such proxying. However, it also means that the class of
the scoped bean must implement at least one interface and that all collaborators
into which the scoped bean is injected must reference the bean through one of its
interfaces. The following example shows a proxy based on an interface:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<!-- DefaultUserPreferences implements the UserPreferences interface -->
	<bean id="userPreferences" class="com.stuff.DefaultUserPreferences" scope="session">
		<aop:scoped-proxy proxy-target-class="false"/>
	</bean>

	<bean id="userManager" class="com.stuff.UserManager">
		<property name="userPreferences" ref="userPreferences"/>
	</bean>
----

For more detailed information about choosing class-based or interface-based proxying,
see <<aop-proxying>>.



[[beans-factory-scopes-custom]]
=== Custom Scopes

The bean scoping mechanism is extensible. You can define your own
scopes or even redefine existing scopes, although the latter is considered bad practice
and you cannot override the built-in `singleton` and `prototype` scopes.


[[beans-factory-scopes-custom-creating]]
==== Creating a Custom Scope

To integrate your custom scopes into the Spring container, you need to implement the
`org.springframework.beans.factory.config.Scope` interface, which is described in this
section. For an idea of how to implement your own scopes, see the `Scope`
implementations that are supplied with the Spring Framework itself and the
{api-spring-framework}/beans/factory/config/Scope.html[`Scope`] javadoc,
which explains the methods you need to implement in more detail.

The `Scope` interface has four methods to get objects from the scope, remove them from
the scope, and let them be destroyed.

The session scope
implementation, for example, returns the session-scoped bean (if it does not exist,
the method returns a new instance of the bean, after having bound it to the session for
future reference). The following method returns the object from the underlying scope:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	Object get(String name, ObjectFactory<?> objectFactory)
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun get(name: String, objectFactory: ObjectFactory<*>): Any
----

The session scope
implementation, for example, removes the session-scoped bean from the underlying session.
The object should be returned, but you can return null if the object with the specified
name is not found. The following method removes the object from the underlying scope:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	Object remove(String name)
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun remove(name: String): Any
----

The following method registers the callbacks the scope should execute when it is
destroyed or when the specified object in the scope is destroyed:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	void registerDestructionCallback(String name, Runnable destructionCallback)
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun registerDestructionCallback(name: String, destructionCallback: Runnable)
----

See the {api-spring-framework}/beans/factory/config/Scope.html#registerDestructionCallback[javadoc]
or a Spring scope implementation for more information on destruction callbacks.

The following method obtains the conversation identifier for the underlying scope:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	String getConversationId()
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun getConversationId(): String
----


This identifier is different for each scope. For a session scoped implementation, this
identifier can be the session identifier.



[[beans-factory-scopes-custom-using]]
==== Using a Custom Scope

After you write and test one or more custom `Scope` implementations, you need to make
the Spring container aware of your new scopes. The following method is the central
method to register a new `Scope` with the Spring container:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	void registerScope(String scopeName, Scope scope);
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun registerScope(scopeName: String, scope: Scope)
----

This method is declared on the `ConfigurableBeanFactory` interface, which is available
through the `BeanFactory` property on most of the concrete `ApplicationContext`
implementations that ship with Spring.

The first argument to the `registerScope(..)` method is the unique name associated with
a scope. Examples of such names in the Spring container itself are `singleton` and
`prototype`. The second argument to the `registerScope(..)` method is an actual instance
of the custom `Scope` implementation that you wish to register and use.

Suppose that you write your custom `Scope` implementation, and then register it as shown
in the next example.

NOTE: The next example uses `SimpleThreadScope`, which is included with Spring but is not
registered by default. The instructions would be the same for your own custom `Scope`
implementations.

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	Scope threadScope = new SimpleThreadScope();
	beanFactory.registerScope("thread", threadScope);
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val threadScope = SimpleThreadScope()
	beanFactory.registerScope("thread", threadScope)
----

You can then create bean definitions that adhere to the scoping rules of your custom
`Scope`, as follows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="..." class="..." scope="thread">
----

With a custom `Scope` implementation, you are not limited to programmatic registration
of the scope. You can also do the `Scope` registration declaratively, by using the
`CustomScopeConfigurer` class, as the following example shows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/aop
			https://www.springframework.org/schema/aop/spring-aop.xsd">

		<bean class="org.springframework.beans.factory.config.CustomScopeConfigurer">
			<property name="scopes">
				<map>
					<entry key="thread">
						<bean class="org.springframework.context.support.SimpleThreadScope"/>
					</entry>
				</map>
			</property>
		</bean>

		<bean id="thing2" class="x.y.Thing2" scope="thread">
			<property name="name" value="Rick"/>
			<aop:scoped-proxy/>
		</bean>

		<bean id="thing1" class="x.y.Thing1">
			<property name="thing2" ref="thing2"/>
		</bean>

	</beans>
----

NOTE: When you place `<aop:scoped-proxy/>` in a `FactoryBean` implementation, it is the factory
bean itself that is scoped, not the object returned from `getObject()`.




[[beans-factory-nature]]
== Customizing the Nature of a Bean

The Spring Framework provides a number of interfaces you can use to customize the nature
of a bean. This section groups them as follows:

* <<beans-factory-lifecycle>>
* <<beans-factory-aware>>
* <<aware-list>>



[[beans-factory-lifecycle]]
=== Lifecycle Callbacks

To interact with the container's management of the bean lifecycle, you can implement
the Spring `InitializingBean` and `DisposableBean` interfaces. The container calls
`afterPropertiesSet()` for the former and `destroy()` for the latter to let the bean
perform certain actions upon initialization and destruction of your beans.

[TIP]
====
The JSR-250 `@PostConstruct` and `@PreDestroy` annotations are generally considered best
practice for receiving lifecycle callbacks in a modern Spring application. Using these
annotations means that your beans are not coupled to Spring-specific interfaces.
For details, see <<beans-postconstruct-and-predestroy-annotations>>.

If you do not want to use the JSR-250 annotations but you still want to remove
coupling, consider `init-method` and `destroy-method` bean definition metadata.
====

Internally, the Spring Framework uses `BeanPostProcessor` implementations to process any
callback interfaces it can find and call the appropriate methods. If you need custom
features or other lifecycle behavior Spring does not by default offer, you can
implement a `BeanPostProcessor` yourself. For more information, see
<<beans-factory-extension>>.

In addition to the initialization and destruction callbacks, Spring-managed objects may
also implement the `Lifecycle` interface so that those objects can participate in the
startup and shutdown process, as driven by the container's own lifecycle.

The lifecycle callback interfaces are described in this section.


[[beans-factory-lifecycle-initializingbean]]
==== Initialization Callbacks

The `org.springframework.beans.factory.InitializingBean` interface lets a bean
perform initialization work after the container has set all necessary properties on the
bean. The `InitializingBean` interface specifies a single method:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	void afterPropertiesSet() throws Exception;
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun afterPropertiesSet()
----

We recommend that you do not use the `InitializingBean` interface, because it
unnecessarily couples the code to Spring. Alternatively, we suggest using
the <<beans-postconstruct-and-predestroy-annotations, `@PostConstruct`>> annotation or
specifying a POJO initialization method. In the case of XML-based configuration metadata,
you can use the `init-method` attribute to specify the name of the method that has a void
no-argument signature. With Java configuration, you can use the `initMethod` attribute of
`@Bean`. See <<beans-java-lifecycle-callbacks>>. Consider the following example:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/>
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class ExampleBean {

		public void init() {
			// do some initialization work
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class ExampleBean {

		fun init() {
			// do some initialization work
		}
	}
----

The preceding example has almost exactly the same effect as the following example
(which consists of two listings):

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleInitBean" class="examples.AnotherExampleBean"/>
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class AnotherExampleBean implements InitializingBean {

		@Override
		public void afterPropertiesSet() {
			// do some initialization work
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class AnotherExampleBean : InitializingBean {

		override fun afterPropertiesSet() {
			// do some initialization work
		}
	}
----

However, the first of the two preceding examples does not couple the code to Spring.


[[beans-factory-lifecycle-disposablebean]]
==== Destruction Callbacks

Implementing the `org.springframework.beans.factory.DisposableBean` interface lets a
bean get a callback when the container that contains it is destroyed. The
`DisposableBean` interface specifies a single method:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	void destroy() throws Exception;
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun destroy()
----

We recommend that you do not use the `DisposableBean` callback interface, because it
unnecessarily couples the code to Spring. Alternatively, we suggest using
the <<beans-postconstruct-and-predestroy-annotations, `@PreDestroy`>> annotation or
specifying a generic method that is supported by bean definitions. With XML-based
configuration metadata, you can use the `destroy-method` attribute on the `<bean/>`.
With Java configuration, you can use the `destroyMethod` attribute of `@Bean`. See
<<beans-java-lifecycle-callbacks>>. Consider the following definition:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleInitBean" class="examples.ExampleBean" destroy-method="cleanup"/>
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class ExampleBean {

		public void cleanup() {
			// do some destruction work (like releasing pooled connections)
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class ExampleBean {

		fun cleanup() {
			// do some destruction work (like releasing pooled connections)
		}
	}
----

The preceding definition has almost exactly the same effect as the following definition:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleInitBean" class="examples.AnotherExampleBean"/>
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class AnotherExampleBean implements DisposableBean {

		@Override
		public void destroy() {
			// do some destruction work (like releasing pooled connections)
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class AnotherExampleBean : DisposableBean {

		override fun destroy() {
			// do some destruction work (like releasing pooled connections)
		}
	}
----

However, the first of the two preceding definitions does not couple the code to Spring.

TIP: You can assign the `destroy-method` attribute of a `<bean>` element a special
`(inferred)` value, which instructs Spring to automatically detect a public `close` or
`shutdown` method on the specific bean class. (Any class that implements
`java.lang.AutoCloseable` or `java.io.Closeable` would therefore match.) You can also set
this special `(inferred)` value on the `default-destroy-method` attribute of a
`<beans>` element to apply this behavior to an entire set of beans (see
<<beans-factory-lifecycle-default-init-destroy-methods>>). Note that this is the
default behavior with Java configuration.

[[beans-factory-lifecycle-default-init-destroy-methods]]
==== Default Initialization and Destroy Methods

When you write initialization and destroy method callbacks that do not use the
Spring-specific `InitializingBean` and `DisposableBean` callback interfaces, you
typically write methods with names such as `init()`, `initialize()`, `dispose()`, and so
on. Ideally, the names of such lifecycle callback methods are standardized across a
project so that all developers use the same method names and ensure consistency.

You can configure the Spring container to "`look`" for named initialization and destroy
callback method names on every bean. This means that you, as an application
developer, can write your application classes and use an initialization callback called
`init()`, without having to configure an `init-method="init"` attribute with each bean
definition. The Spring IoC container calls that method when the bean is created (and in
accordance with the standard lifecycle callback contract <<beans-factory-lifecycle,
described previously>>). This feature also enforces a consistent naming convention for
initialization and destroy method callbacks.

Suppose that your initialization callback methods are named `init()` and your destroy
callback methods are named `destroy()`. Your class then resembles the class in the
following example:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class DefaultBlogService implements BlogService {

		private BlogDao blogDao;

		public void setBlogDao(BlogDao blogDao) {
			this.blogDao = blogDao;
		}

		// this is (unsurprisingly) the initialization callback method
		public void init() {
			if (this.blogDao == null) {
				throw new IllegalStateException("The [blogDao] property must be set.");
			}
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class DefaultBlogService : BlogService {

		private var blogDao: BlogDao? = null
		
		// this is (unsurprisingly) the initialization callback method
		fun init() {
			if (blogDao == null) {
				throw IllegalStateException("The [blogDao] property must be set.")
			}
		}
	}
----

You could then use that class in a bean resembling the following:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans default-init-method="init">

		<bean id="blogService" class="com.something.DefaultBlogService">
			<property name="blogDao" ref="blogDao" />
		</bean>

	</beans>
----

The presence of the `default-init-method` attribute on the top-level `<beans/>` element
attribute causes the Spring IoC container to recognize a method called `init` on the bean
class as the initialization method callback. When a bean is created and assembled, if the
bean class has such a method, it is invoked at the appropriate time.

You can configure destroy method callbacks similarly (in XML, that is) by using the
`default-destroy-method` attribute on the top-level `<beans/>` element.

Where existing bean classes already have callback methods that are named at variance
with the convention, you can override the default by specifying (in XML, that is) the
method name by using the `init-method` and `destroy-method` attributes of the `<bean/>`
itself.

The Spring container guarantees that a configured initialization callback is called
immediately after a bean is supplied with all dependencies. Thus, the initialization
callback is called on the raw bean reference, which means that AOP interceptors and so
forth are not yet applied to the bean. A target bean is fully created first and
then an AOP proxy (for example) with its interceptor chain is applied. If the target
bean and the proxy are defined separately, your code can even interact with the raw
target bean, bypassing the proxy. Hence, it would be inconsistent to apply the
interceptors to the `init` method, because doing so would couple the lifecycle of the
target bean to its proxy or interceptors and leave strange semantics when your code
interacts directly with the raw target bean.



[[beans-factory-lifecycle-combined-effects]]
==== Combining Lifecycle Mechanisms

As of Spring 2.5, you have three options for controlling bean lifecycle behavior:

* The <<beans-factory-lifecycle-initializingbean, `InitializingBean`>> and
<<beans-factory-lifecycle-disposablebean, `DisposableBean`>> callback interfaces
* Custom `init()` and `destroy()` methods
* The <<beans-postconstruct-and-predestroy-annotations, `@PostConstruct` and `@PreDestroy`
annotations>>. You can combine these mechanisms to control a given bean.

NOTE: If multiple lifecycle mechanisms are configured for a bean and each mechanism is
configured with a different method name, then each configured method is executed in the
order listed after this note. However, if the same method name is configured -- for example,
`init()` for an initialization method -- for more than one of these lifecycle mechanisms,
that method is executed once, as explained in the
<<beans-factory-lifecycle-default-init-destroy-methods, preceding section>>.

Multiple lifecycle mechanisms configured for the same bean, with different
initialization methods, are called as follows:

. Methods annotated with `@PostConstruct`
. `afterPropertiesSet()` as defined by the `InitializingBean` callback interface
. A custom configured `init()` method

Destroy methods are called in the same order:

. Methods annotated with `@PreDestroy`
. `destroy()` as defined by the `DisposableBean` callback interface
. A custom configured `destroy()` method



[[beans-factory-lifecycle-processor]]
==== Startup and Shutdown Callbacks

The `Lifecycle` interface defines the essential methods for any object that has its own
lifecycle requirements (such as starting and stopping some background process):

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public interface Lifecycle {

		void start();

		void stop();

		boolean isRunning();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	interface Lifecycle {

		fun start()

		fun stop()

		val isRunning: Boolean
	}
----

Any Spring-managed object may implement the `Lifecycle` interface. Then, when the
`ApplicationContext` itself receives start and stop signals (for example, for a stop/restart
scenario at runtime), it cascades those calls to all `Lifecycle` implementations
defined within that context. It does this by delegating to a `LifecycleProcessor`, shown
in the following listing:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public interface LifecycleProcessor extends Lifecycle {

		void onRefresh();

		void onClose();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	interface LifecycleProcessor : Lifecycle {

		fun onRefresh()

		fun onClose()
	}
----

Notice that the `LifecycleProcessor` is itself an extension of the `Lifecycle`
interface. It also adds two other methods for reacting to the context being refreshed
and closed.

[TIP]
====
Note that the regular `org.springframework.context.Lifecycle` interface is a plain
contract for explicit start and stop notifications and does not imply auto-startup at context
refresh time. For fine-grained control over auto-startup of a specific bean (including startup phases),
consider implementing `org.springframework.context.SmartLifecycle` instead.

Also, please note that stop notifications are not guaranteed to come before destruction.
On regular shutdown, all `Lifecycle` beans first receive a stop notification before
the general destruction callbacks are being propagated. However, on hot refresh during a
context's lifetime or on aborted refresh attempts, only destroy methods are called.
====

The order of startup and shutdown invocations can be important. If a "`depends-on`"
relationship exists between any two objects, the dependent side starts after its
dependency, and it stops before its dependency. However, at times, the direct
dependencies are unknown. You may only know that objects of a certain type should start
prior to objects of another type. In those cases, the `SmartLifecycle` interface defines
another option, namely the `getPhase()` method as defined on its super-interface,
`Phased`. The following listing shows the definition of the `Phased` interface:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public interface Phased {

		int getPhase();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	interface Phased {

		val phase: Int
	}
----

The following listing shows the definition of the `SmartLifecycle` interface:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public interface SmartLifecycle extends Lifecycle, Phased {

		boolean isAutoStartup();

		void stop(Runnable callback);
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	interface SmartLifecycle : Lifecycle, Phased {

		val isAutoStartup: Boolean

		fun stop(callback: Runnable)
	}
----

When starting, the objects with the lowest phase start first. When stopping, the
reverse order is followed. Therefore, an object that implements `SmartLifecycle` and
whose `getPhase()` method returns `Integer.MIN_VALUE` would be among the first to start
and the last to stop. At the other end of the spectrum, a phase value of
`Integer.MAX_VALUE` would indicate that the object should be started last and stopped
first (likely because it depends on other processes to be running). When considering the
phase value, it is also important to know that the default phase for any "`normal`"
`Lifecycle` object that does not implement `SmartLifecycle` is `0`. Therefore, any
negative phase value indicates that an object should start before those standard
components (and stop after them). The reverse is true for any positive phase value.

The stop method defined by `SmartLifecycle` accepts a callback. Any
implementation must invoke that callback's `run()` method after that implementation's
shutdown process is complete. That enables asynchronous shutdown where necessary, since
the default implementation of the `LifecycleProcessor` interface,
`DefaultLifecycleProcessor`, waits up to its timeout value for the group of objects
within each phase to invoke that callback. The default per-phase timeout is 30 seconds.
You can override the default lifecycle processor instance by defining a bean named
`lifecycleProcessor` within the context. If you want only to modify the timeout,
defining the following would suffice:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="lifecycleProcessor" class="org.springframework.context.support.DefaultLifecycleProcessor">
		<!-- timeout value in milliseconds -->
		<property name="timeoutPerShutdownPhase" value="10000"/>
	</bean>
----

As mentioned earlier, the `LifecycleProcessor` interface defines callback methods for the
refreshing and closing of the context as well. The latter drives the shutdown
process as if `stop()` had been called explicitly, but it happens when the context is
closing. The 'refresh' callback, on the other hand, enables another feature of
`SmartLifecycle` beans. When the context is refreshed (after all objects have been
instantiated and initialized), that callback is invoked. At that point, the
default lifecycle processor checks the boolean value returned by each
`SmartLifecycle` object's `isAutoStartup()` method. If `true`, that object is
started at that point rather than waiting for an explicit invocation of the context's or
its own `start()` method (unlike the context refresh, the context start does not happen
automatically for a standard context implementation). The `phase` value and any
"`depends-on`" relationships determine the startup order as described earlier.



[[beans-factory-shutdown]]
==== Shutting Down the Spring IoC Container Gracefully in Non-Web Applications

[NOTE]
====
This section applies only to non-web applications. Spring's web-based
`ApplicationContext` implementations already have code in place to gracefully shut down
the Spring IoC container when the relevant web application is shut down.
====

If you use Spring's IoC container in a non-web application environment (for
example, in a rich client desktop environment), register a shutdown hook with the
JVM. Doing so ensures a graceful shutdown and calls the relevant destroy methods on your
singleton beans so that all resources are released. You must still configure
and implement these destroy callbacks correctly.

To register a shutdown hook, call the `registerShutdownHook()` method that is
declared on the `ConfigurableApplicationContext` interface, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.springframework.context.ConfigurableApplicationContext;
	import org.springframework.context.support.ClassPathXmlApplicationContext;

	public final class Boot {

		public static void main(final String[] args) throws Exception {
			ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");

			// add a shutdown hook for the above context...
			ctx.registerShutdownHook();

			// app runs here...

			// main method exits, hook is called prior to the app shutting down...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.context.support.ClassPathXmlApplicationContext

	fun main() {
		val ctx = ClassPathXmlApplicationContext("beans.xml")

		// add a shutdown hook for the above context...
		ctx.registerShutdownHook()

		// app runs here...

		// main method exits, hook is called prior to the app shutting down...
	}
----



[[beans-factory-aware]]
=== `ApplicationContextAware` and `BeanNameAware`

When an `ApplicationContext` creates an object instance that implements the
`org.springframework.context.ApplicationContextAware` interface, the instance is provided
with a reference to that `ApplicationContext`. The following listing shows the definition
of the `ApplicationContextAware` interface:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public interface ApplicationContextAware {

		void setApplicationContext(ApplicationContext applicationContext) throws BeansException;
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	interface ApplicationContextAware {

		@Throws(BeansException::class)
		fun setApplicationContext(applicationContext: ApplicationContext)
	}
----

Thus, beans can programmatically manipulate the `ApplicationContext` that created them,
through the `ApplicationContext` interface or by casting the reference to a known
subclass of this interface (such as `ConfigurableApplicationContext`, which exposes
additional functionality). One use would be the programmatic retrieval of other beans.
Sometimes this capability is useful. However, in general, you should avoid it, because
it couples the code to Spring and does not follow the Inversion of Control style,
where collaborators are provided to beans as properties. Other methods of the
`ApplicationContext` provide access to file resources, publishing application events,
and accessing a `MessageSource`. These additional features are described in
<<context-introduction>>.

Autowiring is another alternative to obtain a reference to the
`ApplicationContext`. The _traditional_ `constructor` and `byType` autowiring modes
(as described in <<beans-factory-autowire>>) can provide a dependency of type
`ApplicationContext` for a constructor argument or a setter method parameter,
respectively. For more flexibility, including the ability to autowire fields and
multiple parameter methods, use the annotation-based autowiring features. If you do,
the `ApplicationContext` is autowired into a field, constructor argument, or method
parameter that expects the `ApplicationContext` type if the field, constructor, or
method in question carries the `@Autowired` annotation. For more information, see
<<beans-autowired-annotation>>.

When an `ApplicationContext` creates a class that implements the
`org.springframework.beans.factory.BeanNameAware` interface, the class is provided with
a reference to the name defined in its associated object definition. The following listing
shows the definition of the BeanNameAware interface:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public interface BeanNameAware {

		void setBeanName(String name) throws BeansException;
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	interface BeanNameAware {

		@Throws(BeansException::class)
		fun setBeanName(name: String)
	}
----

The callback is invoked after population of normal bean properties but before an
initialization callback such as `InitializingBean`, `afterPropertiesSet`, or a custom
init-method.



[[aware-list]]
=== Other `Aware` Interfaces

Besides `ApplicationContextAware` and `BeanNameAware` (discussed <<beans-factory-aware, earlier>>),
Spring offers a wide range of `Aware` callback interfaces that let beans indicate to the container
that they require a certain infrastructure dependency. As a general rule, the name indicates the
dependency type. The following table summarizes the most important `Aware` interfaces:

[[beans-factory-nature-aware-list]]
.Aware interfaces
|===
| Name| Injected Dependency| Explained in...

| `ApplicationContextAware`
| Declaring `ApplicationContext`.
| <<beans-factory-aware>>

| `ApplicationEventPublisherAware`
| Event publisher of the enclosing `ApplicationContext`.
| <<context-introduction>>

| `BeanClassLoaderAware`
| Class loader used to load the bean classes.
| <<beans-factory-class>>

| `BeanFactoryAware`
| Declaring `BeanFactory`.
| <<beans-factory-aware>>

| `BeanNameAware`
| Name of the declaring bean.
| <<beans-factory-aware>>

| `BootstrapContextAware`
| Resource adapter `BootstrapContext` the container runs in. Typically available only in
  JCA-aware `ApplicationContext` instances.
| <<integration.adoc#cci, JCA CCI>>

| `LoadTimeWeaverAware`
| Defined weaver for processing class definition at load time.
| <<aop-aj-ltw>>

| `MessageSourceAware`
| Configured strategy for resolving messages (with support for parametrization and
  internationalization).
| <<context-introduction>>

| `NotificationPublisherAware`
| Spring JMX notification publisher.
| <<integration.adoc#jmx-notifications, Notifications>>

| `ResourceLoaderAware`
| Configured loader for low-level access to resources.
| <<resources>>

| `ServletConfigAware`
| Current `ServletConfig` the container runs in. Valid only in a web-aware Spring
  `ApplicationContext`.
| <<web.adoc#mvc, Spring MVC>>

| `ServletContextAware`
| Current `ServletContext` the container runs in. Valid only in a web-aware Spring
  `ApplicationContext`.
| <<web.adoc#mvc, Spring MVC>>
|===

Note again that using these interfaces ties your code to the Spring API and does not
follow the Inversion of Control style. As a result, we recommend them for infrastructure
beans that require programmatic access to the container.



[[beans-child-bean-definitions]]
== Bean Definition Inheritance

A bean definition can contain a lot of configuration information, including constructor
arguments, property values, and container-specific information, such as the initialization
method, a static factory method name, and so on. A child bean definition inherits
configuration data from a parent definition. The child definition can override some
values or add others as needed. Using parent and child bean definitions can save a lot
of typing. Effectively, this is a form of templating.

If you work with an `ApplicationContext` interface programmatically, child bean
definitions are represented by the `ChildBeanDefinition` class. Most users do not work
with them on this level. Instead, they configure bean definitions declaratively in a class
such as the `ClassPathXmlApplicationContext`. When you use XML-based configuration
metadata, you can indicate a child bean definition by using the `parent` attribute,
specifying the parent bean as the value of this attribute. The following example shows how
to do so:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="inheritedTestBean" abstract="true"
			class="org.springframework.beans.TestBean">
		<property name="name" value="parent"/>
		<property name="age" value="1"/>
	</bean>

	<bean id="inheritsWithDifferentClass"
			class="org.springframework.beans.DerivedTestBean"
			parent="inheritedTestBean" init-method="initialize">  <1>
		<property name="name" value="override"/>
		<!-- the age property value of 1 will be inherited from parent -->
	</bean>
----
<1> Note the `parent` attribute.

A child bean definition uses the bean class from the parent definition if none is
specified but can also override it. In the latter case, the child bean class must be
compatible with the parent (that is, it must accept the parent's property values).

A child bean definition inherits scope, constructor argument values, property values, and
method overrides from the parent, with the option to add new values. Any scope, initialization
method, destroy method, or `static` factory method settings that you specify
override the corresponding parent settings.

The remaining settings are always taken from the child definition: depends on,
autowire mode, dependency check, singleton, and lazy init.

The preceding example explicitly marks the parent bean definition as abstract by using
the `abstract` attribute. If the parent definition does not specify a class, explicitly
marking the parent bean definition as `abstract` is required, as the following example
shows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="inheritedTestBeanWithoutClass" abstract="true">
		<property name="name" value="parent"/>
		<property name="age" value="1"/>
	</bean>

	<bean id="inheritsWithClass" class="org.springframework.beans.DerivedTestBean"
			parent="inheritedTestBeanWithoutClass" init-method="initialize">
		<property name="name" value="override"/>
		<!-- age will inherit the value of 1 from the parent bean definition-->
	</bean>
----

The parent bean cannot be instantiated on its own because it is incomplete, and it is
also explicitly marked as `abstract`. When a definition is `abstract`, it is
usable only as a pure template bean definition that serves as a parent definition for
child definitions. Trying to use such an `abstract` parent bean on its own, by referring
to it as a ref property of another bean or doing an explicit `getBean()` call with the
parent bean ID returns an error. Similarly, the container's internal
`preInstantiateSingletons()` method ignores bean definitions that are defined as
abstract.

NOTE: `ApplicationContext` pre-instantiates all singletons by default. Therefore, it is
important (at least for singleton beans) that if you have a (parent) bean definition
which you intend to use only as a template, and this definition specifies a class, you
must make sure to set the __abstract__ attribute to __true__, otherwise the application
context will actually (attempt to) pre-instantiate the `abstract` bean.




[[beans-factory-extension]]
== Container Extension Points

Typically, an application developer does not need to subclass `ApplicationContext`
implementation classes. Instead, the Spring IoC container can be extended by plugging in
implementations of special integration interfaces. The next few sections describe these
integration interfaces.



[[beans-factory-extension-bpp]]
=== Customizing Beans by Using a `BeanPostProcessor`

The `BeanPostProcessor` interface defines callback methods that you can implement to
provide your own (or override the container's default) instantiation logic, dependency
resolution logic, and so forth. If you want to implement some custom logic after the
Spring container finishes instantiating, configuring, and initializing a bean, you can
plug in one or more custom `BeanPostProcessor` implementations.

You can configure multiple `BeanPostProcessor` instances, and you can control the order
in which these `BeanPostProcessor` instances execute by setting the `order` property.
You can set this property only if the `BeanPostProcessor` implements the `Ordered`
interface. If you write your own `BeanPostProcessor`, you should consider implementing
the `Ordered` interface, too. For further details, see the javadoc of the
{api-spring-framework}/beans/factory/config/BeanPostProcessor.html[`BeanPostProcessor`]
and {api-spring-framework}/core/Ordered.html[`Ordered`] interfaces. See also the note
on <<beans-factory-programmatically-registering-beanpostprocessors, programmatic
registration of `BeanPostProcessor` instances>>.

[NOTE]
====
`BeanPostProcessor` instances operate on bean (or object) instances. That is,
the Spring IoC container instantiates a bean instance and then `BeanPostProcessor`
instances do their work.

`BeanPostProcessor` instances are scoped per-container. This is relevant only if you
use container hierarchies. If you define a `BeanPostProcessor` in one container,
it post-processes only the beans in that container. In other words, beans that are
defined in one container are not post-processed by a `BeanPostProcessor` defined in
another container, even if both containers are part of the same hierarchy.

To change the actual bean definition (that is, the blueprint that defines the bean),
you instead need to use a `BeanFactoryPostProcessor`, as described in
<<beans-factory-extension-factory-postprocessors>>.
====

The `org.springframework.beans.factory.config.BeanPostProcessor` interface consists of
exactly two callback methods. When such a class is registered as a post-processor with
the container, for each bean instance that is created by the container, the
post-processor gets a callback from the container both before container
initialization methods (such as `InitializingBean.afterPropertiesSet()` or any
declared `init` method) are called, and after any bean initialization callbacks.
The post-processor can take any action with the bean instance, including ignoring the
callback completely. A bean post-processor typically checks for callback interfaces,
or it may wrap a bean with a proxy. Some Spring AOP infrastructure classes are
implemented as bean post-processors in order to provide proxy-wrapping logic.

An `ApplicationContext` automatically detects any beans that are defined in the
configuration metadata that implements the `BeanPostProcessor` interface. The
`ApplicationContext` registers these beans as post-processors so that they can be called
later, upon bean creation. Bean post-processors can be deployed in the container in the
same fashion as any other beans.

Note that, when declaring a `BeanPostProcessor` by using an `@Bean` factory method on a
configuration class, the return type of the factory method should be the implementation
class itself or at least the `org.springframework.beans.factory.config.BeanPostProcessor`
interface, clearly indicating the post-processor nature of that bean. Otherwise, the
`ApplicationContext` cannot autodetect it by type before fully creating it.
Since a `BeanPostProcessor` needs to be instantiated early in order to apply to the
initialization of other beans in the context, this early type detection is critical.

[[beans-factory-programmatically-registering-beanpostprocessors]]
.Programmatically registering `BeanPostProcessor` instances
NOTE: While the recommended approach for `BeanPostProcessor` registration is through
`ApplicationContext` auto-detection (as described earlier), you can register them
programmatically against a `ConfigurableBeanFactory` by using the `addBeanPostProcessor`
method. This can be useful when you need to evaluate conditional logic before
registration or even for copying bean post processors across contexts in a hierarchy.
Note, however, that `BeanPostProcessor` instances added programmatically do not respect
the `Ordered` interface. Here, it is the order of registration that dictates the order
of execution. Note also that `BeanPostProcessor` instances registered programmatically
are always processed before those registered through auto-detection, regardless of any
explicit ordering.

.`BeanPostProcessor` instances and AOP auto-proxying
[NOTE]
====
Classes that implement the `BeanPostProcessor` interface are special and are treated
differently by the container. All `BeanPostProcessor` instances and beans that they
directly reference are instantiated on startup, as part of the special startup phase
of the `ApplicationContext`. Next, all `BeanPostProcessor` instances are registered
in a sorted fashion and applied to all further beans in the container. Because AOP
auto-proxying is implemented as a `BeanPostProcessor` itself, neither `BeanPostProcessor`
instances nor the beans they directly reference are eligible for auto-proxying and,
thus, do not have aspects woven into them.

For any such bean, you should see an informational log message: `Bean someBean is not
eligible for getting processed by all BeanPostProcessor interfaces (for example: not
eligible for auto-proxying)`.

If you have beans wired into your `BeanPostProcessor` by using autowiring or
`@Resource` (which may fall back to autowiring), Spring might access unexpected beans
when searching for type-matching dependency candidates and, therefore, make them
ineligible for auto-proxying or other kinds of bean post-processing. For example, if you
have a dependency annotated with `@Resource` where the field or setter name does not
directly correspond to the declared name of a bean and no name attribute is used,
Spring accesses other beans for matching them by type.
====

The following examples show how to write, register, and use `BeanPostProcessor` instances
in an `ApplicationContext`.


[[beans-factory-extension-bpp-examples-hw]]
==== Example: Hello World, `BeanPostProcessor`-style

This first example illustrates basic usage. The example shows a custom
`BeanPostProcessor` implementation that invokes the `toString()` method of each bean as
it is created by the container and prints the resulting string to the system console.

The following listing shows the custom `BeanPostProcessor` implementation class definition:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package scripting;

	import org.springframework.beans.factory.config.BeanPostProcessor;

	public class InstantiationTracingBeanPostProcessor implements BeanPostProcessor {

		// simply return the instantiated bean as-is
		public Object postProcessBeforeInitialization(Object bean, String beanName) {
			return bean; // we could potentially return any object reference here...
		}

		public Object postProcessAfterInitialization(Object bean, String beanName) {
			System.out.println("Bean '" + beanName + "' created : " + bean.toString());
			return bean;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.beans.factory.config.BeanPostProcessor

	class InstantiationTracingBeanPostProcessor : BeanPostProcessor {

		// simply return the instantiated bean as-is
		override fun postProcessBeforeInitialization(bean: Any, beanName: String): Any? {
			return bean // we could potentially return any object reference here...
		}

		override fun postProcessAfterInitialization(bean: Any, beanName: String): Any? {
			println("Bean '$beanName' created : $bean")
			return bean
		}
	}
----

The following `beans` element uses the `InstantiationTracingBeanPostProcessor`:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:lang="http://www.springframework.org/schema/lang"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/lang
			https://www.springframework.org/schema/lang/spring-lang.xsd">

		<lang:groovy id="messenger"
				script-source="classpath:org/springframework/scripting/groovy/Messenger.groovy">
			<lang:property name="message" value="Fiona Apple Is Just So Dreamy."/>
		</lang:groovy>

		<!--
		when the above bean (messenger) is instantiated, this custom
		BeanPostProcessor implementation will output the fact to the system console
		-->
		<bean class="scripting.InstantiationTracingBeanPostProcessor"/>

	</beans>
----

Notice how the `InstantiationTracingBeanPostProcessor` is merely defined. It does not
even have a name, and, because it is a bean, it can be dependency-injected as you would any
other bean. (The preceding configuration also defines a bean that is backed by a Groovy
script. The Spring dynamic language support is detailed in the chapter entitled
<<languages.adoc#dynamic-language, Dynamic Language Support>>.)

The following Java application runs the preceding code and configuration:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.springframework.context.ApplicationContext;
	import org.springframework.context.support.ClassPathXmlApplicationContext;
	import org.springframework.scripting.Messenger;

	public final class Boot {

		public static void main(final String[] args) throws Exception {
			ApplicationContext ctx = new ClassPathXmlApplicationContext("scripting/beans.xml");
			Messenger messenger = ctx.getBean("messenger", Messenger.class);
			System.out.println(messenger);
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
    import org.springframework.beans.factory.getBean

	fun main() {
		val ctx = ClassPathXmlApplicationContext("scripting/beans.xml")
		val messenger = ctx.getBean<Messenger>("messenger")
		println(messenger)
	}
----

The output of the preceding application resembles the following:

[literal,subs="verbatim,quotes"]
----
Bean 'messenger' created : org.springframework.scripting.groovy.GroovyMessenger@272961
org.springframework.scripting.groovy.GroovyMessenger@272961
----


[[beans-factory-extension-bpp-examples-rabpp]]
==== Example: The `RequiredAnnotationBeanPostProcessor`

Using callback interfaces or annotations in conjunction with a custom
`BeanPostProcessor` implementation is a common means of extending the Spring IoC
container. An example is Spring's `RequiredAnnotationBeanPostProcessor` -- a
`BeanPostProcessor` implementation that ships with the Spring distribution and that ensures
that JavaBean properties on beans that are marked with an (arbitrary) annotation are
actually (configured to be) dependency-injected with a value.



[[beans-factory-extension-factory-postprocessors]]
=== Customizing Configuration Metadata with a `BeanFactoryPostProcessor`

The next extension point that we look at is the
`org.springframework.beans.factory.config.BeanFactoryPostProcessor`. The semantics of
this interface are similar to those of the `BeanPostProcessor`, with one major
difference: `BeanFactoryPostProcessor` operates on the bean configuration metadata.
That is, the Spring IoC container lets a `BeanFactoryPostProcessor` read the
configuration metadata and potentially change it _before_ the container instantiates
any beans other than `BeanFactoryPostProcessor` instances.

You can configure multiple `BeanFactoryPostProcessor` instances, and you can control the order in
which these `BeanFactoryPostProcessor` instances run by setting the `order` property.
However, you can only set this property if the `BeanFactoryPostProcessor` implements the
`Ordered` interface. If you write your own `BeanFactoryPostProcessor`, you should
consider implementing the `Ordered` interface, too. See the javadoc of the
{api-spring-framework}/beans/factory/config/BeanFactoryPostProcessor.html[`BeanFactoryPostProcessor`] and {api-spring-framework}/core/Ordered.html[`Ordered`] interfaces for more details.

[NOTE]
====
If you want to change the actual bean instances (that is, the objects that are created
from the configuration metadata), then you instead need to use a `BeanPostProcessor`
(described earlier in <<beans-factory-extension-bpp>>). While it is technically possible
to work with bean instances within a `BeanFactoryPostProcessor` (for example, by using
`BeanFactory.getBean()`), doing so causes premature bean instantiation, violating the
standard container lifecycle. This may cause negative side effects, such as bypassing
bean post processing.

Also, `BeanFactoryPostProcessor` instances are scoped per-container. This is only relevant
if you use container hierarchies. If you define a `BeanFactoryPostProcessor` in one
container, it is applied only to the bean definitions in that container. Bean definitions
in one container are not post-processed by `BeanFactoryPostProcessor` instances in another
container, even if both containers are part of the same hierarchy.
====

A bean factory post-processor is automatically executed when it is declared inside an
`ApplicationContext`, in order to apply changes to the configuration metadata that
define the container. Spring includes a number of predefined bean factory
post-processors, such as `PropertyOverrideConfigurer` and
`PropertySourcesPlaceholderConfigurer`. You can also use a custom `BeanFactoryPostProcessor`
-- for example, to register custom property editors.

An `ApplicationContext` automatically detects any beans that are deployed into it that
implement the `BeanFactoryPostProcessor` interface. It uses these beans as bean factory
post-processors, at the appropriate time. You can deploy these post-processor beans as
you would any other bean.

NOTE: As with ``BeanPostProcessor``s , you typically do not want to configure
``BeanFactoryPostProcessor``s for lazy initialization. If no other bean references a
`Bean(Factory)PostProcessor`, that post-processor will not get instantiated at all.
Thus, marking it for lazy initialization will be ignored, and the
`Bean(Factory)PostProcessor` will be instantiated eagerly even if you set the
`default-lazy-init` attribute to `true` on the declaration of your `<beans />` element.


[[beans-factory-placeholderconfigurer]]
==== Example: The Class Name Substitution `PropertySourcesPlaceholderConfigurer`

You can use the `PropertySourcesPlaceholderConfigurer` to externalize property values
from a bean definition in a separate file by using the standard Java `Properties` format.
Doing so enables the person deploying an application to customize environment-specific
properties, such as database URLs and passwords, without the complexity or risk of
modifying the main XML definition file or files for the container.

Consider the following XML-based configuration metadata fragment, where a `DataSource`
with placeholder values is defined:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer">
		<property name="locations" value="classpath:com/something/jdbc.properties"/>
	</bean>

	<bean id="dataSource" destroy-method="close"
			class="org.apache.commons.dbcp.BasicDataSource">
		<property name="driverClassName" value="${jdbc.driverClassName}"/>
		<property name="url" value="${jdbc.url}"/>
		<property name="username" value="${jdbc.username}"/>
		<property name="password" value="${jdbc.password}"/>
	</bean>
----

The example shows properties configured from an external `Properties` file. At runtime,
a `PropertySourcesPlaceholderConfigurer` is applied to the metadata that replaces some
properties of the DataSource. The values to replace are specified as placeholders of the
form `${property-name}`, which follows the Ant and log4j and JSP EL style.

The actual values come from another file in the standard Java `Properties` format:

[literal,subs="verbatim,quotes"]
----
jdbc.driverClassName=org.hsqldb.jdbcDriver
jdbc.url=jdbc:hsqldb:hsql://production:9002
jdbc.username=sa
jdbc.password=root
----

Therefore, the `${jdbc.username}` string is replaced at runtime with the value, 'sa', and
the same applies for other placeholder values that match keys in the properties file.
The `PropertySourcesPlaceholderConfigurer` checks for placeholders in most properties and
attributes of a bean definition. Furthermore, you can customize the placeholder prefix and suffix.

With the `context` namespace introduced in Spring 2.5, you can configure property placeholders
with a dedicated configuration element. You can provide one or more locations as a
comma-separated list in the `location` attribute, as the following example shows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<context:property-placeholder location="classpath:com/something/jdbc.properties"/>
----

The `PropertySourcesPlaceholderConfigurer` not only looks for properties in the `Properties`
file you specify. By default, if it cannot find a property in the specified properties files,
it checks against Spring `Environment` properties and regular Java `System` properties.

[TIP]
=====
You can use the `PropertySourcesPlaceholderConfigurer` to substitute class names, which
is sometimes useful when you have to pick a particular implementation class at runtime.
The following example shows how to do so:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean class="org.springframework.beans.factory.config.PropertySourcesPlaceholderConfigurer">
		<property name="locations">
			<value>classpath:com/something/strategy.properties</value>
		</property>
		<property name="properties">
			<value>custom.strategy.class=com.something.DefaultStrategy</value>
		</property>
	</bean>

	<bean id="serviceStrategy" class="${custom.strategy.class}"/>
----

If the class cannot be resolved at runtime to a valid class, resolution of the bean
fails when it is about to be created, which is during the `preInstantiateSingletons()`
phase of an `ApplicationContext` for a non-lazy-init bean.
=====


[[beans-factory-overrideconfigurer]]
==== Example: The `PropertyOverrideConfigurer`

The `PropertyOverrideConfigurer`, another bean factory post-processor, resembles the
`PropertySourcesPlaceholderConfigurer`, but unlike the latter, the original definitions
can have default values or no values at all for bean properties. If an overriding
`Properties` file does not have an entry for a certain bean property, the default
context definition is used.

Note that the bean definition is not aware of being overridden, so it is not
immediately obvious from the XML definition file that the override configurer is being
used. In case of multiple `PropertyOverrideConfigurer` instances that define different
values for the same bean property, the last one wins, due to the overriding mechanism.

Properties file configuration lines take the following format:

[literal,subs="verbatim,quotes"]
----
beanName.property=value
----

The following listing shows an example of the format:

[literal,subs="verbatim,quotes"]
----
dataSource.driverClassName=com.mysql.jdbc.Driver
dataSource.url=jdbc:mysql:mydb
----

This example file can be used with a container definition that contains a bean called
`dataSource` that has `driver` and `url` properties.

Compound property names are also supported, as long as every component of the path
except the final property being overridden is already non-null (presumably initialized
by the constructors). In the following example, the `sammy` property of the `bob` property of the `fred` property of the `tom` bean
is set to the scalar value `123`:

[literal,subs="verbatim,quotes"]
----
tom.fred.bob.sammy=123
----


NOTE: Specified override values are always literal values. They are not translated into
bean references. This convention also applies when the original value in the XML bean
definition specifies a bean reference.

With the `context` namespace introduced in Spring 2.5, it is possible to configure
property overriding with a dedicated configuration element, as the following example shows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<context:property-override location="classpath:override.properties"/>
----



[[beans-factory-extension-factorybean]]
=== Customizing Instantiation Logic with a `FactoryBean`

You can implement the `org.springframework.beans.factory.FactoryBean` interface for objects that
are themselves factories.

The `FactoryBean` interface is a point of pluggability into the Spring IoC container's
instantiation logic. If you have complex initialization code that is better expressed in
Java as opposed to a (potentially) verbose amount of XML, you can create your own
`FactoryBean`, write the complex initialization inside that class, and then plug your
custom `FactoryBean` into the container.

The `FactoryBean` interface provides three methods:

* `Object getObject()`: Returns an instance of the object this factory creates. The
  instance can possibly be shared, depending on whether this factory returns singletons
  or prototypes.
* `boolean isSingleton()`: Returns `true` if this `FactoryBean` returns singletons or
  `false` otherwise.
* `Class getObjectType()`: Returns the object type returned by the `getObject()` method
  or `null` if the type is not known in advance.

The `FactoryBean` concept and interface is used in a number of places within the Spring
Framework. More than 50 implementations of the `FactoryBean` interface ship with Spring
itself.

When you need to ask a container for an actual `FactoryBean` instance itself instead of
the bean it produces, preface the bean's `id` with the ampersand symbol (`&`) when
calling the `getBean()` method of the `ApplicationContext`. So, for a given `FactoryBean`
with an `id` of `myBean`, invoking `getBean("myBean")` on the container returns the
product of the `FactoryBean`, whereas invoking `getBean("&myBean")` returns the
`FactoryBean` instance itself.



[[beans-annotation-config]]
== Annotation-based Container Configuration

.Are annotations better than XML for configuring Spring?
****
The introduction of annotation-based configuration raised the question of whether this
approach is "`better`" than XML. The short answer is "`it depends.`" The long answer is
that each approach has its pros and cons, and, usually, it is up to the developer to
decide which strategy suits them better. Due to the way they are defined, annotations
provide a lot of context in their declaration, leading to shorter and more concise
configuration. However, XML excels at wiring up components without touching their source
code or recompiling them. Some developers prefer having the wiring close to the source
while others argue that annotated classes are no longer POJOs and, furthermore, that the
configuration becomes decentralized and harder to control.

No matter the choice, Spring can accommodate both styles and even mix them together.
It is worth pointing out that through its <<beans-java, JavaConfig>> option, Spring lets
annotations be used in a non-invasive way, without touching the target components
source code and that, in terms of tooling, all configuration styles are supported by the
https://spring.io/tools/sts[Spring Tool Suite].
****

An alternative to XML setup is provided by annotation-based configuration, which relies on
the bytecode metadata for wiring up components instead of angle-bracket declarations.
Instead of using XML to describe a bean wiring, the developer moves the configuration
into the component class itself by using annotations on the relevant class, method, or
field declaration. As mentioned in <<beans-factory-extension-bpp-examples-rabpp>>, using
a `BeanPostProcessor` in conjunction with annotations is a common means of extending the
Spring IoC container. For example, Spring 2.0 introduced the possibility of enforcing
required properties with the <<beans-required-annotation,`@Required`>> annotation. Spring
2.5 made it possible to follow that same general approach to drive Spring's dependency
injection. Essentially, the `@Autowired` annotation provides the same capabilities as
described in <<beans-factory-autowire>> but with more fine-grained control and wider
applicability. Spring 2.5 also added support for JSR-250 annotations, such as
`@PostConstruct` and `@PreDestroy`. Spring 3.0 added support for JSR-330 (Dependency
Injection for Java) annotations contained in the `javax.inject` package such as `@Inject`
and `@Named`. Details about those annotations can be found in the
<<beans-standard-annotations,relevant section>>.

[NOTE]
====
Annotation injection is performed before XML injection. Thus, the XML configuration
overrides the annotations for properties wired through both approaches.
====

As always, you can register them as individual bean definitions, but they can also be
implicitly registered by including the following tag in an XML-based Spring
configuration (notice the inclusion of the `context` namespace):

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">

		<context:annotation-config/>

	</beans>
----

(The implicitly registered post-processors include
{api-spring-framework}/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html[`AutowiredAnnotationBeanPostProcessor`],
{api-spring-framework}/context/annotation/CommonAnnotationBeanPostProcessor.html[`CommonAnnotationBeanPostProcessor`],
{api-spring-framework}/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html[`PersistenceAnnotationBeanPostProcessor`],
and the aforementioned
{api-spring-framework}/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.html[`RequiredAnnotationBeanPostProcessor`].)

[NOTE]
====
`<context:annotation-config/>` only looks for annotations on beans in the same
application context in which it is defined. This means that, if you put
`<context:annotation-config/>` in a `WebApplicationContext` for a `DispatcherServlet`,
it only checks for `@Autowired` beans in your controllers, and not your services. See
<<web.adoc#mvc-servlet, The DispatcherServlet>> for more information.
====



[[beans-required-annotation]]
=== @Required

The `@Required` annotation applies to bean property setter methods, as in the following
example:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SimpleMovieLister {

		private MovieFinder movieFinder;

		@Required
		public void setMovieFinder(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class SimpleMovieLister {

	@Required
	lateinit var movieFinder: MovieFinder

	// ...
}
----


This annotation indicates that the affected bean property must be populated at
configuration time, through an explicit property value in a bean definition or through
autowiring. The container throws an exception if the affected bean property has not been
populated. This allows for eager and explicit failure, avoiding `NullPointerException`
instances or the like later on. We still recommend that you put assertions into the
bean class itself (for example, into an init method). Doing so enforces those required
references and values even when you use the class outside of a container.

[NOTE]
====
The `@Required` annotation is formally deprecated as of Spring Framework 5.1, in favor
of using constructor injection for required settings (or a custom implementation of
`InitializingBean.afterPropertiesSet()` along with bean property setter methods).
====



[[beans-autowired-annotation]]
=== Using `@Autowired`

[NOTE]
====
JSR 330's `@Inject` annotation can be used in place of Spring's `@Autowired` annotation in the
examples included in this section. See <<beans-standard-annotations,here>> for more details.
====

You can apply the `@Autowired` annotation to constructors, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MovieRecommender {

		private final CustomerPreferenceDao customerPreferenceDao;

		@Autowired
		public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
			this.customerPreferenceDao = customerPreferenceDao;
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MovieRecommender @Autowired constructor(
		private val customerPreferenceDao: CustomerPreferenceDao)
----

[NOTE]
====
As of Spring Framework 4.3, an `@Autowired` annotation on such a constructor is
no longer necessary if the target bean defines only one constructor to begin with.
However, if several constructors are available, at least one must be annotated 
with `@Autowired` in order to instruct the container which one to use.
====

You can also apply the `@Autowired` annotation to _traditional_ setter methods,
as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SimpleMovieLister {

		private MovieFinder movieFinder;

		@Autowired
		public void setMovieFinder(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class SimpleMovieLister {

		@Autowired
		lateinit var movieFinder: MovieFinder

		// ...

	}
----

You can also apply the annotation to methods with arbitrary names and multiple
arguments, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MovieRecommender {

		private MovieCatalog movieCatalog;

		private CustomerPreferenceDao customerPreferenceDao;

		@Autowired
		public void prepare(MovieCatalog movieCatalog,
				CustomerPreferenceDao customerPreferenceDao) {
			this.movieCatalog = movieCatalog;
			this.customerPreferenceDao = customerPreferenceDao;
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MovieRecommender {

		private lateinit var movieCatalog: MovieCatalog

		private lateinit var customerPreferenceDao: CustomerPreferenceDao

		@Autowired
		fun prepare(movieCatalog: MovieCatalog,
					customerPreferenceDao: CustomerPreferenceDao) {
			this.movieCatalog = movieCatalog
			this.customerPreferenceDao = customerPreferenceDao
		}

		// ...
	}
----

You can apply `@Autowired` to fields as well and even mix it with constructors, as the
following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MovieRecommender {

		private final CustomerPreferenceDao customerPreferenceDao;

		@Autowired
		private MovieCatalog movieCatalog;

		@Autowired
		public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
			this.customerPreferenceDao = customerPreferenceDao;
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MovieRecommender @Autowired constructor(
		private val customerPreferenceDao: CustomerPreferenceDao) {

		@Autowired
		private lateinit var movieCatalog: MovieCatalog

		// ...
	}
----

[TIP]
====
Make sure that your target components (for example, `MovieCatalog` or `CustomerPreferenceDao`)
are consistently declared by the type that you use for your `@Autowired`-annotated
injection points. Otherwise, injection may fail due to a "no type match found" error at runtime.

For XML-defined beans or component classes found via classpath scanning, the container
usually knows the concrete type up front. However, for `@Bean` factory methods, you need
to make sure that the declared return type is sufficiently expressive. For components
that implement several interfaces or for components potentially referred to by their
implementation type, consider declaring the most specific return type on your factory
method (at least as specific as required by the injection points referring to your bean).
====

You can also instruct Spring to provide all beans of a particular type from the
`ApplicationContext` by adding the `@Autowired` annotation to a field or method that
expects an array of that type, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MovieRecommender {

		@Autowired
		private MovieCatalog[] movieCatalogs;

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MovieRecommender {

		@Autowired
		private lateinit var movieCatalogs: Array<MovieCatalog>

		// ...
	}
----

The same applies for typed collections, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MovieRecommender {

		private Set<MovieCatalog> movieCatalogs;

		@Autowired
		public void setMovieCatalogs(Set<MovieCatalog> movieCatalogs) {
			this.movieCatalogs = movieCatalogs;
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MovieRecommender {

		@Autowired
		lateinit var movieCatalogs: Set<MovieCatalog>
		
		// ...
	}
----

[TIP]
====
Your target beans can implement the `org.springframework.core.Ordered` interface or use
the `@Order` or standard `@Priority` annotation if you want items in the array or list
to be sorted in a specific order. Otherwise, their order follows the registration
order of the corresponding target bean definitions in the container.

You can declare the `@Order` annotation at the target class level and on `@Bean` methods,
potentially for individual bean definitions (in case of multiple definitions that
use the same bean class). `@Order` values may influence priorities at injection points,
but be aware that they do not influence singleton startup order, which is an
orthogonal concern determined by dependency relationships and `@DependsOn` declarations.

Note that the standard `javax.annotation.Priority` annotation is not available at the
`@Bean` level, since it cannot be declared on methods. Its semantics can be modeled
through `@Order` values in combination with `@Primary` on a single bean for each type.
====

Even typed `Map` instances can be autowired as long as the expected key type is `String`.
The map values contain all beans of the expected type, and the keys contain the
corresponding bean names, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MovieRecommender {

		private Map<String, MovieCatalog> movieCatalogs;

		@Autowired
		public void setMovieCatalogs(Map<String, MovieCatalog> movieCatalogs) {
			this.movieCatalogs = movieCatalogs;
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MovieRecommender {

		@Autowired
		lateinit var movieCatalogs: Map<String, MovieCatalog>
		
		// ...
	}
----

By default, autowiring fails when no matching candidate beans are available for a given
injection point. In the case of a declared array, collection, or map, at least one
matching element is expected.

The default behavior is to treat annotated methods and fields as indicating required
dependencies. You can change this behavior as demonstrated in the following example,
enabling the framework to skip a non-satisfiable injection point through marking it as
non-required (i.e., by setting the `required` attribute in `@Autowired` to `false`):

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SimpleMovieLister {

		private MovieFinder movieFinder;

		@Autowired(required = false)
		public void setMovieFinder(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class SimpleMovieLister {

		@Autowired(required = false)
		var movieFinder: MovieFinder? = null

		// ...
	}
----

A non-required method will not be called at all if its dependency (or one of its
dependencies, in case of multiple arguments) is not available. A non-required field will
not get populated at all in such case, leaving its default value in place.

Injected constructor and factory method arguments are a special case since the `required`
attribute in `@Autowired` has a somewhat different meaning due to Spring's constructor
resolution algorithm that may potentially deal with multiple constructors. Constructor
and factory method arguments are effectively required by default but with a few special
rules in a single-constructor scenario, such as multi-element injection points (arrays,
collections, maps) resolving to empty instances if no matching beans are available. This
allows for a common implementation pattern where all dependencies can be declared in a
unique multi-argument constructor — for example, declared as a single public constructor
without an `@Autowired` annotation.

[NOTE]
====
Only one constructor of any given bean class may declare `@Autowired` with the `required`
attribute set to `true`, indicating _the_ constructor to autowire when used as a Spring
bean. Furthermore, if the `required` attribute is set to `true`, only a single
constructor may be annotated with `@Autowired`. If multiple _non-required_ constructors
declare the annotation, they will be considered as candidates for autowiring. The
constructor with the greatest number of dependencies that can be satisfied by matching
beans in the Spring container will be chosen. If none of the candidates can be satisfied,
then a primary/default constructor (if present) will be used. If a class only declares a
single constructor to begin with, it will always be used, even if not annotated. An
annotated constructor does not have to be public.

The `required` attribute of `@Autowired` is recommended over the deprecated `@Required`
annotation on setter methods. Setting the `required` attribute to `false` indicates that
the property is not required for autowiring purposes, and the property is ignored if it
cannot be autowired. `@Required`, on the other hand, is stronger in that it enforces the
property to be set by any means supported by the container, and if no value is defined, a
corresponding exception is raised.
====

Alternatively, you can express the non-required nature of a particular dependency
through Java 8's `java.util.Optional`, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes"]
----
	public class SimpleMovieLister {

		@Autowired
		public void setMovieFinder(Optional<MovieFinder> movieFinder) {
			...
		}
	}
----

As of Spring Framework 5.0, you can also use a `@Nullable` annotation (of any kind
in any package -- for example, `javax.annotation.Nullable` from JSR-305) or just leverage
Kotlin builtin null-safety support:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SimpleMovieLister {

		@Autowired
		public void setMovieFinder(@Nullable MovieFinder movieFinder) {
			...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class SimpleMovieLister {

		@Autowired
		var movieFinder: MovieFinder? = null

		// ...
	}
----

You can also use `@Autowired` for interfaces that are well-known resolvable
dependencies: `BeanFactory`, `ApplicationContext`, `Environment`, `ResourceLoader`,
`ApplicationEventPublisher`, and `MessageSource`. These interfaces and their extended
interfaces, such as `ConfigurableApplicationContext` or `ResourcePatternResolver`, are
automatically resolved, with no special setup necessary. The following example autowires
an `ApplicationContext` object:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MovieRecommender {

		@Autowired
		private ApplicationContext context;

		public MovieRecommender() {
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
class MovieRecommender {

	@Autowired
	lateinit var context: ApplicationContext

	// ...
}
----

[NOTE]
====
The `@Autowired`, `@Inject`, `@Value`, and `@Resource` annotations are handled by Spring
`BeanPostProcessor` implementations. This means that you cannot apply these annotations
within your own `BeanPostProcessor` or `BeanFactoryPostProcessor` types (if any).
These types must be 'wired up' explicitly by using XML or a Spring `@Bean` method.
====



[[beans-autowired-annotation-primary]]
=== Fine-tuning Annotation-based Autowiring with `@Primary`

Because autowiring by type may lead to multiple candidates, it is often necessary to have
more control over the selection process. One way to accomplish this is with Spring's
`@Primary` annotation. `@Primary` indicates that a particular bean should be given
preference when multiple beans are candidates to be autowired to a single-valued
dependency. If exactly one primary bean exists among the candidates, it becomes the
autowired value.

Consider the following configuration that defines `firstMovieCatalog` as the
primary `MovieCatalog`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class MovieConfiguration {

		@Bean
		@Primary
		public MovieCatalog firstMovieCatalog() { ... }

		@Bean
		public MovieCatalog secondMovieCatalog() { ... }

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class MovieConfiguration {

		@Bean
		@Primary
		fun firstMovieCatalog(): MovieCatalog { ... }

		@Bean
		fun secondMovieCatalog(): MovieCatalog { ... }

		// ...
	}
----

With the preceding configuration, the following `MovieRecommender` is autowired with the
`firstMovieCatalog`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MovieRecommender {

		@Autowired
		private MovieCatalog movieCatalog;

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
class MovieRecommender {

	@Autowired
	private lateinit var movieCatalog: MovieCatalog

	// ...
}
----

The corresponding bean definitions follow:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">

		<context:annotation-config/>

		<bean class="example.SimpleMovieCatalog" primary="true">
			<!-- inject any dependencies required by this bean -->
		</bean>

		<bean class="example.SimpleMovieCatalog">
			<!-- inject any dependencies required by this bean -->
		</bean>

		<bean id="movieRecommender" class="example.MovieRecommender"/>

	</beans>
----



[[beans-autowired-annotation-qualifiers]]
=== Fine-tuning Annotation-based Autowiring with Qualifiers

`@Primary` is an effective way to use autowiring by type with several instances when one
primary candidate can be determined. When you need more control over the selection process,
you can use Spring's `@Qualifier` annotation. You can associate qualifier values
with specific arguments, narrowing the set of type matches so that a specific bean is
chosen for each argument. In the simplest case, this can be a plain descriptive value, as
shown in the following example:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MovieRecommender {

		@Autowired
		@Qualifier("main")
		private MovieCatalog movieCatalog;

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MovieRecommender {

		@Autowired
		@Qualifier("main")
		private lateinit var movieCatalog: MovieCatalog

		// ...
	}
----

You can also specify the `@Qualifier` annotation on individual constructor arguments or
method parameters, as shown in the following example:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MovieRecommender {

		private MovieCatalog movieCatalog;

		private CustomerPreferenceDao customerPreferenceDao;

		@Autowired
		public void prepare(@Qualifier("main") MovieCatalog movieCatalog,
				CustomerPreferenceDao customerPreferenceDao) {
			this.movieCatalog = movieCatalog;
			this.customerPreferenceDao = customerPreferenceDao;
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MovieRecommender {

		private lateinit var movieCatalog: MovieCatalog

		private lateinit var customerPreferenceDao: CustomerPreferenceDao

		@Autowired
		fun prepare(@Qualifier("main") movieCatalog: MovieCatalog,
					customerPreferenceDao: CustomerPreferenceDao) {
			this.movieCatalog = movieCatalog
			this.customerPreferenceDao = customerPreferenceDao
		}

		// ...
	}
----

The following example shows corresponding bean definitions.

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">

		<context:annotation-config/>

		<bean class="example.SimpleMovieCatalog">
			<qualifier value="main"/> <1>

			<!-- inject any dependencies required by this bean -->
		</bean>

		<bean class="example.SimpleMovieCatalog">
			<qualifier value="action"/> <2>

			<!-- inject any dependencies required by this bean -->
		</bean>

		<bean id="movieRecommender" class="example.MovieRecommender"/>

	</beans>
----
<1> The bean with the `main` qualifier value is wired with the constructor argument that
is qualified with the same value.
<2> The bean with the `action` qualifier value is wired with the constructor argument that
is qualified with the same value.
====

For a fallback match, the bean name is considered a default qualifier value. Thus, you
can define the bean with an `id` of `main` instead of the nested qualifier element, leading
to the same matching result. However, although you can use this convention to refer to
specific beans by name, `@Autowired` is fundamentally about type-driven injection with
optional semantic qualifiers. This means that qualifier values, even with the bean name
fallback, always have narrowing semantics within the set of type matches. They do not
semantically express a reference to a unique bean `id`. Good qualifier values are `main`
or `EMEA` or `persistent`, expressing characteristics of a specific component that are
independent from the bean `id`, which may be auto-generated in case of an anonymous bean
definition such as the one in the preceding example.

Qualifiers also apply to typed collections, as discussed earlier -- for example, to
`Set<MovieCatalog>`. In this case, all matching beans, according to the declared
qualifiers, are injected as a collection. This implies that qualifiers do not have to be
unique. Rather, they constitute filtering criteria. For example, you can define
multiple `MovieCatalog` beans with the same qualifier value "`action`", all of which are
injected into a `Set<MovieCatalog>` annotated with `@Qualifier("action")`.

[TIP]
====
Letting qualifier values select against target bean names, within the type-matching
candidates, does not require a `@Qualifier` annotation at the injection point.
If there is no other resolution indicator (such as a qualifier or a primary marker),
for a non-unique dependency situation, Spring matches the injection point name
(that is, the field name or parameter name) against the target bean names and choose the
same-named candidate, if any.
====

That said, if you intend to express annotation-driven injection by name, do not
primarily use `@Autowired`, even if it is capable of selecting by bean name among
type-matching candidates. Instead, use the JSR-250 `@Resource` annotation, which is
semantically defined to identify a specific target component by its unique name, with
the declared type being irrelevant for the matching process. `@Autowired` has rather
different semantics: After selecting candidate beans by type, the specified `String`
qualifier value is considered within those type-selected candidates only (for example,
matching an `account` qualifier against beans marked with the same qualifier label).

For beans that are themselves defined as a collection, `Map`, or array type, `@Resource`
is a fine solution, referring to the specific collection or array bean by unique name.
That said, as of 4.3, collection, you can match `Map`, and array types through Spring's
`@Autowired` type matching algorithm as well, as long as the element type information
is preserved in `@Bean` return type signatures or collection inheritance hierarchies.
In this case, you can use qualifier values to select among same-typed collections,
as outlined in the previous paragraph.

As of 4.3, `@Autowired` also considers self references for injection (that is, references
back to the bean that is currently injected). Note that self injection is a fallback.
Regular dependencies on other components always have precedence. In that sense, self
references do not participate in regular candidate selection and are therefore in
particular never primary. On the contrary, they always end up as lowest precedence.
In practice, you should use self references as a last resort only (for example, for
calling other methods on the same instance through the bean's transactional proxy).
Consider factoring out the effected methods to a separate delegate bean in such a scenario.
Alternatively, you can use `@Resource`, which may obtain a proxy back to the current bean
by its unique name.

[NOTE]
====
Trying to inject the results from `@Bean` methods on the same configuration class is
effectively a self-reference scenario as well. Either lazily resolve such references
in the method signature where it is actually needed (as opposed to an autowired field
in the configuration class) or declare the affected `@Bean` methods as `static`,
decoupling them from the containing configuration class instance and its lifecycle.
Otherwise, such beans are only considered in the fallback phase, with matching beans
on other configuration classes selected as primary candidates instead (if available).
====

`@Autowired` applies to fields, constructors, and multi-argument methods, allowing for
narrowing through qualifier annotations at the parameter level. In contrast, `@Resource`
is supported only for fields and bean property setter methods with a single argument.
As a consequence, you should stick with qualifiers if your injection target is a
constructor or a multi-argument method.

You can create your own custom qualifier annotations. To do so, define an annotation and
provide the `@Qualifier` annotation within your definition, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Target({ElementType.FIELD, ElementType.PARAMETER})
	@Retention(RetentionPolicy.RUNTIME)
	@Qualifier
	public @interface Genre {

		String value();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Target(AnnotationTarget.FIELD, AnnotationTarget.VALUE_PARAMETER)
	@Retention(AnnotationRetention.RUNTIME)
	@Qualifier
	annotation class Genre(val value: String)
----

Then you can provide the custom qualifier on autowired fields and parameters, as the
following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MovieRecommender {

		@Autowired
		@Genre("Action")
		private MovieCatalog actionCatalog;

		private MovieCatalog comedyCatalog;

		@Autowired
		public void setComedyCatalog(@Genre("Comedy") MovieCatalog comedyCatalog) {
			this.comedyCatalog = comedyCatalog;
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MovieRecommender {

		@Autowired
		@Genre("Action")
		private lateinit var actionCatalog: MovieCatalog

		private lateinit var comedyCatalog: MovieCatalog

		@Autowired
		fun setComedyCatalog(@Genre("Comedy") comedyCatalog: MovieCatalog) {
			this.comedyCatalog = comedyCatalog
		}

		// ...
	}
----

Next, you can provide the information for the candidate bean definitions. You can add
`<qualifier/>` tags as sub-elements of the `<bean/>` tag and then specify the `type` and
`value` to match your custom qualifier annotations. The type is matched against the
fully-qualified class name of the annotation. Alternately, as a convenience if no risk of
conflicting names exists, you can use the short class name. The following example
demonstrates both approaches:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">

		<context:annotation-config/>

		<bean class="example.SimpleMovieCatalog">
			<qualifier type="Genre" value="Action"/>
			<!-- inject any dependencies required by this bean -->
		</bean>

		<bean class="example.SimpleMovieCatalog">
			<qualifier type="example.Genre" value="Comedy"/>
			<!-- inject any dependencies required by this bean -->
		</bean>

		<bean id="movieRecommender" class="example.MovieRecommender"/>

	</beans>
----

In <<beans-classpath-scanning>>, you can see an annotation-based alternative to
providing the qualifier metadata in XML. Specifically, see <<beans-scanning-qualifiers>>.

In some cases, using an annotation without a value may suffice. This can be
useful when the annotation serves a more generic purpose and can be applied across
several different types of dependencies. For example, you may provide an offline
catalog that can be searched when no Internet connection is available. First, define
the simple annotation, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Target({ElementType.FIELD, ElementType.PARAMETER})
	@Retention(RetentionPolicy.RUNTIME)
	@Qualifier
	public @interface Offline {

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Target(AnnotationTarget.FIELD, AnnotationTarget.VALUE_PARAMETER)
	@Retention(AnnotationRetention.RUNTIME)
	@Qualifier
	annotation class Offline
----

Then add the annotation to the field or property to be autowired, as shown in the
following example:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MovieRecommender {

		@Autowired
		@Offline // <1>
		private MovieCatalog offlineCatalog;

		// ...
	}
----
<1> This line adds the `@Offline` annotation.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
class MovieRecommender {

	@Autowired
	@Offline // <1>
	private lateinit var offlineCatalog: MovieCatalog

	// ...
}
----
<1> This line adds the `@Offline` annotation.

Now the bean definition only needs a qualifier `type`, as shown in the following example:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean class="example.SimpleMovieCatalog">
		<qualifier type="Offline"/> <1>
		<!-- inject any dependencies required by this bean -->
	</bean>
----
<1> This element specifies the qualifier.


You can also define custom qualifier annotations that accept named attributes in
addition to or instead of the simple `value` attribute. If multiple attribute values are
then specified on a field or parameter to be autowired, a bean definition must match
all such attribute values to be considered an autowire candidate. As an example,
consider the following annotation definition:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Target({ElementType.FIELD, ElementType.PARAMETER})
	@Retention(RetentionPolicy.RUNTIME)
	@Qualifier
	public @interface MovieQualifier {

		String genre();

		Format format();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Target(AnnotationTarget.FIELD, AnnotationTarget.VALUE_PARAMETER)
	@Retention(AnnotationRetention.RUNTIME)
	@Qualifier
	annotation class MovieQualifier(val genre: String, val format: Format)
----

In this case `Format` is an enum, defined as follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public enum Format {
		VHS, DVD, BLURAY
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	enum class Format {
		VHS, DVD, BLURAY
	}
----

The fields to be autowired are annotated with the custom qualifier and include values
for both attributes: `genre` and `format`, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MovieRecommender {

		@Autowired
		@MovieQualifier(format=Format.VHS, genre="Action")
		private MovieCatalog actionVhsCatalog;

		@Autowired
		@MovieQualifier(format=Format.VHS, genre="Comedy")
		private MovieCatalog comedyVhsCatalog;

		@Autowired
		@MovieQualifier(format=Format.DVD, genre="Action")
		private MovieCatalog actionDvdCatalog;

		@Autowired
		@MovieQualifier(format=Format.BLURAY, genre="Comedy")
		private MovieCatalog comedyBluRayCatalog;

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MovieRecommender {

		@Autowired
		@MovieQualifier(format = Format.VHS, genre = "Action")
		private lateinit var actionVhsCatalog: MovieCatalog

		@Autowired
		@MovieQualifier(format = Format.VHS, genre = "Comedy")
		private lateinit var comedyVhsCatalog: MovieCatalog

		@Autowired
		@MovieQualifier(format = Format.DVD, genre = "Action")
		private lateinit var actionDvdCatalog: MovieCatalog

		@Autowired
		@MovieQualifier(format = Format.BLURAY, genre = "Comedy")
		private lateinit var comedyBluRayCatalog: MovieCatalog

		// ...
	}
----

Finally, the bean definitions should contain matching qualifier values. This example
also demonstrates that you can use bean meta attributes instead of the
`<qualifier/>` elements. If available, the `<qualifier/>` element and its attributes take
precedence, but the autowiring mechanism falls back on the values provided within the
`<meta/>` tags if no such qualifier is present, as in the last two bean definitions in
the following example:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">

		<context:annotation-config/>

		<bean class="example.SimpleMovieCatalog">
			<qualifier type="MovieQualifier">
				<attribute key="format" value="VHS"/>
				<attribute key="genre" value="Action"/>
			</qualifier>
			<!-- inject any dependencies required by this bean -->
		</bean>

		<bean class="example.SimpleMovieCatalog">
			<qualifier type="MovieQualifier">
				<attribute key="format" value="VHS"/>
				<attribute key="genre" value="Comedy"/>
			</qualifier>
			<!-- inject any dependencies required by this bean -->
		</bean>

		<bean class="example.SimpleMovieCatalog">
			<meta key="format" value="DVD"/>
			<meta key="genre" value="Action"/>
			<!-- inject any dependencies required by this bean -->
		</bean>

		<bean class="example.SimpleMovieCatalog">
			<meta key="format" value="BLURAY"/>
			<meta key="genre" value="Comedy"/>
			<!-- inject any dependencies required by this bean -->
		</bean>

	</beans>
----



[[beans-generics-as-qualifiers]]
=== Using Generics as Autowiring Qualifiers

In addition to the `@Qualifier` annotation, you can use Java generic types
as an implicit form of qualification. For example, suppose you have the following
configuration:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class MyConfiguration {

		@Bean
		public StringStore stringStore() {
			return new StringStore();
		}

		@Bean
		public IntegerStore integerStore() {
			return new IntegerStore();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class MyConfiguration {

		@Bean
		fun stringStore() = StringStore()
			
		@Bean
		fun integerStore() = IntegerStore()
	}
----

Assuming that the preceding beans implement a generic interface, (that is, `Store<String>` and
`Store<Integer>`), you can `@Autowire` the `Store` interface and the generic is
used as a qualifier, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Autowired
	private Store<String> s1; // <String> qualifier, injects the stringStore bean

	@Autowired
	private Store<Integer> s2; // <Integer> qualifier, injects the integerStore bean
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Autowired
	private lateinit var s1: Store<String> // <String> qualifier, injects the stringStore bean

	@Autowired
	private lateinit var s2: Store<Integer> // <Integer> qualifier, injects the integerStore bean
----

Generic qualifiers also apply when autowiring lists, `Map` instances and arrays. The
following example autowires a generic `List`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// Inject all Store beans as long as they have an <Integer> generic
	// Store<String> beans will not appear in this list
	@Autowired
	private List<Store<Integer>> s;
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// Inject all Store beans as long as they have an <Integer> generic
	// Store<String> beans will not appear in this list
	@Autowired
	private lateinit var s: List<Store<Integer>>
----



[[beans-custom-autowire-configurer]]
=== Using `CustomAutowireConfigurer`

{api-spring-framework}/beans/factory/annotation/CustomAutowireConfigurer.html[`CustomAutowireConfigurer`]
is a `BeanFactoryPostProcessor` that lets you register your own custom qualifier
annotation types, even if they are not annotated with Spring's `@Qualifier` annotation.
The following example shows how to use `CustomAutowireConfigurer`:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="customAutowireConfigurer"
			class="org.springframework.beans.factory.annotation.CustomAutowireConfigurer">
		<property name="customQualifierTypes">
			<set>
				<value>example.CustomQualifier</value>
			</set>
		</property>
	</bean>
----

The `AutowireCandidateResolver` determines autowire candidates by:

* The `autowire-candidate` value of each bean definition
* Any `default-autowire-candidates` patterns available on the `<beans/>` element
* The presence of `@Qualifier` annotations and any custom annotations registered
with the `CustomAutowireConfigurer`

When multiple beans qualify as autowire candidates, the determination of a "`primary`" is
as follows: If exactly one bean definition among the candidates has a `primary`
attribute set to `true`, it is selected.



[[beans-resource-annotation]]
=== Injection with `@Resource`

Spring also supports injection by using the JSR-250 `@Resource` annotation
(`javax.annotation.Resource`) on fields or bean property setter methods.
This is a common pattern in Java EE: for example, in JSF-managed beans and JAX-WS
endpoints. Spring supports this pattern for Spring-managed objects as well.

`@Resource` takes a name attribute. By default, Spring interprets that value as
the bean name to be injected. In other words, it follows by-name semantics,
as demonstrated in the following example:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SimpleMovieLister {

		private MovieFinder movieFinder;

		@Resource(name="myMovieFinder") // <1>
		public void setMovieFinder(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
		}
	}
----
<1> This line injects a `@Resource`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
class SimpleMovieLister {

	@Resource(name="myMovieFinder") // <1>
	private lateinit var movieFinder:MovieFinder
}
----
<1> This line injects a `@Resource`.


If no name is explicitly specified, the default name is derived from the field name or
setter method. In case of a field, it takes the field name. In case of a setter method,
it takes the bean property name. The following example is going to have the bean
named `movieFinder` injected into its setter method:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SimpleMovieLister {

		private MovieFinder movieFinder;

		@Resource
		public void setMovieFinder(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class SimpleMovieLister {

		@Resource
		private lateinit var movieFinder: MovieFinder
		
	}
----

NOTE: The name provided with the annotation is resolved as a bean name by the
`ApplicationContext` of which the `CommonAnnotationBeanPostProcessor` is aware.
The names can be resolved through JNDI if you configure Spring's
{api-spring-framework}/jndi/support/SimpleJndiBeanFactory.html[`SimpleJndiBeanFactory`]
explicitly. However, we recommend that you rely on the default behavior and
use Spring's JNDI lookup capabilities to preserve the level of indirection.

In the exclusive case of `@Resource` usage with no explicit name specified, and similar
to `@Autowired`, `@Resource` finds a primary type match instead of a specific named bean
and resolves well known resolvable dependencies: the `BeanFactory`,
`ApplicationContext`, `ResourceLoader`, `ApplicationEventPublisher`, and `MessageSource`
interfaces.

Thus, in the following example, the `customerPreferenceDao` field first looks for a bean
named "customerPreferenceDao" and then falls back to a primary type match for the type
`CustomerPreferenceDao`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MovieRecommender {

		@Resource
		private CustomerPreferenceDao customerPreferenceDao;

		@Resource
		private ApplicationContext context; // <1>

		public MovieRecommender() {
		}

		// ...
	}
----
<1> The `context` field is injected based on the known resolvable dependency type:
`ApplicationContext`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MovieRecommender {

		@Resource
		private lateinit var customerPreferenceDao: CustomerPreferenceDao


		@Resource
		private lateinit var context: ApplicationContext // <1>

		// ...
	}
----
<1> The `context` field is injected based on the known resolvable dependency type:
`ApplicationContext`.

[[beans-value-annotations]]
=== Using `@Value`

`@Value` is typically used to inject externalized properties:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
    @Component
    public class MovieRecommender {

        private final String catalog;

        public MovieRecommender(@Value("${catalog.name}") String catalog) {
            this.catalog = catalog;
        }
    }
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Component
	class MovieRecommender(@Value("\${catalog.name}") private val catalog: String)
----

With the following configuration:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
    @Configuration
    @PropertySource("classpath:application.properties")
    public class AppConfig { }
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@PropertySource("classpath:application.properties")
	class AppConfig
----

And the following `application.properties` file:

[source,java,indent=0,subs="verbatim,quotes"]
----
    catalog.name=MovieCatalog
----

In that case, the `catalog` parameter and field will be equal to the `MovieCatalog` value.

A default lenient embedded value resolver is provided by Spring. It will try to resolve the
property value and if it cannot be resolved, the property name (for example `${catalog.name}`)
will be injected as the value. If you want to maintain strict control over nonexistent
values, you should declare a `PropertySourcesPlaceholderConfigurer` bean, as the following
example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
    @Configuration
    public class AppConfig {

         @Bean
         public static PropertySourcesPlaceholderConfigurer propertyPlaceholderConfigurer() {
               return new PropertySourcesPlaceholderConfigurer();
         }
    }
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class AppConfig {

		@Bean
		fun propertyPlaceholderConfigurer() = PropertySourcesPlaceholderConfigurer()
	}
----

NOTE: When configuring a `PropertySourcesPlaceholderConfigurer` using JavaConfig, the
`@Bean` method must be `static`.

Using the above configuration ensures Spring initialization failure if any `${}`
placeholder could not be resolved. It is also possible to use methods like
`setPlaceholderPrefix`, `setPlaceholderSuffix`, or `setValueSeparator` to customize
placeholders.

NOTE: Spring Boot configures by default a `PropertySourcesPlaceholderConfigurer` bean that
will get properties from `application.properties` and `application.yml` files.

Built-in converter support provided by Spring allows simple type conversion (to `Integer`
or `int` for example) to be automatically handled. Multiple comma-separated values can be
automatically converted to String array without extra effort.

It is possible to provide a default value as following:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
    @Component
    public class MovieRecommender {

        private final String catalog;

        public MovieRecommender(@Value("${catalog.name:defaultCatalog}") String catalog) {
            this.catalog = catalog;
        }
    }
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Component
	class MovieRecommender(@Value("\${catalog.name:defaultCatalog}") private val catalog: String)
----

A Spring `BeanPostProcessor` uses a `ConversionService` behind the scene to handle the
process for converting the String value in `@Value` to the target type. If you want to
provide conversion support for your own custom type, you can provide your own
`ConversionService` bean instance as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
    @Configuration
    public class AppConfig {

        @Bean
        public ConversionService conversionService() {
            DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService();
            conversionService.addConverter(new MyCustomConverter());
            return conversionService;
        }
    }
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class AppConfig {

		@Bean
		fun conversionService(): ConversionService {
				return DefaultFormattingConversionService().apply {
				addConverter(MyCustomConverter())
			}
		}
	}
----

When `@Value` contains a <<expressions, `SpEL` expression>> the value will be dynamically
computed at runtime as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
    @Component
    public class MovieRecommender {

        private final String catalog;

        public MovieRecommender(@Value("#{systemProperties['user.catalog'] + 'Catalog' }") String catalog) {
            this.catalog = catalog;
        }
    }
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Component
	class MovieRecommender(
		@Value("#{systemProperties['user.catalog'] + 'Catalog' }") private val catalog: String)
----

SpEL also enables the use of more complex data structures:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
    @Component
    public class MovieRecommender {

        private final Map<String, Integer> countOfMoviesPerCatalog;

        public MovieRecommender(
                @Value("#{{'Thriller': 100, 'Comedy': 300}}") Map<String, Integer> countOfMoviesPerCatalog) {
            this.countOfMoviesPerCatalog = countOfMoviesPerCatalog;
        }
    }
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Component
	class MovieRecommender(
		@Value("#{{'Thriller': 100, 'Comedy': 300}}") private val countOfMoviesPerCatalog: Map<String, Int>)
----


[[beans-postconstruct-and-predestroy-annotations]]
=== Using `@PostConstruct` and `@PreDestroy`

The `CommonAnnotationBeanPostProcessor` not only recognizes the `@Resource` annotation
but also the JSR-250 lifecycle annotations: `javax.annotation.PostConstruct` and
`javax.annotation.PreDestroy`. Introduced in Spring 2.5, the support for these
annotations offers an alternative to the lifecycle callback mechanism described in
<<beans-factory-lifecycle-initializingbean,initialization callbacks>> and
<<beans-factory-lifecycle-disposablebean,destruction callbacks>>. Provided that the
`CommonAnnotationBeanPostProcessor` is registered within the Spring `ApplicationContext`,
a method carrying one of these annotations is invoked at the same point in the lifecycle
as the corresponding Spring lifecycle interface method or explicitly declared callback
method. In the following example, the cache is pre-populated upon initialization and
cleared upon destruction:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class CachingMovieLister {

		@PostConstruct
		public void populateMovieCache() {
			// populates the movie cache upon initialization...
		}

		@PreDestroy
		public void clearMovieCache() {
			// clears the movie cache upon destruction...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class CachingMovieLister {

		@PostConstruct
		fun populateMovieCache() {
			// populates the movie cache upon initialization...
		}

		@PreDestroy
		fun clearMovieCache() {
			// clears the movie cache upon destruction...
		}
	}
----

For details about the effects of combining various lifecycle mechanisms, see
<<beans-factory-lifecycle-combined-effects>>.

[NOTE]
====
Like `@Resource`, the `@PostConstruct` and `@PreDestroy` annotation types were a part
of the standard Java libraries from JDK 6 to 8. However, the entire `javax.annotation`
package got separated from the core Java modules in JDK 9 and eventually removed in
JDK 11. If needed, the `javax.annotation-api` artifact needs to be obtained via Maven
Central now, simply to be added to the application's classpath like any other library.
====




[[beans-classpath-scanning]]
== Classpath Scanning and Managed Components

Most examples in this chapter use XML to specify the configuration metadata that produces
each `BeanDefinition` within the Spring container. The previous section
(<<beans-annotation-config>>) demonstrates how to provide a lot of the configuration
metadata through source-level annotations. Even in those examples, however, the "`base`"
bean definitions are explicitly defined in the XML file, while the annotations drive only
the dependency injection. This section describes an option for implicitly detecting the
candidate components by scanning the classpath. Candidate components are classes that
match against a filter criteria and have a corresponding bean definition registered with
the container. This removes the need to use XML to perform bean registration. Instead, you
can use annotations (for example, `@Component`), AspectJ type expressions, or your own
custom filter criteria to select which classes have bean definitions registered with
the container.

[NOTE]
====
Starting with Spring 3.0, many features provided by the Spring JavaConfig project are
part of the core Spring Framework. This allows you to define beans using Java rather
than using the traditional XML files. Take a look at the `@Configuration`, `@Bean`,
`@Import`, and `@DependsOn` annotations for examples of how to use these new features.
====



[[beans-stereotype-annotations]]
=== `@Component` and Further Stereotype Annotations

The `@Repository` annotation is a marker for any class that fulfills the role or
stereotype of a repository (also known as Data Access Object or DAO). Among the uses
of this marker is the automatic translation of exceptions, as described in
<<data-access.adoc#orm-exception-translation, Exception Translation>>.

Spring provides further stereotype annotations: `@Component`, `@Service`, and
`@Controller`. `@Component` is a generic stereotype for any Spring-managed component.
`@Repository`, `@Service`, and `@Controller` are specializations of `@Component` for
more specific use cases (in the persistence, service, and presentation
layers, respectively). Therefore, you can annotate your component classes with
`@Component`, but, by annotating them with `@Repository`, `@Service`, or `@Controller`
instead, your classes are more properly suited for processing by tools or associating
with aspects. For example, these stereotype annotations make ideal targets for
pointcuts. `@Repository`, `@Service`, and `@Controller` can also
carry additional semantics in future releases of the Spring Framework. Thus, if you are
choosing between using `@Component` or `@Service` for your service layer, `@Service` is
clearly the better choice. Similarly, as stated earlier, `@Repository` is already
supported as a marker for automatic exception translation in your persistence layer.



[[beans-meta-annotations]]
=== Using Meta-annotations and Composed Annotations

Many of the annotations provided by Spring can be used as meta-annotations in your
own code. A meta-annotation is an annotation that can be applied to another annotation.
For example, the `@Service` annotation mentioned <<beans-stereotype-annotations, earlier>>
is meta-annotated with `@Component`, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@Component // <1>
	public @interface Service {

		// ...
	}
----
<1> The `Component` causes `@Service` to be treated in the same way as `@Component`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Target(AnnotationTarget.TYPE)
	@Retention(AnnotationRetention.RUNTIME)
	@MustBeDocumented
	@Component // <1>
	annotation class Service {

		// ...
	}
----
<1> The `Component` causes `@Service` to be treated in the same way as `@Component`.

You can also combine meta-annotations to create "`composed annotations`". For example,
the `@RestController` annotation from Spring MVC is composed of `@Controller` and
`@ResponseBody`.

In addition, composed annotations can optionally redeclare attributes from
meta-annotations to allow customization. This can be particularly useful when you
want to only expose a subset of the meta-annotation's attributes. For example, Spring's
`@SessionScope` annotation hardcodes the scope name to `session` but still allows
customization of the `proxyMode`. The following listing shows the definition of the
`SessionScope` annotation:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Target({ElementType.TYPE, ElementType.METHOD})
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@Scope(WebApplicationContext.SCOPE_SESSION)
	public @interface SessionScope {

		/**
		 * Alias for {@link Scope#proxyMode}.
		 * <p>Defaults to {@link ScopedProxyMode#TARGET_CLASS}.
		 */
		@AliasFor(annotation = Scope.class)
		ScopedProxyMode proxyMode() default ScopedProxyMode.TARGET_CLASS;

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Target(AnnotationTarget.TYPE, AnnotationTarget.FUNCTION)
	@Retention(AnnotationRetention.RUNTIME)
	@MustBeDocumented
	@Scope(WebApplicationContext.SCOPE_SESSION)
	annotation class SessionScope(
			@get:AliasFor(annotation = Scope::class)
			val proxyMode: ScopedProxyMode = ScopedProxyMode.TARGET_CLASS
	)
----

You can then use `@SessionScope` without declaring the `proxyMode` as follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Service
	@SessionScope
	public class SessionScopedService {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Service
	@SessionScope
	class SessionScopedService {
		// ...
	}
----

You can also override the value for the `proxyMode`, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Service
	@SessionScope(proxyMode = ScopedProxyMode.INTERFACES)
	public class SessionScopedUserService implements UserService {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Service
	@SessionScope(proxyMode = ScopedProxyMode.INTERFACES)
	class SessionScopedUserService : UserService {
		// ...	
	}
----

For further details, see the
https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model[Spring Annotation Programming Model]
wiki page.



[[beans-scanning-autodetection]]
=== Automatically Detecting Classes and Registering Bean Definitions

Spring can automatically detect stereotyped classes and register corresponding
`BeanDefinition` instances with the `ApplicationContext`. For example, the following two classes
are eligible for such autodetection:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Service
	public class SimpleMovieLister {

		private MovieFinder movieFinder;

		public SimpleMovieLister(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Service
	class SimpleMovieLister(private val movieFinder: MovieFinder)
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Repository
	public class JpaMovieFinder implements MovieFinder {
		// implementation elided for clarity
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Repository
	class JpaMovieFinder : MovieFinder {
		// implementation elided for clarity	
	}
----


To autodetect these classes and register the corresponding beans, you need to add
`@ComponentScan` to your `@Configuration` class, where the `basePackages` attribute
is a common parent package for the two classes. (Alternatively, you can specify a
comma- or semicolon- or space-separated list that includes the parent package of each class.)

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@ComponentScan(basePackages = "org.example")
	public class AppConfig  {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@ComponentScan(basePackages = ["org.example"])
	class AppConfig  {
		// ...
	}
----

NOTE: For brevity, the preceding example could have used the `value` attribute of the
annotation (that is, `@ComponentScan("org.example")`).

The following alternative uses XML:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">

		<context:component-scan base-package="org.example"/>

	</beans>
----

TIP: The use of `<context:component-scan>` implicitly enables the functionality of
`<context:annotation-config>`. There is usually no need to include the
`<context:annotation-config>` element when using `<context:component-scan>`.

[NOTE]
====
The scanning of classpath packages requires the presence of corresponding directory
entries in the classpath. When you build JARs with Ant, make sure that you do not
activate the files-only switch of the JAR task. Also, classpath directories may not be
exposed based on security policies in some environments -- for example, standalone apps on
JDK 1.7.0_45 and higher (which requires 'Trusted-Library' setup in your manifests -- see
https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources).

On JDK 9's module path (Jigsaw), Spring's classpath scanning generally works as expected.
However, make sure that your component classes are exported in your `module-info`
descriptors. If you expect Spring to invoke non-public members of your classes, make
sure that they are 'opened' (that is, that they use an `opens` declaration instead of an
`exports` declaration in your `module-info` descriptor).
====

Furthermore, the `AutowiredAnnotationBeanPostProcessor` and
`CommonAnnotationBeanPostProcessor` are both implicitly included when you use the
component-scan element. That means that the two components are autodetected and
wired together -- all without any bean configuration metadata provided in XML.

NOTE: You can disable the registration of `AutowiredAnnotationBeanPostProcessor` and
`CommonAnnotationBeanPostProcessor` by including the `annotation-config` attribute
with a value of `false`.



[[beans-scanning-filters]]
=== Using Filters to Customize Scanning

By default, classes annotated with `@Component`, `@Repository`, `@Service`, `@Controller`,
`@Configuration`, or a custom annotation that itself is annotated with `@Component` are
the only detected candidate components. However, you can modify and extend this behavior
by applying custom filters. Add them as `includeFilters` or `excludeFilters` attributes of
the `@ComponentScan` annotation (or as `<context:include-filter />` or
`<context:exclude-filter />` child elements of the `<context:component-scan>` element in
XML configuration). Each filter element requires the `type` and `expression` attributes.
The following table describes the filtering options:

[[beans-scanning-filters-tbl]]
.Filter Types
|===
| Filter Type| Example Expression| Description

| annotation (default)
| `org.example.SomeAnnotation`
| An annotation to be _present_ or _meta-present_ at the type level in target components.

| assignable
| `org.example.SomeClass`
| A class (or interface) that the target components are assignable to (extend or implement).

| aspectj
| `org.example..*Service+`
| An AspectJ type expression to be matched by the target components.

| regex
| `org\.example\.Default.*`
| A regex expression to be matched by the target components' class names.

| custom
| `org.example.MyTypeFilter`
| A custom implementation of the `org.springframework.core.type.TypeFilter` interface.
|===

The following example shows the configuration ignoring all `@Repository` annotations
and using "`stub`" repositories instead:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@ComponentScan(basePackages = "org.example",
			includeFilters = @Filter(type = FilterType.REGEX, pattern = ".*Stub.*Repository"),
			excludeFilters = @Filter(Repository.class))
	public class AppConfig {
		...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@ComponentScan(basePackages = "org.example",
			includeFilters = [Filter(type = FilterType.REGEX, pattern = [".*Stub.*Repository"])],
			excludeFilters = [Filter(Repository::class)])
	class AppConfig {
		// ...
	}
----

The following listing shows the equivalent XML:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<context:component-scan base-package="org.example">
			<context:include-filter type="regex"
					expression=".*Stub.*Repository"/>
			<context:exclude-filter type="annotation"
					expression="org.springframework.stereotype.Repository"/>
		</context:component-scan>
	</beans>
----

NOTE: You can also disable the default filters by setting `useDefaultFilters=false` on the
annotation or by providing `use-default-filters="false"` as an attribute of the
`<component-scan/>` element. This effectively disables automatic detection of classes
annotated or meta-annotated with `@Component`, `@Repository`, `@Service`, `@Controller`,
`@RestController`, or `@Configuration`.



[[beans-factorybeans-annotations]]
=== Defining Bean Metadata within Components

Spring components can also contribute bean definition metadata to the container. You can do
this with the same `@Bean` annotation used to define bean metadata within `@Configuration`
annotated classes. The following example shows how to do so:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Component
	public class FactoryMethodComponent {

		@Bean
		@Qualifier("public")
		public TestBean publicInstance() {
			return new TestBean("publicInstance");
		}

		public void doWork() {
			// Component method implementation omitted
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Component
	class FactoryMethodComponent {

		@Bean
		@Qualifier("public")
		fun publicInstance() = TestBean("publicInstance")

		fun doWork() {
			// Component method implementation omitted
		}
	}
----

The preceding class is a Spring component that has application-specific code in its
`doWork()` method. However, it also contributes a bean definition that has a factory
method referring to the method `publicInstance()`. The `@Bean` annotation identifies the
factory method and other bean definition properties, such as a qualifier value through
the `@Qualifier` annotation. Other method-level annotations that can be specified are
`@Scope`, `@Lazy`, and custom qualifier annotations.

TIP: In addition to its role for component initialization, you can also place the `@Lazy` annotation
on injection points marked with `@Autowired` or `@Inject`. In this context, it
leads to the injection of a lazy-resolution proxy.

Autowired fields and methods are supported, as previously discussed, with additional
support for autowiring of `@Bean` methods. The following example shows how to do so:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Component
	public class FactoryMethodComponent {

		private static int i;

		@Bean
		@Qualifier("public")
		public TestBean publicInstance() {
			return new TestBean("publicInstance");
		}

		// use of a custom qualifier and autowiring of method parameters
		@Bean
		protected TestBean protectedInstance(
				@Qualifier("public") TestBean spouse,
				@Value("#{privateInstance.age}") String country) {
			TestBean tb = new TestBean("protectedInstance", 1);
			tb.setSpouse(spouse);
			tb.setCountry(country);
			return tb;
		}

		@Bean
		private TestBean privateInstance() {
			return new TestBean("privateInstance", i++);
		}

		@Bean
		@RequestScope
		public TestBean requestScopedInstance() {
			return new TestBean("requestScopedInstance", 3);
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Component
	class FactoryMethodComponent {

		companion object {
			private var i: Int = 0
		}

		@Bean
		@Qualifier("public")
		fun publicInstance() = TestBean("publicInstance")

		// use of a custom qualifier and autowiring of method parameters
		@Bean
		protected fun protectedInstance(
				@Qualifier("public") spouse: TestBean,
				@Value("#{privateInstance.age}") country: String) = TestBean("protectedInstance", 1).apply {
			this.spouse = spouse
			this.country = country
		}

		@Bean
		private fun privateInstance() = TestBean("privateInstance", i++)

		@Bean
		@RequestScope
		fun requestScopedInstance() = TestBean("requestScopedInstance", 3)
	}
----

The example autowires the `String` method parameter `country` to the value of the `age`
property on another bean named `privateInstance`. A Spring Expression Language element
defines the value of the property through the notation `#{ <expression> }`. For `@Value`
annotations, an expression resolver is preconfigured to look for bean names when
resolving expression text.

As of Spring Framework 4.3, you may also declare a factory method parameter of type
`InjectionPoint` (or its more specific subclass: `DependencyDescriptor`) to
access the requesting injection point that triggers the creation of the current bean.
Note that this applies only to the actual creation of bean instances, not to the
injection of existing instances. As a consequence, this feature makes most sense for
beans of prototype scope. For other scopes, the factory method only ever sees the
injection point that triggered the creation of a new bean instance in the given scope
(for example, the dependency that triggered the creation of a lazy singleton bean).
You can use the provided injection point metadata with semantic care in such scenarios.
The following example shows how to do use `InjectionPoint`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Component
	public class FactoryMethodComponent {

		@Bean @Scope("prototype")
		public TestBean prototypeInstance(InjectionPoint injectionPoint) {
			return new TestBean("prototypeInstance for " + injectionPoint.getMember());
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Component
	class FactoryMethodComponent {

		@Bean
		@Scope("prototype")
		fun prototypeInstance(injectionPoint: InjectionPoint) =
				TestBean("prototypeInstance for ${injectionPoint.member}")
	}
----

The `@Bean` methods in a regular Spring component are processed differently than their
counterparts inside a Spring `@Configuration` class. The difference is that `@Component`
classes are not enhanced with CGLIB to intercept the invocation of methods and fields.
CGLIB proxying is the means by which invoking methods or fields within `@Bean` methods
in `@Configuration` classes creates bean metadata references to collaborating objects.
Such methods are not invoked with normal Java semantics but rather go through the
container in order to provide the usual lifecycle management and proxying of Spring
beans, even when referring to other beans through programmatic calls to `@Bean` methods.
In contrast, invoking a method or field in a `@Bean` method within a plain `@Component`
class has standard Java semantics, with no special CGLIB processing or other
constraints applying.

[NOTE]
====
You may declare `@Bean` methods as `static`, allowing for them to be called without
creating their containing configuration class as an instance. This makes particular
sense when defining post-processor beans (for example, of type `BeanFactoryPostProcessor`
or `BeanPostProcessor`), since such beans get initialized early in the container
lifecycle and should avoid triggering other parts of the configuration at that point.

Calls to static `@Bean` methods never get intercepted by the container, not even within
`@Configuration` classes (as described earlier in this section), due to technical
limitations: CGLIB subclassing can override only non-static methods. As a consequence,
a direct call to another `@Bean` method has standard Java semantics, resulting
in an independent instance being returned straight from the factory method itself.

The Java language visibility of `@Bean` methods does not have an immediate impact on
the resulting bean definition in Spring's container. You can freely declare your
factory methods as you see fit in non-`@Configuration` classes and also for static
methods anywhere. However, regular `@Bean` methods in `@Configuration` classes need
to be overridable -- that is, they must not be declared as `private` or `final`.

`@Bean` methods are also discovered on base classes of a given component or
configuration class, as well as on Java 8 default methods declared in interfaces
implemented by the component or configuration class. This allows for a lot of
flexibility in composing complex configuration arrangements, with even multiple
inheritance being possible through Java 8 default methods as of Spring 4.2.

Finally, a single class may hold multiple `@Bean` methods for the same
bean, as an arrangement of multiple factory methods to use depending on available
dependencies at runtime. This is the same algorithm as for choosing the "`greediest`"
constructor or factory method in other configuration scenarios: The variant with
the largest number of satisfiable dependencies is picked at construction time,
analogous to how the container selects between multiple `@Autowired` constructors.
====



[[beans-scanning-name-generator]]
=== Naming Autodetected Components

When a component is autodetected as part of the scanning process, its bean name is
generated by the `BeanNameGenerator` strategy known to that scanner. By default, any
Spring stereotype annotation (`@Component`, `@Repository`, `@Service`, and
`@Controller`) that contains a name `value` thereby provides that name to the
corresponding bean definition.

If such an annotation contains no name `value` or for any other detected component
(such as those discovered by custom filters), the default bean name generator returns
the uncapitalized non-qualified class name. For example, if the following component
classes were detected, the names would be `myMovieLister` and `movieFinderImpl`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Service("myMovieLister")
	public class SimpleMovieLister {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Service("myMovieLister")
	class SimpleMovieLister {
		// ...
	}
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Repository
	public class MovieFinderImpl implements MovieFinder {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Repository
	class MovieFinderImpl : MovieFinder {
		// ...
	}
----

NOTE: If you do not want to rely on the default bean-naming strategy, you can provide a
custom bean-naming strategy. First, implement the
{api-spring-framework}/beans/factory/support/BeanNameGenerator.html[`BeanNameGenerator`]
interface, and be sure to include a default no-arg constructor. Then, provide the fully
qualified class name when configuring the scanner, as the following example annotation
and bean definition show:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@ComponentScan(basePackages = "org.example", nameGenerator = MyNameGenerator.class)
	public class AppConfig {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@ComponentScan(basePackages = ["org.example"], nameGenerator = MyNameGenerator::class)
	class AppConfig {
		// ...
	}
----

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<context:component-scan base-package="org.example"
			name-generator="org.example.MyNameGenerator" />
	</beans>
----

As a general rule, consider specifying the name with the annotation whenever other
components may be making explicit references to it. On the other hand, the
auto-generated names are adequate whenever the container is responsible for wiring.



[[beans-scanning-scope-resolver]]
=== Providing a Scope for Autodetected Components

As with Spring-managed components in general, the default and most common scope for
autodetected components is `singleton`. However, sometimes you need a different scope
that can be specified by the `@Scope` annotation. You can provide the name of the
scope within the annotation, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Scope("prototype")
	@Repository
	public class MovieFinderImpl implements MovieFinder {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Scope("prototype")
	@Repository
	class MovieFinderImpl : MovieFinder {
		// ...
	}
----

NOTE: `@Scope` annotations are only introspected on the concrete bean class (for annotated
components) or the factory method (for `@Bean` methods). In contrast to XML bean
definitions, there is no notion of bean definition inheritance, and inheritance
hierarchies at the class level are irrelevant for metadata purposes.

For details on web-specific scopes such as "`request`" or "`session`" in a Spring context,
see <<beans-factory-scopes-other>>. As with the pre-built annotations for those scopes,
you may also compose your own scoping annotations by using Spring's meta-annotation
approach: for example, a custom annotation meta-annotated with `@Scope("prototype")`,
possibly also declaring a custom scoped-proxy mode.

NOTE: To provide a custom strategy for scope resolution rather than relying on the
annotation-based approach, you can implement the
{api-spring-framework}/context/annotation/ScopeMetadataResolver.html[`ScopeMetadataResolver`]
interface. Be sure to include a default no-arg constructor. Then you can provide the
fully qualified class name when configuring the scanner, as the following example of both
an annotation and a bean definition shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@ComponentScan(basePackages = "org.example", scopeResolver = MyScopeResolver.class)
	public class AppConfig {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@ComponentScan(basePackages = ["org.example"], scopeResolver = MyScopeResolver::class)
	class AppConfig {
		// ...
	}
----

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<context:component-scan base-package="org.example" scope-resolver="org.example.MyScopeResolver"/>
	</beans>
----

When using certain non-singleton scopes, it may be necessary to generate proxies for the
scoped objects. The reasoning is described in <<beans-factory-scopes-other-injection>>.
For this purpose, a scoped-proxy attribute is available on the component-scan
element. The three possible values are: `no`, `interfaces`, and `targetClass`. For example,
the following configuration results in standard JDK dynamic proxies:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@ComponentScan(basePackages = "org.example", scopedProxy = ScopedProxyMode.INTERFACES)
	public class AppConfig {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@ComponentScan(basePackages = ["org.example"], scopedProxy = ScopedProxyMode.INTERFACES)
	class AppConfig {
		// ...
	}
----

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<context:component-scan base-package="org.example" scoped-proxy="interfaces"/>
	</beans>
----



[[beans-scanning-qualifiers]]
=== Providing Qualifier Metadata with Annotations

The `@Qualifier` annotation is discussed in <<beans-autowired-annotation-qualifiers>>.
The examples in that section demonstrate the use of the `@Qualifier` annotation and
custom qualifier annotations to provide fine-grained control when you resolve autowire
candidates. Because those examples were based on XML bean definitions, the qualifier
metadata was provided on the candidate bean definitions by using the `qualifier` or `meta`
child elements of the `bean` element in the XML. When relying upon classpath scanning for
auto-detection of components, you can provide the qualifier metadata with type-level
annotations on the candidate class. The following three examples demonstrate this
technique:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Component
	@Qualifier("Action")
	public class ActionMovieCatalog implements MovieCatalog {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Component
	@Qualifier("Action")
	class ActionMovieCatalog : MovieCatalog
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Component
	@Genre("Action")
	public class ActionMovieCatalog implements MovieCatalog {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Component
	@Genre("Action")
	class ActionMovieCatalog : MovieCatalog {
		// ...	
	}
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Component
	@Offline
	public class CachingMovieCatalog implements MovieCatalog {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
@Component
@Offline
class CachingMovieCatalog : MovieCatalog {
	// ...
}
----

NOTE: As with most annotation-based alternatives, keep in mind that the annotation metadata is
bound to the class definition itself, while the use of XML allows for multiple beans
of the same type to provide variations in their qualifier metadata, because that
metadata is provided per-instance rather than per-class.



[[beans-scanning-index]]
=== Generating an Index of Candidate Components

While classpath scanning is very fast, it is possible to improve the startup performance
of large applications by creating a static list of candidates at compilation time. In this
mode, all modules that are target of component scan must use this mechanism.

NOTE: Your existing `@ComponentScan` or `<context:component-scan` directives must stay as
is to request the context to scan candidates in certain packages. When the
`ApplicationContext` detects such an index, it automatically uses it rather than scanning
the classpath.

To generate the index, add an additional dependency to each module that contains
components that are targets for component scan directives. The following example shows
how to do so with Maven:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<dependencies>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-context-indexer</artifactId>
			<version>{spring-version}</version>
			<optional>true</optional>
		</dependency>
	</dependencies>
----

With Gradle 4.5 and earlier, the dependency should be declared in the `compileOnly`
configuration, as shown in the following example:

[source,groovy,indent=0,subs="verbatim,quotes,attributes"]
----
	dependencies {
		compileOnly "org.springframework:spring-context-indexer:{spring-version}"
	}
----
====

With Gradle 4.6 and later, the dependency should be declared in the `annotationProcessor`
configuration, as shown in the following example:

====
[source,groovy,indent=0subs="verbatim,quotes,attributes"]
----
	dependencies {
		annotationProcessor "org.springframework:spring-context-indexer:{spring-version}"
	}
----

That process generates a `META-INF/spring.components` file that is
included in the jar file.

NOTE: When working with this mode in your IDE, the `spring-context-indexer` must be
registered as an annotation processor to make sure the index is up-to-date when
candidate components are updated.

TIP: The index is enabled automatically when a `META-INF/spring.components` is found
on the classpath. If an index is partially available for some libraries (or use cases)
but could not be built for the whole application, you can fallback to a regular classpath
arrangement (as though no index was present at all) by setting `spring.index.ignore` to
`true`, either as a system property or in a `spring.properties` file at the root of the
classpath.



[[beans-standard-annotations]]
== Using JSR 330 Standard Annotations

Starting with Spring 3.0, Spring offers support for JSR-330 standard annotations
(Dependency Injection). Those annotations are scanned in the same way as the Spring
annotations. To use them, you need to have the relevant jars in your classpath.

[NOTE]
=====
If you use Maven, the `javax.inject` artifact is available in the standard Maven
repository (
https://repo1.maven.org/maven2/javax/inject/javax.inject/1/[https://repo1.maven.org/maven2/javax/inject/javax.inject/1/]).
You can add the following dependency to your file pom.xml:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<dependency>
		<groupId>javax.inject</groupId>
		<artifactId>javax.inject</artifactId>
		<version>1</version>
	</dependency>
----
=====



[[beans-inject-named]]
=== Dependency Injection with `@Inject` and `@Named`

Instead of `@Autowired`, you can use `@javax.inject.Inject` as follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import javax.inject.Inject;

	public class SimpleMovieLister {

		private MovieFinder movieFinder;

		@Inject
		public void setMovieFinder(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
		}

		public void listMovies() {
			this.movieFinder.findMovies(...);
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import javax.inject.Inject

	class SimpleMovieLister {

		@Inject
		lateinit var movieFinder: MovieFinder


		fun listMovies() {
			movieFinder.findMovies(...)
			// ...
		}
	}
----

As with `@Autowired`, you can use `@Inject` at the field level, method level
and constructor-argument level. Furthermore, you may declare your injection point as a
`Provider`, allowing for on-demand access to beans of shorter scopes or lazy access to
other beans through a `Provider.get()` call. The following example offers a variant of the
preceding example:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import javax.inject.Inject;
	import javax.inject.Provider;

	public class SimpleMovieLister {

		private Provider<MovieFinder> movieFinder;

		@Inject
		public void setMovieFinder(Provider<MovieFinder> movieFinder) {
			this.movieFinder = movieFinder;
		}

		public void listMovies() {
			this.movieFinder.get().findMovies(...);
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import javax.inject.Inject

	class SimpleMovieLister {

		@Inject
		lateinit var movieFinder: MovieFinder


		fun listMovies() {
			movieFinder.findMovies(...)
			// ...
		}
	}
----

If you would like to use a qualified name for the dependency that should be injected,
you should use the `@Named` annotation, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import javax.inject.Inject;
	import javax.inject.Named;

	public class SimpleMovieLister {

		private MovieFinder movieFinder;

		@Inject
		public void setMovieFinder(@Named("main") MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import javax.inject.Inject
	import javax.inject.Named

	class SimpleMovieLister {

		private lateinit var movieFinder: MovieFinder

		@Inject
		fun setMovieFinder(@Named("main") movieFinder: MovieFinder) {
			this.movieFinder = movieFinder
		}

		// ...
	}
----

As with `@Autowired`, `@Inject` can also be used with `java.util.Optional` or
`@Nullable`. This is even more applicable here, since `@Inject` does not have
a `required` attribute. The following pair of examples show how to use `@Inject` and
`@Nullable`:

[source,java,indent=0,subs="verbatim,quotes"]
----
	public class SimpleMovieLister {

		@Inject
		public void setMovieFinder(Optional<MovieFinder> movieFinder) {
			// ...
		}
	}
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SimpleMovieLister {

		@Inject
		public void setMovieFinder(@Nullable MovieFinder movieFinder) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class SimpleMovieLister {

		@Inject
		var movieFinder: MovieFinder? = null
	}
----



[[beans-named]]
=== `@Named` and `@ManagedBean`: Standard Equivalents to the `@Component` Annotation

Instead of `@Component`, you can use `@javax.inject.Named` or `javax.annotation.ManagedBean`,
as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import javax.inject.Inject;
	import javax.inject.Named;

	@Named("movieListener")  // @ManagedBean("movieListener") could be used as well
	public class SimpleMovieLister {

		private MovieFinder movieFinder;

		@Inject
		public void setMovieFinder(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import javax.inject.Inject
	import javax.inject.Named

	@Named("movieListener")  // @ManagedBean("movieListener") could be used as well
	class SimpleMovieLister {

		@Inject
		lateinit var movieFinder: MovieFinder

		// ...
	}
----

It is very common to use `@Component` without specifying a name for the component.
`@Named` can be used in a similar fashion, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import javax.inject.Inject;
	import javax.inject.Named;

	@Named
	public class SimpleMovieLister {

		private MovieFinder movieFinder;

		@Inject
		public void setMovieFinder(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import javax.inject.Inject
	import javax.inject.Named

	@Named
	class SimpleMovieLister {

		@Inject
		lateinit var movieFinder: MovieFinder

		// ...
	}
----

When you use `@Named` or `@ManagedBean`, you can use component scanning in the
exact same way as when you use Spring annotations, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@ComponentScan(basePackages = "org.example")
	public class AppConfig  {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@ComponentScan(basePackages = ["org.example"])
	class AppConfig  {
		// ...
	}
----

NOTE: In contrast to `@Component`, the JSR-330 `@Named` and the JSR-250 `ManagedBean`
annotations are not composable. You should use Spring's stereotype model for building
custom component annotations.



[[beans-standard-annotations-limitations]]
=== Limitations of JSR-330 Standard Annotations

When you work with standard annotations, you should know that some significant
features are not available, as the following table shows:

[[annotations-comparison]]
.Spring component model elements versus JSR-330 variants
|===
| Spring| javax.inject.*| javax.inject restrictions / comments

| @Autowired
| @Inject
| `@Inject` has no 'required' attribute. Can be used with Java 8's `Optional` instead.

| @Component
| @Named / @ManagedBean
| JSR-330 does not provide a composable model, only a way to identify named components.

| @Scope("singleton")
| @Singleton
| The JSR-330 default scope is like Spring's `prototype`. However, in order to keep it
  consistent with Spring's general defaults, a JSR-330 bean declared in the Spring
  container is a `singleton` by default. In order to use a scope other than `singleton`,
  you should use Spring's `@Scope` annotation. `javax.inject` also provides a
  https://download.oracle.com/javaee/6/api/javax/inject/Scope.html[@Scope] annotation.
  Nevertheless, this one is only intended to be used for creating your own annotations.

| @Qualifier
| @Qualifier / @Named
| `javax.inject.Qualifier` is just a meta-annotation for building custom qualifiers.
  Concrete `String` qualifiers (like Spring's `@Qualifier` with a value) can be associated
  through `javax.inject.Named`.

| @Value
| -
| no equivalent

| @Required
| -
| no equivalent

| @Lazy
| -
| no equivalent

| ObjectFactory
| Provider
| `javax.inject.Provider` is a direct alternative to Spring's `ObjectFactory`,
  only with a shorter `get()` method name. It can also be used in combination with
  Spring's `@Autowired` or with non-annotated constructors and setter methods.
|===



[[beans-java]]
== Java-based Container Configuration

This section covers how to use annotations in your Java code to configure the Spring
container. It includes the following topics:

* <<beans-java-basic-concepts>>
* <<beans-java-instantiating-container>>
* <<beans-java-bean-annotation>>
* <<beans-java-configuration-annotation>>
* <<beans-java-composing-configuration-classes>>
* <<beans-definition-profiles>>
* <<beans-property-source-abstraction>>
* <<beans-using-propertysource>>
* <<beans-placeholder-resolution-in-statements>>



[[beans-java-basic-concepts]]
=== Basic Concepts: `@Bean` and `@Configuration`

The central artifacts in Spring's new Java-configuration support are
`@Configuration`-annotated classes and `@Bean`-annotated methods.

The `@Bean` annotation is used to indicate that a method instantiates, configures, and
initializes a new object to be managed by the Spring IoC container. For those familiar
with Spring's `<beans/>` XML configuration, the `@Bean` annotation plays the same role as
the `<bean/>` element. You can use `@Bean`-annotated methods with any Spring
`@Component`. However, they are most often used with `@Configuration` beans.

Annotating a class with `@Configuration` indicates that its primary purpose is as a
source of bean definitions. Furthermore, `@Configuration` classes let inter-bean
dependencies be defined by calling other `@Bean` methods in the same class.
The simplest possible `@Configuration` class reads as follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class AppConfig {

		@Bean
		public MyService myService() {
			return new MyServiceImpl();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class AppConfig {

		@Bean
		fun myService(): MyService {
			return MyServiceImpl()
		}
	}
----

The preceding `AppConfig` class is equivalent to the following Spring `<beans/>` XML:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<bean id="myService" class="com.acme.services.MyServiceImpl"/>
	</beans>
----

.Full @Configuration vs "`lite`" @Bean mode?
****
When `@Bean` methods are declared within classes that are not annotated with
`@Configuration`, they are referred to as being processed in a "`lite`" mode. Bean methods
declared in a `@Component` or even in a plain old class are considered to be "`lite`",
with a different primary purpose of the containing class and a `@Bean` method
being a sort of bonus there. For example, service components may expose management views
to the container through an additional `@Bean` method on each applicable component class.
In such scenarios, `@Bean` methods are a general-purpose factory method mechanism.

Unlike full `@Configuration`, lite `@Bean` methods cannot declare inter-bean dependencies.
Instead, they operate on their containing component's internal state and, optionally, on
arguments that they may declare. Such a `@Bean` method should therefore not invoke other
`@Bean` methods. Each such method is literally only a factory method for a particular
bean reference, without any special runtime semantics. The positive side-effect here is
that no CGLIB subclassing has to be applied at runtime, so there are no limitations in
terms of class design (that is, the containing class may be `final` and so forth).

In common scenarios, `@Bean` methods are to be declared within `@Configuration` classes,
ensuring that "`full`" mode is always used and that cross-method references therefore
get redirected to the container's lifecycle management. This prevents the same
`@Bean` method from accidentally being invoked through a regular Java call, which helps
to reduce subtle bugs that can be hard to track down when operating in "`lite`" mode.
****

The `@Bean` and `@Configuration` annotations are discussed in depth in the following sections.
First, however, we cover the various ways of creating a spring container using by
Java-based configuration.



[[beans-java-instantiating-container]]
=== Instantiating the Spring Container by Using `AnnotationConfigApplicationContext`

The following sections document Spring's `AnnotationConfigApplicationContext`, introduced in Spring
3.0. This versatile `ApplicationContext` implementation is capable of accepting not only
`@Configuration` classes as input but also plain `@Component` classes and classes
annotated with JSR-330 metadata.

When `@Configuration` classes are provided as input, the `@Configuration` class itself
is registered as a bean definition and all declared `@Bean` methods within the class
are also registered as bean definitions.

When `@Component` and JSR-330 classes are provided, they are registered as bean
definitions, and it is assumed that DI metadata such as `@Autowired` or `@Inject` are
used within those classes where necessary.


[[beans-java-instantiating-container-constructor]]
==== Simple Construction

In much the same way that Spring XML files are used as input when instantiating a
`ClassPathXmlApplicationContext`, you can use `@Configuration` classes as input when
instantiating an `AnnotationConfigApplicationContext`. This allows for completely
XML-free usage of the Spring container, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public static void main(String[] args) {
		ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
		MyService myService = ctx.getBean(MyService.class);
		myService.doStuff();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.beans.factory.getBean

	fun main() {
		val ctx = AnnotationConfigApplicationContext(AppConfig::class.java)
		val myService = ctx.getBean<MyService>()
		myService.doStuff()
	}
----

As mentioned earlier, `AnnotationConfigApplicationContext` is not limited to working only
with `@Configuration` classes. Any `@Component` or JSR-330 annotated class may be supplied
as input to the constructor, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public static void main(String[] args) {
		ApplicationContext ctx = new AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);
		MyService myService = ctx.getBean(MyService.class);
		myService.doStuff();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.beans.factory.getBean

	fun main() {
		val ctx = AnnotationConfigApplicationContext(MyServiceImpl::class.java, Dependency1::class.java, Dependency2::class.java)
		val myService = ctx.getBean<MyService>()
		myService.doStuff()
	}
----

The preceding example assumes that `MyServiceImpl`, `Dependency1`, and `Dependency2` use Spring
dependency injection annotations such as `@Autowired`.


[[beans-java-instantiating-container-register]]
==== Building the Container Programmatically by Using `register(Class<?>...)`

You can instantiate an `AnnotationConfigApplicationContext` by using a no-arg constructor
and then configure it by using the `register()` method. This approach is particularly useful
when programmatically building an `AnnotationConfigApplicationContext`. The following
example shows how to do so:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public static void main(String[] args) {
		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
		ctx.register(AppConfig.class, OtherConfig.class);
		ctx.register(AdditionalConfig.class);
		ctx.refresh();
		MyService myService = ctx.getBean(MyService.class);
		myService.doStuff();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.beans.factory.getBean

	fun main() {
		val ctx = AnnotationConfigApplicationContext()
		ctx.register(AppConfig::class.java, OtherConfig::class.java)
		ctx.register(AdditionalConfig::class.java)
		ctx.refresh()
		val myService = ctx.getBean<MyService>()
		myService.doStuff()
	}
----


[[beans-java-instantiating-container-scan]]
==== Enabling Component Scanning with `scan(String...)`

To enable component scanning, you can annotate your `@Configuration` class as follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@ComponentScan(basePackages = "com.acme") // <1>
	public class AppConfig  {
		...
	}
----
<1> This annotation enables component scanning.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@ComponentScan(basePackages = ["com.acme"]) // <1>
	class AppConfig  {
		// ...
	}
----
<1> This annotation enables component scanning.


[TIP]
=====
Experienced Spring users may be familiar with the XML declaration equivalent from
Spring's `context:` namespace, shown in the following example:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>
		<context:component-scan base-package="com.acme"/>
	</beans>
----
=====

In the preceding example, the `com.acme` package is scanned to look for any
`@Component`-annotated classes, and those classes are registered as Spring bean
definitions within the container. `AnnotationConfigApplicationContext` exposes the
`scan(String...)` method to allow for the same component-scanning functionality, as the
following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public static void main(String[] args) {
		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
		ctx.scan("com.acme");
		ctx.refresh();
		MyService myService = ctx.getBean(MyService.class);
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun main() {
		val ctx = AnnotationConfigApplicationContext()
		ctx.scan("com.acme")
		ctx.refresh()
		val myService = ctx.getBean<MyService>()
	}
----

NOTE: Remember that `@Configuration` classes are <<beans-meta-annotations, meta-annotated>>
with `@Component`, so they are candidates for component-scanning. In the preceding example,
assuming that `AppConfig` is declared within the `com.acme` package (or any package
underneath), it is picked up during the call to `scan()`. Upon `refresh()`, all its `@Bean`
methods are processed and registered as bean definitions within the container.


[[beans-java-instantiating-container-web]]
==== Support for Web Applications with `AnnotationConfigWebApplicationContext`

A `WebApplicationContext` variant of `AnnotationConfigApplicationContext` is available
with `AnnotationConfigWebApplicationContext`. You can use this implementation when
configuring the Spring `ContextLoaderListener` servlet listener, Spring MVC
`DispatcherServlet`, and so forth. The following `web.xml` snippet configures a typical
Spring MVC web application (note the use of the `contextClass` context-param and
init-param):

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<web-app>
		<!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext
			instead of the default XmlWebApplicationContext -->
		<context-param>
			<param-name>contextClass</param-name>
			<param-value>
				org.springframework.web.context.support.AnnotationConfigWebApplicationContext
			</param-value>
		</context-param>

		<!-- Configuration locations must consist of one or more comma- or space-delimited
			fully-qualified @Configuration classes. Fully-qualified packages may also be
			specified for component-scanning -->
		<context-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>com.acme.AppConfig</param-value>
		</context-param>

		<!-- Bootstrap the root application context as usual using ContextLoaderListener -->
		<listener>
			<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
		</listener>

		<!-- Declare a Spring MVC DispatcherServlet as usual -->
		<servlet>
			<servlet-name>dispatcher</servlet-name>
			<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
			<!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext
				instead of the default XmlWebApplicationContext -->
			<init-param>
				<param-name>contextClass</param-name>
				<param-value>
					org.springframework.web.context.support.AnnotationConfigWebApplicationContext
				</param-value>
			</init-param>
			<!-- Again, config locations must consist of one or more comma- or space-delimited
				and fully-qualified @Configuration classes -->
			<init-param>
				<param-name>contextConfigLocation</param-name>
				<param-value>com.acme.web.MvcConfig</param-value>
			</init-param>
		</servlet>

		<!-- map all requests for /app/* to the dispatcher servlet -->
		<servlet-mapping>
			<servlet-name>dispatcher</servlet-name>
			<url-pattern>/app/*</url-pattern>
		</servlet-mapping>
	</web-app>
----



[[beans-java-bean-annotation]]
=== Using the `@Bean` Annotation

`@Bean` is a method-level annotation and a direct analog of the XML `<bean/>` element.
The annotation supports some of the attributes offered by `<bean/>`, such as:
* <<beans-factory-lifecycle-initializingbean, init-method>>
* <<beans-factory-lifecycle-disposablebean, destroy-method>>
* <<beans-factory-autowire,autowiring>>
* `name`.

You can use the `@Bean` annotation in a `@Configuration`-annotated or in a
`@Component`-annotated class.


[[beans-java-declaring-a-bean]]
==== Declaring a Bean

To declare a bean, you can annotate a method with the `@Bean` annotation. You use this
method to register a bean definition within an `ApplicationContext` of the type
specified as the method's return value. By default, the bean name is the same as
the method name. The following example shows a `@Bean` method declaration:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class AppConfig {

		@Bean
		public TransferServiceImpl transferService() {
			return new TransferServiceImpl();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class AppConfig {

		@Bean
		fun transferService() = TransferServiceImpl()
	}
----

The preceding configuration is exactly equivalent to the following Spring XML:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<bean id="transferService" class="com.acme.TransferServiceImpl"/>
	</beans>
----

Both declarations make a bean named `transferService` available in the
`ApplicationContext`, bound to an object instance of type `TransferServiceImpl`, as the
following text image shows:

[literal,subs="verbatim,quotes"]
----
transferService -> com.acme.TransferServiceImpl
----

You can also declare your `@Bean` method with an interface (or base class)
return type, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class AppConfig {

		@Bean
		public TransferService transferService() {
			return new TransferServiceImpl();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class AppConfig {

		@Bean
		fun transferService(): TransferService {
			return TransferServiceImpl()
		}
	}
----

However, this limits the visibility for advance type prediction to the specified
interface type (`TransferService`). Then, with the full type (`TransferServiceImpl`)
known to the container only once, the affected singleton bean has been instantiated.
Non-lazy singleton beans get instantiated according to their declaration order,
so you may see different type matching results depending on when another component
tries to match by a non-declared type (such as `@Autowired TransferServiceImpl`,
which resolves only once the `transferService` bean has been instantiated).

TIP: If you consistently refer to your types by a declared service interface, your
`@Bean` return types may safely join that design decision. However, for components
that implement several interfaces or for components potentially referred to by their
implementation type, it is safer to declare the most specific return type possible
(at least as specific as required by the injection points that refer to your bean).


[[beans-java-dependencies]]
==== Bean Dependencies

A `@Bean`-annotated method can have an arbitrary number of parameters that describe the
dependencies required to build that bean. For instance, if our `TransferService`
requires an `AccountRepository`, we can materialize that dependency with a method
parameter, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class AppConfig {

		@Bean
		public TransferService transferService(AccountRepository accountRepository) {
			return new TransferServiceImpl(accountRepository);
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class AppConfig {

		@Bean
		fun transferService(accountRepository: AccountRepository): TransferService {
			return TransferServiceImpl(accountRepository)
		}
	}
----


The resolution mechanism is pretty much identical to constructor-based dependency
injection. See <<beans-constructor-injection, the relevant section>> for more details.


[[beans-java-lifecycle-callbacks]]
==== Receiving Lifecycle Callbacks

Any classes defined with the `@Bean` annotation support the regular lifecycle callbacks
and can use the `@PostConstruct` and `@PreDestroy` annotations from JSR-250. See
<<beans-postconstruct-and-predestroy-annotations, JSR-250 annotations>> for further
details.

The regular Spring <<beans-factory-nature, lifecycle>> callbacks are fully supported as
well. If a bean implements `InitializingBean`, `DisposableBean`, or `Lifecycle`, their
respective methods are called by the container.

The standard set of `*Aware` interfaces (such as <<beans-beanfactory, BeanFactoryAware>>,
<<beans-factory-aware, BeanNameAware>>,
<<context-functionality-messagesource, MessageSourceAware>>,
<<beans-factory-aware, ApplicationContextAware>>, and so on) are also fully supported.

The `@Bean` annotation supports specifying arbitrary initialization and destruction
callback methods, much like Spring XML's `init-method` and `destroy-method` attributes
on the `bean` element, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class BeanOne {

		public void init() {
			// initialization logic
		}
	}

	public class BeanTwo {

		public void cleanup() {
			// destruction logic
		}
	}

	@Configuration
	public class AppConfig {

		@Bean(initMethod = "init")
		public BeanOne beanOne() {
			return new BeanOne();
		}

		@Bean(destroyMethod = "cleanup")
		public BeanTwo beanTwo() {
			return new BeanTwo();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
class BeanOne {

	fun init() {
		// initialization logic
	}
}

class BeanTwo {

	fun cleanup() {
		// destruction logic
	}
}

@Configuration
class AppConfig {

	@Bean(initMethod = "init")
	fun beanOne() = BeanOne()

	@Bean(destroyMethod = "cleanup")
	fun beanTwo() = BeanTwo()
}
----

[NOTE]
=====
By default, beans defined with Java configuration that have a public `close` or `shutdown`
method are automatically enlisted with a destruction callback. If you have a public
`close` or `shutdown` method and you do not wish for it to be called when the container
shuts down, you can add `@Bean(destroyMethod="")` to your bean definition to disable the
default `(inferred)` mode.

You may want to do that by default for a resource that you acquire with JNDI, as its
lifecycle is managed outside the application. In particular, make sure to always do it
for a `DataSource`, as it is known to be problematic on Java EE application servers.

The following example shows how to prevent an automatic destruction callback for a
`DataSource`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Bean(destroyMethod="")
	public DataSource dataSource() throws NamingException {
		return (DataSource) jndiTemplate.lookup("MyDS");
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Bean(destroyMethod = "")
	fun dataSource(): DataSource {
		return jndiTemplate.lookup("MyDS") as DataSource
	}
----

Also, with `@Bean` methods, you typically use programmatic JNDI lookups, either by
using Spring's `JndiTemplate` or `JndiLocatorDelegate` helpers or straight JNDI
`InitialContext` usage but not the `JndiObjectFactoryBean` variant (which would force
you to declare the return type as the `FactoryBean` type instead of the actual target
type, making it harder to use for cross-reference calls in other `@Bean` methods that
intend to refer to the provided resource here).
=====

In the case of `BeanOne` from the example above the preceding note, it would be equally valid to call the `init()`
method directly during construction, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class AppConfig {

		@Bean
		public BeanOne beanOne() {
			BeanOne beanOne = new BeanOne();
			beanOne.init();
			return beanOne;
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class AppConfig {

		@Bean
		fun beanOne() = BeanOne().apply {
			init()
		}

		// ...
	}
----

TIP: When you work directly in Java, you can do anything you like with your objects and do
not always need to rely on the container lifecycle.


[[beans-java-specifying-bean-scope]]
==== Specifying Bean Scope

Spring includes the `@Scope` annotation so that you can specify the scope of a bean.

[[beans-java-available-scopes]]
===== Using the `@Scope` Annotation

You can specify that your beans defined with the `@Bean` annotation should have a
specific scope. You can use any of the standard scopes specified in the
<<beans-factory-scopes, Bean Scopes>> section.

The default scope is `singleton`, but you can override this with the `@Scope` annotation,
as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class MyConfiguration {

		@Bean
		@Scope("prototype")
		public Encryptor encryptor() {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class MyConfiguration {

		@Bean
		@Scope("prototype")
		fun encryptor(): Encryptor {
			// ...
		}
	}
----

[[beans-java-scoped-proxy]]
===== `@Scope` and `scoped-proxy`

Spring offers a convenient way of working with scoped dependencies through
<<beans-factory-scopes-other-injection, scoped proxies>>. The easiest way to create
such a proxy when using the XML configuration is the `<aop:scoped-proxy/>` element.
Configuring your beans in Java with a `@Scope` annotation offers equivalent support
with the `proxyMode` attribute. The default is no proxy (`ScopedProxyMode.NO`),
but you can specify `ScopedProxyMode.TARGET_CLASS` or `ScopedProxyMode.INTERFACES`.

If you port the scoped proxy example from the XML reference documentation (see
<<beans-factory-scopes-other-injection, scoped proxies>>) to our `@Bean` using Java,
it resembles the following:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// an HTTP Session-scoped bean exposed as a proxy
	@Bean
	@SessionScope
	public UserPreferences userPreferences() {
		return new UserPreferences();
	}

	@Bean
	public Service userService() {
		UserService service = new SimpleUserService();
		// a reference to the proxied userPreferences bean
		service.setUserPreferences(userPreferences());
		return service;
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// an HTTP Session-scoped bean exposed as a proxy
	@Bean
	@SessionScope
	fun userPreferences() = UserPreferences()

	@Bean
	fun userService(): Service {
		return SimpleUserService().apply {
			// a reference to the proxied userPreferences bean
			setUserPreferences(userPreferences()
		}
	}
----

[[beans-java-customizing-bean-naming]]
==== Customizing Bean Naming

By default, configuration classes use a `@Bean` method's name as the name of the
resulting bean. This functionality can be overridden, however, with the `name` attribute,
as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class AppConfig {

		@Bean(name = "myThing")
		public Thing thing() {
			return new Thing();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class AppConfig {

		@Bean("myThing")
		fun thing() = Thing()
	}
----


[[beans-java-bean-aliasing]]
==== Bean Aliasing

As discussed in <<beans-beanname>>, it is sometimes desirable to give a single bean
multiple names, otherwise known as bean aliasing. The `name` attribute of the `@Bean`
annotation accepts a String array for this purpose. The following example shows how to set
a number of aliases for a bean:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class AppConfig {

		@Bean({"dataSource", "subsystemA-dataSource", "subsystemB-dataSource"})
		public DataSource dataSource() {
			// instantiate, configure and return DataSource bean...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class AppConfig {

		@Bean("dataSource", "subsystemA-dataSource", "subsystemB-dataSource")
		fun dataSource(): DataSource {
			// instantiate, configure and return DataSource bean...
		}
	}
----


[[beans-java-bean-description]]
==== Bean Description

Sometimes, it is helpful to provide a more detailed textual description of a bean. This can
be particularly useful when beans are exposed (perhaps through JMX) for monitoring purposes.

To add a description to a `@Bean`, you can use the
{api-spring-framework}/context/annotation/Description.html[`@Description`]
annotation, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class AppConfig {

		@Bean
		@Description("Provides a basic example of a bean")
		public Thing thing() {
			return new Thing();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class AppConfig {

		@Bean
		@Description("Provides a basic example of a bean")
		fun thing() = Thing()
	}
----



[[beans-java-configuration-annotation]]
=== Using the `@Configuration` annotation

`@Configuration` is a class-level annotation indicating that an object is a source of
bean definitions. `@Configuration` classes declare beans through public `@Bean` annotated
methods. Calls to `@Bean` methods on `@Configuration` classes can also be used to define
inter-bean dependencies. See <<beans-java-basic-concepts>> for a general introduction.


[[beans-java-injecting-dependencies]]
==== Injecting Inter-bean Dependencies

When beans have dependencies on one another, expressing that dependency is as simple
as having one bean method call another, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class AppConfig {

		@Bean
		public BeanOne beanOne() {
			return new BeanOne(beanTwo());
		}

		@Bean
		public BeanTwo beanTwo() {
			return new BeanTwo();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class AppConfig {

		@Bean
		fun beanOne() = BeanOne(beanTwo())

		@Bean
		fun beanTwo() = BeanTwo()
	}
----

In the preceding example, `beanOne` receives a reference to `beanTwo` through constructor
injection.

NOTE: This method of declaring inter-bean dependencies works only when the `@Bean` method
is declared within a `@Configuration` class. You cannot declare inter-bean dependencies
by using plain `@Component` classes.



[[beans-java-method-injection]]
==== Lookup Method Injection

As noted earlier, <<beans-factory-method-injection, lookup method injection>> is an
advanced feature that you should use rarely. It is useful in cases where a
singleton-scoped bean has a dependency on a prototype-scoped bean. Using Java for this
type of configuration provides a natural means for implementing this pattern. The
following example shows how to use lookup method injection:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public abstract class CommandManager {
		public Object process(Object commandState) {
			// grab a new instance of the appropriate Command interface
			Command command = createCommand();
			// set the state on the (hopefully brand new) Command instance
			command.setState(commandState);
			return command.execute();
		}

		// okay... but where is the implementation of this method?
		protected abstract Command createCommand();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	abstract class CommandManager {
		fun process(commandState: Any): Any {
			// grab a new instance of the appropriate Command interface
			val command = createCommand()
			// set the state on the (hopefully brand new) Command instance
			command.setState(commandState)
			return command.execute()
		}

		// okay... but where is the implementation of this method?
		protected abstract fun createCommand(): Command
	}
----

By using Java configuration, you can create a subclass of `CommandManager` where
the abstract `createCommand()` method is overridden in such a way that it looks up a new
(prototype) command object. The following example shows how to do so:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Bean
	@Scope("prototype")
	public AsyncCommand asyncCommand() {
		AsyncCommand command = new AsyncCommand();
		// inject dependencies here as required
		return command;
	}

	@Bean
	public CommandManager commandManager() {
		// return new anonymous implementation of CommandManager with createCommand()
		// overridden to return a new prototype Command object
		return new CommandManager() {
			protected Command createCommand() {
				return asyncCommand();
			}
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Bean
	@Scope("prototype")
	fun asyncCommand(): AsyncCommand {
		val command = AsyncCommand()
		// inject dependencies here as required
		return command
	}

	@Bean
	fun commandManager(): CommandManager {
		// return new anonymous implementation of CommandManager with createCommand()
		// overridden to return a new prototype Command object
		return object : CommandManager() {
			override fun createCommand(): Command {
				return asyncCommand()
			}
		}
	}
----


[[beans-java-further-information-java-config]]
==== Further Information About How Java-based Configuration Works Internally

Consider the following example, which shows a `@Bean` annotated method being called twice:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class AppConfig {

		@Bean
		public ClientService clientService1() {
			ClientServiceImpl clientService = new ClientServiceImpl();
			clientService.setClientDao(clientDao());
			return clientService;
		}

		@Bean
		public ClientService clientService2() {
			ClientServiceImpl clientService = new ClientServiceImpl();
			clientService.setClientDao(clientDao());
			return clientService;
		}

		@Bean
		public ClientDao clientDao() {
			return new ClientDaoImpl();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class AppConfig {

		@Bean
		fun clientService1(): ClientService {
			return ClientServiceImpl().apply {
				clientDao = clientDao()
			}
		}

		@Bean
		fun clientService2(): ClientService {
			return ClientServiceImpl().apply {
				clientDao = clientDao()
			}
		}

		@Bean
		fun clientDao(): ClientDao {
			return ClientDaoImpl()
		}
	}
----

`clientDao()` has been called once in `clientService1()` and once in `clientService2()`.
Since this method creates a new instance of `ClientDaoImpl` and returns it, you would
normally expect to have two instances (one for each service). That definitely would be
problematic: In Spring, instantiated beans have a `singleton` scope by default. This is
where the magic comes in: All `@Configuration` classes are subclassed at startup-time
with `CGLIB`. In the subclass, the child method checks the container first for any
cached (scoped) beans before it calls the parent method and creates a new instance.

NOTE: The behavior could be different according to the scope of your bean. We are talking
about singletons here.

[NOTE]
====
As of Spring 3.2, it is no longer necessary to add CGLIB to your classpath because CGLIB
classes have been repackaged under `org.springframework.cglib` and included directly
within the spring-core JAR.
====

[TIP]
====
There are a few restrictions due to the fact that CGLIB dynamically adds features at
startup-time. In particular, configuration classes must not be final. However, as
of 4.3, any constructors are allowed on configuration classes, including the use of
`@Autowired` or a single non-default constructor declaration for default injection.

If you prefer to avoid any CGLIB-imposed limitations, consider declaring your `@Bean`
methods on non-`@Configuration` classes (for example, on plain `@Component` classes instead).
Cross-method calls between `@Bean` methods are not then intercepted, so you have
to exclusively rely on dependency injection at the constructor or method level there.
====



[[beans-java-composing-configuration-classes]]
=== Composing Java-based Configurations

Spring's Java-based configuration feature lets you compose annotations, which can reduce
the complexity of your configuration.


[[beans-java-using-import]]
==== Using the `@Import` Annotation

Much as the `<import/>` element is used within Spring XML files to aid in modularizing
configurations, the `@Import` annotation allows for loading `@Bean` definitions from
another configuration class, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class ConfigA {

		@Bean
		public A a() {
			return new A();
		}
	}

	@Configuration
	@Import(ConfigA.class)
	public class ConfigB {

		@Bean
		public B b() {
			return new B();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class ConfigA {

		@Bean
		fun a() = A()
	}

	@Configuration
	@Import(ConfigA::class)
	class ConfigB {

		@Bean
		fun b() = B()
	}
----

Now, rather than needing to specify both `ConfigA.class` and `ConfigB.class` when
instantiating the context, only `ConfigB` needs to be supplied explicitly, as the
following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public static void main(String[] args) {
		ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class);

		// now both beans A and B will be available...
		A a = ctx.getBean(A.class);
		B b = ctx.getBean(B.class);
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.beans.factory.getBean

	fun main() {
		val ctx = AnnotationConfigApplicationContext(ConfigB::class.java)

		// now both beans A and B will be available...
		val a = ctx.getBean<A>()
		val b = ctx.getBean<B>()
	}
----

This approach simplifies container instantiation, as only one class needs to be dealt
with, rather than requiring you to remember a potentially large number of
`@Configuration` classes during construction.

TIP: As of Spring Framework 4.2, `@Import` also supports references to regular component
classes, analogous to the `AnnotationConfigApplicationContext.register` method.
This is particularly useful if you want to avoid component scanning, by using a few
configuration classes as entry points to explicitly define all your components.

[[beans-java-injecting-imported-beans]]
===== Injecting Dependencies on Imported `@Bean` Definitions

The preceding example works but is simplistic. In most practical scenarios, beans have
dependencies on one another across configuration classes. When using XML, this is not an
issue, because no compiler is involved, and you can declare
`ref="someBean"` and trust Spring to work it out during container initialization.
When using `@Configuration` classes, the Java compiler places constraints on
the configuration model, in that references to other beans must be valid Java syntax.

Fortunately, solving this problem is simple. As <<beans-java-dependencies, we already discussed>>,
a `@Bean` method can have an arbitrary number of parameters that describe the bean
dependencies. Consider the following more real-world scenario with several `@Configuration`
classes, each depending on beans declared in the others:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class ServiceConfig {

		@Bean
		public TransferService transferService(AccountRepository accountRepository) {
			return new TransferServiceImpl(accountRepository);
		}
	}

	@Configuration
	public class RepositoryConfig {

		@Bean
		public AccountRepository accountRepository(DataSource dataSource) {
			return new JdbcAccountRepository(dataSource);
		}
	}

	@Configuration
	@Import({ServiceConfig.class, RepositoryConfig.class})
	public class SystemTestConfig {

		@Bean
		public DataSource dataSource() {
			// return new DataSource
		}
	}

	public static void main(String[] args) {
		ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
		// everything wires up across configuration classes...
		TransferService transferService = ctx.getBean(TransferService.class);
		transferService.transfer(100.00, "A123", "C456");
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.beans.factory.getBean

	@Configuration
	class ServiceConfig {

		@Bean
		fun transferService(accountRepository: AccountRepository): TransferService {
			return TransferServiceImpl(accountRepository)
		}
	}

	@Configuration
	class RepositoryConfig {

		@Bean
		fun accountRepository(dataSource: DataSource): AccountRepository {
			return JdbcAccountRepository(dataSource)
		}
	}

	@Configuration
	@Import(ServiceConfig::class, RepositoryConfig::class)
	class SystemTestConfig {

		@Bean
		fun dataSource(): DataSource {
			// return new DataSource
		}
	}


	fun main() {
		val ctx = AnnotationConfigApplicationContext(SystemTestConfig::class.java)
		// everything wires up across configuration classes...
		val transferService = ctx.getBean<TransferService>()
		transferService.transfer(100.00, "A123", "C456")
	}
----


There is another way to achieve the same result. Remember that `@Configuration` classes are
ultimately only another bean in the container: This means that they can take advantage of
`@Autowired` and `@Value` injection and other features the same as any other bean.

[WARNING]
====
Make sure that the dependencies you inject that way are of the simplest kind only. `@Configuration`
classes are processed quite early during the initialization of the context, and forcing a dependency
to be injected this way may lead to unexpected early initialization. Whenever possible, resort to
parameter-based injection, as in the preceding example.

Also, be particularly careful with `BeanPostProcessor` and `BeanFactoryPostProcessor` definitions
through `@Bean`. Those should usually be declared as `static @Bean` methods, not triggering the
instantiation of their containing configuration class. Otherwise, `@Autowired` and `@Value` do not
work on the configuration class itself, since it is being created as a bean instance too early.
====

The following example shows how one bean can be autowired to another bean:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class ServiceConfig {

		@Autowired
		private AccountRepository accountRepository;

		@Bean
		public TransferService transferService() {
			return new TransferServiceImpl(accountRepository);
		}
	}

	@Configuration
	public class RepositoryConfig {

		private final DataSource dataSource;

		public RepositoryConfig(DataSource dataSource) {
			this.dataSource = dataSource;
		}

		@Bean
		public AccountRepository accountRepository() {
			return new JdbcAccountRepository(dataSource);
		}
	}

	@Configuration
	@Import({ServiceConfig.class, RepositoryConfig.class})
	public class SystemTestConfig {

		@Bean
		public DataSource dataSource() {
			// return new DataSource
		}
	}

	public static void main(String[] args) {
		ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
		// everything wires up across configuration classes...
		TransferService transferService = ctx.getBean(TransferService.class);
		transferService.transfer(100.00, "A123", "C456");
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.beans.factory.getBean

	@Configuration
	class ServiceConfig {

		@Autowired
		lateinit var accountRepository: AccountRepository

		@Bean
		fun transferService(): TransferService {
			return TransferServiceImpl(accountRepository)
		}
	}

	@Configuration
	class RepositoryConfig(private val dataSource: DataSource) {

		@Bean
		fun accountRepository(): AccountRepository {
			return JdbcAccountRepository(dataSource)
		}
	}

	@Configuration
	@Import(ServiceConfig::class, RepositoryConfig::class)
	class SystemTestConfig {

		@Bean
		fun dataSource(): DataSource {
			// return new DataSource
		}
	}

	fun main() {
		val ctx = AnnotationConfigApplicationContext(SystemTestConfig::class.java)
		// everything wires up across configuration classes...
		val transferService = ctx.getBean<TransferService>()
		transferService.transfer(100.00, "A123", "C456")
	}
----

TIP: Constructor injection in `@Configuration` classes is only supported as of Spring
Framework 4.3. Note also that there is no need to specify `@Autowired` if the target
bean defines only one constructor.

.[[beans-java-injecting-imported-beans-fq]]Fully-qualifying imported beans for ease of navigation
--
In the preceding scenario, using `@Autowired` works well and provides the desired
modularity, but determining exactly where the autowired bean definitions are declared is
still somewhat ambiguous. For example, as a developer looking at `ServiceConfig`, how do
you know exactly where the `@Autowired AccountRepository` bean is declared? It is not
explicit in the code, and this may be just fine. Remember that the
https://spring.io/tools/sts[Spring Tool Suite] provides tooling that
can render graphs showing how everything is wired, which may be all you need. Also,
your Java IDE can easily find all declarations and uses of the `AccountRepository` type
and quickly show you the location of `@Bean` methods that return that type.

In cases where this ambiguity is not acceptable and you wish to have direct navigation
from within your IDE from one `@Configuration` class to another, consider autowiring the
configuration classes themselves. The following example shows how to do so:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class ServiceConfig {

		@Autowired
		private RepositoryConfig repositoryConfig;

		@Bean
		public TransferService transferService() {
			// navigate 'through' the config class to the @Bean method!
			return new TransferServiceImpl(repositoryConfig.accountRepository());
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
@Configuration
class ServiceConfig {

	@Autowired
	private lateinit var repositoryConfig: RepositoryConfig

	@Bean
	fun transferService(): TransferService {
		// navigate 'through' the config class to the @Bean method!
		return TransferServiceImpl(repositoryConfig.accountRepository())
	}
}
----

In the preceding situation, where `AccountRepository` is defined is completely explicit.
However, `ServiceConfig` is now tightly coupled to `RepositoryConfig`. That is the
tradeoff. This tight coupling can be somewhat mitigated by using interface-based or
abstract class-based `@Configuration` classes. Consider the following example:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class ServiceConfig {

		@Autowired
		private RepositoryConfig repositoryConfig;

		@Bean
		public TransferService transferService() {
			return new TransferServiceImpl(repositoryConfig.accountRepository());
		}
	}

	@Configuration
	public interface RepositoryConfig {

		@Bean
		AccountRepository accountRepository();
	}

	@Configuration
	public class DefaultRepositoryConfig implements RepositoryConfig {

		@Bean
		public AccountRepository accountRepository() {
			return new JdbcAccountRepository(...);
		}
	}

	@Configuration
	@Import({ServiceConfig.class, DefaultRepositoryConfig.class})  // import the concrete config!
	public class SystemTestConfig {

		@Bean
		public DataSource dataSource() {
			// return DataSource
		}

	}

	public static void main(String[] args) {
		ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
		TransferService transferService = ctx.getBean(TransferService.class);
		transferService.transfer(100.00, "A123", "C456");
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.beans.factory.getBean

	@Configuration
	class ServiceConfig {

		@Autowired
		private lateinit var repositoryConfig: RepositoryConfig

		@Bean
		fun transferService(): TransferService {
			return TransferServiceImpl(repositoryConfig.accountRepository())
		}
	}

	@Configuration
	interface RepositoryConfig {

		@Bean
		fun accountRepository(): AccountRepository
	}

	@Configuration
	class DefaultRepositoryConfig : RepositoryConfig {

		@Bean
		fun accountRepository(): AccountRepository {
			return JdbcAccountRepository(...)
		}
	}

	@Configuration
	@Import(ServiceConfig::class, DefaultRepositoryConfig::class)  // import the concrete config!
	class SystemTestConfig {

		@Bean
		fun dataSource(): DataSource {
			// return DataSource
		}

	}

	fun main() {
		val ctx = AnnotationConfigApplicationContext(SystemTestConfig::class.java)
		val transferService = ctx.getBean<TransferService>()
		transferService.transfer(100.00, "A123", "C456")
	}
----

Now `ServiceConfig` is loosely coupled with respect to the concrete
`DefaultRepositoryConfig`, and built-in IDE tooling is still useful: You can easily
get a type hierarchy of `RepositoryConfig` implementations. In this
way, navigating `@Configuration` classes and their dependencies becomes no different
than the usual process of navigating interface-based code.
--

TIP: If you want to influence the startup creation order of certain beans, consider
declaring some of them as `@Lazy` (for creation on first access instead of on startup)
or as `@DependsOn` certain other beans (making sure that specific other beans are
created before the current bean, beyond what the latter's direct dependencies imply).


[[beans-java-conditional]]
==== Conditionally Include `@Configuration` Classes or `@Bean` Methods

It is often useful to conditionally enable or disable a complete `@Configuration` class
or even individual `@Bean` methods, based on some arbitrary system state. One common
example of this is to use the `@Profile` annotation to activate beans only when a specific
profile has been enabled in the Spring `Environment` (see <<beans-definition-profiles>>
for details).

The `@Profile` annotation is actually implemented by using a much more flexible annotation
called {api-spring-framework}/context/annotation/Conditional.html[`@Conditional`].
The `@Conditional` annotation indicates specific
`org.springframework.context.annotation.Condition` implementations that should be
consulted before a `@Bean` is registered.

Implementations of the `Condition` interface provide a `matches(...)`
method that returns `true` or `false`. For example, the following listing shows the actual
`Condition` implementation used for `@Profile`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Override
	public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
		// Read the @Profile annotation attributes
		MultiValueMap<String, Object> attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());
		if (attrs != null) {
			for (Object value : attrs.get("value")) {
				if (context.getEnvironment().acceptsProfiles(((String[]) value))) {
					return true;
				}
			}
			return false;
		}
		return true;
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	override fun matches(context: ConditionContext, metadata: AnnotatedTypeMetadata): Boolean {
		// Read the @Profile annotation attributes
		val attrs = metadata.getAllAnnotationAttributes(Profile::class.java.name)
		if (attrs != null) {
			for (value in attrs["value"]!!) {
				if (context.environment.acceptsProfiles(Profiles .of(*value as Array<String>))) {
					return true
				}
			}
			return false
		}
		return true
	}
----

See the {api-spring-framework}/context/annotation/Conditional.html[`@Conditional`]
javadoc for more detail.


[[beans-java-combining]]
==== Combining Java and XML Configuration

Spring's `@Configuration` class support does not aim to be a 100% complete replacement
for Spring XML. Some facilities, such as Spring XML namespaces, remain an ideal way to
configure the container. In cases where XML is convenient or necessary, you have a
choice: either instantiate the container in an "`XML-centric`" way by using, for example,
`ClassPathXmlApplicationContext`, or instantiate it in a "`Java-centric`" way by using
`AnnotationConfigApplicationContext` and the `@ImportResource` annotation to import XML
as needed.

[[beans-java-combining-xml-centric]]
===== XML-centric Use of `@Configuration` Classes

It may be preferable to bootstrap the Spring container from XML and include
`@Configuration` classes in an ad-hoc fashion. For example, in a large existing codebase
that uses Spring XML, it is easier to create `@Configuration` classes on an
as-needed basis and include them from the existing XML files. Later in this section, we cover the
options for using `@Configuration` classes in this kind of "`XML-centric`" situation.

.[[beans-java-combining-xml-centric-declare-as-bean]]Declaring `@Configuration` classes as plain Spring `<bean/>` elements
--
Remember that `@Configuration` classes are ultimately bean definitions in the
container. In this series examples, we create a `@Configuration` class named `AppConfig` and
include it within `system-test-config.xml` as a `<bean/>` definition. Because
`<context:annotation-config/>` is switched on, the container recognizes the
`@Configuration` annotation and processes the `@Bean` methods declared in `AppConfig`
properly.

The following example shows an ordinary configuration class in Java:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class AppConfig {

		@Autowired
		private DataSource dataSource;

		@Bean
		public AccountRepository accountRepository() {
			return new JdbcAccountRepository(dataSource);
		}

		@Bean
		public TransferService transferService() {
			return new TransferService(accountRepository());
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class AppConfig {

		@Autowired
		private lateinit var dataSource: DataSource

		@Bean
		fun accountRepository(): AccountRepository {
			return JdbcAccountRepository(dataSource)
		}

		@Bean
		fun transferService() = TransferService(accountRepository())
	}
----

The following example shows part of a sample `system-test-config.xml` file:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<!-- enable processing of annotations such as @Autowired and @Configuration -->
		<context:annotation-config/>
		<context:property-placeholder location="classpath:/com/acme/jdbc.properties"/>

		<bean class="com.acme.AppConfig"/>

		<bean class="org.springframework.jdbc.datasource.DriverManagerDataSource">
			<property name="url" value="${jdbc.url}"/>
			<property name="username" value="${jdbc.username}"/>
			<property name="password" value="${jdbc.password}"/>
		</bean>
	</beans>
----

The following example shows a possible `jdbc.properties` file:

[literal,subs="verbatim,quotes"]
----
jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
jdbc.username=sa
jdbc.password=
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public static void main(String[] args) {
		ApplicationContext ctx = new ClassPathXmlApplicationContext("classpath:/com/acme/system-test-config.xml");
		TransferService transferService = ctx.getBean(TransferService.class);
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun main() {
		val ctx = ClassPathXmlApplicationContext("classpath:/com/acme/system-test-config.xml")
		val transferService = ctx.getBean<TransferService>()
		// ...
	}
----


NOTE: In `system-test-config.xml` file, the `AppConfig` `<bean/>` does not declare an `id`
element. While it would be acceptable to do so, it is unnecessary, given that no other bean
ever refers to it, and it is unlikely to be explicitly fetched from the container by name.
Similarly, the `DataSource` bean is only ever autowired by type, so an explicit bean `id`
is not strictly required.
--

.[[beans-java-combining-xml-centric-component-scan]] Using <context:component-scan/> to pick up `@Configuration` classes
--
Because `@Configuration` is meta-annotated with `@Component`, `@Configuration`-annotated
classes are automatically candidates for component scanning. Using the same scenario as
describe in the previous example, we can redefine `system-test-config.xml` to take advantage of component-scanning.
Note that, in this case, we need not explicitly declare
`<context:annotation-config/>`, because `<context:component-scan/>` enables the same
functionality.

The following example shows the modified `system-test-config.xml` file:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<!-- picks up and registers AppConfig as a bean definition -->
		<context:component-scan base-package="com.acme"/>
		<context:property-placeholder location="classpath:/com/acme/jdbc.properties"/>

		<bean class="org.springframework.jdbc.datasource.DriverManagerDataSource">
			<property name="url" value="${jdbc.url}"/>
			<property name="username" value="${jdbc.username}"/>
			<property name="password" value="${jdbc.password}"/>
		</bean>
	</beans>
----
--

[[beans-java-combining-java-centric]]
===== `@Configuration` Class-centric Use of XML with `@ImportResource`

In applications where `@Configuration` classes are the primary mechanism for configuring
the container, it is still likely necessary to use at least some XML. In these
scenarios, you can use `@ImportResource` and define only as much XML as you need. Doing
so achieves a "`Java-centric`" approach to configuring the container and keeps XML to a
bare minimum. The following example (which includes a configuration class, an XML file
that defines a bean, a properties file, and the `main` class) shows how to use
the `@ImportResource` annotation to achieve "`Java-centric`" configuration that uses XML
as needed:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@ImportResource("classpath:/com/acme/properties-config.xml")
	public class AppConfig {

		@Value("${jdbc.url}")
		private String url;

		@Value("${jdbc.username}")
		private String username;

		@Value("${jdbc.password}")
		private String password;

		@Bean
		public DataSource dataSource() {
			return new DriverManagerDataSource(url, username, password);
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@ImportResource("classpath:/com/acme/properties-config.xml")
	class AppConfig {

		@Value("\${jdbc.url}")
		private lateinit var url: String

		@Value("\${jdbc.username}")
		private lateinit var username: String

		@Value("\${jdbc.password}")
		private lateinit var password: String

		@Bean
		fun dataSource(): DataSource {
			return DriverManagerDataSource(url, username, password)
		}
	}
----

[source,xml,indent=0,subs="verbatim,quotes"]
----
	properties-config.xml
	<beans>
		<context:property-placeholder location="classpath:/com/acme/jdbc.properties"/>
	</beans>
----

[literal,subs="verbatim,quotes"]
----
jdbc.properties
jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
jdbc.username=sa
jdbc.password=
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public static void main(String[] args) {
		ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
		TransferService transferService = ctx.getBean(TransferService.class);
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.beans.factory.getBean

	fun main() {
		val ctx = AnnotationConfigApplicationContext(AppConfig::class.java)
		val transferService = ctx.getBean<TransferService>()
		// ...
	}
----



[[beans-environment]]
== Environment Abstraction

The {api-spring-framework}/core/env/Environment.html[`Environment`] interface
is an abstraction integrated in the container that models two key
aspects of the application environment: <<beans-definition-profiles, profiles>>
and <<beans-property-source-abstraction, properties>>.

A profile is a named, logical group of bean definitions to be registered with the
container only if the given profile is active. Beans may be assigned to a profile
whether defined in XML or with annotations. The role of the `Environment` object with
relation to profiles is in determining which profiles (if any) are currently active,
and which profiles (if any) should be active by default.

Properties play an important role in almost all applications and may originate from
a variety of sources: properties files, JVM system properties, system environment
variables, JNDI, servlet context parameters, ad-hoc `Properties` objects, `Map` objects, and so
on. The role of the `Environment` object with relation to properties is to provide the
user with a convenient service interface for configuring property sources and resolving
properties from them.



[[beans-definition-profiles]]
=== Bean Definition Profiles

Bean definition profiles provide a mechanism in the core container that allows for
registration of different beans in different environments. The word, "`environment,`"
can mean different things to different users, and this feature can help with many
use cases, including:

* Working against an in-memory datasource in development versus looking up that same
datasource from JNDI when in QA or production.
* Registering monitoring infrastructure only when deploying an application into a
performance environment.
* Registering customized implementations of beans for customer A versus customer
B deployments.

Consider the first use case in a practical application that requires a
`DataSource`. In a test environment, the configuration might resemble the following:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Bean
	public DataSource dataSource() {
		return new EmbeddedDatabaseBuilder()
			.setType(EmbeddedDatabaseType.HSQL)
			.addScript("my-schema.sql")
			.addScript("my-test-data.sql")
			.build();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Bean
	fun dataSource(): DataSource {
		return EmbeddedDatabaseBuilder()
				.setType(EmbeddedDatabaseType.HSQL)
				.addScript("my-schema.sql")
				.addScript("my-test-data.sql")
				.build()
	}
----

Now consider how this application can be deployed into a QA or production
environment, assuming that the datasource for the application is registered
with the production application server's JNDI directory. Our `dataSource` bean
now looks like the following listing:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Bean(destroyMethod="")
	public DataSource dataSource() throws Exception {
		Context ctx = new InitialContext();
		return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Bean(destroyMethod = "")
	fun dataSource(): DataSource {
		val ctx = InitialContext()
		return ctx.lookup("java:comp/env/jdbc/datasource") as DataSource
	}
----

The problem is how to switch between using these two variations based on the
current environment. Over time, Spring users have devised a number of ways to
get this done, usually relying on a combination of system environment variables
and XML `<import/>` statements containing `${placeholder}` tokens that resolve
to the correct configuration file path depending on the value of an environment
variable. Bean definition profiles is a core container feature that provides a
solution to this problem.

If we generalize the use case shown in the preceding example of environment-specific bean
definitions, we end up with the need to register certain bean definitions in
certain contexts but not in others. You could say that you want to register a
certain profile of bean definitions in situation A and a different profile in
situation B. We start by updating our configuration to reflect this need.


[[beans-definition-profiles-java]]
==== Using `@Profile`

The {api-spring-framework}/context/annotation/Profile.html[`@Profile`]
annotation lets you indicate that a component is eligible for registration
when one or more specified profiles are active. Using our preceding example, we
can rewrite the `dataSource` configuration as follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@Profile("development")
	public class StandaloneDataConfig {

		@Bean
		public DataSource dataSource() {
			return new EmbeddedDatabaseBuilder()
				.setType(EmbeddedDatabaseType.HSQL)
				.addScript("classpath:com/bank/config/sql/schema.sql")
				.addScript("classpath:com/bank/config/sql/test-data.sql")
				.build();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@Profile("development")
	class StandaloneDataConfig {

		@Bean
		fun dataSource(): DataSource {
			return EmbeddedDatabaseBuilder()
					.setType(EmbeddedDatabaseType.HSQL)
					.addScript("classpath:com/bank/config/sql/schema.sql")
					.addScript("classpath:com/bank/config/sql/test-data.sql")
					.build()
		}
	}
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@Profile("production")
	public class JndiDataConfig {

		@Bean(destroyMethod="")
		public DataSource dataSource() throws Exception {
			Context ctx = new InitialContext();
			return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@Profile("production")
	class JndiDataConfig {

		@Bean(destroyMethod = "")
		fun dataSource(): DataSource {
			val ctx = InitialContext()
			return ctx.lookup("java:comp/env/jdbc/datasource") as DataSource
		}
	}
----

NOTE: As mentioned earlier, with `@Bean` methods, you typically choose to use programmatic
JNDI lookups, by using either Spring's `JndiTemplate`/`JndiLocatorDelegate` helpers or the
straight JNDI `InitialContext` usage shown earlier but not the `JndiObjectFactoryBean`
variant, which would force you to declare the return type as the `FactoryBean` type.

The profile string may contain a simple profile name (for example, `production`) or a
profile expression. A profile expression allows for more complicated profile logic to be
expressed (for example, `production & us-east`). The following operators are supported in
profile expressions:

* `!`: A logical "`not`" of the profile
* `&`: A logical "`and`" of the profiles
* `|`: A logical "`or`" of the profiles

NOTE: You cannot mix the `&` and `|` operators without using parentheses. For example,
`production & us-east | eu-central` is not a valid expression. It must be expressed as
`production & (us-east | eu-central)`.

You can use `@Profile` as a <<beans-meta-annotations, meta-annotation>> for the purpose
of creating a custom composed annotation. The following example defines a custom
`@Production` annotation that you can use as a drop-in replacement for
`@Profile("production")`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@Profile("production")
	public @interface Production {
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Target(AnnotationTarget.TYPE)
	@Retention(AnnotationRetention.RUNTIME)
	@Profile("production")
	annotation class Production
----

TIP: If a `@Configuration` class is marked with `@Profile`, all of the `@Bean` methods and
`@Import` annotations associated with that class are bypassed unless one or more of
the specified profiles are active. If a `@Component` or `@Configuration` class is marked
with `@Profile({"p1", "p2"})`, that class is not registered or processed unless
profiles 'p1' or 'p2' have been activated. If a given profile is prefixed with the
NOT operator (`!`), the annotated element is registered only if the profile is not
active. For example, given `@Profile({"p1", "!p2"})`, registration will occur if profile
'p1' is active or if profile 'p2' is not active.

`@Profile` can also be declared at the method level to include only one particular bean
of a configuration class (for example, for alternative variants of a particular bean), as
the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class AppConfig {

		@Bean("dataSource")
		@Profile("development") // <1>
		public DataSource standaloneDataSource() {
			return new EmbeddedDatabaseBuilder()
				.setType(EmbeddedDatabaseType.HSQL)
				.addScript("classpath:com/bank/config/sql/schema.sql")
				.addScript("classpath:com/bank/config/sql/test-data.sql")
				.build();
		}

		@Bean("dataSource")
		@Profile("production") // <2>
		public DataSource jndiDataSource() throws Exception {
			Context ctx = new InitialContext();
			return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
		}
	}
----
<1> The `standaloneDataSource` method is available only in the `development` profile.
<2> The `jndiDataSource` method is available only in the `production` profile.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class AppConfig {

		@Bean("dataSource")
		@Profile("development") // <1>
		fun standaloneDataSource(): DataSource {
			return EmbeddedDatabaseBuilder()
					.setType(EmbeddedDatabaseType.HSQL)
					.addScript("classpath:com/bank/config/sql/schema.sql")
					.addScript("classpath:com/bank/config/sql/test-data.sql")
					.build()
		}

		@Bean("dataSource")
		@Profile("production") // <2>
		fun jndiDataSource() =
			InitialContext().lookup("java:comp/env/jdbc/datasource") as DataSource
	}
----
<1> The `standaloneDataSource` method is available only in the `development` profile.
<2> The `jndiDataSource` method is available only in the `production` profile.

[NOTE]
====
With `@Profile` on `@Bean` methods, a special scenario may apply: In the case of
overloaded `@Bean` methods of the same Java method name (analogous to constructor
overloading), a `@Profile` condition needs to be consistently declared on all
overloaded methods. If the conditions are inconsistent, only the condition on the
first declaration among the overloaded methods matters. Therefore, `@Profile` can
not be used to select an overloaded method with a particular argument signature over
another. Resolution between all factory methods for the same bean follows Spring's
constructor resolution algorithm at creation time.

If you want to define alternative beans with different profile conditions,
use distinct Java method names that point to the same bean name by using the `@Bean` name
attribute, as shown in the preceding example. If the argument signatures are all
the same (for example, all of the variants have no-arg factory methods), this is the only
way to represent such an arrangement in a valid Java class in the first place
(since there can only be one method of a particular name and argument signature).
====


[[beans-definition-profiles-xml]]
==== XML Bean Definition Profiles

The XML counterpart is the `profile` attribute of the `<beans>` element. Our preceding sample
configuration can be rewritten in two XML files, as follows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans profile="development"
		xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:jdbc="http://www.springframework.org/schema/jdbc"
		xsi:schemaLocation="...">

		<jdbc:embedded-database id="dataSource">
			<jdbc:script location="classpath:com/bank/config/sql/schema.sql"/>
			<jdbc:script location="classpath:com/bank/config/sql/test-data.sql"/>
		</jdbc:embedded-database>
	</beans>
----

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans profile="production"
		xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:jee="http://www.springframework.org/schema/jee"
		xsi:schemaLocation="...">

		<jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/datasource"/>
	</beans>
----

It is also possible to avoid that split and nest `<beans/>` elements within the same file,
as the following example shows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:jdbc="http://www.springframework.org/schema/jdbc"
		xmlns:jee="http://www.springframework.org/schema/jee"
		xsi:schemaLocation="...">

		<!-- other bean definitions -->

		<beans profile="development">
			<jdbc:embedded-database id="dataSource">
				<jdbc:script location="classpath:com/bank/config/sql/schema.sql"/>
				<jdbc:script location="classpath:com/bank/config/sql/test-data.sql"/>
			</jdbc:embedded-database>
		</beans>

		<beans profile="production">
			<jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/datasource"/>
		</beans>
	</beans>
----

The `spring-bean.xsd` has been constrained to allow such elements only as the
last ones in the file. This should help provide flexibility without incurring
clutter in the XML files.

[NOTE]
=====
The XML counterpart does not support the profile expressions described earlier. It is possible,
however, to negate a profile by using the `!` operator. It is also possible to apply a logical
"`and`" by nesting the profiles, as the following example shows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:jdbc="http://www.springframework.org/schema/jdbc"
		xmlns:jee="http://www.springframework.org/schema/jee"
		xsi:schemaLocation="...">

		<!-- other bean definitions -->

		<beans profile="production">
			<beans profile="us-east">
				<jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/datasource"/>
			</beans>
		</beans>
	</beans>
----

In the preceding example, the `dataSource` bean is exposed if both the `production` and
`us-east` profiles are active.
=====


[[beans-definition-profiles-enable]]
==== Activating a Profile

Now that we have updated our configuration, we still need to instruct Spring which
profile is active. If we started our sample application right now, we would see
a `NoSuchBeanDefinitionException` thrown, because the container could not find
the Spring bean named `dataSource`.

Activating a profile can be done in several ways, but the most straightforward is to do
it programmatically against the `Environment` API which is available through an
`ApplicationContext`. The following example shows how to do so:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
	ctx.getEnvironment().setActiveProfiles("development");
	ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);
	ctx.refresh();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val ctx = AnnotationConfigApplicationContext().apply {
		environment.setActiveProfiles("development")
		register(SomeConfig::class.java, StandaloneDataConfig::class.java, JndiDataConfig::class.java)
		refresh()	
	}
----

In addition, you can also declaratively activate profiles through the
`spring.profiles.active` property, which may be specified through system environment
variables, JVM system properties, servlet context parameters in `web.xml`, or even as an
entry in JNDI (see <<beans-property-source-abstraction>>). In integration tests, active
profiles can be declared by using the `@ActiveProfiles` annotation in the `spring-test`
module (see <<testing.adoc#testcontext-ctx-management-env-profiles,
context configuration with environment profiles>>).

Note that profiles are not an "`either-or`" proposition. You can activate multiple
profiles at once. Programmatically, you can provide multiple profile names to the
`setActiveProfiles()` method, which accepts `String...` varargs. The following example
activates multiple profiles:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	ctx.getEnvironment().setActiveProfiles("profile1", "profile2");
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	ctx.getEnvironment().setActiveProfiles("profile1", "profile2")
----

Declaratively, `spring.profiles.active` may accept a comma-separated list of profile names,
as the following example shows:

[literal,subs="verbatim,quotes"]
----
	-Dspring.profiles.active="profile1,profile2"
----


[[beans-definition-profiles-default]]
==== Default Profile

The default profile represents the profile that is enabled by default. Consider the
following example:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@Profile("default")
	public class DefaultDataConfig {

		@Bean
		public DataSource dataSource() {
			return new EmbeddedDatabaseBuilder()
				.setType(EmbeddedDatabaseType.HSQL)
				.addScript("classpath:com/bank/config/sql/schema.sql")
				.build();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@Profile("default")
	class DefaultDataConfig {

		@Bean
		fun dataSource(): DataSource {
			return EmbeddedDatabaseBuilder()
					.setType(EmbeddedDatabaseType.HSQL)
					.addScript("classpath:com/bank/config/sql/schema.sql")
					.build()
		}
	}
----

If no profile is active, the `dataSource` is created. You can see this
as a way to provide a default definition for one or more beans. If any
profile is enabled, the default profile does not apply.

You can change the name of the default profile by using `setDefaultProfiles()` on
the `Environment` or ,declaratively, by using the `spring.profiles.default` property.



[[beans-property-source-abstraction]]
=== `PropertySource` Abstraction

Spring's `Environment` abstraction provides search operations over a configurable
hierarchy of property sources. Consider the following listing:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	ApplicationContext ctx = new GenericApplicationContext();
	Environment env = ctx.getEnvironment();
	boolean containsMyProperty = env.containsProperty("my-property");
	System.out.println("Does my environment contain the 'my-property' property? " + containsMyProperty);
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val ctx = GenericApplicationContext()
	val env = ctx.environment
	val containsMyProperty = env.containsProperty("my-property")
	println("Does my environment contain the 'my-property' property? $containsMyProperty")
----

In the preceding snippet, we see a high-level way of asking Spring whether the `my-property` property is
defined for the current environment. To answer this question, the `Environment` object performs
a search over a set of {api-spring-framework}/core/env/PropertySource.html[`PropertySource`]
objects. A `PropertySource` is a simple abstraction over any source of key-value pairs, and
Spring's {api-spring-framework}/core/env/StandardEnvironment.html[`StandardEnvironment`]
is configured with two PropertySource objects -- one representing the set of JVM system properties
(`System.getProperties()`) and one representing the set of system environment variables
(`System.getenv()`).

NOTE: These default property sources are present for `StandardEnvironment`, for use in standalone
applications. {api-spring-framework}/web/context/support/StandardServletEnvironment.html[`StandardServletEnvironment`]
is populated with additional default property sources including servlet config and servlet
context parameters. It can optionally enable a {api-spring-framework}/jndi/JndiPropertySource.html[`JndiPropertySource`].
See the javadoc for details.

Concretely, when you use the `StandardEnvironment`, the call to `env.containsProperty("my-property")`
returns true if a `my-property` system property or `my-property` environment variable is present at
runtime.

[TIP]
====
The search performed is hierarchical. By default, system properties have precedence over
environment variables. So, if the `my-property` property happens to be set in both places during
a call to `env.getProperty("my-property")`, the system property value "`wins`" and is returned.
Note that property values are not merged
but rather completely overridden by a preceding entry.

For a common `StandardServletEnvironment`, the full hierarchy is as follows, with the
highest-precedence entries at the top:

. ServletConfig parameters (if applicable -- for example, in case of a `DispatcherServlet` context)
. ServletContext parameters (web.xml context-param entries)
. JNDI environment variables (`java:comp/env/` entries)
. JVM system properties (`-D` command-line arguments)
. JVM system environment (operating system environment variables)
====

Most importantly, the entire mechanism is configurable. Perhaps you have a custom source
of properties that you want to integrate into this search. To do so, implement
and instantiate your own `PropertySource` and add it to the set of `PropertySources` for the
current `Environment`. The following example shows how to do so:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
ConfigurableApplicationContext ctx = new GenericApplicationContext();
MutablePropertySources sources = ctx.getEnvironment().getPropertySources();
sources.addFirst(new MyPropertySource());
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val ctx = GenericApplicationContext()
	val sources = ctx.environment.propertySources
	sources.addFirst(MyPropertySource())
----

In the preceding code, `MyPropertySource` has been added with highest precedence in the
search. If it contains a  `my-property` property, the property is detected and returned, in favor of
any `my-property` property in any other `PropertySource`. The
{api-spring-framework}/core/env/MutablePropertySources.html[`MutablePropertySources`]
API exposes a number of methods that allow for precise manipulation of the set of
property sources.



[[beans-using-propertysource]]
=== Using `@PropertySource`

The {api-spring-framework}/context/annotation/PropertySource.html[`@PropertySource`]
annotation provides a convenient and declarative mechanism for adding a `PropertySource`
to Spring's `Environment`.

Given a file called `app.properties` that contains the key-value pair `testbean.name=myTestBean`,
the following `@Configuration` class uses `@PropertySource` in such a way that
a call to `testBean.getName()` returns `myTestBean`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
   @Configuration
   @PropertySource("classpath:/com/myco/app.properties")
   public class AppConfig {

	   @Autowired
	   Environment env;

	   @Bean
	   public TestBean testBean() {
		   TestBean testBean = new TestBean();
		   testBean.setName(env.getProperty("testbean.name"));
		   return testBean;
	   }
   }
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@PropertySource("classpath:/com/myco/app.properties")
	class AppConfig {

		@Autowired
		private lateinit var env: Environment

		@Bean
		fun testBean() = TestBean().apply {
			name = env.getProperty("testbean.name")!!
		}
	}
----

Any `${...}` placeholders present in a `@PropertySource` resource location are
resolved against the set of property sources already registered against the
environment, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
   @Configuration
   @PropertySource("classpath:/com/${my.placeholder:default/path}/app.properties")
   public class AppConfig {

	   @Autowired
	   Environment env;

	   @Bean
	   public TestBean testBean() {
		   TestBean testBean = new TestBean();
		   testBean.setName(env.getProperty("testbean.name"));
		   return testBean;
	   }
   }
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@PropertySource("classpath:/com/\${my.placeholder:default/path}/app.properties")
	class AppConfig {

		@Autowired
		private lateinit var env: Environment

		@Bean
		fun testBean() = TestBean().apply {
			name = env.getProperty("testbean.name")!!
		}
	}
----

Assuming that `my.placeholder` is present in one of the property sources already
registered (for example, system properties or environment variables), the placeholder is
resolved to the corresponding value. If not, then `default/path` is used
as a default. If no default is specified and a property cannot be resolved, an
`IllegalArgumentException` is thrown.

NOTE: The `@PropertySource` annotation is repeatable, according to Java 8 conventions.
However, all such `@PropertySource` annotations need to be declared at the same
level, either directly on the configuration class or as meta-annotations within the
same custom annotation. Mixing direct annotations and meta-annotations is not
recommended, since direct annotations effectively override meta-annotations.



[[beans-placeholder-resolution-in-statements]]
=== Placeholder Resolution in Statements

Historically, the value of placeholders in elements could be resolved only against
JVM system properties or environment variables. This is no longer the case. Because
the `Environment` abstraction is integrated throughout the container, it is easy to
route resolution of placeholders through it. This means that you may configure the
resolution process in any way you like. You can change the precedence of searching through
system properties and environment variables or remove them entirely. You can also add your
own property sources to the mix, as appropriate.

Concretely, the following statement works regardless of where the `customer`
property is defined, as long as it is available in the `Environment`:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<import resource="com/bank/service/${customer}-config.xml"/>
	</beans>
----




[[context-load-time-weaver]]
== Registering a `LoadTimeWeaver`

The `LoadTimeWeaver` is used by Spring to dynamically transform classes as they are
loaded into the Java virtual machine (JVM).

To enable load-time weaving, you can add the `@EnableLoadTimeWeaving` to one of your
`@Configuration` classes, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableLoadTimeWeaving
	public class AppConfig {
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableLoadTimeWeaving
	class AppConfig
----

Alternatively, for XML configuration, you can use the `context:load-time-weaver` element:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<context:load-time-weaver/>
	</beans>
----

Once configured for the `ApplicationContext`, any bean within that `ApplicationContext`
may implement `LoadTimeWeaverAware`, thereby receiving a reference to the load-time
weaver instance. This is particularly useful in combination with
<<data-access.adoc#orm-jpa, Spring's JPA support>> where load-time weaving may be
necessary for JPA class transformation.
Consult the
{api-spring-framework}/orm/jpa/LocalContainerEntityManagerFactoryBean.html[`LocalContainerEntityManagerFactoryBean`]
javadoc for more detail. For more on AspectJ load-time weaving, see <<aop-aj-ltw>>.




[[context-introduction]]
== Additional Capabilities of the `ApplicationContext`

As discussed in the <<beans, chapter introduction>>, the `org.springframework.beans.factory`
package provides basic functionality for managing and manipulating beans, including in a
programmatic way. The `org.springframework.context` package adds the
{api-spring-framework}/context/ApplicationContext.html[`ApplicationContext`]
interface, which extends the `BeanFactory` interface, in addition to extending other
interfaces to provide additional functionality in a more application
framework-oriented style. Many people use the `ApplicationContext` in a completely
declarative fashion, not even creating it programmatically, but instead relying on
support classes such as `ContextLoader` to automatically instantiate an
`ApplicationContext` as part of the normal startup process of a Java EE web application.

To enhance `BeanFactory` functionality in a more framework-oriented style, the context
package also provides the following functionality:

* Access to messages in i18n-style, through the `MessageSource` interface.
* Access to resources, such as URLs and files, through the `ResourceLoader` interface.
* Event publication, namely to beans that implement the `ApplicationListener` interface,
  through the use of the `ApplicationEventPublisher` interface.
* Loading of multiple (hierarchical) contexts, letting each be focused on one
  particular layer, such as the web layer of an application, through the
  `HierarchicalBeanFactory` interface.



[[context-functionality-messagesource]]
=== Internationalization using `MessageSource`

The `ApplicationContext` interface extends an interface called `MessageSource` and,
therefore, provides internationalization ("`i18n`") functionality. Spring also provides the
`HierarchicalMessageSource` interface, which can resolve messages hierarchically.
Together, these interfaces provide the foundation upon which Spring effects message
resolution. The methods defined on these interfaces include:

* `String getMessage(String code, Object[] args, String default, Locale loc)`: The basic
  method used to retrieve a message from the `MessageSource`. When no message is found
  for the specified locale, the default message is used. Any arguments passed in become
  replacement values, using the `MessageFormat` functionality provided by the standard
  library.
* `String getMessage(String code, Object[] args, Locale loc)`: Essentially the same as
  the previous method but with one difference: No default message can be specified. If
  the message cannot be found, a `NoSuchMessageException` is thrown.
* `String getMessage(MessageSourceResolvable resolvable, Locale locale)`: All properties
  used in the preceding methods are also wrapped in a class named
  `MessageSourceResolvable`, which you can use with this method.

When an `ApplicationContext` is loaded, it automatically searches for a `MessageSource`
bean defined in the context. The bean must have the name `messageSource`. If such a bean
is found, all calls to the preceding methods are delegated to the message source. If no
message source is found, the `ApplicationContext` attempts to find a parent containing a
bean with the same name. If it does, it uses that bean as the `MessageSource`. If the
`ApplicationContext` cannot find any source for messages, an empty
`DelegatingMessageSource` is instantiated in order to be able to accept calls to the
methods defined above.

Spring provides two `MessageSource` implementations, `ResourceBundleMessageSource` and
`StaticMessageSource`. Both implement `HierarchicalMessageSource` in order to do nested
messaging. The `StaticMessageSource` is rarely used but provides programmatic ways to
add messages to the source. The following example shows `ResourceBundleMessageSource`:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<bean id="messageSource"
				class="org.springframework.context.support.ResourceBundleMessageSource">
			<property name="basenames">
				<list>
					<value>format</value>
					<value>exceptions</value>
					<value>windows</value>
				</list>
			</property>
		</bean>
	</beans>
----

The example assumes that you have three resource bundles called `format`, `exceptions` and `windows`
defined in your classpath. Any request to resolve a message is
handled in the JDK-standard way of resolving messages through `ResourceBundle` objects. For the
purposes of the example, assume the contents of two of the above resource bundle files
are as follows:

[literal,subs="verbatim,quotes"]
----
	# in format.properties
	message=Alligators rock!
----

[literal,subs="verbatim,quotes"]
----
	# in exceptions.properties
	argument.required=The {0} argument is required.
----

The next example shows a program to execute the `MessageSource` functionality.
Remember that all `ApplicationContext` implementations are also `MessageSource`
implementations and so can be cast to the `MessageSource` interface.

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public static void main(String[] args) {
		MessageSource resources = new ClassPathXmlApplicationContext("beans.xml");
		String message = resources.getMessage("message", null, "Default", Locale.ENGLISH);
		System.out.println(message);
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun main() {
		val resources = ClassPathXmlApplicationContext("beans.xml")
		val message = resources.getMessage("message", null, "Default", Locale.ENGLISH)
		println(message)
	}
----

The resulting output from the above program is as follows:

[literal,subs="verbatim,quotes"]
----
Alligators rock!
----

To summarize, the `MessageSource` is defined in a file called `beans.xml`, which
exists at the root of your classpath. The `messageSource` bean definition refers to a
number of resource bundles through its `basenames` property. The three files that are
passed in the list to the `basenames` property exist as files at the root of your
classpath and are called `format.properties`, `exceptions.properties`, and
`windows.properties`, respectively.

The next example shows arguments passed to the message lookup. These arguments are
converted into `String` objects and inserted into placeholders in the lookup message.

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>

		<!-- this MessageSource is being used in a web application -->
		<bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource">
			<property name="basename" value="exceptions"/>
		</bean>

		<!-- lets inject the above MessageSource into this POJO -->
		<bean id="example" class="com.something.Example">
			<property name="messages" ref="messageSource"/>
		</bean>

	</beans>
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class Example {

		private MessageSource messages;

		public void setMessages(MessageSource messages) {
			this.messages = messages;
		}

		public void execute() {
			String message = this.messages.getMessage("argument.required",
				new Object [] {"userDao"}, "Required", Locale.ENGLISH);
			System.out.println(message);
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class Example {

	lateinit var messages: MessageSource

	fun execute() {
		val message = messages.getMessage("argument.required",
				arrayOf("userDao"), "Required", Locale.ENGLISH)
		println(message)
	}
}
----

The resulting output from the invocation of the `execute()` method is as follows:

[literal,subs="verbatim,quotes"]
----
The userDao argument is required.
----

With regard to internationalization ("`i18n`"), Spring's various `MessageSource`
implementations follow the same locale resolution and fallback rules as the standard JDK
`ResourceBundle`. In short, and continuing with the example `messageSource` defined
previously, if you want to resolve messages against the British (`en-GB`) locale, you
would create files called `format_en_GB.properties`, `exceptions_en_GB.properties`, and
`windows_en_GB.properties`, respectively.

Typically, locale resolution is managed by the surrounding environment of the
application. In the following example, the locale against which (British) messages are
resolved is specified manually:

[literal,subs="verbatim,quotes"]
----
# in exceptions_en_GB.properties
argument.required=Ebagum lad, the {0} argument is required, I say, required.
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public static void main(final String[] args) {
		MessageSource resources = new ClassPathXmlApplicationContext("beans.xml");
		String message = resources.getMessage("argument.required",
			new Object [] {"userDao"}, "Required", Locale.UK);
		System.out.println(message);
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun main() {
		val resources = ClassPathXmlApplicationContext("beans.xml")
		val message = resources.getMessage("argument.required",
				arrayOf("userDao"), "Required", Locale.UK)
		println(message)
	}
----

The resulting output from the running of the above program is as follows:

[literal,subs="verbatim,quotes"]
----
Ebagum lad, the 'userDao' argument is required, I say, required.
----

You can also use the `MessageSourceAware` interface to acquire a reference to any
`MessageSource` that has been defined. Any bean that is defined in an
`ApplicationContext` that implements the `MessageSourceAware` interface is injected with
the application context's `MessageSource` when the bean is created and configured.

NOTE: As an alternative to `ResourceBundleMessageSource`, Spring provides a
`ReloadableResourceBundleMessageSource` class. This variant supports the same bundle
file format but is more flexible than the standard JDK based
`ResourceBundleMessageSource` implementation. In particular, it allows for reading
files from any Spring resource location (not only from the classpath) and supports hot
reloading of bundle property files (while efficiently caching them in between).
See the {api-spring-framework}/context/support/ReloadableResourceBundleMessageSource.html[`ReloadableResourceBundleMessageSource`]
javadoc for details.



[[context-functionality-events]]
=== Standard and Custom Events

Event handling in the `ApplicationContext` is provided through the `ApplicationEvent`
class and the `ApplicationListener` interface. If a bean that implements the
`ApplicationListener` interface is deployed into the context, every time an
`ApplicationEvent` gets published to the `ApplicationContext`, that bean is notified.
Essentially, this is the standard Observer design pattern.

TIP: As of Spring 4.2, the event infrastructure has been significantly improved and offers
an <<context-functionality-events-annotation, annotation-based model>> as well as the
ability to publish any arbitrary event (that is, an object that does not necessarily
extend from `ApplicationEvent`). When such an object is published, we wrap it in an
event for you.

The following table describes the standard events that Spring provides:

[[beans-ctx-events-tbl]]
.Built-in Events
[cols="30%,70%"]
|===
| Event| Explanation

| `ContextRefreshedEvent`
| Published when the `ApplicationContext` is initialized or refreshed (for example, by
  using the `refresh()` method on the `ConfigurableApplicationContext` interface).
  Here, "`initialized`" means that all beans are loaded, post-processor beans are detected
  and activated, singletons are pre-instantiated, and the `ApplicationContext` object is
  ready for use. As long as the context has not been closed, a refresh can be triggered
  multiple times, provided that the chosen `ApplicationContext` actually supports such
  "`hot`" refreshes. For example, `XmlWebApplicationContext` supports hot refreshes, but
  `GenericApplicationContext` does not.

| `ContextStartedEvent`
| Published when the `ApplicationContext` is started by using the `start()` method on the
  `ConfigurableApplicationContext` interface. Here, "`started`" means that all `Lifecycle`
  beans receive an explicit start signal. Typically, this signal is used to restart beans
  after an explicit stop, but it may also be used to start components that have not been
  configured for autostart (for example, components that have not already started on
  initialization).

| `ContextStoppedEvent`
| Published when the `ApplicationContext` is stopped by using the `stop()` method on the
  `ConfigurableApplicationContext` interface. Here, "`stopped`" means that all `Lifecycle`
  beans receive an explicit stop signal. A stopped context may be restarted through a
  `start()` call.

| `ContextClosedEvent`
| Published when the `ApplicationContext` is being closed by using the `close()` method
  on the `ConfigurableApplicationContext` interface or via a JVM shutdown hook. Here,
  "closed" means that all singleton beans will be destroyed. Once the context is closed,
  it reaches its end of life and cannot be refreshed or restarted.

| `RequestHandledEvent`
| A web-specific event telling all beans that an HTTP request has been serviced. This
  event is published after the request is complete. This event is only applicable to
  web applications that use Spring's `DispatcherServlet`.

| `ServletRequestHandledEvent`
| A subclass of `RequestHandledEvent` that adds Servlet-specific context information.

|===

You can also create and publish your own custom events. The following example shows a
simple class that extends Spring's `ApplicationEvent` base class:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class BlackListEvent extends ApplicationEvent {

		private final String address;
		private final String content;

		public BlackListEvent(Object source, String address, String content) {
			super(source);
			this.address = address;
			this.content = content;
		}

		// accessor and other methods...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class BlackListEvent(source: Any,
						val address: String,
						val content: String) : ApplicationEvent(source)
----

To publish a custom `ApplicationEvent`, call the `publishEvent()` method on an
`ApplicationEventPublisher`. Typically, this is done by creating a class that implements
`ApplicationEventPublisherAware` and registering it as a Spring bean. The following
example shows such a class:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class EmailService implements ApplicationEventPublisherAware {

		private List<String> blackList;
		private ApplicationEventPublisher publisher;

		public void setBlackList(List<String> blackList) {
			this.blackList = blackList;
		}

		public void setApplicationEventPublisher(ApplicationEventPublisher publisher) {
			this.publisher = publisher;
		}

		public void sendEmail(String address, String content) {
			if (blackList.contains(address)) {
				publisher.publishEvent(new BlackListEvent(this, address, content));
				return;
			}
			// send email...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class EmailService : ApplicationEventPublisherAware {

		private lateinit var blackList: List<String>
		private lateinit var publisher: ApplicationEventPublisher

		fun setBlackList(blackList: List<String>) {
			this.blackList = blackList
		}

		override fun setApplicationEventPublisher(publisher: ApplicationEventPublisher) {
			this.publisher = publisher
		}

		fun sendEmail(address: String, content: String) {
			if (blackList!!.contains(address)) {
				publisher!!.publishEvent(BlackListEvent(this, address, content))
				return
			}
			// send email...
		}
	}
----

At configuration time, the Spring container detects that `EmailService` implements
`ApplicationEventPublisherAware` and automatically calls
`setApplicationEventPublisher()`. In reality, the parameter passed in is the Spring
container itself. You are interacting with the application context through its
`ApplicationEventPublisher` interface.

To receive the custom `ApplicationEvent`, you can create a class that implements
`ApplicationListener` and register it as a Spring bean. The following example
shows such a class:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class BlackListNotifier implements ApplicationListener<BlackListEvent> {

		private String notificationAddress;

		public void setNotificationAddress(String notificationAddress) {
			this.notificationAddress = notificationAddress;
		}

		public void onApplicationEvent(BlackListEvent event) {
			// notify appropriate parties via notificationAddress...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class BlackListNotifier : ApplicationListener<BlackListEvent> {

		lateinit var notificationAddres: String

		override fun onApplicationEvent(event: BlackListEvent) {
			// notify appropriate parties via notificationAddress...
		}
	}
----

Notice that `ApplicationListener` is generically parameterized with the type of your
custom event (`BlackListEvent` in the preceding example). This means that the `onApplicationEvent()` method can
remain type-safe, avoiding any need for downcasting. You can register as many event
listeners as you wish, but note that, by default, event listeners receive events
synchronously. This means that the `publishEvent()` method blocks until all listeners have
finished processing the event. One advantage of this synchronous and single-threaded
approach is that, when a listener receives an event, it operates inside the transaction
context of the publisher if a transaction context is available. If another strategy for
event publication becomes necessary, see the javadoc for Spring's
{api-spring-framework}/context/event/ApplicationEventMulticaster.html[`ApplicationEventMulticaster`] interface
and {api-spring-framework}/context/event/SimpleApplicationEventMulticaster.html[`SimpleApplicationEventMulticaster`]
implementation for configuration options.

The following example shows the bean definitions used to register and configure each of
the classes above:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="emailService" class="example.EmailService">
		<property name="blackList">
			<list>
				<value>known.spammer@example.org</value>
				<value>known.hacker@example.org</value>
				<value>john.doe@example.org</value>
			</list>
		</property>
	</bean>

	<bean id="blackListNotifier" class="example.BlackListNotifier">
		<property name="notificationAddress" value="blacklist@example.org"/>
	</bean>
----

Putting it all together, when the `sendEmail()` method of the `emailService` bean is
called, if there are any email messages that should be blacklisted, a custom event of type
`BlackListEvent` is published. The `blackListNotifier` bean is registered as an
`ApplicationListener` and receives the `BlackListEvent`, at which point it can
notify appropriate parties.

NOTE: Spring's eventing mechanism is designed for simple communication between Spring beans
within the same application context. However, for more sophisticated enterprise
integration needs, the separately maintained
https://projects.spring.io/spring-integration/[Spring Integration] project provides
complete support for building lightweight,
https://www.enterpriseintegrationpatterns.com[pattern-oriented], event-driven
architectures that build upon the well-known Spring programming model.


[[context-functionality-events-annotation]]
==== Annotation-based Event Listeners

As of Spring 4.2, you can register an event listener on any public method of a managed
bean by using the `@EventListener` annotation. The `BlackListNotifier` can be rewritten as
follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class BlackListNotifier {

		private String notificationAddress;

		public void setNotificationAddress(String notificationAddress) {
			this.notificationAddress = notificationAddress;
		}

		@EventListener
		public void processBlackListEvent(BlackListEvent event) {
			// notify appropriate parties via notificationAddress...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class BlackListNotifier {

		lateinit var notificationAddress: String

		@EventListener
		fun processBlackListEvent(event: BlackListEvent) {
			// notify appropriate parties via notificationAddress...
		}
	}
----

The method signature once again declares the event type to which it listens,
but, this time, with a flexible name and without implementing a specific listener interface.
The event type can also be narrowed through generics as long as the actual event type
resolves your generic parameter in its implementation hierarchy.

If your method should listen to several events or if you want to define it with no
parameter at all, the event types can also be specified on the annotation itself. The
following example shows how to do so:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@EventListener({ContextStartedEvent.class, ContextRefreshedEvent.class})
	public void handleContextStart() {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@EventListener(ContextStartedEvent::class, ContextRefreshedEvent::class)
	fun handleContextStart() {
		// ...
	}
----

It is also possible to add additional runtime filtering by using the `condition` attribute
of the annotation that defines a <<expressions, `SpEL` expression>> , which should match
to actually invoke the method for a particular event.

The following example shows how our notifier can be rewritten to be invoked only if the
`content` attribute of the event is equal to `my-event`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@EventListener(condition = "#blEvent.content == 'my-event'")
	public void processBlackListEvent(BlackListEvent blEvent) {
		// notify appropriate parties via notificationAddress...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@EventListener(condition = "#blEvent.content == 'my-event'")
	fun processBlackListEvent(blEvent: BlackListEvent) {
		// notify appropriate parties via notificationAddress...
	}
----

Each `SpEL` expression evaluates against a dedicated context. The following table lists the
items made available to the context so that you can use them for conditional event processing:

[[context-functionality-events-annotation-tbl]]
.Event SpEL available metadata
|===
| Name| Location| Description| Example

| Event
| root object
| The actual `ApplicationEvent`.
| `#root.event` or `event`

| Arguments array
| root object
| The arguments (as an object array) used to invoke the method.
| `#root.args` or `args`; `args[0]` to access the first argument, etc.

| __Argument name__
| evaluation context
| The name of any of the method arguments. If, for some reason, the names are not available
  (for example, because there is no debug information in the compiled byte code), individual
  arguments are also available using the `#a<#arg>` syntax where `<#arg>` stands for the
  argument index (starting from 0).
| `#blEvent` or `#a0` (you can also use `#p0` or `#p<#arg>` parameter notation as an alias)
|===

Note that `#root.event` gives you access to the underlying event, even if your method
signature actually refers to an arbitrary object that was published.

If you need to publish an event as the result of processing another event, you can change the
method signature to return the event that should be published, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@EventListener
	public ListUpdateEvent handleBlackListEvent(BlackListEvent event) {
		// notify appropriate parties via notificationAddress and
		// then publish a ListUpdateEvent...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@EventListener
	fun handleBlackListEvent(event: BlackListEvent): ListUpdateEvent {
		// notify appropriate parties via notificationAddress and
		// then publish a ListUpdateEvent...
	}
----

NOTE: This feature is not supported for
<<context-functionality-events-async, asynchronous listeners>>.

This new method publishes a new `ListUpdateEvent` for every `BlackListEvent` handled by the
method above. If you need to publish several events, you can return a `Collection` of events
instead.


[[context-functionality-events-async]]
==== Asynchronous Listeners

If you want a particular listener to process events asynchronously, you can reuse the
<<integration.adoc#scheduling-annotation-support-async, regular `@Async` support>>.
The following example shows how to do so:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@EventListener
	@Async
	public void processBlackListEvent(BlackListEvent event) {
		// BlackListEvent is processed in a separate thread
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@EventListener
	@Async
	fun processBlackListEvent(event: BlackListEvent) {
		// BlackListEvent is processed in a separate thread
	}
----

Be aware of the following limitations when using asynchronous events:

* If an asynchronous event listener throws an `Exception`, it is not propagated to the
  caller. See `AsyncUncaughtExceptionHandler` for more details.
* Asynchronous event listener methods cannot publish a subsequent event by returning a
  value. If you need to publish another event as the result of the processing, inject an
  {api-spring-framework}/aop/interceptor/AsyncUncaughtExceptionHandler.html[`ApplicationEventPublisher`]
  to publish the event manually.


[[context-functionality-events-order]]
==== Ordering Listeners

If you need one listener to be invoked before another one, you can add the `@Order`
annotation to the method declaration, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@EventListener
	@Order(42)
	public void processBlackListEvent(BlackListEvent event) {
		// notify appropriate parties via notificationAddress...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@EventListener
	@Order(42)
	fun processBlackListEvent(event: BlackListEvent) {
		// notify appropriate parties via notificationAddress...
	}
----


[[context-functionality-events-generics]]
==== Generic Events

You can also use generics to further define the structure of your event. Consider using an
`EntityCreatedEvent<T>` where `T` is the type of the actual entity that got created. For example, you
can create the following listener definition to receive only `EntityCreatedEvent` for a
`Person`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@EventListener
	public void onPersonCreated(EntityCreatedEvent<Person> event) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@EventListener
	fun onPersonCreated(event: EntityCreatedEvent<Person>) {
		// ...
	}
----

Due to type erasure, this works only if the event that is fired resolves the generic
parameters on which the event listener filters (that is, something like
`class PersonCreatedEvent extends EntityCreatedEvent<Person> { ... }`).

In certain circumstances, this may become quite tedious if all events follow the same
structure (as should be the case for the event in the preceding example). In such a case,
you can implement `ResolvableTypeProvider` to guide the framework beyond what the runtime
environment provides. The following event shows how to do so:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class EntityCreatedEvent<T> extends ApplicationEvent implements ResolvableTypeProvider {

		public EntityCreatedEvent(T entity) {
			super(entity);
		}

		@Override
		public ResolvableType getResolvableType() {
			return ResolvableType.forClassWithGenerics(getClass(), ResolvableType.forInstance(getSource()));
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class EntityCreatedEvent<T>(entity: T) : ApplicationEvent(entity), ResolvableTypeProvider {

		override fun getResolvableType(): ResolvableType? {
			return ResolvableType.forClassWithGenerics(javaClass, ResolvableType.forInstance(getSource()))
		}
	}
----

TIP: This works not only for `ApplicationEvent` but any arbitrary object that you send as
an event.



[[context-functionality-resources]]
=== Convenient Access to Low-level Resources

For optimal usage and understanding of application contexts, you should familiarize
yourself with Spring's `Resource` abstraction, as described in <<resources>>.

An application context is a `ResourceLoader`, which can be used to load `Resource` objects.
A `Resource` is essentially a more feature rich version of the JDK `java.net.URL` class.
In fact, the implementations of the `Resource` wrap an instance of `java.net.URL`, where
appropriate. A `Resource` can obtain low-level resources from almost any location in a
transparent fashion, including from the classpath, a filesystem location, anywhere
describable with a standard URL, and some other variations. If the resource location
string is a simple path without any special prefixes, where those resources come from is
specific and appropriate to the actual application context type.

You can configure a bean deployed into the application context to implement the special
callback interface, `ResourceLoaderAware`, to be automatically called back at
initialization time with the application context itself passed in as the `ResourceLoader`.
You can also expose properties of type `Resource`, to be used to access static resources.
They are injected into it like any other properties. You can specify those `Resource`
properties as simple `String` paths and rely on automatic conversion from those text
strings to actual `Resource` objects when the bean is deployed.

The location path or paths supplied to an `ApplicationContext` constructor are actually
resource strings and, in simple form, are treated appropriately according to the specific
context implementation. For example `ClassPathXmlApplicationContext` treats a simple
location path as a classpath location. You can also use location paths (resource strings)
with special prefixes to force loading of definitions from the classpath or a URL,
regardless of the actual context type.



[[context-create]]
=== Convenient ApplicationContext Instantiation for Web Applications

You can create `ApplicationContext` instances declaratively by using, for example, a
`ContextLoader`. Of course, you can also create `ApplicationContext` instances
programmatically by using one of the `ApplicationContext` implementations.

You can register an `ApplicationContext` by using the `ContextLoaderListener`, as the
following example shows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml</param-value>
	</context-param>

	<listener>
		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	</listener>
----

The listener inspects the `contextConfigLocation` parameter. If the parameter does not
exist, the listener uses `/WEB-INF/applicationContext.xml` as a default. When the
parameter does exist, the listener separates the `String` by using predefined
delimiters (comma, semicolon, and whitespace) and uses the values as locations where
application contexts are searched. Ant-style path patterns are supported as well.
Examples are `/WEB-INF/{asterisk}Context.xml` (for all files with names that end with
`Context.xml` and that reside in the `WEB-INF` directory) and `/WEB-INF/**/*Context.xml`
(for all such files in any subdirectory of `WEB-INF`).



[[context-deploy-rar]]
=== Deploying a Spring `ApplicationContext` as a Java EE RAR File

It is possible to deploy a Spring `ApplicationContext` as a RAR file, encapsulating the
context and all of its required bean classes and library JARs in a Java EE RAR deployment
unit. This is the equivalent of bootstrapping a stand-alone `ApplicationContext` (only hosted
in Java EE environment) being able to access the Java EE servers facilities. RAR deployment
is a more natural alternative to a scenario of deploying a headless WAR file -- in effect,
a WAR file without any HTTP entry points that is used only for bootstrapping a Spring
`ApplicationContext` in a Java EE environment.

RAR deployment is ideal for application contexts that do not need HTTP entry points but
rather consist only of message endpoints and scheduled jobs. Beans in such a context can
use application server resources such as the JTA transaction manager and JNDI-bound JDBC
`DataSource` instances and JMS `ConnectionFactory` instances and can also register with
the platform's JMX server -- all through Spring's standard transaction management and JNDI
and JMX support facilities. Application components can also interact with the application
server's JCA `WorkManager` through Spring's `TaskExecutor` abstraction.

See the javadoc of the
{api-spring-framework}/jca/context/SpringContextResourceAdapter.html[`SpringContextResourceAdapter`]
class for the configuration details involved in RAR deployment.

For a simple deployment of a Spring ApplicationContext as a Java EE RAR file:

. Package
all application classes into a RAR file (which is a standard JAR file with a different
file extension).
.Add all required library JARs into the root of the RAR archive.
.Add a
`META-INF/ra.xml` deployment descriptor (as shown in the {api-spring-framework}/jca/context/SpringContextResourceAdapter.html[javadoc for `SpringContextResourceAdapter`])
and the corresponding Spring XML bean definition file(s) (typically
`META-INF/applicationContext.xml`).
. Drop the resulting RAR file into your
application server's deployment directory.

NOTE: Such RAR deployment units are usually self-contained. They do not expose components
to the outside world, not even to other modules of the same application. Interaction with a
RAR-based `ApplicationContext` usually occurs through JMS destinations that it shares with
other modules. A RAR-based `ApplicationContext` may also, for example, schedule some jobs
or react to new files in the file system (or the like). If it needs to allow synchronous
access from the outside, it could (for example) export RMI endpoints, which may be used
by other application modules on the same machine.




[[beans-beanfactory]]
== The `BeanFactory`

The `BeanFactory` API provides the underlying basis for Spring's IoC functionality.
Its specific contracts are mostly used in integration with other parts of Spring and
related third-party frameworks, and its `DefaultListableBeanFactory` implementation
is a key delegate within the higher-level `GenericApplicationContext` container.

`BeanFactory` and related interfaces (such as `BeanFactoryAware`, `InitializingBean`,
`DisposableBean`) are important integration points for other framework components.
By not requiring any annotations or even reflection, they allow for very efficient
interaction between the container and its components. Application-level beans may
use the same callback interfaces but typically prefer declarative dependency
injection instead, either through annotations or through programmatic configuration.

Note that the core `BeanFactory` API level and its `DefaultListableBeanFactory`
implementation do not make assumptions about the configuration format or any
component annotations to be used. All of these flavors come in through extensions
(such as `XmlBeanDefinitionReader` and `AutowiredAnnotationBeanPostProcessor`) and
operate on shared `BeanDefinition` objects as a core metadata representation.
This is the essence of what makes Spring's container so flexible and extensible.



[[context-introduction-ctx-vs-beanfactory]]
=== `BeanFactory` or `ApplicationContext`?

This section explains the differences between the `BeanFactory` and
`ApplicationContext` container levels and the implications on bootstrapping.

You should use an `ApplicationContext` unless you have a good reason for not doing so, with
`GenericApplicationContext` and its subclass `AnnotationConfigApplicationContext`
as the common implementations for custom bootstrapping. These are the primary entry
points to Spring's core container for all common purposes: loading of configuration
files, triggering a classpath scan, programmatically registering bean definitions
and annotated classes, and (as of 5.0) registering functional bean definitions.

Because an `ApplicationContext` includes all the functionality of a `BeanFactory`, it is
generally recommended over a plain `BeanFactory`, except for scenarios where full
control over bean processing is needed. Within an `ApplicationContext` (such as the
`GenericApplicationContext` implementation), several kinds of beans are detected
by convention (that is, by bean name or by bean type -- in particular, post-processors),
while a plain `DefaultListableBeanFactory` is agnostic about any special beans.

For many extended container features, such as annotation processing and AOP proxying,
the <<beans-factory-extension-bpp, `BeanPostProcessor` extension point>> is essential.
If you use only a plain `DefaultListableBeanFactory`, such post-processors do not
get detected and activated by default. This situation could be confusing, because
nothing is actually wrong with your bean configuration. Rather,  in such a scenario,
the container needs to be fully bootstrapped through additional setup.

The following table lists features provided by the `BeanFactory` and
`ApplicationContext` interfaces and implementations.

[[context-introduction-ctx-vs-beanfactory-feature-matrix]]
.Feature Matrix
[cols="50%,25%,25%"]
|===
| Feature | `BeanFactory` | `ApplicationContext`

| Bean instantiation/wiring
| Yes
| Yes

| Integrated lifecycle management
| No
| Yes

| Automatic `BeanPostProcessor` registration
| No
| Yes

| Automatic `BeanFactoryPostProcessor` registration
| No
| Yes

| Convenient `MessageSource` access (for internalization)
| No
| Yes

| Built-in `ApplicationEvent` publication mechanism
| No
| Yes
|===

To explicitly register a bean post-processor with a `DefaultListableBeanFactory`,
you need to programmatically call `addBeanPostProcessor`, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
	// populate the factory with bean definitions

	// now register any needed BeanPostProcessor instances
	factory.addBeanPostProcessor(new AutowiredAnnotationBeanPostProcessor());
	factory.addBeanPostProcessor(new MyBeanPostProcessor());

	// now start using the factory
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val factory = DefaultListableBeanFactory()
	// populate the factory with bean definitions

	// now register any needed BeanPostProcessor instances
	factory.addBeanPostProcessor(AutowiredAnnotationBeanPostProcessor())
	factory.addBeanPostProcessor(MyBeanPostProcessor())

	// now start using the factory
----

To apply a `BeanFactoryPostProcessor` to a plain `DefaultListableBeanFactory`,
you need to call its `postProcessBeanFactory` method, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
	XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);
	reader.loadBeanDefinitions(new FileSystemResource("beans.xml"));

	// bring in some property values from a Properties file
	PropertySourcesPlaceholderConfigurer cfg = new PropertySourcesPlaceholderConfigurer();
	cfg.setLocation(new FileSystemResource("jdbc.properties"));

	// now actually do the replacement
	cfg.postProcessBeanFactory(factory);
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val factory = DefaultListableBeanFactory()
	val reader = XmlBeanDefinitionReader(factory)
	reader.loadBeanDefinitions(FileSystemResource("beans.xml"))

	// bring in some property values from a Properties file
	val cfg = PropertySourcesPlaceholderConfigurer()
	cfg.setLocation(FileSystemResource("jdbc.properties"))

	// now actually do the replacement
	cfg.postProcessBeanFactory(factory)
----

In both cases, the explicit registration steps are inconvenient, which is
why the various `ApplicationContext` variants are preferred over a plain
`DefaultListableBeanFactory` in Spring-backed applications, especially when
relying on `BeanFactoryPostProcessor` and `BeanPostProcessor` instances for extended
container functionality in a typical enterprise setup.

[NOTE]
====
An `AnnotationConfigApplicationContext` has all common annotation post-processors
registered and may bring in additional processors underneath the
covers through configuration annotations, such as `@EnableTransactionManagement`.
At the abstraction level of Spring's annotation-based configuration model,
the notion of bean post-processors becomes a mere internal container detail.
====
