[[upgrading-migrating]]
== 更新和迁移

[[upgrading-upgrading-gradle6]]
=== 从 Gradle 6.x 升级到最新版本

本章提供了将 Gradle 6.x 版本迁移到 Gradle 最新 Release 版本所需的信息,要从 Gradle 4.x 或 5.x 进行迁移，请首先参阅 <<upgrading-upgrading-gradle5,以前的迁移指南>>。

我们建议所有用户执行以下步骤：


. 运行 `gradle help --scan` 命令,并查看生成的构建扫描的 https://gradle.com/enterprise/releases/2018.4/#identify-usages-of-deprecated-gradle-functionality[弃用视图]。
+
images::images/gradle-005.jpg
+
这样一来，您就可以看到适用于您的构建的所有弃用警告。另外，您可以运行 `gradle help --warning-mode=all` 来查看控制台，尽管它可能不会报告太多详细信息。

. 更新你的插件
有些插件可能在新版本中无法使用，例如，因为它们使用内部已删除或更改的API。 上一步将通过在插件尝试使用 API 弃用的部分时发出弃用警告来帮助您识别潜在的问题。

. 运行 `gradle wrapper --gradle-version 6.7` 讲项目更新到 `6.7`.
. 尝试使用 <<start-troubleshooting-builds,故障排除指南>> 运行项目并调试所有错误。

[[upgrading-upgrading-gradle66]]
==== 从 Gradle 6.6 升级

===== 重大变化

. `buildSrc` 现在可以从根目录查看包含的构建
+
以前，`buildSrc` 的构建方式是从根构建中忽略其包含的构建。
+
从 Gradle 6.7 开始，`buildSrc` 可以从根构建中看到任何包含的版本。 这可能导致依赖关系从 `buildSrc` 中包含的内部版本中替换。 如果 `buildSrc` 需要包含的构建，这也可能会更改某些构建的执行顺序。

. 更新默认工具集成版本

* PMD 更新至 https://github.com/pmd/pmd/releases/tag/pmd_releases%2F6.26.0[PMD 6.26.0]。
* Checkstyle 更新至 https://checkstyle.sourceforge.io/releasenotes.html#Release_8.35[Checkstyle 8.35]。
* CodeNarc 更新至 https://github.com/CodeNarc/CodeNarc/blob/v1.6.1/CHANGELOG.md[CodeNarc 1.6.1]。

===== 弃用

. 在执行阶段更改默认值排除
+
为了方便起见，Gradle 的文件树应用了一些默认的排除模式-实际上与 Ant 相同。 有关更多信息，请参见 <<authoring-work-files-trees,用户手册>>。 有时，Ant 的默认排除选项会引起问题，例如，当您想在存档文件中包含 `.gitignore` 时。
+
在执行阶段更改 Gradle 的默认排除值会导致最新检查的正确性问题，因此不建议使用。 您只能在 settings 脚本中更改 Gradle 的默认排除项，有关示例，请参见 <<authoring-work-files-trees-example140,用户手册>>。

. 直接使用配置作为依赖项

Gradle 允许 Configuration 实例直接用作依赖项：

[source,groovy]
----
dependencies {
    implementation(configurations.myConfiguration)
}
----

现在不赞成这样使用，因为它令人困惑：我们希望先解决 "dependent configuration"，然后将解析结果作为从属关系添加到包含的配置中，事实并非如此。 不推荐使用的版本可以替换为实际行为，即配置继承：

[source,groovy]
----
configurations.implementation.extendsFrom(configurations.myConfiguration)
----

[[upgrading-upgrading-gradle65]]
==== 从 Gradle 6.5 升级

===== 重大变化

. 更新 Gradle 依赖
* Ant 更新至 https://downloads.apache.org/ant/RELEASE-NOTES-1.10.8.html[1.10.8]。
* Groovy 更新至 https://groovy-lang.org/changelogs/changelog-2.5.12.html[Groovy 2.5.12]。
. 依赖替换和变量感知依赖解析
+
在依赖替换中的添加 <<dependency-transitive-dependencies-substituting,表达变量支持>>的同时，错误修复可能引入了某些构建依赖的行为更改。 以前，替换的依赖项仍将使用原始 selector  的 <<dependency-libraries-working-variant-attributes,属性>>，而不是替换 selector  的属性。
+
有了这一更改，用更丰富的 selectors 围绕依赖项进行的现有替换（例如平台依赖项）将不再像以前那样起作用。必须在目标 selectors 中定义变量识别部分。
+
如果发生以下情况，您可能会受到此更改的影响：
+
* 对平台有依赖性，例如 `implementation platform("org:platform:1.0")`
* 或者，如果您指定依赖项的属性，
* 并在这些依赖项上使用 <<dependency-transitive-dependencies-dependency-directly,解析规则>>。

如果您受到这些影响，请 <<dependency-transitive-dependencies-substituting,参阅文档>>以解决问题。

===== 弃用

Gradle 6.6 没有弃用项

[[upgrading-upgrading-gradle64]]
==== 从 Gradle 6.4 升级

===== 重大变化

. 更新 Gradle 依赖
* Kotlin 更新至 https://github.com/JetBrains/kotlin/releases/tag/v1.3.72[1.3.72].
* Groovy 更新至 https://groovy-lang.org/changelogs/changelog-2.5.11.html[Groovy 2.5.11]
. 更新默认工具集成版本
* PMD 更新至 https://github.com/pmd/pmd/releases/tag/pmd_releases%2F6.23.0[PMD 6.23.0]

===== 弃用

. 内部类 `AbstractTask` 已弃用
+
`AbstractTask` 是在 public  API 上可见的内部类，它是 public 类型 `DefaultTask` 的超类。 在 Gradle 7.0 中将删除 `AbstractTask`，在 Gradle 6.5 中不推荐使用以下内容：
* 注册类型为 `AbstractTask` 或 `TaskInternal` 的任务。 您可以从任务注册中删除任务类型，Gradle 将改用 `DefaultTask`。
* 注册一个类型为 `AbstractTask` 的子类但不是 `DefaultTask` 的子类的任务。 您可以更改任务类型以扩展 `DefaultTask`。
* 使用插件代码或构建脚本中的 `AbstractTask` 类。您可以更改代码使用 `DefaultTask`。

[[upgrading-upgrading-gradle63]]
==== 从 Gradle 6.3 升级

===== 重大变化

. PMD插件默认需要PMD 6.0.0或更高版本
+
Gradle 6.4 默认情况下启用了增量分析。增量分析仅在 `PMD 6.0.0` 或更高版本中可用。如果要使用较旧的 PMD 版本，则需要禁用增量分析：
+
[source,groovy]
----
pmd {
    incrementalAnalysis = false
}
----

. 更改依赖锁定
+
对于 Gradle 6.4，<<dependency-declaring-versions-locking-behaviour-with,依赖锁定 `LockMode`>> 的孵化 API 已更改。 现在，可以通过 `Property<LockMode>` 而不是直接来设置值。 这意味着必须为 `Kotlin DSL` 更新设置值的表示法：
+
[source,groovy]
----
dependencyLocking {
    lockMode.set(LockMode.STRICT)
}
----
+
Groovy DSL 的用户不应受到影响，因为符号 `lockMode = LockMode.STRICT` 仍然有效。

. 发布元数据中的 Java 版本
+
如果 Java 库是随 Gradle Module Metadata 发布的，则它支持的 Java 版本的信息将编码在 `org.gradle.jvm.version` 属性中。 默认情况下，此属性为您在 `java.targetCompatibility` 中配置的属性。
如果未配置，则将其设置为运行 Gradle 的当前 Java 版本。 更改特定编译任务的版本，例如 `javaCompile.targetCompatibility` 对该属性没有影响，如果未手动调整该属性，则会导致错误信息。 现在，此问题已修复，并且属性默认为与构建发布 jar 的源相关联的编译任务的设置。
. 具有自定义布局的 Ivy 存储库
+
此版本在不同的地方引入了一些新属性- `mainClass，mainModule，modularity`。 由于这些是非常通用的名称，因此您有可能在构建脚本中使用其中之一作为变量名称。
然后，新属性可能会以不希望的方式遮盖您的变量中的一个，从而导致构建失败，在该构建中，访问属性而不是使用具有相同名称的局部变量。 您可以通过在构建脚本中重命名相应的变量来修复它。
+
受影响的是 `application {}` 和 `java {}` 配置块内的项目，配置为 `project.javaexec {}` 的 java 执行设置以及各种任务配置 (JavaExec, CreateStartScripts, JavaCompile, Test, Javadoc) 内的配置代码。
. 更新 Gradle 依赖
* Kotlin 更新至 https://github.com/JetBrains/kotlin/releases/tag/v1.3.71[Kotlin 1.3.71]

===== 弃用

Gradle 6.3 和 6.4 之间没有弃用。

[[upgrading-upgrading-gradle62]]
==== 从 Gradle 6.2 升级

===== 重大变化

. IDEA 中可用的依赖更少
+
Gradle 不再将注解处理器类路径包括为 IDEA 中提供的依赖项。 IDEA 在编译时看到的依赖项与 Gradle 在解决编译类路径（配置为 `compileClasspath` 的配置）后看到的依赖项相同。 这样可以防止注解处理器依赖项泄漏到项目代码中。
+
在 Gradle 引入 <<plugins-java-incremental-annotation-processing,增量注解处理器>>支持之前，IDEA 要求所有注解处理器都在编译类路径上，以便在 IDEA 中进行编译时能够运行注解处理。 这不再是必需的，因为 Gradle 具有单独的 <<plugins-java-dependency-configurations,注解处理器类路径>>。
导入带有注解处理器的 Gradle 项目时，注解处理器的依赖项不会添加到 IDEA 模块的类路径中。
. 更新 Gradle 依赖
* Kotlin 更新至 https://blog.jetbrains.com/kotlin/2020/03/kotlin-1-3-70-released/[Kotlin 1.3.70].
* Groovy 更新至 http://groovy-lang.org/changelogs/changelog-2.5.10.html[Groovy 2.5.10].
. 更新默认工具集成版本
* PMD 更新至 PMD https://pmd.github.io/pmd-6.21.0/pmd_release_notes.html#24-january-2020---6210[6.21.0].
* CodeNarc 更新至 https://github.com/CodeNarc/CodeNarc/blob/v1.5/CHANGELOG.md#version-15----nov-2019[CodeNarc 1.5]
. 对某些32位操作系统删除了丰富的控制台支持
+
对于 32 位 Unix 系统和旧的 FreeBSD 版本（早于 FreeBSD 10），Gradle 6.3 不支持 <<reference-command-rich-console,丰富的控制台>>。 Microsoft Windows 32 位不受影响。
+
Gradle 将继续在 32 位系统上构建项目，但不再显示丰富的控制台。

===== 弃用
. 使用默认配置和存档配置
几乎每个 Gradle 项目都有默认配置和存档配置，这些配置是由基本插件添加的。这些配置已不再用于现代 Gradle 使用 <<dependency-libraries-understanding-variant-selection,变量感知依赖管理>>和 <<dependency-publishing-module,新发布插件>>的构建中。

虽然目前这些配置将保留在 Gradle 中以实现向后兼容，但现在不建议使用它们来声明依赖或解析依赖。

解决这些配置从来都不是一个期望的用例，只是可能的，因为在早期的 Gradle 版本中，每个配置都是可解决的。为了声明依赖关系，请使用您使用的插件提供的配置，例如 <<plugins-java>>。

[[upgrading-upgrading-gradle61]]
==== 从 Gradle 6.1 升级

===== 重大变化
. 默认情况下，编译和运行时类路径请求库
+
现在，JVM 项目中的类路径显式请求 `org.gradle.category=library` 属性。 如果无法使用某些库，这将导致更清晰的错误消息。 例如，当库不支持所需的 Java 版本时。 实际的效果是，现在所有 <<plugins-java-platform-consuming,平台依赖>>项都必须这样声明。
+
以前，当本地平台或使用 `Gradle Module Metadata` 发布的平台省略了 `platform()` 关键字时，平台依赖关系也偶然起作用
. 来自项目根 `gradle.properties` 的属性泄漏到 `buildSrc` 和包括的内部版本中
+
Gradle 6.2 和 Gradle 6.2.1 中进行了回归，这导致在项目根 `gradle.properties` 文件中设置的 Gradle 属性泄漏到 `buildSrc` 构建和该根包含的任何构建中。
+
如果 `buildSrc` 版本或包含的版本突然发现来自项目根 `gradle.properties` 文件的属性的意外值或不兼容值，这可能会导致构建开始失败。
+
回归已在 `Gradle 6.2.2` 中修复。

===== 弃用

* Gradle 6.1 和6.2 之间没有弃用。

[[upgrading-upgrading-gradle60]]
==== 从 Gradle 6.0 或 更早的版本升级

===== 弃用

====== 在任务完成之前查询任务的映射输出属性

在任务完成之前查询映射的输出属性的值可能会导致奇怪的构建失败，因为这表明过时或不存在的输出可能会被错误使用。 此行为已弃用，并将发出弃用警告。 这将成为 Gradle 7.0 中的错误。

下面的示例演示了在 Producer 执行之前分析 Producer 的输出文件的问题：
[source,groovy]
----
class Consumer extends DefaultTask {
    @Input
    final Property<Integer> threadPoolSize = ...
}

class Producer extends DefaultTask {
    @OutputFile
    final RegularFileProperty outputFile = ...
}

// threadPoolSize is read from the producer's outputFile
consumer.threadPoolSize = producer.outputFile.map { it.text.toInteger() }

// Emits deprecation warning
println("thread pool size = " + consumer.threadPoolSize.get())
----

如果在 Producer 完成之前进行查询，则查询 `consumer.threadPoolSize` 的值将产生弃用警告，因为尚未生成输出文件。

====== 方法停用

以下方法已终止，不应再使用。它们将在 Gradle 7.0 中删除。

* BasePluginConvention.setProject(ProjectInternal)
* BasePluginConvention.getProject()
* StartParameter.useEmptySettings()
* StartParameter.isUseEmptySettings()

====== 备用JVM插件（也称为“软件模型”）

Gradle 2.x 中引入了一组用于 Java 和 Scala 开发的替代插件，作为基于“软件模型”的实验。 这些插件现已弃用，最终将被删除。 如果您仍在使用这些旧插件之一 (java-lang, scala-lang, jvm-component, jvm-resources, junit-test-suite) ，请查阅有关构建
Java 和 JVM 项目的文档，以确定哪个稳定的 <<jvm-build,JVM 插件>>适合您的项目。

===== 重大更改

====== `ProjectLayout` 不可用于服务 worker actions

在 Gradle 6.0 中，通过服务注入使 `ProjectLayout` 服务可用于 worker actions 操作。该服务允许可变状态泄漏到工作程序动作中，并为工作程序动作中未声明的依赖项提供了一种方法。

`ProjectLayout` 已从可用服务中删除。使用 `ProjectLayout` 的辅助操作应改为注入 `projectDirectory` 或 `buildDirectory` 作为参数。

===== 更新 Gradle 依赖

* Kotlin 更新至 https://blog.jetbrains.com/kotlin/2019/11/kotlin-1-3-60-released/[Kotlin 1.3.61].

===== 更新 Gradle 工具集

* Checkstyle 更新至 https://checkstyle.org/releasenotes.html#Release_8.27[Checkstyle 8.27].
* PMD 更新至 https://pmd.github.io/pmd-6.20.0/pmd_release_notes.html#29-november-2019---6200[PMD 6.20.0]

===== 发布 Spring Boot 应用程序

从 Gradle 6.2 开始，Gradle 会在上传之前执行健康安全性检查，以确保您没有上传过时的文件（由另一个版本生成的文件）。 这引入了使用 `component.java` 组件上传的 Spring Boot` 应用程序的问题：
[source,groovy]
----
Artifact my-application-0.0.1-SNAPSHOT.jar wasn't produced by this build.
----

这是由于 main jar任务被 Spring Boot 应用程序禁用，并且组件希望它存在而导致的。 由于默认情况下 bootJar 任务使用与 main jar 任务相同的文件，因此 Gradle 的先前版本将：

* 发布过时的 bootJar 工件
* 或如果先前未调用 bootJar 任务则失败

一种解决方法是告诉 Gradle 上传什么。 如果要上传 bootJar，则需要配置以执行此操作：

[source,java]
----
configurations {
   [apiElements, runtimeElements].each {
       it.outgoing.artifacts.removeIf { it.buildDependencies.getDependencies(null).contains(jar) }
       it.outgoing.artifact(bootJar)
   }
}
----

或者，您可能想重新启用 jar 任务，并使用其他 classifier 添加 `bootJar`。

[source,java]
----
jar {
   enabled = true
}

bootJar {
   classifier = 'application'
}
----

[[upgrading-upgrading-gradle5]]
=== 从 Gradle 5.x 升级到 6.0

不做翻译，可查看官方文档 https://docs.gradle.org/current/userguide/upgrading_version_5.html[从 Gradle 5.x 升级到 6.0]

[[upgrading-upgrading-gradle4]]
=== 从 Gradle 4.x 升级到 5.0

不做翻译，可查看官方文档 https://docs.gradle.org/current/userguide/upgrading_version_4.html[从 Gradle 4.x 升级到 5.0]

[[upgrading-migrating-maven]]
=== 从 Apache Maven 迁移到 Gradle 构建

[TIP]
====
使用慢的 Maven 构建？ 在 https://gradle.com/training/build-cache-deep-dive/?bid=docs-migrating-maven&_ga=2.89594589.735409872.1603160974-222249235.1603160974[此处注册] 以参加我们的构建缓存培训课程，以了解 Gradle Enterprise 如何将 Maven 构建速度提高多达90％。
====

https://maven.apache.org/[Apache Maven] 是用于 Java 和其他基于 JVM 的项目的构建工具，这些项目已被广泛使用，因此想要使用 Gradle 的人们通常必须迁移现有的 Maven 构建。
本指南将通过解释这两种工具的模型之间的差异和相似之处，并提供可简化操作的步骤来帮助进行这种迁移。

转化一种构建方式听起来可能会很吓人，但您不必独自完成。您可以从 https://gradle.org/help/[help.gradle.org] 搜索文档，论坛和 StackOverflow，或者在遇到麻烦时访问 https://discuss.gradle.org/c/help-discuss/14[Gradle 社区]。

==== 进行迁移

Gradle 和 Maven 之间的主要区别是灵活性，性能，用户体验和依赖管理。 https://gradle.org/maven-vs-gradle/[Maven 与 Gradle 功能比较中] 提供了这些方面的直观概述。

自 Gradle 3.0 以来，Gradle 投入了大量资金，以使 Gradle 的构建速度更快，并具有 https://blog.gradle.org/introducing-gradle-build-cache[构建缓存]，https://blog.gradle.org/incremental-compiler-avoidance[增量编译]和改进的增量 Java 编译器等功能。 对于大多数项目，即使不使用构建缓存，Gradle 的速度也比 Maven 快 2-10 倍。 从此处可以进行深入的 https://gradle.org/gradle-vs-maven-performance/[性能比较] 和从 Maven 切换到 Gradle 的业务案例。

==== 一般准则

Gradle 和 Maven 对如何构建项目有根本不同的看法。 Gradle 提供了一种灵活且可扩展的构建模型，该模型将实际工作委托给 <<about-gradle-five-task,任务依赖关系图>>。 Maven 使用固定的线性阶段模型，可以在其中附加目标（完成工作的事物）。
这可能会使两者之间的迁移看起来令人生畏，但迁移也许会出奇的容易，因为 Gradle 遵循许多与 Maven 相同的约定（例如 <<plugins-java-project-layout,标准项目结构>>），并且其依赖管理以类似的方式工作。

在这里，我们列出了一系列步骤供您参阅，这将有助于促进将任何 Maven 构建移植到 Gradle：

[TIP]
====
保留旧的 Maven 构建和新的 Gradle 构建。 您知道 Maven 构建可以工作，因此您应该保留它，直到确信 Gradle 构建可以生成所有相同的工件，然后再做您需要的事情。
这也意味着用户无需获取复制源码即可尝试 Gradle 构建。
====

. https://scans.gradle.com/?_ga=2.163518586.735409872.1603160974-222249235.1603160974#maven[为 Maven 构建创建构建扫描]。
+
构建扫描提供一种可视化的界面使您能够了解 Maven 构建中发生的情况。 对于 Maven 构建，您将能够查看项目结构，正在使用的插件，构建步骤的时间表等等。
以便您可以将其与转换项目时获得的 Gradle 构建扫描进行比较。
. 开发一种机制来验证两个构建产生相同的工件
+
这是确保您的部署和测试连续的至关重要的一步。 即使是很小的更改，例如 JAR 中清单文件的内容，也会引起问题。 如果您的 Gradle 构建生成的输出与 Maven 构建生成的输出相同，
您可以放心的切换了
+
这并不意味着您需要在每个阶段都验证每个工件，尽管这样做可以帮助您快速确定问题的根源。 您可以只关注关键输出，例如最终报告以及已发布或部署的工件。
+
与 Maven 相比，您需要考虑 Gradle 产生的构建输出中的某些固有差异。 生成的 POM 将仅包含消耗所需的信息，并且它们将针对该方案正确使用 `<compile>` 和 `<runtime>` 作用域。
您可能还会看到存档中文件和类路径中文件顺序的差异。 大多数差异都是良性的，但值得识别它们并确认它们是可以的。
. <<upgrading-migrating-maven-automatic,执行自动转换>>
+
这将创建您需要的所有 Gradle 构建文件，即使对于多模块构建也是如此。 对于更简单的 Maven 项目，Gradle 构建可以运行！

. https://scans.gradle.com/?_ga=2.126907467.735409872.1603160974-222249235.1603160974[为 Gradle 构建创建构建扫描]。
+
通过构建扫描，可以更轻松地查看构建中发生的情况。 对于 Gradle 构建，您将能够查看项目结构，依赖项（常规和项目间的依赖关系），正在使用的插件以及构建的控制台输出。
+
此时您的构建可能会失败，但是没关系；扫描仍将运行。将Gradle构建的构建扫描与Maven构建的构建扫描进行比较，然后继续执行此列表以排除故障。
+
我们建议您在迁移过程中定期生成构建扫描，以帮助您确定问题并排除故障。 如果您愿意，您还可以使用 Gradle 构建扫描来确定提高构建性能的机会，毕竟，性能首先是切换到 Gradle 的一个重要原因。

. <<upgrading-migrating-maven-migrating-dependencies>>
. <<upgrading-migrating-maven-test>>
+
通过配置额外的源集，可以简单地迁移许多测试。 如果您使用的是第三方库（例如 FitNesse），请查看 https://plugins.gradle.org/[Gradle 插件网站] 上是否有合适的社区插件。

. 用 Gradle 插件替换等效的 Maven 插件
+
对于 <<upgrading-migrating-maven-migrating-plugins,流行的插件>>，Gradle 经常有一个等效的插件供您使用。 您可能还会发现可以用 <<upgrading-migrating-maven-migrating-understanding-plugins,内置的 Gradle 功能替换插件>>。
作为最后的选择，您可能需要通过自己的 <<upgrading-migrating-maven-migrating-custom-plugins,自定义插件和任务类型>>重新实现 Maven 插件。

本章的其余部分更详细地介绍了将构建从 Maven 迁移到 Gradle 的具体方面。

[[upgrading-migrating-maven-migrating-understanding-build-lifecycle]]
==== 了解构建生命周期

Maven 构建的 https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html[构建生命周期] 由一组固定阶段组成。
这可能会成为用户迁移到 Gradle 的障碍，因为它的构建生命周期和 Gradle <<authoring-lifecycle,有所不同>>，尽管了解 Gradle 的构建方式如何适合初始化，配置和执行阶段的结构很重要。
幸运的是，Gradle 具有可以模仿 Maven 各个阶段的功能的<<authoring-tasks-lifecycle,生命周期的任务>>。

这些使您可以通过创建仅依赖于您感兴趣的任务的无操作任务来定义自己的“生命周期”。并且为了使 Maven 用户更轻松地过渡到 Gradle，<<plugins-base-task,Base 插件>> - 由所有 JVM 语言应用 <<plugins-java,Java Library 插件>>之类的插件提供了一组与主要 Maven 阶段相对应的生命周期任务。

这是一些主要的 Maven 阶段以及它们映射到的 Gradle 任务的列表：

*clean*::
使用 Base 插件提供的 `clean` 任务.
*compile*::
使用 <<plugins-java-task,Java 插件>>提供的 `classes` 任务和其他 JVM 语言插件。这将编译所有语言的所有源文件的所有类，并通过 `processResources` 任务执行 <<upgrading-migrating-maven-migrating-filtering-resources,资源过滤>>。
*test*::
使用 Java 插件提供的 `test` 任务.它仅运行单元测试，或更具体地说，运行组成 `test source set` 的测试。
*package*::
使用 Base 插件提供的 `assemble` 任务.这将构建适合该项目的任何软件包，例如 Java 库的 JAR 或传统 Java Webapp 的 WAR。
*verify*::
使用 Base 插件提供的 `check` 任务.这将运行所有附加的验证任务，通常包括单元测试，静态分析任务（如 <<plugins-checkstyle,Checkstyle>>）和其他任务。 如果要包括集成测试，则必须 <<upgrading-migrating-maven-migrating-Configuring-integration-tests,手动配置>>这些，这是一个简单的过程。
*install*::
使用 <<plugins-maven-publish, Maven Publish 插件>> 提供的 `publishToMavenLocal` 任务.
+
请注意，Gradle 构建不需要您 "install" 工件，因为您可以使用更合适的功能，例如项目间依赖关系和复合构建。 您只应使用 `publishToMavenLocal` 与 `Maven` 构建进行互操作。
+
Gradle 还允许您解决对本地 Maven 缓存的依赖关系，如 <<dependency-declaring-versions-project,声明仓库>>部分中所述。
*deploy*::
使用 <<plugins-maven-publish, Maven Publish 插件>> 提供的 `publish` 任务 - 确保您的构建使用的是旧版本的 Maven 插件(ID: maven) 。 这会将您的程序包发布到所有已配置的发布存储库。
还有其他一些任务，即使定义了多个资源，也可以将其发布到单个资源库。
+
请注意，默认情况下，Maven Publish Plugin 不会发布源代码和 Javadoc JAR，但是可以按照 <<jvm-build-packaging,构建 Java 项目>>的指南中的说明轻松激活它。

[[upgrading-migrating-maven-automatic]]
==== 执行自动转换

Gradle 的 `init` 任务通常用于创建新的骨架项目，但是您也可以使用它将现有的 Maven 构建自动转换为 Gradle。在系统上安装 Gradle 之后，只需执行以下命令

[source,groovy]
----
> gradle init
----

从根项目目录，并让 Gradle 做它的事情。 这基本上包括解析现有的 POM 并生成相应的 Gradle 构建脚本。 如果您要迁移 <<authoring-multi-project-builds,构建多项目>>，Gradle 还将创建一个 settings 脚本。

您会发现新的Gradle构建包括以下内容：

* POM 中指定的所有自定义存储库
* 您的外部和项目间依赖
* 用于构建项目的适当插件（仅限于 <<plugins-maven-publish,Maven Publish>>，<<plugins-java,Java>> 和 <<plugins-war,War>> 插件中的一个或多个）

有关自动转换功能的完整列表，请参见 <<plugins-build-init-types,Build Init 插件>>一章。

要记住的一件事是有些组件不会自动转换。它们转换时可能有问题，您需要做一些手工工作。选项包括：

* 使用 <<plugins-distribution,Distribution Plugin>>
* 使用 <<plugins-java-library-distribution,Java Library Distribution Plugin>>
* 使用 <<plugins-application,Application Plugin>>
* <<authoring-work-files-archives,创建自定义 archive tasks>>
* 从 https://plugins.gradle.org/[Gradle 插件网站] 使用合适的社区插件

如果您的 Maven 构建没有使用大量的插件或者自定义的方式，则只需运行

[source,groovy]
----
> gradle build
----

迁移完成后。这将运行测试并产生所需的工件，而您无需任何额外的干预。

[[upgrading-migrating-maven-migrating-dependencies]]
==== 迁移依赖

Gradle 的依赖关系管理系统比 Maven 的依赖项管理系统更灵活，但是它仍然支持相同的存储库，声明的依赖关系，作用域（Gradle 中的 <<dependency-learning-dependency-configurations,依赖关系配置>>）和可传递依赖关系的概念。
实际上，Gradle 与 Maven 兼容的存储库完美配合，这使得迁移依赖关系变得容易。

[TIP]
====
两种工具之间的一个显着区别是它们如何管理版本冲突。 Maven 使用 "最接近" 的匹配算法，而 Gradle 选择 最新 的匹配算法。 不过，请放心，您可以控制选择哪个版本，如 <<dependency-transitive-dependencies-upgrading,管理依赖传递>>中所述。
====

在以下各节中，我们将向您展示如何迁移 Maven 构建的依赖管理信息中最常见的元素。

===== 声明依赖

Gradle 使用与 Maven 相同的依赖标识符组件：group ID, artifact ID 和 version.。 它还支持 classifiers。 因此，您所需要做的就是将标识符的依赖信息替换为 Gradle 的语法，这在 <<dependency-learning-declaring-dependencies,声明依赖项>> 一章中进行了介绍。

例如，Log4J 使用 Maven 风格的依赖关系：

[source,xml]
----
<dependencies>
    <dependency>
        <groupId>log4j</groupId>
        <artifactId>log4j</artifactId>
        <version>1.2.12</version>
    </dependency>
</dependencies>
----

在 Gradle 构建脚本中，这种依赖关系如下所示：

Example 1. Declaring a simple compile-time dependency
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Groovy
----
dependencies {
    implementation 'log4j:log4j:1.2.12' // <1>
}
----
<1> 将 Log4J 版本 `1.2.12` 舔加到  implementation 配置（作用域）

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
dependencies {
    implementation("log4j:log4j:1.2.12") // <1>
}
----
<1> 将 Log4J 版本 `1.2.12` 舔加到  implementation 配置（作用域）

字符串标识符采用 Maven 的 `groupId`，`artifactId` 和 `version` 值，尽管 Gradle 将它们称为 `group`, `module` 和 `version`。

上面的示例提出了一个明显的问题：该 `implementation` 配置是什么？ 它是 <<plugins-java,Java 插件>>提供的标准依赖配置之一，通常用于替代 Maven 的默认 `compile` 范围

Maven 的作用域与 Gradle 的标准配置之间的几个区别归结为 Gradle 区分了构建模块所需的依赖性和构建依赖于该模块的模块所需的依赖性。 Maven 没有这种区别，因此已发布的 POM 通常包括库的使用者实际上不需要的依赖项。

以下是主要的 Maven 依赖范围以及如何处理它们的迁移：

*compile*::
Gradle 具有两种可用于代替 `compile` 作用域的配置： `implementation`  和 `api`。 前者适用于所有应用 Java 插件的项目，而 api 仅适用于专门应用 <<plugins-java-library,Java Library Plugin>>的项目。
+
在大多数情况下，您应该只使用 `implementation`  配置，尤其是在构建应用程序或网络应用程序时。 但是，如果您要构建库，则可以在构建 Java 库部分中了解使用 `api` 声明哪些依赖项。
上面链接的 <<jvm-build-building,Java 库插件>> 一章提供了有关 `api` 和 `implementation`  之间区别的更多信息。
*runtime*::
使用 `runtimeOnly` 配置
*test*::
Gradle 区分了编译项目测试所需的那些依赖项和仅运行它们所需的那些依赖项。
+
应针对 `testImplementation` 配置声明测试编译所需的依赖关系。仅运行测试所需的那些应该使用 `testRuntimeOnly`。
*provided*::
使用 `compileOnly` 配置。
+
请注意，<<plugins-war,War 插件>>添加了 `provideCompile` 和 `providerRuntime` 依赖项配置。 它们的行为与 `compileOnly` 略有不同，只需确保 WAR 文件中没有打包这些依赖项即可。
但是，依赖项包括在运行时和测试运行时类路径中，因此，如果需要，请使用这些配置。
*import*::
`import` 主用于主要在 `<dependencyManagement>` 块中使用，并且仅适用于仅 POM 的发布。 阅读有关 <<upgrading-migrating-maven-migrating-using-boms,使用物料清单>>的部分，以了解有关如何复制此行为的更多信息。
+
您还可以指定对仅POM的发布的常规依赖性。 在这种情况下，在该POM中声明的依赖关系将被视为构建的常规传递依赖关系。
+
例如，假设您想在测试中使用 `groovy-all` 的POM。这是仅支持POM的出版物，在 `<dependencies>` 块中列出了自己的依赖项。 Gradle 构建中的适当配置如下所示：

Example 2. Consuming a POM-only dependency
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Groovy
----
dependencies {
    testImplementation 'org.codehaus.groovy:groovy-all:2.5.4'
}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
dependencies {
    testImplementation("org.codehaus.groovy:groovy-all:2.5.4")
}
----

这样做的结果是，将所有 `groovy-POM` 中的所有编译和运行时范围依赖项都添加到测试运行时类路径中，而仅将编译范围依赖项添加到测试编译类路径中。 与其他作用域的依赖关系将被忽略。

[[upgrading-migrating-maven-migrating-plugins]]
==== Migrating common plugins

[[upgrading-migrating-maven-migrating-understanding-plugins]]
==== Understanding which plugins you don’t need

[[upgrading-migrating-maven-migrating-custom-plugins]]
==== Dealing with uncommon and custom plugins

[[upgrading-migrating-maven-migrating-filtering-resources]]
==== Filtering resources

[[upgrading-migrating-maven-migrating-Configuring-integration-tests]]
==== Configuring integration tests

[[upgrading-migrating-maven-migrating-using-boms]]
==== Using bills of materials (BOMs)

[[upgrading-migrating-maven-test]]
==== 配置集成和功能测试


[[upgrading-migrating-ant]]
=== 从 Apache Ant 迁移到 Gradle 构建