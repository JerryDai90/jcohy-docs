[[boot-features]]
= Spring Boot Features
include::attributes.adoc[]

本部分将介绍 Spring Boot 相关的细节内容。在这里，您可以学习到可能需要使用和自定义的主要功能。您如果还没有做好充分准备，可能需要阅读 "<<getting-started.adoc#getting-started,入门>>" 和 "<<using-spring-boot.adoc#using-boot,使用 Spring Boot>>" ，以便打下前期基础。

[[boot-features-spring-application]]
== SpringApplication
`SpringApplication` 类提供了一种可通过运行 `main()` 方法来启动 Spring 应用的简单方式。多数情况下，您只需要委托给静态的 `SpringApplication.run` 方法：

[source,java,indent=0]
----
	public static void main(String[] args) {
		SpringApplication.run(MySpringConfiguration.class, args);
	}
----

当应用启动时，您应该会看到类似以下的内容输出：

[indent=0,subs="attributes"]
----
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::   v{spring-boot-version}

2019-04-31 13:09:54.117  INFO 56603 --- [           main] o.s.b.s.app.SampleApplication            : Starting SampleApplication v0.1.0 on mycomputer with PID 56603 (/apps/myapp.jar started by pwebb)
2019-04-31 13:09:54.166  INFO 56603 --- [           main] ationConfigServletWebServerApplicationContext : Refreshing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@6e5a8246: startup date [Wed Jul 31 00:08:16 PDT 2013]; root of context hierarchy
2019-04-01 13:09:56.912  INFO 41370 --- [           main] .t.TomcatServletWebServerFactory : Server initialized with port: 8080
2019-04-01 13:09:57.501  INFO 41370 --- [           main] o.s.b.s.app.SampleApplication            : Started SampleApplication in 2.992 seconds (JVM running for 3.658)
----

默认情况下，将显示 `INFO` 级别的日志信息，包括一些应用启动相关信息。如果您需要修改 `INFO` 日志级别，请参考<<boot-features-custom-log-levels,日志等级>>。

使用主应用程序类包中的实现版本来确定应用程序版本。 可以通过将 `spring.main.log-startup-info` 设置为 `false` 来关闭启动信息记录。 这还将关闭对应用程序活动配置文件的日志记录。

TIP: 要在启动期间添加其他日志记录，可以在 `SpringApplication` 的子类中重写 `logStartupInfo(boolean)`。


[[boot-features-startup-failure]]
=== 启动失败
如果您的应用无法启动，注册的 `FailureAnalyzers` 可能会提供有相关的错误信息和解决问题的具体方法。例如，如果您在已经被占用的 `8080` 端口上启动了一个 web 应用，会看到类似以下的错误信息：

[indent=0]
----
	***************************
	APPLICATION FAILED TO START
	***************************

	Description:

	Embedded servlet container failed to start. Port 8080 was already in use.

	Action:

	Identify and stop the process that's listening on port 8080 or configure this application to listen on another port.
----

NOTE: Spring Boot 提供了许多的 `FailureAnalyzer` 实现，您也可以<<howto.adoc#howto-failure-analyzer,添加自己的实现>>。

如果没有失败分析器能够处理的异常，您仍然可以显示完整的条件报告以便更好地了解出现的问题。为此，您需要针对 `org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener` <<boot-features-external-config,启用 `debug` 属性>> 或者<<boot-features-custom-log-levels,开启 `DEBUG` 日志>>。

例如，如果您使用 `java -jar` 运行应用，可以按以下方式启用 `debug` 属性：

[indent=0,subs="attributes"]
----
	$ java -jar myproject-0.0.1-SNAPSHOT.jar --debug
----



[[boot-features-lazy-initialization]]
=== 延迟初始化
`SpringApplication` 允许延迟地初始化应用程序。 启用延迟初始化后，将根据需要创建bean，而不是在应用程序启动期间创建bean。 因此，启用延迟初始化可以减少应用程序启动所需的时间。 在Web应用程序中，启用延迟初始化将导致许多与Web相关的Bean直到收到HTTP请求后才被初始化。

延迟初始化的缺点是，它可能会延迟发现应用程序问题的时间。 如果错误配置的Bean延迟初始化，则启动期间将不再发生故障，并且只有在初始化Bean时问题才会变得明显。 还必须注意确保JVM有足够的内存来容纳所有应用程序的bean，而不仅仅是启动期间初始化的bean。 由于这些原因，默认情况下不会启用延迟初始化，因此建议在启用延迟初始化之前先对JVM的堆大小进行微调。

可以使用 `SpringApplicationBuilder` 上的 `lazyInitialization` 方法或 `SpringApplication` 上的 `setLazyInitialization` 方法以编程方式启用延迟初始化。 另外，可以使用 configprop:spring.main.lazy-initialization[] 属性启用它，如以下示例所示：

[source,properties,indent=0,configprops]
----
	spring.main.lazy-initialization=true
----

TIP: 如果要在对应用程序其余部分使用延迟初始化时禁用某些bean的延迟初始化，则可以使用 `@Lazy(false)` 注解将它们的延迟属性显式设置为 `false`。



[[boot-features-banner]]
=== 自定义 banner
可以通过在 classpath 下添加一个 `banner.txt` 文件，或者将 configprop:spring.banner.location[]  属性指向该文件的位置来更改启动时打印的 banner。如果文件采用了非 UTF-8 编码，您可以设置 `spring.banner.charset` 来解决。除了文本文件，
您还可以将 `banner.gif`、`banner.jpg` 或者 `banner.png` 图片文件添加到 classpath 下，或者设置 configprop:spring.banner.image.location[] 属性。指定的图片将会被转换成 ASCII 形式并打印在 banner 文本上方。

您可以在 `banner.txt` 文件中使用以下占位符：

.Banner 变量
|===
| 变量 | 描述

| `${application.version}`
| 您的应用版本号，声明在 `MANIFEST.MF` 中。例如，`Implementation-Version: 1.0` 将被打印为 `1.0`。

| `${application.formatted-version}`
| 您的应用版本号，声明在 `MANIFEST.MF` 中，格式化之后打印（用括号括起来，以 `v` 为前缀），例如 (`v1.0`)。

| `${spring-boot.version}`
| 您使用的 Spring Boot 版本。例如 `{spring-boot-version}`。

| `${spring-boot.formatted-version}`
| 您使用的 Spring Boot 版本格式化之后显示（用括号括起来，以 `v` 为前缀）。例如 `(v{spring-boot-version})`。

| `${Ansi.NAME}` (or `${AnsiColor.NAME}`, `${AnsiBackground.NAME}`, `${AnsiStyle.NAME}`)
| 其中 `NAME` 是 ANSI 转义码的名称。有关详细信息，请参阅 {spring-boot-module-code}/ansi/AnsiPropertySource.java[`AnsiPropertySource`]。

| `${application.title}`
| 您的应用标题，声明在 `MANIFEST.MF` 中，例如 `Implementation-Title: MyApp` 打印为 `MyApp`。
|===

TIP: 如果您想以编程的方式生成 banner，可以使用 `SpringApplication.setBanner(​...)` 方法。使用 `org.springframework.boot.Banner` 接口并实现自己的 `printBanner()` 方法。

您还可以使用 configprop:spring.main.banner-mode[] 属性来确定是否必须在  `System.out` (`console`) 上打印 banner，还是使用日志记录器 (`log`)或者都不打印(`off`)。

打印的 banner 被注册名为 `springBootBanner` 的单例 bean。

[[boot-features-customizing-spring-application]]
=== 自定义 SpringApplication
如果 `SpringApplication` 的默认设置不符合您的想法，您可以创建本地实例进行定制化。例如，要关闭 banner，您可以这样：

[source,java,indent=0]
----
	public static void main(String[] args) {
		SpringApplication app = new SpringApplication(MySpringConfiguration.class);
		app.setBannerMode(Banner.Mode.OFF);
		app.run(args);
	}
----

NOTE: 传入 `SpringApplication` 的构造参数是 spring bean 的配置源。大多情况下是引用 `@Configuration` 类，但您也可以引用 XML 配置或者被扫描的包。

也可以使用 `application.properties` 文件配置 `SpringApplication`。有关详细信息，请参见_<<boot-features-external-config,外部化配置>>_。

关于配置选项的完整列表，请参阅  {spring-boot-module-api}/SpringApplication.html[`SpringApplication` Javadoc]。

[[boot-features-fluent-builder-api]]
=== Fluent Builder API

如果您需要构建一个有层级关系的 `ApplicationContext`（具有父/子关系的多上下文），或者偏向使用 fluent（流式）构建器 API，可以使用 `SpringApplicationBuilder`。

`SpringApplicationBuilder` 允许您链式调用多个方法，包括能创建出具有层次结构的 `parent` 和 `child` 方法。

例如：

[source,java,indent=0]
----
include::{code-examples}/builder/SpringApplicationBuilderExample.java[tag=hierarchy]
----

NOTE: 创建层级的 `ApplicationContext` 时有部分限制，比如 Web 组件必须包含在子上下文中，并且相同的 `Environment` 将作用于父子上下文。有关详细信息，请参阅 {spring-boot-module-api}/builder/SpringApplicationBuilder.html[`SpringApplicationBuilder` Javadoc] 。

[[boot-features-application-events-and-listeners]]
=== 应用程序事件与监听器

除了常见的 Spring Framework 事件，比如  {spring-framework-api}/context/event/ContextRefreshedEvent.html[`ContextRefreshedEvent`]，`SpringApplication` 还会发送其他应用程序事件。

[NOTE]
====
在 `ApplicationContext` 创建之前，实际上触发了一些事件，因此您不能像 `@Bean` 一样注册监听器。您可以通过 `SpringApplication.addListeners(​...)` 或者 `SpringApplicationBuilder.listeners(...​)` 方法注册它们。
如果您希望无论应用使用何种创建方式都能自动注册这些监听器，您都可以将 `META-INF/spring.factories` 文件添加到项目中，并使用 `org.springframework.context.ApplicationListener` 属性键指向您的监听器。
比如：`org.springframework.context.ApplicationListener=com.example.project.MyListener`

[indent=0]
----
	org.springframework.context.ApplicationListener=com.example.project.MyListener
----

====

当您运行应用时，应用程序事件将按照以下顺序发送：

. 在开始应用开始运行但还没有进行任何处理时（除了注册监听器和初始化器[initializer]），将发送 `ApplicationStartingEvent`。
. 当 Environment 被上下文使用，但是在上下文创建之前，将发送 `ApplicationEnvironmentPreparedEvent`。
. 准备 `ApplicationContext` 并调用 `ApplicationContextInitializers` 之后但在加载任何bean定义之前，将发送 `ApplicationContextInitializedEvent`。
. 开始刷新之前，bean 定义被加载之后发送 `ApplicationPreparedEvent`。
. 在上下文刷新之后且所有的应用和命令行运行器（command-line runner）被调用之前发送 `ApplicationStartedEvent`。
. 在应用程序和命令行运行器（command-line runner）被调用之后，将发出 `ApplicationReadyEvent`，该事件用于通知应用已经准备处理请求。
. 如果启动时发生异常，将发送 `ApplicationFailedEvent`。

上面的列表仅包含绑定到 `SpringApplication` 的 `SpringApplicationEvents`。 除这些以外，以下事件也在 `ApplicationPreparedEvent` 之后和 `ApplicationStartedEvent` 之前发布：

. 刷新 `ApplicationContext` 时，将发送 `ContextRefreshedEvent`。
. `WebServer` 准备就绪后，将发送 `WebServerInitializedEvent`。 `ServletWebServerInitializedEvent` 和 `ReactiveWebServerInitializedEvent` 分别是servlet和reactive变量。

TIP: 您可能不会经常使用应用程序事件，但了解他们的存在还是很有必要的。在框架内部，Spring Boot 使用这些事件来处理各种任务。

应用程序事件发送使用了 Spring Framework 的事件发布机制。该部分机制确保在子上下文中发布给监听器的事件也会发布给所有祖先上下文中的监听器。因此，如果您的应用程序使用有层级结构的 `SpringApplication` 实例，则监听器可能会收到同种类型应用程序事件的多个实例。

为了让监听器能够区分其上下文事件和后代上下文事件，您应该注入其应用程序上下文，然后将注入的上下文与事件的上下文进行比较。可以通过实现 `ApplicationContextAware` 来注入上下文，如果监听器是 bean，则使用 `@Autowired` 注入上下文。

[[boot-features-web-environment]]
=== Web 环境
`SpringApplication` 试图为您创建正确类型的 `ApplicationContext`。确定 `WebApplicationType` 的算法非常简单：

* 如果存在 Spring MVC，则使用 `AnnotationConfigServletWebServerApplicationContext`
* 如果 Spring MVC 不存在且存在 Spring WebFlux，则使用 `AnnotationConfigReactiveWebServerApplicationContext`
* 否则，使用 `AnnotationConfigApplicationContext`

这意味着如果您在同一个应用程序中使用了 Spring MVC 和 Spring WebFlux 中的新 `WebClient`，默认情况下将使用 Spring MVC。您可以通过调用 `setWebApplicationType(WebApplicationType)` 修改默认行为。

也可以调用 `setApplicationContextClass(...)` 来完全控制 `ApplicationContext` 类型。

TIP: 在 JUnit 测试中使用 `SpringApplication` 时，通常需要调用 `setWebApplicationType(WebApplicationType.NONE)`。

[[boot-features-application-arguments]]
=== 访问应用程序参数
如果您需要访问从 `SpringApplication.run(​...)` 传入的应用程序参数，可以注入一个 `org.springframework.boot.ApplicationArguments` bean。`ApplicationArguments` 接口提供了访问原始 `String[]` 参数以及解析后的 `option` 和 `non-option` 参数的方法：

[source,java,indent=0]
----
	import org.springframework.boot.*;
	import org.springframework.beans.factory.annotation.*;
	import org.springframework.stereotype.*;

	@Component
	public class MyBean {

		@Autowired
		public MyBean(ApplicationArguments args) {
			boolean debug = args.containsOption("debug");
			List<String> files = args.getNonOptionArgs();
			// if run with "--debug logfile.txt" debug=true, files=["logfile.txt"]
		}

	}
----

TIP: Spring Boot 还向 Spring `Environment` 注册了一个 `CommandLinePropertySource`。这允许您可以使用 `@Value` 注解注入单个应用参数。

[[boot-features-command-line-runner]]
=== 使用 ApplicationRunner 或 CommandLineRunner
如果您需要在 `SpringApplication` 启动时运行一些代码，可以实现 `ApplicationRunner` 或者 `CommandLineRunner` 接口。这两个接口的工作方式是一样的，都提供了一个单独的 `run` 方法，它将在 `SpringApplication.run(​...)` 完成之前调用。

`CommandLineRunner` 接口提供了访问应用程序字符串数组形式参数的方法，而 `ApplicationRunner` 则使用了上述的 `ApplicationArguments` 接口。以下示例展示 `CommandLineRunner` 和 `run` 方法的使用：

[source,java,indent=0]
----
	import org.springframework.boot.*;
	import org.springframework.stereotype.*;

	@Component
	public class MyBean implements CommandLineRunner {

		public void run(String... args) {
			// Do something...
		}

	}
----

如果您定义了多个 `CommandLineRunner` 或者 `ApplicationRunner` bean，则必须指定调用顺序，您可以实现 `org.springframework.core.Ordered` 接口，也可以使用 `org.springframework.core.annotation.Order` 注解解决顺序问题。

[[boot-features-application-exit]]
=== 应用程序退出
每个 `SpringApplication` 注册了一个 JVM 关闭钩子，以确保 `ApplicationContext` 在退出时可以优雅关闭。所有标准的 Spring 生命周期回调（比如 `DisposableBean` 接口，或者 `@PreDestroy` 注解）都可以使用。

此外，如果希望在调用 `SpringApplication.exit()` 时返回特定的退出码，则 bean 可以实现 `org.springframework.boot.ExitCodeGenerator` 接口。之后退出码将传递给 `System.exit()` 以将其作为状态码返回，如示例所示：

[source,java,indent=0]
----
include::{code-examples}/ExitCodeApplication.java[tag=example]
----

此外，`ExitCodeGenerator` 接口可以通过异常实现。遇到这类异常时，Spring Boot 将返回实现的 `getExitCode()` 方法提供的退出码。

[[boot-features-application-admin]]
=== 管理功能
可以通过指定 configprop:spring.application.admin.enabled[]  属性来为应用程序启用管理相关的功能。其将在 `MBeanServer` 平台上暴露  {spring-boot-module-code}/admin/SpringApplicationAdminMXBean.java[`SpringApplicationAdminMXBean`]。您可以使用此功能来远程管理 Spring Boot 应用。该功能对服务包装器的实现也是非常有用的。

TIP: 如果您想知道应用程序在哪一个 HTTP 端口上运行，请使用 `local.server.port` 键获取该属性。



[[boot-features-external-config]]
== 外部化配置
Spring Boot 可以让您的配置外部化，以便可以在不同环境中使用相同的应用程序代码。您可以使用 properties 文件、YAML 文件、环境变量或者命令行参数来外部化配置。可以使用 `@Value` 注解将属性值直接注入到 bean 中，可通过 Spring 的 `Environment` 访问，
或者通过 `@ConfigurationProperties` <<boot-features-external-config-typesafe-configuration-properties,绑定到结构化对象>>。

Spring Boot 使用了一个非常特别的 `PropertySource` 指令，用于智能覆盖默认值。属性将按照以下顺序处理：

. 当 devtools 被激活， `$HOME/.config/spring-boot` 文件夹中的 <<using-spring-boot.adoc#using-boot-devtools-globalsettings,Devtools 全局设置属性>>。
. 在测试中使用到的 {spring-framework-api}/test/context/TestPropertySource.html[`@TestPropertySource`] 注解。
. 在测试中使用到的 `properties` 属性，可以是 {spring-boot-test-module-api}/context/SpringBootTest.html[`@SpringBootTest`] 和 <<boot-features-testing-spring-boot-applications-testing-autoconfigured-tests,用于测试应用程序某部分的测试注解>>。
. 命令行参数。
. 来自 `SPRING_APPLICATION_JSON` 的属性（嵌入在环境变量或者系统属性【system propert】中的内联 JSON）。
. `ServletConfig` 初始化参数。
. `ServletContext` 初始化参数。
. 来自 `java:comp/env` 的 JNDI 属性。
. Java 系统属性（`System.getProperties()`）。
. 操作系统环境变量。
. 只有 `random.*` 属性的 `RandomValuePropertySource`。
. 在已打包的 jar 外部的 <<boot-features-external-config-profile-specific-properties,指定 profile 的应用属性文件>> (`application-\{profile}.properties` 和 YAML 变量).
. 在已打包的 jar 内部的<<boot-features-external-config-profile-specific-properties,指定 profile 的应用属性文件>> (`application-\{profile}.properties` 和 YAML 变量).
. 在已打包的 jar 外部的应用属性文件 (`application.properties` 和 YAML 变量).
. 在已打包的 jar 内部的应用属性文件 (`application.properties` 和 YAML 变量).
. 在 `@Configuration` 类上的 {spring-framework-api}/context/annotation/PropertySource.html[`@PropertySource`]  注解。
请注意，在刷新应用程序上下文之前，不会将此类属性源添加到环境中。 现在配置某些属性（如 `logging.*` 和 `spring.main.*` ）为时已晚，这些属性在刷新开始之前就已读取。
. 默认属性（使用 `SpringApplication.setDefaultProperties` 指定）。

举个例子，假设开发的 `@Component` 使用了 `name` 属性，可以这样：

[source,java,indent=0]
----
	import org.springframework.stereotype.*;
	import org.springframework.beans.factory.annotation.*;

	@Component
	public class MyBean {

	    @Value("${name}")
	    private String name;

	    // ...

	}
----

在您的应用程序的 classpath 中（比如在 jar 中），您可以有一个 `application.properties`，它为 name 提供了一个合适的默认属性值。当在新环境中运行时，您可以在 jar 外面提供一个 `application.properties` 来覆盖 `name`。对于一次性测试，您可以使用命令行指定形式启动（比如 `java -jar app.jar --name="Spring"`）。

[[boot-features-external-config-application-json]]
[TIP]
====
`SPRING_APPLICATION_JSON` 属性可以在命令行中提供一个环境变量。比如在 UN*X shell 中：

[indent=0]
----
	$ SPRING_APPLICATION_JSON='{"acme":{"name":"test"}}' java -jar myapp.jar
----

在此示例中，您可以在 Spring `Environment` 中使用 `acme.name=test`，也可以在系统属性（System property）中将 JSON 作为 `spring.application.json` 属性提供：

[indent=0]
----
	$ java -Dspring.application.json='{"name":"test"}' -jar myapp.jar
----

或者以命令行参数形式：

[indent=0]
----
	$ java -jar myapp.jar --spring.application.json='{"name":"test"}'
----

或者将 JSON 作为一个 JNDI 变量：`java:comp/env/spring.application.json`。
====



[[boot-features-external-config-random-values]]
=== 配置随机值
`RandomValuePropertySource` 对于随机值注入非常有用（比如在保密场景或者测试用例中)。它可以产生 integer、long、uuid 和 string。如下示例：

[source,properties,indent=0]
----
	my.secret=${random.value}
	my.number=${random.int}
	my.bignumber=${random.long}
	my.uuid=${random.uuid}
	my.number.less.than.ten=${random.int(10)}
	my.number.in.range=${random.int[1024,65536]}
----

`random.int*` 语法为 `OPEN value (,max) CLOSE`，`OPEN,CLOSE` 可为任意字符，`value,max` 为整数。如果使用了 `max`，`value` 则为最小值，`max` 为最大值。

[[boot-features-external-config-command-line-args]]
=== 访问命令行属性
默认情况下，`SpringApplication` 将所有命令行选项参数（即以 `--` 开头的参数，比如 `--server.port=9000`）转换为属性，并将它们添加到 Spring `Environment` 中。如之前所述，命令行属性始终优先于其他属性源。

如果您不希望将命令行属性添加到 `Environment`，可以使用 `SpringApplication.setAddCommandLineProperties(false)` 来禁用它们。

[[boot-features-external-config-application-property-files]]
=== 应用程序属性文件
`SpringApplication` 从以下位置的 `application.properties` 文件中加载属性（properties），并将它们添加到 Spring `Environment` 中：
`SpringApplication` loads properties from `application.properties` files in the following locations and adds them to the Spring `Environment`:

. 当前目录的 `/config` 子目录
. 当前目录
. classpath 上的 `/config` 包
. classpath 根路径

列表按序号优先级排序，序号越小，优先级越高。

NOTE: 您还可以 <<boot-features-external-config-yaml, 使用 YAML（.yml） 文件>>来替代 '.properties'.

如果您不喜欢 `application.properties` 作为配置文件名，则可以通过指定  configprop:spring.config.name[]  环境属性来切换到另一个文件名。您还可以使用 `spring.config.location` 环境属性来引用一个显式位置（以逗号分隔的目录位置或文件路径列表）。
以下示例展示了如何指定其他文件名：

[indent=0]
----
	$ java -jar myproject.jar --spring.config.name=myproject
----

以下示例展示了如何指定两个位置：

[indent=0]
----
	$ java -jar myproject.jar --spring.config.location=classpath:/default.properties,classpath:/override.properties
----

WARNING: `spring.config.name` 和 `spring.config.location` 在程序启动早期就用来确定哪些文件必须加载，因此必须将它们定义为环境属性（通常是 OS 环境变量、系统属性或命令行参数）。

如果 `spring.config.location` 包含目录（而不是文件），则它们应该以 `/` 结尾（并且在运行期间，在加载之前追加从 `spring.config.name` 生成的名称，包括指定 profile 的文件名）。
`spring.config.location` 中指定的文件按原样使用，不支持指定 profile 形式，并且可被任何指定 profile 的文件的属性所覆盖。

配置位置以相反的顺序搜索。默认情况下，配置的位置为 `classpath:/,classpath:/config/,file:./,file:./config/`。生成的搜索顺序如下：

. `file:./config/`
. `file:./`
. `classpath:/config/`
. `classpath:/`

使用了 `spring.config.location` 配置自定义配置位置时，默认位置配置将被替代。例如，如果 `spring.config.location` 配置为 `classpath:/custom-config/,file:./custom-config/`，搜索顺序将变为以下：

. `file:./custom-config/`
. `classpath:custom-config/`

或者，当使用 `spring.config.additional-location` 配置自定义配置位置时，除了使用默认位置外，还会使用它们。这些其他（additional）位置将在默认位置之前搜索。例如，如果将其他位置配置为  `classpath:/custom-config/,file:./custom-config/` ，则搜索顺序将变为以下内容：

. `file:./custom-config/`
. `classpath:custom-config/`
. `file:./config/`
. `file:./`
. `classpath:/config/`
. `classpath:/`

该搜索顺序允许您在一个配置文件中指定默认值，然后有选择地覆盖另一个配置文件中的值。您可以在 `application.properties`（或您使用 `spring.config.name` 指定的其他文件）中的某个默认位置为应用程序提供默认值。之后，在运行时，这些默认值将被自定义位置中的某个文件所覆盖。

NOTE: 如果您使用的是环境变量而不是系统属性，大部分操作系统都不允许使用 . 分隔的键名，但您可以使用下划线来代替（例如，使用 `SPRING_CONFIG_NAME` 而不是 `spring.config.name`）。

NOTE: 如果应用程序在容器中运行，则可以使用 JNDI 属性（`java:comp/env`）或 servlet 上下文初始化参数来代替环境变量或系统属性。(in `java:comp/env`)



[[boot-features-external-config-profile-specific-properties]]
=== 特定 Profile 的属性文件
除 `application.properties` 文件外，还可以使用以下命名约定定义特定 profile 的属性文件：application-{profile}.properties。Environment 有一组默认配置文件（默认情况下为 `default`），如果未设置激活的（active）profile，则使用这些配置文件。换句话说，如果没有显式激活 profile，则会加载 `application-default.properties` 中的属性。

特定 profile 的属性文件从与标准 `application.properties` 相同的位置加载，特定 profile 的属性文件无论是否在打包的 jar 内部，都始终覆盖非特定文件。

如果指定了多个配置文件，则应用 last-wins 策略（优先采取最后一个）。例如，configprop:spring.profiles.active[] 属性指定的配置文件是在使用 `SpringApplication` API 配置的配置文件之后添加的，因此优先应用。

NOTE: 如果在 `spring.config.location` 中指定了文件，则不考虑这些文件的特定 profile 形式。如果您还想使用特定 profile 的属性文件，请在 `spring.config.location` 中使用目录形式。

[[boot-features-external-config-placeholders-in-properties]]
=== 属性中的占位符
`application.properties` 中的值在使用时通过现有的 `Environment` 进行过滤，因此您可以返回之前定义的值（例如，从系统属性）。

[source,properties,indent=0]
----
	app.name=MyApp
	app.description=${app.name} is a Spring Boot application
----

TIP: 您还可以使用此技术创建现有 Spring Boot 属性的简短形式。有关详细信息，请参见 _<<howto.adoc#howto-use-short-command-line-arguments,使用简短命令行参数>>_ 。

[[boot-features-encrypting-properties]]
=== 加密属性
Spring Boot 没有为加密属性值提供任何内置支持，然而，它提供了修改 Spring `Environment` 包含的值所必需的钩子。`EnvironmentPostProcessor` 接口允许您在应用程序启动之前操作 Environment。
有关详细信息，请参见 <<howto.adoc#howto-customize-the-environment-or-application-context,在启动前自定义 Environment 或 ApplicationContext>> 。

如果您正在寻找一种可用于存储凭据和密码的安全方法， https://cloud.spring.io/spring-cloud-vault/[Spring Cloud Vault]  项目支持在  https://www.vaultproject.io/[HashiCorp Vault] 中存储外部化配置。

[[boot-features-external-config-yaml]]
=== 使用 YAML 代替属性文件
https://yaml.org[YAML] 是 JSON 的超集，是一个可用于指定层级配置数据的便捷格式。只要在 classpath 上有 https://bitbucket.org/asomov/snakeyaml[SnakeYAML]  库，`SpringApplication` 类就会自动支持 YAML 作为属性文件（properties）的替代。

NOTE: 如果使用 `starter`，则 `spring-boot-starter` 会自动提供 SnakeYAML。

[[boot-features-external-config-loading-yaml]]
==== 加载 YAML
Spring Framework 提供了两个便捷类，可用于加载 YAML 文档。`YamlPropertiesFactoryBean` 将 YAML 加载为 `Properties`，`YamlMapFactoryBean` 将 YAML 加载为 `Map`。

例如以下 YAML 文档：

[source,yaml,indent=0]
----
	environments:
		dev:
			url: https://dev.example.com
			name: Developer Setup
		prod:
			url: https://another.example.com
			name: My Cool App
----

前面的示例将转换为以下属性（properties）：

[source,properties,indent=0]
----
	environments.dev.url=https://dev.example.com
	environments.dev.name=Developer Setup
	environments.prod.url=https://another.example.com
	environments.prod.name=My Cool App
----

YAML 列表表示带有 `[index]` 下标引用的属性键。例如以下 YAML：

[source,yaml,indent=0]
----
	 my:
		servers:
			- dev.example.com
			- another.example.com
----

以上示例将转成以下属性：

[source,properties,indent=0]
----
	my.servers[0]=dev.example.com
	my.servers[1]=another.example.com
----

要使用 Spring Boot 的 Binder 工具来绑定这样配置到属性（这是 `@ConfigurationProperties` 所做的），你需要在目标 bean 中有一个 `java.util.List`（或 `Set`）类型的属性，你需要为其提供一个 setter 或者使用可变值初始化它。 例如，以下示例展示将上述的配置与属性绑定：

[source,java,indent=0]
----
	@ConfigurationProperties(prefix="my")
	public class Config {

		private List<String> servers = new ArrayList<String>();

		public List<String> getServers() {
			return this.servers;
		}
	}
----



[[boot-features-external-config-exposing-yaml-to-spring]]
==== 在 Spring Environment 中将 YAML 暴露为属性
`YamlPropertySourceLoader` 类可用于在 Spring `Environment` 中将 YAML 暴露为 `PropertySource`。这样做可以让您使用带占位符语法的 `@Value` 注解来访问 YAML 属性。

[[boot-features-external-config-multi-profile-yaml]]
==== 多 profile YAML 文档
您可以使用 `spring.profiles` key 在单个文件中指定多个特定 profile 的 YAML 文档，以指示文档何时应用，如下所示：

[source,yaml,indent=0]
----
	server:
		address: 192.168.1.100
	---
	spring:
		profiles: development
	server:
		address: 127.0.0.1
	---
	spring:
		profiles: production & eu-central
	server:
		address: 192.168.1.120
----

在前面示例中，如果 `development` profile 处于激活状态，则 `server.address` 属性得值为 `127.0.0.1`。 同样，如果 `production` 和 `eu-central` profile 处于激活状态，则 `server.address` 属性的值为 `192.168.1.120`。
如果未激活 `development`、`production` 或 `eu-central` profile，则该属性的值为 `192.168.1.100`。

[NOTE]
====
因此，`spring.profiles` 可以包含一个简单的 profile 名称（例如 `production`）或一个 profile 表达式。profile 表达式允许表达更复杂的 profile 逻辑，例如  `production & (eu-central | eu-west)`。有关详细信息，请查阅{spring-framework-docs}core.html#beans-definition-profiles-java[reference guide]。
====

如果在应用程序上下文启动时没有显式激活，则激活默认 profile。因此，在以下 YAML 中，我们为 `spring.security.user.password` 设置了一个值，该值仅在 default profile 中可用：

[source,yaml,indent=0]
----
	server:
	  port: 8000
	---
	spring:
	  profiles: default
	  security:
	    user:
	      password: weak
----

然而，在以下示例中，始终设置密码，因为它未附加到任何 profile，如果需要更改，必须在所有其他 profile 中显式重置：

[source,yaml,indent=0]
----
	server:
	  port: 8000
	spring:
	  security:
	    user:
	      password: weak
----

使用 `spring.profiles` 元素来指定 Spring profile 可以选择通过使用 `!` 字符来取反（否定）。如果为单个文档指定了否定和非否定的 profile，则至少一个非否定的 profile 必须匹配，没有否定的 profile 可以匹配。

[[boot-features-external-config-yaml-shortcomings]]
==== YAML 的缺点
无法使用 `@PropertySource` 注解加载 YAML 文件。因此，如果您需要以这种方式加载值，请使用属性文件（properties）。

在特定于配置文件的YAML文件中使用多YAML文档语法可能会导致意外行为。 例如，考虑文件中的以下配置：

.application-dev.yml
[source,yaml,indent=0]
----
	server:
	  port: 8000
	---
	spring:
	  profiles: "!test"
	  security:
	    user:
	      password: "secret"
----

如果使用参数 `--spring.profiles.active=dev` 运行该应用程序，则可能希望将 `security.user.password` 设置为 "`secret`"，但事实并非如此。

嵌套文档将被过滤，因为主文件名为 `application-dev.yml`。 它已经被认为是特定于配置文件的，并且嵌套文档将被忽略。

TIP: 我们建议您不要混用特定于配置文件的YAML文件和多个YAML文档。 坚持只使用其中之一。

[[boot-features-external-config-typesafe-configuration-properties]]
=== 类型安全的配置属性
使用 `@Value("${property}")` 注解来注入配置属性有时会很麻烦，特别是如果您使用了多个属性或者您的数据本质上是分层结构。Spring Boot 提供了另一种使用属性的方法，该方法使用强类型的 bean 来管理和验证应用程序的配置，如下所示：

TIP: 另请参见<<boot-features-external-config-vs-value, `@Value` 和类型安全的配置属性之间的区别>>。

[[boot-features-external-config-java-bean-binding]]
==== JavaBean 属性绑定
可以绑定一个声明标准JavaBean属性的bean，如以下示例所示：

[source,java,indent=0]
----
	package com.example;

	import java.net.InetAddress;
	import java.util.ArrayList;
	import java.util.Collections;
	import java.util.List;

	import org.springframework.boot.context.properties.ConfigurationProperties;

	@ConfigurationProperties("acme")
	public class AcmeProperties {

		private boolean enabled;

		private InetAddress remoteAddress;

		private final Security security = new Security();

		public boolean isEnabled() { ... }

		public void setEnabled(boolean enabled) { ... }

		public InetAddress getRemoteAddress() { ... }

		public void setRemoteAddress(InetAddress remoteAddress) { ... }

		public Security getSecurity() { ... }

		public static class Security {

			private String username;

			private String password;

			private List<String> roles = new ArrayList<>(Collections.singleton("USER"));

			public String getUsername() { ... }

			public void setUsername(String username) { ... }

			public String getPassword() { ... }

			public void setPassword(String password) { ... }

			public List<String> getRoles() { ... }

			public void setRoles(List<String> roles) { ... }

		}
	}
----

前面的 POJO 定义了以下属性：

* `acme.enabled`, 默认值为 `false`。
* `acme.remote-address`, 可以从 `String` 强制转换的类型。
* `acme.security.username`, 内嵌一个 `security` 对象，其名称由属性名称决定。特别是，返回类型根本没有使用，可能是 `SecurityProperties`。
* `acme.security.password`.
* `acme.security.roles`, `String` 集合。 默认为 `USER`.

NOTE: Spring Boot自动配置大量使用 `@ConfigurationProperties` 来轻松配置自动配置的bean。 与自动配置类相似，Spring Boot中可用的 `@ConfigurationProperties` 类仅供内部使用。 通过属性文件，YAML文件，环境变量等配置的映射到该类的属性是公共API，
但是该类本身的内容并不意味着可以直接使用。

[NOTE]
====
getter 和 setter 通常是必需的，因为绑定是通过标准的 Java Bean 属性描述符来完成，就像在 Spring MVC 中一样。以下情况可以省略 setter：

* Map，只要它们要初始化，就需要一个 getter 但不一定需要setter，因为它们可以被 binder 修改。
* 集合和数组可以通过一个索引（通常使用 YAML）或使用单个逗号分隔值（属性）进行访问。最后一种情况必须使用 setter。我们建议始终为此类型添加 setter。如果初始化集合，请确保它是可变的（如上例所示）。
* 如果初始化嵌套的 POJO 属性（如前面示例中的 `Security` 字段），则不需要 setter。如果您希望 binder 使用其默认构造函数动态创建实例，则需要一个 setter。

有些人可能会使用 Project Lombok 来自动生成 getter 和 setter。请确保 Lombok 不为此类型生成任何特定构造函数，因为容器会自动使用它来实例化对象。

最后，考虑到标准 Java Bean 属性，不支持对静态属性的绑定。
====

[[boot-features-external-config-constructor-binding]]
==== 构造函数绑定
上一节中的示例可以以不变的方式重写，如下例所示：

[source,java,indent=0]
----
	package com.example;

	import java.net.InetAddress;
	import java.util.List;

	import org.springframework.boot.context.properties.ConfigurationProperties;
	import org.springframework.boot.context.properties.ConstructorBinding;
	import org.springframework.boot.context.properties.DefaultValue;

	@ConstructorBinding
	@ConfigurationProperties("acme")
	public class AcmeProperties {

		private final boolean enabled;

		private final InetAddress remoteAddress;

		private final Security security;

		public AcmeProperties(boolean enabled, InetAddress remoteAddress, Security security) {
			this.enabled = enabled;
			this.remoteAddress = remoteAddress;
			this.security = security;
		}

		public boolean isEnabled() { ... }

		public InetAddress getRemoteAddress() { ... }

		public Security getSecurity() { ... }

		public static class Security {

			private final String username;

			private final String password;

			private final List<String> roles;

			public Security(String username, String password,
					@DefaultValue("USER") List<String> roles) {
				this.username = username;
				this.password = password;
				this.roles = roles;
			}

			public String getUsername() { ... }

			public String getPassword() { ... }

			public List<String> getRoles() { ... }

		}

	}
----

在此设置中，`@ConstructorBinding` 注解用于指示应使用构造函数绑定。 这意味着绑定器将期望找到带有您希望绑定的参数的构造函数。

`@ConstructorBinding` 类的嵌套成员（例如上例中的 `Security` ）也将通过其构造函数进行绑定。

可以使用 `@DefaultValue` 指定默认值，并且将应用相同的转换服务将 `String` 值强制为缺少属性的目标类型。

NOTE: 要使用构造函数绑定，必须使用 `@EnableConfigurationProperties` 或配置属性扫描来启用该类。 您不能对通过常规Spring机制创建的bean使用构造函数绑定（例如 `@Component` bean，通过 `@Bean` 方法创建的bean或使用 `@Import` 加载的bean）

TIP: 如果您的类具有多个构造函数，则还可以直接在应绑定的构造函数上使用 `@ConstructorBinding`。



[[boot-features-external-config-enabling]]
==== 启用 `@ConfigurationProperties` 注解的类型
Spring Boot提供了绑定 `@ConfigurationProperties` 类型并将其注册为Bean的基础架构。 您可以逐类启用配置属性，也可以启用与组件扫描类似的方式进行配置属性扫描。

有时，用 `@ConfigurationProperties` 注释的类可能不适用于扫描，例如，如果您正在开发自己的自动配置，或者想要有条件地启用它们。 在这些情况下，请使用 `@EnableConfigurationProperties` 批注指定要处理的类型列表。 可以在任何 `@Configuration` 类上完成此操作，如以下示例所示：

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(AcmeProperties.class)
	public class MyConfiguration {
	}
----

要使用配置属性扫描，请将 `@ConfigurationPropertiesScan` 批注添加到您的应用程序。 通常，它被添加到使用 `@SpringBootApplication` 注释的主应用程序类中，但可以将其添加到任何 `@Configuration` 类中。
默认情况下，将从声明注释的类的包中进行扫描。 如果要定义要扫描的特定程序包，可以按照以下示例所示进行操作：

[source,java,indent=0]
----
	@SpringBootApplication
	@ConfigurationPropertiesScan({ "com.example.app", "org.acme.another" })
	public class MyApplication {
	}
----

[NOTE]
====
当以这种方式注册 `@ConfigurationProperties` bean 时，bean 具有一个固定格式的名称：`<prefix>-<fqn>`，其中 <prefix> 是 `@ConfigurationProperties` 注解中指定的环境 key 前缀，`<fqn>` 是 bean 的完全限定类名。如果注解未提供任何前缀，则仅使用 bean 的完全限定类名。

上面示例中的 bean 名称为 `acme-com.example.AcmeProperties`。
====

即使前面的配置为 `AcmeProperties` 创建了一个 bean，我们也建议 `@ConfigurationProperties` 只处理环境（environment），特别是不要从上下文中注入其他 bean。
对于极端情况，可以使用setter注入或框架提供的任何 `*Aware` 接口（例如，需要访问 `Environment` 的 `EnvironmentAware`）。 如果仍然想使用构造函数注入其他bean，则必须使用 `@Component` 注释配置属性bean，并使用基于JavaBean的属性绑定。

[[boot-features-external-config-using]]
==== 使用 `@ConfigurationProperties` 注解类型
这种配置样式与 `SpringApplication` 外部YAML配置特别有效，如以下示例所示：

[source,yaml,indent=0]
----
	# application.yml

	acme:
		remote-address: 192.168.1.1
		security:
			username: admin
			roles:
			  - USER
			  - ADMIN

	# additional configuration as required
----

要使用 `@ConfigurationProperties` bean，您可以使用与其他 bean 相同的方式注入它们，如下所示：

[source,java,indent=0]
----
	@Service
	public class MyService {

		private final AcmeProperties properties;

		@Autowired
		public MyService(AcmeProperties properties) {
		    this.properties = properties;
		}

	 	//...

		@PostConstruct
		public void openConnection() {
			Server server = new Server(this.properties.getRemoteAddress());
			// ...
		}

	}
----

TIP: 使用 `@ConfigurationProperties` 还可以生成元数据文件，IDE 可以通过这些文件来为您自己的 key 提供自动完成功能。有关详细信息，请参阅<<appendix-configuration-metadata.adoc#configuration-metadata,附录 B：配置元数据>> 。

[[boot-features-external-config-3rd-party-configuration]]
==== 第三方配置
`@ConfigurationProperties` 除了可以使用来注解类之外，您还可以在公共的 `@Bean` 方法上使用。当您想要将属性绑定到您掌控之外的第三方组件时，这样做特别有用。

要使用 `Environment` 属性配置 bean，请将 `@ConfigurationProperties` 添加到 bean 注册上，如下所示：

[source,java,indent=0]
----
	@ConfigurationProperties(prefix = "another")
	@Bean
	public AnotherComponent anotherComponent() {
		...
	}
----

使用 `another` 前缀定义的所有属性都使用与前面的 `AcmeProperties` 示例类似的方式映射到 `AnotherComponent` bean。

[[boot-features-external-config-relaxed-binding]]
==== 宽松绑定
Spring Boot 使用一些宽松的规则将 `Environment` 属性绑定到 `@ConfigurationProperties` bean，因此 `Environment` 属性名不需要和 bean 属性名精确匹配。
常见的示例包括使用了 `-` 符号分割的环境属性（例如，`context-path` 绑定到 `contextPath`）和大写环境属性（例如，`PORT` 绑定到 `port`）。

如下 `@ConfigurationProperties` 类：

[source,java,indent=0]
----
	@ConfigurationProperties(prefix="acme.my-project.person")
	public class OwnerProperties {

		private String firstName;

		public String getFirstName() {
			return this.firstName;
		}

		public void setFirstName(String firstName) {
			this.firstName = firstName;
		}

	}
----

在上述示例中，同样可以使用以下属性名称：

.宽松绑定
[cols="1,4"]
|===
| 属性 | 描述

| `acme.my-project.person.first-name`
| Kebab 风格（短横线命名），建议在 `.properties` 和 `.yml` 文件中使用。

| `acme.myProject.person.firstName`
| 标准驼峰式风格。

| `acme.my_project.person.first_name`
| 下划线表示法，`.properties` 和 `.yaml` 文件中的另外一种格式。

| `ACME_MYPROJECT_PERSON_FIRSTNAME`
| 大写风格，当使用系统环境变量时推荐使用该风格。
|===

NOTE: 注解的 `prefix` 值必须是 kebab (短横线命名)风格（小写并用 `-` 分隔，例如 `acme.my-project.person`）。

.每种属性源（property source）的宽松绑定规则
[cols="2,4,4"]
|===
| 属性源 | 简单类型 | 列表集合类型

| Properties 文件
| 驼峰式、短横线式或下划线式
| 	标准列表语法使用 `[ ]` 或逗号分隔值

| YAML 文件
| 驼峰式、短横线式或者下划线式
| 标准 YAML 列表语法或者逗号分隔值

| 环境变量
| 大写并且以下划线作为定界符，`_` 不能放在属性名之间使用
| 数字值两边使用下划线连接，例如 `MY_ACME_1_OTHER = my.acme[1].other`

| 系统属性
| 驼峰式、短横线式或者下划线式
| 标准列表语法使用 `[ ]` 或逗号分隔值
|===

TIP: 我们建议，属性尽可能以小写的短横线格式存储，比如 `my.property-name=acme`。

当绑定到 `Map` 属性时，如果 `key` 包含除小写字母数字字符或 `-` 以外的任何内容，则需要使用括号表示法来保留原始值。如果 key 没有使用 `[]` 包裹，则里面的任何非字母数字字符或 `-` 的字符都将被删除。例如，将以下属性绑定到一个 `Map`：

[source,yaml,indent=0]
----
	acme:
	  map:
	    "[/key1]": value1
	    "[/key2]": value2
	    /key3: value3

----

上面的属性将绑定到一个 `Map` 上，其中 `/key1`，`/key2` 和 `key3` 作为 map 的 key。

NOTE: 对于YAML文件，方括号需要用引号引起来，以便正确解析 keys。


[[boot-features-external-config-complex-type-merge]]
==== 合并复杂类型
当列表集合（list）在多个地方配置时，整个列表集合将被替换。

例如，假设带有 `name` 和 `description` 属性的 `MyPojo` 对象默认为 `null`。以下示例中，`AcmeProperties` 暴露了一个 `MyPojo` 对象列表集合：

[source,java,indent=0]
----
	@ConfigurationProperties("acme")
	public class AcmeProperties {

		private final List<MyPojo> list = new ArrayList<>();

		public List<MyPojo> getList() {
			return this.list;
		}

	}
----

配置可以如下：

[source,yaml,indent=0]
----
	acme:
	  list:
	    - name: my name
	      description: my description
	---
	spring:
	  profiles: dev
	acme:
	  list:
	    - name: my another name
----

如果 `dev` 配置文件未激活，则 `AcmeProperties.list` 只包含一条 `MyPojo` 条目，如之前所述。但是，如果激活了 `dev` 配置文件，列表集合仍然只包含一个条目（name 属性值为 `my another name`，description 为 `null`）。
此配置不会向列表集合中添加第二个 `MyPojo` 实例，也不会合并条目。

在多个配置文件中指定一个 `List` 时，最高优先级（并且只有一个）的列表集合将被使用。可做如下配置：

[source,yaml,indent=0]
----
	acme:
	  list:
	    - name: my name
	      description: my description
	    - name: another name
	      description: another description
	---
	spring:
	  profiles: dev
	acme:
	  list:
	    - name: my another name
----

在前面示例中，如果 `dev` 配置文件处于活动状态，则 `AcmeProperties.list` 包含一个 `MyPojo` 条目（name 为 `my another name`，description 为 `null`）。对于 YAML 而言，逗号分隔的列表和YAML 列表同样会完全覆盖列表集合的内容。

对于 Map 属性，您可以绑定来自多个源中提取的属性值。但是，对于多个源中的相同属性，则使用高优先级最高的属性。以下示例从 `AcmeProperties` 暴露了一个 `Map<String, MyPojo>`：

[source,java,indent=0]
----
	@ConfigurationProperties("acme")
	public class AcmeProperties {

		private final Map<String, MyPojo> map = new HashMap<>();

		public Map<String, MyPojo> getMap() {
			return this.map;
		}

	}
----

可以考虑以下配置：

[source,yaml,indent=0]
----
	acme:
	  map:
	    key1:
	      name: my name 1
	      description: my description 1
	---
	spring:
	  profiles: dev
	acme:
	  map:
	    key1:
	      name: dev name 1
	    key2:
	      name: dev name 2
	      description: dev description 2
----

如果 `dev` 配置文件未激活，则 `AcmeProperties.map` 只包含一个带 `key1` key 的条目（name 为 `my name 1`，description 为 `my description 1`）。
如果激活了 `dev` 配置文件，则 map 将包含两个条目， key 分别为 `key1`（name 为 `dev name 1` 和 description 为 `my description 1`）和 `key2`（name 为 `dev name 2` 和 description 为 `dev description 2`）。

NOTE: 前面的合并规则适用于所有不同属性源的属性，而不仅仅是 YAML 文件。

[[boot-features-external-config-conversion]]
==== 属性转换
当外部应用程序属性（application properties） 绑定到 `@ConfigurationProperties` bean 时，Spring Boot 会尝试将其属性强制转换为正确的类型。如果需要自定义类型转换，可以提供 `ConversionService` bean（名为 `conversionService` 的 bean）或自定义属性编辑器（通过 `CustomEditorConfigurer` bean）或自定义转换器（带有注解为 `@ConfigurationPropertiesBinding` 的 bean 定义）。

NOTE: 由于该 bean 在应用程序生命周期早期就被请求 ，因此请限制 `ConversionService` 使用的依赖。您在创建时可能无法完全初始化所需的依赖。如果配置 key 为非强制需要，您可能希望重命名自定义的 `ConversionService`，并仅依赖于使用 `@ConfigurationPropertiesBinding` 限定的自定义转换器。

[[boot-features-external-config-conversion-duration]]
===== 转换 duration
Spring Boot 支持持续时间（duration）表达。如果您暴露一个 `java.time.Duration` 属性，则可以在应用程序属性中使用以下格式：

* 常规 `long` 表示（除非指定 `@DurationUnit`，否则使用毫秒作为默认单位）
* {java-api}/java/time/Duration.html#parse-java.lang.CharSequence-[used by `java.time.Duration`] 使用的标准 ISO-8601 格式
* 一种更易读的格式，值和单位在一起（例如 `10s` 表示 10 秒）

思考以下示例：

[source,java,indent=0]
----
include::{code-examples}/context/properties/bind/AppSystemProperties.java[tag=example]
----

指定一个会话超时时间为 `30` 秒，使用 `30`、`PT30S` 和 `30s` 等形式都是可以的。读取超时时间设置为 `500ms`，可以采用以下任何一种形式：`500`、`PT0.5S` 和 `500ms`。

您也可以使用任何支持的单位来标识：

* `ns` 纳秒
* `us` 微秒
* `ms` 毫秒
* `s` 秒
* `m` 分
* `h` 小时
* `d` 天

默认单位是毫秒，可以使用 `@DurationUnit` 配合上面的单位示例重写。

TIP: 要从先前仅使用 `Long` 来表示持续时间的版本进行升级，如果切换到 `Duration` 时不是毫秒，请定义单位（使用 `@DurationUnit`）。这样做可以提供透明的升级路径，同时支持更丰富的格式。

[[boot-features-external-config-conversion-datasize]]
===== 转换 Data Size
Spring Framework 有一个 `DataSize` 值类型，允许以字节表示大小。如果暴露一个 `DataSize` 属性，则可以在应用程序属性中使用以下格式：

* 常规的 `long` 表示（使用字节作为默认单位，除非指定了 `@DataSizeUnit`）
* 更具有可读性的格式，值和单位在一起（例如 `10MB` 表示 10 兆字节）

请思考以下示例：

[source,java,indent=0]
----
include::{code-examples}/context/properties/bind/AppIoProperties.java[tag=example]
----

要指定 `10` 兆字节的缓冲大小，使用 `10` 和 `10MB` 是等效的。`256` 字节的大小可以指定为 `256` 或 `256B`。

您也可以使用任何支持的单位：

* `B` 字节
* `KB` 千字节
* `MB` 兆字节
* `GB` 千兆字节
* `TB` 兆兆字节

默认单位是字节，可以使用 `@DataSizeUnit` 配合上面的示例单位重写。

TIP: 要从先前仅使用 `Long` 来表示大小的版本进行升级，请确保在切换到 `DataSize` 不是字节的情况下定义单位（使用 `@DataSizeUnit`）。这样做可以提供透明的升级路径，同时支持更丰富的格式。

[[boot-features-external-config-validation]]
==== @ConfigurationProperties 验证
只要使用了 Spring 的 `@Validated` 注解，Spring Boot 就会尝试验证 `@ConfigurationProperties` 类。您可以直接在配置类上使用 JSR-303 `javax.validation` 约束注解。为此，请确保 JSR-303 实现在 classpath 上，然后将约束注解添加到字段上，如下所示：

[source,java,indent=0]
----
	@ConfigurationProperties(prefix="acme")
	@Validated
	public class AcmeProperties {

		@NotNull
		private InetAddress remoteAddress;

		// ... getters and setters

	}
----

TIP: 您还可以通过使用 `@Validated` 注解创建配置属性的 `@Bean` 方法来触发验证。

虽然绑定时也会验证嵌套属性，但最好的做法还是将关联字段注解上 `@Valid`。这可确保即使未找到嵌套属性也会触发验证。以下示例基于前面的 `AcmeProperties` 示例：

[source,java,indent=0]
----
	@ConfigurationProperties(prefix="acme")
	@Validated
	public class AcmeProperties {

		@NotNull
		private InetAddress remoteAddress;

		@Valid
		private final Security security = new Security();

		// ... getters and setters

		public static class Security {

			@NotEmpty
			public String username;

			// ... getters and setters

		}

	}
----

您还可以通过创建一个名为 `configurationPropertiesValidator` 的 bean 定义来添加自定义 Spring `Validator`。应该将 @Bean 方法声明为 `static`。
配置属性验证器在应用程序生命周期的早期创建，将 `@Bean` 方法声明为 `static` 可以无需实例化 `@Configuration` 类来创建 bean。这样做可以避免早期实例化可能导致的意外问题。这里有一个属性验证示例，讲解了如何设置。

TIP: `spring-boot-actuator` 模块包括一个暴露所有 `@ConfigurationPropertie`s bean 的端点。可将 Web 浏览器指向 `/actuator/configprops` 或使用等效的 JMX 端点。有关详细信息，请参阅 "<<production-ready-features.adoc#production-ready-endpoints, 生产就绪功能>>" 部分。

[[boot-features-external-config-vs-value]]
==== `@ConfigurationProperties` 与 `@Value` 对比
`@Value` 注解是核心容器功能，它不提供与类型安全配置属性相同的功能。下表总结了 `@ConfigurationProperties` 和 `@Value` 支持的功能：

[cols="4,2,2"]
|===
| 功能 |`@ConfigurationProperties` |`@Value`

| <<boot-features-external-config-relaxed-binding,宽松绑定>>
| Yes
| No

| <<appendix-configuration-metadata.adoc#configuration-metadata,元数据支持>>
| Yes
| No

| `SpEL` 表达式
| No
| Yes
|===

如果您要为自己的组件定义一组配置 key，我们建议您将它们分组到使用 `@ConfigurationProperties` 注解的 POJO 中。您应该知道，由于 `@Value` 不支持宽松绑定，因此如果您需要通过环境变量来提供值，它并不是一个好的选择。

最后，虽然您可以在 `@Value` 中编写 SpEL 表达式，但来自<<boot-features-external-config-application-property-files,应用程序属性文件>>的此类表达式并不会被处理。

[[boot-features-profiles]]
== Profiles
Spring Profile 提供了一种应用程序配置部分隔离并使其仅在特定环境中可用的方法。可以使用 `@Profile` 来注解任何 `@Component` 或 `@Configuration` 以指定何时加载它，如下所示：

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	@Profile("production")
	public class ProductionConfiguration {

		// ...

	}
----

NOTE: 如果 `@ConfigurationProperties` Bean是通过 `@EnableConfigurationProperties` 而非自动扫描注册的，则需要在 `@EnableConfigurationProperties` 注解的 `@Configuration` 类上指定 `@Profile` 注解。
在扫描 `@ConfigurationProperties` 的情况下，可以在 `@ConfigurationProperties` 类本身上指定 `@Profile`。

您可以使用 configprop:spring.profiles.active[] `Environment` 属性指定哪些配置文件处于激活状态。您可以使用本章前面介绍的任何方法指定属性。例如，您可以将其包含在 `application.properties` 中，如下所示：

[source,properties,indent=0,configprops]
----
	spring.profiles.active=dev,hsqldb
----

您还可以在命令行上使用以下开关指定它：`--spring.profiles.active=dev,hsqldb`。



[[boot-features-adding-active-profiles]]
=== 添加激活 Profile
configprop:spring.profiles.active[] 属性遵循与其他属性相同的排序规则：应用优先级最高的 `PropertySource`。这意味着您可以在 `application.properties` 中指定激活配置文件，然后使用命令行开关替换它们。

有时，将特定 profile 的属性添加到激活配置文件而不是替换它们，这种方式也是很有用的。 configprop:spring.profiles.include[]  属性可无条件地添加激活配置文件。`SpringApplication` 入口还有一个 Java API，用于设置其他 profile（即，在 `spring.profiles.active` 属性激活的 profile 之上）。请参阅 {spring-boot-module-api}/SpringApplication.html[SpringApplication] 中的 `setAdditionalProfiles()` 方法。

例如，当使用开关 `--spring.profiles.active=prod` 运行有以下属性的应用程序时，`proddb` 和 `prodmq` 配置文件也会被激活：

[source,yaml,indent=0]
----
	---
	my.property: fromyamlfile
	---
	spring.profiles: prod
	spring.profiles.include:
	  - proddb
	  - prodmq
----

NOTE: 请记住，可以在 YAML 文档中定义 `spring.profiles` 属性，以确定此特定文档何时包含在配置中。有关更多详细信息，请参见<<howto.adoc#howto-change-configuration-depending-on-the-environment,根据环境更改配置>>。

[[boot-features-programmatically-setting-profiles]]
=== 以编程方式设置 Profile
您可以在应用程序运行之前通过调用 `SpringApplication.setAdditionalProfiles(…)` 以编程方式设置活动配置文件。 也可以使用Spring的 `ConfigurableEnvironment` 接口激活 profile。

[[boot-features-profile-specific-configuration]]
=== 特定 Profile 的配置文件
特定 profile 的 `application.properties`（或 `application.yml`）和通过 `@ConfigurationProperties` 引用的文件被当做文件并加载。有关详细信息，请参见 "<<boot-features-external-config-profile-specific-properties,特定 Profile 的属性文件>>" 。

[[boot-features-logging]]
== 日志记录
Spring Boot 使用 https://commons.apache.org/logging[Commons Logging]  记录所有内部日志，但开放日志的底层实现。其为 {java-api}/java/util/logging/package-summary.html[Java Util Logging] 、https://logging.apache.org/log4j/2.x/[Log4J2] 和 https://logback.qos.ch/[Logback] 提供了默认配置。在每种情况下，日志记录器都预先配置为使用控制台输出，并且还提供可选的文件输出。

默认情况下，如果您使用了 `Starter`，则使用 Logback 进行日志记录。还包括合适的 Logback 路由，以确保在使用 Java Util Logging、Commons Logging、Log4J 或 SLF4J 的依赖库都能正常工作。

TIP: Java 有很多日志框架可供使用。如果以上列表让您感到困惑，请不要担心。通常，您不需要更改日志依赖，并且 Spring Boot 提供的默认配置可以保证日志正常工作。

TIP: 将应用程序部署到Servlet容器或应用程序服务器时，通过Java Util Logging API执行的日志记录不会路由到应用程序的日志中。 这样可以防止容器或其他已部署到容器中的应用程序执行的日志记录出现在应用程序的日志中。


[[boot-features-logging-format]]
=== 日志格式
Spring Boot 默认日志输出类似于以下示例：

[indent=0]
----
2019-03-05 10:57:51.112  INFO 45469 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/7.0.52
2019-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2019-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1358 ms
2019-03-05 10:57:51.698  INFO 45469 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: 'dispatcherServlet' to [/]
2019-03-05 10:57:51.702  INFO 45469 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]
----

输出以下项：

* 日期和时间：毫秒精度，易于排序。
* 日志级别：`ERROR`、`WARN`、`INFO`、`DEBUG` 或 `TRACE`。
* 进程 ID。
* 一个 `---` 分隔符，用于区分实际日志内容的开始。
* 线程名称：在方括号中（可能会截断控制台输出）。
* 日志记录器名称：这通常是源类名称（通常为缩写）。
* 日志内容。

NOTE: Logback 没有 `FATAL` 级别。该级别映射到 `ERROR`。

[[boot-features-logging-console-output]]
=== 控制台输出
默认日志配置会在写入时将消息回显到控制台。默认情况下，会记录 `ERROR`、`WARN` 和 `INFO` 级别的日志。您还可以通过使用 `--debug `标志启动应用程序来启用调试模式。

[indent=0]
----
	$ java -jar myapp.jar --debug
----

NOTE: 您还可以在 `application.properties` 中指定 `debug=true`。

启用调试模式后，核心日志记录器（内嵌容器、Hibernate 和 Spring Boot）将被配置为输出更多日志信息。启用调试模式不会将应用程序配置为使用 `DEBUG` 级别记录所有日志内容。

或者，您可以通过使用 `--trace` 标志（或在 `application.properties` 中的设置 `trace=true`）启动应用程序来启用跟踪模式。这样做可以为选择的核心日志记录器（内嵌容器、Hibernate 模式生成和整个 Spring 组合）启用日志追踪。

[[boot-features-logging-color-coded-output]]
==== 着色输出
如果您的终端支持 ANSI，则可以使用颜色输出来提高可读性。您可以将 `spring.output.ansi.enabled` 设置为 {spring-boot-module-api}/ansi/AnsiOutput.Enabled.html[受支持的值] 以覆盖自动检测。

可使用 `%clr`  转换字配置颜色编码。最简单形式是，转换器根据日志级别对输出进行着色，如下所示：

[source,indent=0]
----
%clr(%5p)
----

下表描述日志级别与颜色的映射关系：

|===
| Level | Color

| `FATAL`
| Red

| `ERROR`
| Red

| `WARN`
| Yellow

| `INFO`
| Green

| `DEBUG`
| Green

| `TRACE`
| Green
|===

或者，您可以通过将其作为转换选项指定应使用的颜色或样式。例如，要将文本变为黄色，请使用以下设置：

[source,indent=0]
----
%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){yellow}
----

支持以下颜色和样式：

* `blue`
* `cyan`
* `faint`
* `green`
* `magenta`
* `red`
* `yellow`



[[boot-features-logging-file-output]]
=== 文件输出
默认情况下，Spring Boot 仅记录到控制台，不会写入日志文件。想除了控制台输出之外还要写入日志文件，则需要设置 `logging.file` 或 `logging.path` 属性（例如，在 `application.properties` 中）。

下表展示了如何与 `logging.*` 属性一起使用：

.Logging 属性
[cols="1,1,1,4"]
|===
| configprop:logging.file.name[] | configprop:logging.file.path[] | Example | Description

| _(none)_
| _(none)_
|
| 仅在控制台输出

| 指定文件
| _(none)_
| `my.log`
| 写入指定的日志文件。名称可以是绝对位置或相对于当前目录。

| _(none)_
| 指定目录
| `/var/log`
| 将 `spring.log` 写入指定的目录。名称可以是绝对位置或相对于当前目录。
|===

日志文件在达到 `10MB` 时会轮转，并且与控制台输出一样，默认情况下会记录 `ERROR`、`WARN` 和 `INFO` 级别的内容。可以使用 `logging.file.max-size` 属性更改大小限制。除非已设置 `logging.file.max-history` 属性，否则以前轮转的文件将无限期归档。
可以使用 `logging.file.total-size-cap` 限制日志归档文件的总大小。 当日志归档的总大小超过该阈值时，将删除备份。 要在应用程序启动时强制清除日志归档文件，请使用 `logging.file.clean-history-on-start` 属性。

TIP: 日日志属性独立于实际的日志底层。因此，spring Boot 不管理特定的配置 key（例如 Logback 的 `logback.configurationFile`）。


[[boot-features-custom-log-levels]]
=== 日志等级
所有受支持的日志记录系统都可以使用 `logging.level.<logger-name>=<level>` 来设置 Spring `Environment` 中的记录器等级（例如，在 `application.properties` 中）。其中 level 是 `TRACE`、`DEBUG`、`INFO`、`WARN`、`ERROR`、`FATAL` 和 `OFF` 其中之一。可以使用 `logging.level.root` 配置 `root` 记录器。

以下示例展示了 `application.properties` 中默认的日志记录设置：

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	logging.level.root=warn
	logging.level.org.springframework.web=debug
	logging.level.org.hibernate=error
----

也可以使用环境变量设置日志记录级别。 例如， `LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_WEB=DEBUG` 会将 `org.springframework.web` 设置为 `DEBUG`。

NOTE: 以上方法仅适用于程序包级别的日志记录。 由于宽松的绑定总是将环境变量转换为小写，因此无法以这种方式为单个类配置日志记录。 如果需要为类配置日志记录，则可以使用  <<boot-features-external-config-application-json, the `SPRING_APPLICATION_JSON`>> 变量。

[[boot-features-custom-log-groups]]
=== 日志组
将相关记录器组合在一起以便可以同时配置，这通常很有用。例如，您可以更改所有 Tomcat 相关记录器的日志记录级别，但您无法轻松记住顶层的包名。

为了解决这个问题，Spring Boot 允许您在 Spring `Environment` 中定义日志记录组。例如，以下通过将 tomcat 组添加到 `application.properties` 来定义 tomcat 组：

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	logging.group.tomcat=org.apache.catalina, org.apache.coyote, org.apache.tomcat
----

定义后，您可以使用一行配置来更改组中所有记录器的级别：

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	logging.level.tomcat=TRACE
----

Spring Boot 包含以下预定义的日志记录组，可以直接使用：

[cols="1,4"]
|===
| 名称 | 日志记录器

| web
| `org.springframework.core.codec`, `org.springframework.http`, `org.springframework.web`, `org.springframework.boot.actuate.endpoint.web`, `org.springframework.boot.web.servlet.ServletContextInitializerBeans`

| sql
| `org.springframework.jdbc.core`, `org.hibernate.SQL`, `org.jooq.tools.LoggerListener`
|===



[[boot-features-custom-log-configuration]]
=== 自定义日志配置
可以通过在 classpath 中引入适合的库来激活各种日志记录系统，并且可以通过在 classpath 的根目录中或在以下 Spring Environment 属性指定的位置提供合适的配置文件来进一步自定义：logging.config。

您可以使用 `org.springframework.boot.logging.LoggingSystem` 系统属性强制 Spring Boot 使用特定的日志记录系统。该值应该是一个实现了 `LoggingSystem` 的类的完全限定类名。您还可以使用 `none` 值完全禁用 Spring Boot 的日志记录配置。


NOTE: 由于日志记录在创建 `ApplicationContext` 之前初始化，因此无法在 Spring `@Configuration` 文件中控制来自 `@PropertySources` 的日志记录。更改日志记录系统或完全禁用它的唯一方法是通过系统属性设置。

根据您的日志记录系统，将加载以下文件：

|===
| 日志记录系统 | 文件

| Logback
| `logback-spring.xml`, `logback-spring.groovy`, `logback.xml`, 或者 `logback.groovy`

| Log4j2
| `log4j2-spring.xml` 或者 `log4j2.xml`

| JDK (Java Util Logging)
| `logging.properties`
|===

NOTE: 如果可能，我们建议您使用 `-spring` 的形式来配置日志记录（比如 `logback-spring.xml` 而不是 `logback.xml`）。如果使用标准的配置位置，Spring 无法完全控制日志初始化。

WARNING: Java Util Logging 存在已知的类加载问题，这些问题在以 'executable jar' 运行时会触发。如果可能的话，我们建议您在使用可执行 jar 方式运行时避免使用它。 .

为了进行自定义，部分其他属性会从 Spring `Environment` 传输到 `System` 属性，如下表所述：

|===
| Spring Environment | 系统属性 | 说明

| configprop:logging.exception-conversion-word[]
| `LOG_EXCEPTION_CONVERSION_WORD`
| 记录异常时使用的转换字。

| configprop:logging.file.clean-history-on-start[]
| `LOG_FILE_CLEAN_HISTORY_ON_START`
| 是否在启动时清除存档日志文件（如果启用了LOG_FILE）。 （仅默认的Logback设置受支持。）

| configprop:logging.file.name[]
| `LOG_FILE`
| 如果已定义，则在默认日志配置中使用它。

| configprop:logging.file.max-size[]
| `LOG_FILE_MAX_SIZE`
| 最大日志文件大小（如果启用了 LOG_FILE）。（仅支持默认的 Logback 设置。）

| configprop:logging.file.max-history[]
| `LOG_FILE_MAX_HISTORY`
| 要保留的归档日志文件最大数量（如果启用了 LOG_FILE）。（仅支持默认的 Logback 设置。）

| configprop:logging.file.path[]
| `LOG_PATH`
| 如果已定义，则在默认日志配置中使用它。

| configprop:logging.file.total-size-cap[]
| `LOG_FILE_TOTAL_SIZE_CAP`
| 要保留的日志备份的总大小（如果启用了LOG_FILE）。 （仅默认的Logback设置受支持。）

| configprop:logging.pattern.console[]
| `CONSOLE_LOG_PATTERN`
| 要在控制台上使用的日志模式（stdout）。（仅支持默认的 Logback 设置。）

| configprop:logging.pattern.dateformat[]
| `LOG_DATEFORMAT_PATTERN`
| 日志日期格式的 Appender 模式。（仅支持默认的 Logback 设置。）

| configprop:logging.pattern.file[]
| `FILE_LOG_PATTERN`
| 要在文件中使用的日志模式（如果启用了 `LOG_FILE`）。（仅支持默认的 Logback 设置。）

| configprop:logging.pattern.level[]
| `LOG_LEVEL_PATTERN`
| 渲染日志级别时使用的格式（默认值为 `%5p`）。（仅支持默认的 Logback 设置。）

| configprop:logging.pattern.rolling-file-name[]
| `ROLLING_FILE_NAME_PATTERN`
| 过渡日志文件名的模式(默认 `$\{LOG_FILE}.%d\{yyyy-MM-dd}.%i.gz`)。

| `PID`
| `PID`
| 当前进程 ID（如果可能，则在未定义为 OS 环境变量时发现）。
|===

所有受支持的日志记录系统在解析其配置文件时都可以参考系统属性。有关示例，请参阅 `spring-boot.jar` 中的默认配置：

* {spring-boot-code}/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/logback/defaults.xml[Logback]
* {spring-boot-code}/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/log4j2/log4j2.xml[Log4j 2]
* {spring-boot-code}/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/java/logging-file.properties[Java Util logging]

[TIP]
====
如果要在日志记录属性中使用占位符，则应使用 <<boot-features-external-config-placeholders-in-properties,Spring Boot 的语法>>，而不是使用底层框架的语法。值得注意的是，如果使用 Logback，则应使用 `:` 作为属性名称与其默认值之间的分隔符，而不是使用 `:-`。
====

[TIP]
====
您可以通过仅覆盖 `LOG_LEVEL_PATTERN`（或带 Logback 的 `logging.pattern.level`）将 MDC 和其他特别的内容添加到日志行。例如，如果使用 `logging.pattern.level=user:%X{user} %5p`，则默认日志格式包含 user MDC 项（如果存在），如下所示:

[indent=0]
----
	2019-08-30 12:30:04.031 user:someone INFO 22174 --- [  nio-8080-exec-0] demo.Controller
	Handling authenticated request
----
====



[[boot-features-logback-extensions]]
=== Logback 扩展
Spring Boot 包含许多 Logback 扩展，可用于进行高级配置。您可以在 `logback-spring.xml` 配置文件中使用这些扩展。

NOTE: 由于标准的 `logback.xml` 配置文件加载过早，因此无法在其中使用扩展。您需要使用 `logback-spring.xml` 或定义 `logging.config` 属性。

WARNING: 扩展不能与 Logback 的 https://logback.qos.ch/manual/configuration.html#autoScan[配置扫描] 一起使用。如果尝试这样做，更改配置文件会导致发生类似以下错误日志： .

[indent=0]
----
	ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProperty], current ElementPath is [[configuration][springProperty]]
	ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProfile], current ElementPath is [[configuration][springProfile]]
----



==== 特定 Profile 配置
`<springProfile>` 标签允许您根据激活的 Spring profile 选择性地包含或排除配置部分。在 `<configuration>` 元素中的任何位置都支持配置 profile。使用 `name` 属性指定哪个 proifle 接受配置。`<springProfile>` 标记可以包含简单的 proifle 名称（例如 `staging`）或 profile 表达式。profile 表达式允许表达更复杂的 profile 逻辑，
例如 `production & (eu-central | eu-west)`。有关详细信息，请查阅 {spring-framework-docs}core.html#beans-definition-profiles-java[参考指南] 。以下清单展示了三个示例 profile：

[source,xml,indent=0]
----
	<springProfile name="staging">
		<!-- configuration to be enabled when the "staging" profile is active -->
	</springProfile>

	<springProfile name="dev | staging">
		<!-- configuration to be enabled when the "dev" or "staging" profiles are active -->
	</springProfile>

	<springProfile name="!production">
		<!-- configuration to be enabled when the "production" profile is not active -->
	</springProfile>
----



==== 环境属性
使用 `<springProperty>` 标签可以让您暴露 Spring 环境（`Environment`）中的属性，以便在 Logback 中使用。如果在 Logback 配置中访问来自 `application.properties` 文件的值，这样做很有用。标签的工作方式与 Logback 的标准 `<property>` 标签类似。但是，您可以指定属性（来自 `Environment`）的 `source`，而不是指定直接的 `value`。如果需要将属性存储在 `local` 范围以外的其他位置，则可以使用 `scope` 属性。
如果需要回退值（如果未在 `Environment` 中设置该属性），则可以使用 `defaultValue` 属性。以下示例展示了如何暴露属性以便在 Logback 中使用：

[source,xml,indent=0]
----
	<springProperty scope="context" name="fluentHost" source="myapp.fluentd.host"
			defaultValue="localhost"/>
	<appender name="FLUENT" class="ch.qos.logback.more.appenders.DataFluentAppender">
		<remoteHost>${fluentHost}</remoteHost>
		...
	</appender>
----

NOTE: 必须以 kebab 风格（短横线小写风格）指定 `source`（例如 `my.property-name`）。但可以使用宽松规则将属性添加到 `Environment` 中。

[[boot-features-internationalization]]
== 国际化
Spring Boot支持本地化消息，因此您的应用程序可以迎合不同语言首选项的用户。 默认情况下，Spring Boot在类路径的根目录下查找 `messages` 资源包的存在。

NOTE: 当已配置资源束的默认属性文件可用时（即默认情况下为 `messages.properties`），将应用自动配置。 如果您的资源包仅包含特定于语言的属性文件，则需要添加默认文件。 如果找不到与任何配置的基本名称匹配的属性文件，将没有自动配置的 `MessageSource`。

可以使用 `spring.messages` 命名空间配置资源包的基本名称以及其他几个属性，如以下示例所示：

[source,properties,indent=0,configprops]
----
	spring.messages.basename=messages,config.i18n.messages
	spring.messages.fallback-to-system-locale=false
----

TIP: `spring.messages.basename` 支持以逗号分隔的位置列表，可以是包限定符，也可以是从类路径根目录解析的资源。

有关更多支持的选项，请参见 {spring-boot-autoconfigure-module-code}/context/MessageSourceProperties.java[`MessageSourceProperties`]

[[boot-features-json]]
== JSON
Spring Boot 为三个 JSON 映射库提供了内置集成：

- Gson
- Jackson
- JSON-B

Jackson 是首选和默认的库。

[[boot-features-json-jackson]]
=== Jackson
Spring Boot 提供了 Jackson 的自动配置，Jackson 是 `spring-boot-starter-json` 的一部分。当 Jackson 在 classpath 上时，会自动配置 `ObjectMapper` bean。Spring Boot 提供了几个配置属性来 <<howto.adoc#howto-customize-the-jackson-objectmapper,自定义 `ObjectMapper` 的配置>>。

[[boot-features-json-gson]]
=== Gson
Spring Boot 提供 Gson 的自动配置。当 `Gson` 在 classpath 上时，会自动配置 Gson bean。Spring Boot 提供了几个 `spring.gson.*` 配置属性来自定义配置。为了获得更多控制，可以使用一个或多个 `GsonBuilderCustomizer` bean。

[[boot-features-json-json-b]]
=== JSON-B
Spring Boot 提供了 JSON-B 的自动配置。当 JSON-B API 和实现在 classpath 上时，将自动配置 `Jsonb` bean。首选的 JSON-B 实现是 Apache Johnzon，它提供了依赖管理。

[[boot-features-developing-web-applications]]
== Developing Web Applications
Spring Boot is well suited for web application development.
You can create a self-contained HTTP server by using embedded Tomcat, Jetty, Undertow, or Netty.
Most web applications use the `spring-boot-starter-web` module to get up and running quickly.
You can also choose to build reactive web applications by using the `spring-boot-starter-webflux` module.

If you have not yet developed a Spring Boot web application, you can follow the "Hello World!" example in the _<<getting-started.adoc#getting-started-first-application, Getting started>>_ section.



[[boot-features-spring-mvc]]
=== The "`Spring Web MVC Framework`"
The {spring-framework-docs}web.html#mvc[Spring Web MVC framework] (often referred to as simply "`Spring MVC`") is a rich "`model view controller`" web framework.
Spring MVC lets you create special `@Controller` or `@RestController` beans to handle incoming HTTP requests.
Methods in your controller are mapped to HTTP by using `@RequestMapping` annotations.

The following code shows a typical `@RestController` that serves JSON data:

[source,java,indent=0]
----
	@RestController
	@RequestMapping(value="/users")
	public class MyRestController {

		@RequestMapping(value="/{user}", method=RequestMethod.GET)
		public User getUser(@PathVariable Long user) {
			// ...
		}

		@RequestMapping(value="/{user}/customers", method=RequestMethod.GET)
		List<Customer> getUserCustomers(@PathVariable Long user) {
			// ...
		}

		@RequestMapping(value="/{user}", method=RequestMethod.DELETE)
		public User deleteUser(@PathVariable Long user) {
			// ...
		}

	}
----

Spring MVC is part of the core Spring Framework, and detailed information is available in the  {spring-framework-docs}web.html#mvc[reference documentation].
There are also several guides that cover Spring MVC available at https://spring.io/guides.



[[boot-features-spring-mvc-auto-configuration]]
==== Spring MVC Auto-configuration
Spring Boot provides auto-configuration for Spring MVC that works well with most applications.

The auto-configuration adds the following features on top of Spring's defaults:

* Inclusion of `ContentNegotiatingViewResolver` and `BeanNameViewResolver` beans.
* Support for serving static resources, including support for WebJars (covered <<boot-features-spring-mvc-static-content,later in this document>>)).
* Automatic registration of `Converter`, `GenericConverter`, and `Formatter` beans.
* Support for `HttpMessageConverters` (covered <<boot-features-spring-mvc-message-converters,later in this document>>).
* Automatic registration of `MessageCodesResolver` (covered <<boot-features-spring-message-codes,later in this document>>).
* Static `index.html` support.
* Custom `Favicon` support (covered <<boot-features-spring-mvc-favicon,later in this document>>).
* Automatic use of a `ConfigurableWebBindingInitializer` bean (covered <<boot-features-spring-mvc-web-binding-initializer,later in this document>>).

If you want to keep Spring Boot MVC features and you want to add additional {spring-framework-docs}web.html#mvc[MVC configuration] (interceptors, formatters, view controllers, and other features), you can add your own `@Configuration` class of type `WebMvcConfigurer` but *without* `@EnableWebMvc`.
If you wish to provide custom instances of `RequestMappingHandlerMapping`, `RequestMappingHandlerAdapter`, or `ExceptionHandlerExceptionResolver`, you can declare a `WebMvcRegistrationsAdapter` instance to provide such components.

If you want to take complete control of Spring MVC, you can add your own `@Configuration` annotated with `@EnableWebMvc`.


[[boot-features-spring-mvc-message-converters]]
==== HttpMessageConverters
Spring MVC uses the `HttpMessageConverter` interface to convert HTTP requests and responses.
Sensible defaults are included out of the box.
For example, objects can be automatically converted to JSON (by using the Jackson library) or XML (by using the Jackson XML extension, if available, or by using JAXB if the Jackson XML extension is not available).
By default, strings are encoded in `UTF-8`.

If you need to add or customize converters, you can use Spring Boot's `HttpMessageConverters` class, as shown in the following listing:

[source,java,indent=0]
----
	import org.springframework.boot.autoconfigure.http.HttpMessageConverters;
	import org.springframework.context.annotation.*;
	import org.springframework.http.converter.*;

	@Configuration(proxyBeanMethods = false)
	public class MyConfiguration {

		@Bean
		public HttpMessageConverters customConverters() {
			HttpMessageConverter<?> additional = ...
			HttpMessageConverter<?> another = ...
			return new HttpMessageConverters(additional, another);
		}

	}
----

Any `HttpMessageConverter` bean that is present in the context is added to the list of converters.
You can also override default converters in the same way.



[[boot-features-json-components]]
==== Custom JSON Serializers and Deserializers
If you use Jackson to serialize and deserialize JSON data, you might want to write your own `JsonSerializer` and `JsonDeserializer` classes.
Custom serializers are usually https://github.com/FasterXML/jackson-docs/wiki/JacksonHowToCustomSerializers[registered with Jackson through a module], but Spring Boot provides an alternative `@JsonComponent` annotation that makes it easier to directly register Spring Beans.

You can use the `@JsonComponent` annotation directly on `JsonSerializer`, `JsonDeserializer` or `KeyDeserializer` implementations.
You can also use it on classes that contain serializers/deserializers as inner classes, as shown in the following example:

[source,java,indent=0]
----
	import java.io.*;
	import com.fasterxml.jackson.core.*;
	import com.fasterxml.jackson.databind.*;
	import org.springframework.boot.jackson.*;

	@JsonComponent
	public class Example {

		public static class Serializer extends JsonSerializer<SomeObject> {
			// ...
		}

		public static class Deserializer extends JsonDeserializer<SomeObject> {
			// ...
		}

	}
----

All `@JsonComponent` beans in the `ApplicationContext` are automatically registered with Jackson.
Because `@JsonComponent` is meta-annotated with `@Component`, the usual component-scanning rules apply.

Spring Boot also provides {spring-boot-module-code}/jackson/JsonObjectSerializer.java[`JsonObjectSerializer`] and {spring-boot-module-code}/jackson/JsonObjectDeserializer.java[`JsonObjectDeserializer`] base classes that provide useful alternatives to the standard Jackson versions when serializing objects.
See {spring-boot-module-api}/jackson/JsonObjectSerializer.html[`JsonObjectSerializer`] and {spring-boot-module-api}/jackson/JsonObjectDeserializer.html[`JsonObjectDeserializer`] in the Javadoc for details.



[[boot-features-spring-message-codes]]
==== MessageCodesResolver
Spring MVC has a strategy for generating error codes for rendering error messages from binding errors: `MessageCodesResolver`.
If you set the configprop:spring.mvc.message-codes-resolver-format[] property `PREFIX_ERROR_CODE` or `POSTFIX_ERROR_CODE`, Spring Boot creates one for you (see the enumeration in {spring-framework-api}/validation/DefaultMessageCodesResolver.Format.html[`DefaultMessageCodesResolver.Format`]).



[[boot-features-spring-mvc-static-content]]
==== Static Content
By default, Spring Boot serves static content from a directory called `/static` (or `/public` or `/resources` or `/META-INF/resources`) in the classpath or from the root of the `ServletContext`.
It uses the `ResourceHttpRequestHandler` from Spring MVC so that you can modify that behavior by adding your own `WebMvcConfigurer` and overriding the `addResourceHandlers` method.

In a stand-alone web application, the default servlet from the container is also enabled and acts as a fallback, serving content from the root of the `ServletContext` if Spring decides not to handle it.
Most of the time, this does not happen (unless you modify the default MVC configuration), because Spring can always handle requests through the `DispatcherServlet`.

By default, resources are mapped on `+/**+`, but you can tune that with the configprop:spring.mvc.static-path-pattern[] property.
For instance, relocating all resources to `/resources/**` can be achieved as follows:

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	spring.mvc.static-path-pattern=/resources/**
----

You can also customize the static resource locations by using the configprop:spring.resources.static-locations[] property (replacing the default values with a list of directory locations).
The root Servlet context path, `"/"`, is automatically added as a location as well.

In addition to the "`standard`" static resource locations mentioned earlier, a special case is made for https://www.webjars.org/[Webjars content].
Any resources with a path in `+/webjars/**+` are served from jar files if they are packaged in the Webjars format.

TIP: Do not use the `src/main/webapp` directory if your application is packaged as a jar.
Although this directory is a common standard, it works *only* with war packaging, and it is silently ignored by most build tools if you generate a jar.

Spring Boot also supports the advanced resource handling features provided by Spring MVC, allowing use cases such as cache-busting static resources or using version agnostic URLs for Webjars.

To use version agnostic URLs for Webjars, add the `webjars-locator-core` dependency.
Then declare your Webjar.
Using jQuery as an example, adding `"/webjars/jquery/jquery.min.js"` results in `"/webjars/jquery/x.y.z/jquery.min.js"` where `x.y.z` is the Webjar version.

NOTE: If you use JBoss, you need to declare the `webjars-locator-jboss-vfs` dependency instead of the `webjars-locator-core`.
Otherwise, all Webjars resolve as a `404`.

To use cache busting, the following configuration configures a cache busting solution for all static resources, effectively adding a content hash, such as `<link href="/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css"/>`, in URLs:

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	spring.resources.chain.strategy.content.enabled=true
	spring.resources.chain.strategy.content.paths=/**
----

NOTE: Links to resources are rewritten in templates at runtime, thanks to a `ResourceUrlEncodingFilter` that is auto-configured for Thymeleaf and FreeMarker.
You should manually declare this filter when using JSPs.
Other template engines are currently not automatically supported but can be with custom template macros/helpers and the use of the {spring-framework-api}/web/servlet/resource/ResourceUrlProvider.html[`ResourceUrlProvider`].

When loading resources dynamically with, for example, a JavaScript module loader, renaming files is not an option.
That is why other strategies are also supported and can be combined.
A "fixed" strategy adds a static version string in the URL without changing the file name, as shown in the following example:

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	spring.resources.chain.strategy.content.enabled=true
	spring.resources.chain.strategy.content.paths=/**
	spring.resources.chain.strategy.fixed.enabled=true
	spring.resources.chain.strategy.fixed.paths=/js/lib/
	spring.resources.chain.strategy.fixed.version=v12
----

With this configuration, JavaScript modules located under `"/js/lib/"` use a fixed versioning strategy (`"/v12/js/lib/mymodule.js"`), while other resources still use the content one (`<link href="/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css"/>`).

See {spring-boot-autoconfigure-module-code}/web/ResourceProperties.java[`ResourceProperties`] for more supported options.

[TIP]
====
This feature has been thoroughly described in a dedicated https://spring.io/blog/2014/07/24/spring-framework-4-1-handling-static-web-resources[blog post] and in Spring Framework's {spring-framework-docs}web.html#mvc-config-static-resources[reference documentation].
====

[[boot-features-spring-mvc-welcome-page]]
==== Welcome Page
Spring Boot supports both static and templated welcome pages.
It first looks for an `index.html` file in the configured static content locations.
If one is not found, it then looks for an `index` template.
If either is found, it is automatically used as the welcome page of the application.



[[boot-features-spring-mvc-favicon]]
==== Custom Favicon
As with other static resources, Spring Boot looks for a `favicon.ico` in the configured static content locations.
If such a file is present, it is automatically used as the favicon of the application.



[[boot-features-spring-mvc-pathmatch]]
==== Path Matching and Content Negotiation
Spring MVC can map incoming HTTP requests to handlers by looking at the request path and matching it to the mappings defined in your application (for example, `@GetMapping` annotations on Controller methods).

Spring Boot chooses to disable suffix pattern matching by default, which means that requests like `"GET /projects/spring-boot.json"` won't be matched to `@GetMapping("/projects/spring-boot")` mappings.
This is considered as a {spring-framework-docs}web.html#mvc-ann-requestmapping-suffix-pattern-match[best practice for Spring MVC applications].
This feature was mainly useful in the past for HTTP clients which did not send proper "Accept" request headers; we needed to make sure to send the correct Content Type to the client.
Nowadays, Content Negotiation is much more reliable.

There are other ways to deal with HTTP clients that don't consistently send proper "Accept" request headers.
Instead of using suffix matching, we can use a query parameter to ensure that requests like `"GET /projects/spring-boot?format=json"` will be mapped to `@GetMapping("/projects/spring-boot")`:

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	spring.mvc.contentnegotiation.favor-parameter=true

	# We can change the parameter name, which is "format" by default:
	# spring.mvc.contentnegotiation.parameter-name=myparam

	# We can also register additional file extensions/media types with:
	spring.mvc.contentnegotiation.media-types.markdown=text/markdown
----

If you understand the caveats and would still like your application to use suffix pattern matching, the following configuration is required:

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	spring.mvc.contentnegotiation.favor-path-extension=true
	spring.mvc.pathmatch.use-suffix-pattern=true
----

Alternatively, rather than open all suffix patterns, it's more secure to just support registered suffix patterns:

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	spring.mvc.contentnegotiation.favor-path-extension=true
	spring.mvc.pathmatch.use-registered-suffix-pattern=true

	# You can also register additional file extensions/media types with:
	# spring.mvc.contentnegotiation.media-types.adoc=text/asciidoc
----



[[boot-features-spring-mvc-web-binding-initializer]]
==== ConfigurableWebBindingInitializer
Spring MVC uses a `WebBindingInitializer` to initialize a `WebDataBinder` for a particular request.
If you create your own `ConfigurableWebBindingInitializer` `@Bean`, Spring Boot automatically configures Spring MVC to use it.



[[boot-features-spring-mvc-template-engines]]
==== Template Engines
As well as REST web services, you can also use Spring MVC to serve dynamic HTML content.
Spring MVC supports a variety of templating technologies, including Thymeleaf, FreeMarker, and JSPs.
Also, many other templating engines include their own Spring MVC integrations.

Spring Boot includes auto-configuration support for the following templating engines:

 * https://freemarker.apache.org/docs/[FreeMarker]
 * http://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_the_markuptemplateengine[Groovy]
 * https://www.thymeleaf.org[Thymeleaf]
 * https://mustache.github.io/[Mustache]

TIP: If possible, JSPs should be avoided.
There are several <<boot-features-jsp-limitations, known limitations>> when using them with embedded servlet containers.

When you use one of these templating engines with the default configuration, your templates are picked up automatically from `src/main/resources/templates`.

TIP: Depending on how you run your application, IntelliJ IDEA orders the classpath differently.
Running your application in the IDE from its main method results in a different ordering than when you run your application by using Maven or Gradle or from its packaged jar.
This can cause Spring Boot to fail to find the templates on the classpath.
If you have this problem, you can reorder the classpath in the IDE to place the module's classes and resources first.
Alternatively, you can configure the template prefix to search every `templates` directory on the classpath, as follows: `classpath*:/templates/`.



[[boot-features-error-handling]]
==== Error Handling
By default, Spring Boot provides an `/error` mapping that handles all errors in a sensible way, and it is registered as a "`global`" error page in the servlet container.
For machine clients, it produces a JSON response with details of the error, the HTTP status, and the exception message.
For browser clients, there is a "`whitelabel`" error view that renders the same data in HTML format (to customize it, add a `View` that resolves to `error`).
To replace the default behavior completely, you can implement `ErrorController` and register a bean definition of that type or add a bean of type `ErrorAttributes` to use the existing mechanism but replace the contents.

TIP: The `BasicErrorController` can be used as a base class for a custom `ErrorController`.
This is particularly useful if you want to add a handler for a new content type (the default is to handle `text/html` specifically and provide a fallback for everything else).
To do so, extend `BasicErrorController`, add a public method with a `@RequestMapping` that has a `produces` attribute, and create a bean of your new type.

You can also define a class annotated with `@ControllerAdvice` to customize the JSON document to return for a particular controller and/or exception type, as shown in the following example:

[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	@ControllerAdvice(basePackageClasses = AcmeController.class)
	public class AcmeControllerAdvice extends ResponseEntityExceptionHandler {

		@ExceptionHandler(YourException.class)
		@ResponseBody
		ResponseEntity<?> handleControllerException(HttpServletRequest request, Throwable ex) {
			HttpStatus status = getStatus(request);
			return new ResponseEntity<>(new CustomErrorType(status.value(), ex.getMessage()), status);
		}

		private HttpStatus getStatus(HttpServletRequest request) {
			Integer statusCode = (Integer) request.getAttribute("javax.servlet.error.status_code");
			if (statusCode == null) {
				return HttpStatus.INTERNAL_SERVER_ERROR;
			}
			return HttpStatus.valueOf(statusCode);
		}

	}
----

In the preceding example, if `YourException` is thrown by a controller defined in the same package as `AcmeController`, a JSON representation of the `CustomErrorType` POJO is used instead of the `ErrorAttributes` representation.



[[boot-features-error-handling-custom-error-pages]]
===== Custom Error Pages
If you want to display a custom HTML error page for a given status code, you can add a file to an `/error` folder.
Error pages can either be static HTML (that is, added under any of the static resource folders) or be built by using templates.
The name of the file should be the exact status code or a series mask.

For example, to map `404` to a static HTML file, your folder structure would be as follows:

[source,indent=0,subs="verbatim,quotes,attributes"]
----
	src/
	 +- main/
	     +- java/
	     |   + <source code>
	     +- resources/
	         +- public/
	             +- error/
	             |   +- 404.html
	             +- <other public assets>
----

To map all `5xx` errors by using a FreeMarker template, your folder structure would be as follows:

[source,indent=0,subs="verbatim,quotes,attributes"]
----
	src/
	 +- main/
	     +- java/
	     |   + <source code>
	     +- resources/
	         +- templates/
	             +- error/
	             |   +- 5xx.ftlh
	             +- <other templates>
----

For more complex mappings, you can also add beans that implement the `ErrorViewResolver` interface, as shown in the following example:

[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	public class MyErrorViewResolver implements ErrorViewResolver {

		@Override
		public ModelAndView resolveErrorView(HttpServletRequest request,
				HttpStatus status, Map<String, Object> model) {
			// Use the request or status to optionally return a ModelAndView
			return ...
		}

	}
----


You can also use regular Spring MVC features such as {spring-framework-docs}web.html#mvc-exceptionhandlers[`@ExceptionHandler` methods] and {spring-framework-docs}web.html#mvc-ann-controller-advice[`@ControllerAdvice`].
The `ErrorController` then picks up any unhandled exceptions.



[[boot-features-error-handling-mapping-error-pages-without-mvc]]
===== Mapping Error Pages outside of Spring MVC
For applications that do not use Spring MVC, you can use the `ErrorPageRegistrar` interface to directly register `ErrorPages`.
This abstraction works directly with the underlying embedded servlet container and works even if you do not have a Spring MVC `DispatcherServlet`.

[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	@Bean
	public ErrorPageRegistrar errorPageRegistrar(){
		return new MyErrorPageRegistrar();
	}

	// ...

	private static class MyErrorPageRegistrar implements ErrorPageRegistrar {

		@Override
		public void registerErrorPages(ErrorPageRegistry registry) {
			registry.addErrorPages(new ErrorPage(HttpStatus.BAD_REQUEST, "/400"));
		}

	}
----

NOTE: If you register an `ErrorPage` with a path that ends up being handled by a `Filter` (as is common with some non-Spring web frameworks, like Jersey and Wicket), then the `Filter` has to be explicitly registered as an `ERROR` dispatcher, as shown in the following example:

[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	@Bean
	public FilterRegistrationBean myFilter() {
		FilterRegistrationBean registration = new FilterRegistrationBean();
		registration.setFilter(new MyFilter());
		...
		registration.setDispatcherTypes(EnumSet.allOf(DispatcherType.class));
		return registration;
	}
----

Note that the default `FilterRegistrationBean` does not include the `ERROR` dispatcher type.



[[boot-features-error-handling-websphere]]
CAUTION:When deployed to a servlet container, Spring Boot uses its error page filter to forward a request with an error status to the appropriate error page.
The request can only be forwarded to the correct error page if the response has not already been committed.
By default, WebSphere Application Server 8.0 and later commits the response upon successful completion of a servlet's service method.
You should disable this behavior by setting `com.ibm.ws.webcontainer.invokeFlushAfterService` to `false`.



[[boot-features-spring-hateoas]]
==== Spring HATEOAS
If you develop a RESTful API that makes use of hypermedia, Spring Boot provides auto-configuration for Spring HATEOAS that works well with most applications.
The auto-configuration replaces the need to use `@EnableHypermediaSupport` and registers a number of beans to ease building hypermedia-based applications, including a `LinkDiscoverers` (for client side support) and an `ObjectMapper` configured to correctly marshal responses into the desired representation.
The `ObjectMapper` is customized by setting the various `spring.jackson.*` properties or, if one exists, by a `Jackson2ObjectMapperBuilder` bean.

You can take control of Spring HATEOAS's configuration by using `@EnableHypermediaSupport`.
Note that doing so disables the `ObjectMapper` customization described earlier.



[[boot-features-cors]]
==== CORS Support
https://en.wikipedia.org/wiki/Cross-origin_resource_sharing[Cross-origin resource sharing] (CORS) is a https://www.w3.org/TR/cors/[W3C specification] implemented by https://caniuse.com/#feat=cors[most browsers] that lets you specify in a flexible way what kind of cross-domain requests are authorized., instead of using some less secure and less powerful approaches such as IFRAME or JSONP.

As of version 4.2, Spring MVC {spring-framework-docs}web.html#mvc-cors[supports CORS].
Using {spring-framework-docs}web.html#mvc-cors-controller[controller method CORS configuration] with {spring-framework-api}/web/bind/annotation/CrossOrigin.html[`@CrossOrigin`] annotations in your Spring Boot application does not require any specific configuration.
{spring-framework-docs}web.html#mvc-cors-global[Global CORS configuration] can be defined by registering a `WebMvcConfigurer` bean with a customized `addCorsMappings(CorsRegistry)` method, as shown in the following example:

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	public class MyConfiguration {

		@Bean
		public WebMvcConfigurer corsConfigurer() {
			return new WebMvcConfigurer() {
				@Override
				public void addCorsMappings(CorsRegistry registry) {
					registry.addMapping("/api/**");
				}
			};
		}
	}
----



[[boot-features-webflux]]
=== The "`Spring WebFlux Framework`"
Spring WebFlux is the new reactive web framework introduced in Spring Framework 5.0.
Unlike Spring MVC, it does not require the Servlet API, is fully asynchronous and non-blocking, and implements the https://www.reactive-streams.org/[Reactive Streams] specification through https://projectreactor.io/[the Reactor project].

Spring WebFlux comes in two flavors: functional and annotation-based.
The annotation-based one is quite close to the Spring MVC model, as shown in the following example:

[source,java,indent=0]
----
	@RestController
	@RequestMapping("/users")
	public class MyRestController {

		@GetMapping("/{user}")
		public Mono<User> getUser(@PathVariable Long user) {
			// ...
		}

		@GetMapping("/{user}/customers")
		public Flux<Customer> getUserCustomers(@PathVariable Long user) {
			// ...
		}

		@DeleteMapping("/{user}")
		public Mono<User> deleteUser(@PathVariable Long user) {
			// ...
		}

	}
----

"`WebFlux.fn`", the functional variant, separates the routing configuration from the actual handling of the requests, as shown in the following example:

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	public class RoutingConfiguration {

		@Bean
		public RouterFunction<ServerResponse> monoRouterFunction(UserHandler userHandler) {
			return route(GET("/{user}").and(accept(APPLICATION_JSON)), userHandler::getUser)
					.andRoute(GET("/{user}/customers").and(accept(APPLICATION_JSON)), userHandler::getUserCustomers)
					.andRoute(DELETE("/{user}").and(accept(APPLICATION_JSON)), userHandler::deleteUser);
		}

	}

	@Component
	public class UserHandler {

		public Mono<ServerResponse> getUser(ServerRequest request) {
			// ...
		}

		public Mono<ServerResponse> getUserCustomers(ServerRequest request) {
			// ...
		}

		public Mono<ServerResponse> deleteUser(ServerRequest request) {
			// ...
		}
	}
----

WebFlux is part of the Spring Framework and detailed information is available in its {spring-framework-docs}web-reactive.html#webflux-fn[reference documentation].

TIP: You can define as many `RouterFunction` beans as you like to modularize the definition of the router.
Beans can be ordered if you need to apply a precedence.

To get started, add the `spring-boot-starter-webflux` module to your application.

NOTE: Adding both `spring-boot-starter-web` and `spring-boot-starter-webflux` modules in your application results in Spring Boot auto-configuring Spring MVC, not WebFlux.
This behavior has been chosen because many Spring developers add `spring-boot-starter-webflux` to their Spring MVC application to use the reactive `WebClient`.
You can still enforce your choice by setting the chosen application type to `SpringApplication.setWebApplicationType(WebApplicationType.REACTIVE)`.



[[boot-features-webflux-auto-configuration]]
==== Spring WebFlux Auto-configuration
Spring Boot provides auto-configuration for Spring WebFlux that works well with most applications.

The auto-configuration adds the following features on top of Spring's defaults:

* Configuring codecs for `HttpMessageReader` and `HttpMessageWriter` instances (described <<boot-features-webflux-httpcodecs,later in this document>>).
* Support for serving static resources, including support for WebJars (described <<boot-features-spring-mvc-static-content,later in this document>>).

If you want to keep Spring Boot WebFlux features and you want to add additional {spring-framework-docs}web-reactive.html#webflux-config[WebFlux configuration], you can add your own `@Configuration` class of type `WebFluxConfigurer` but *without* `@EnableWebFlux`.

If you want to take complete control of Spring WebFlux, you can add your own `@Configuration` annotated with `@EnableWebFlux`.



[[boot-features-webflux-httpcodecs]]
==== HTTP Codecs with HttpMessageReaders and HttpMessageWriters
Spring WebFlux uses the `HttpMessageReader` and `HttpMessageWriter` interfaces to convert HTTP requests and responses.
They are configured with `CodecConfigurer` to have sensible defaults by looking at the libraries available in your classpath.

Spring Boot provides dedicated configuration properties for codecs, `+spring.codec.*+`.
It also applies further customization by using `CodecCustomizer` instances.
For example, `+spring.jackson.*+` configuration keys are applied to the Jackson codec.

If you need to add or customize codecs, you can create a custom `CodecCustomizer` component, as shown in the following example:

[source,java,indent=0]
----
	import org.springframework.boot.web.codec.CodecCustomizer;

	@Configuration(proxyBeanMethods = false)
	public class MyConfiguration {

		@Bean
		public CodecCustomizer myCodecCustomizer() {
			return codecConfigurer -> {
				// ...
			};
		}

	}
----

You can also leverage <<boot-features-json-components,Boot's custom JSON serializers and deserializers>>.



[[boot-features-webflux-static-content]]
==== Static Content
By default, Spring Boot serves static content from a directory called `/static` (or `/public` or `/resources` or `/META-INF/resources`) in the classpath.
It uses the `ResourceWebHandler` from Spring WebFlux so that you can modify that behavior by adding your own `WebFluxConfigurer` and overriding the `addResourceHandlers` method.

By default, resources are mapped on `+/**+`, but you can tune that by setting the configprop:spring.webflux.static-path-pattern[] property.
For instance, relocating all resources to `/resources/**` can be achieved as follows:

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	spring.webflux.static-path-pattern=/resources/**
----

You can also customize the static resource locations by using `spring.resources.static-locations`.
Doing so replaces the default values with a list of directory locations.
If you do so, the default welcome page detection switches to your custom locations.
So, if there is an `index.html` in any of your locations on startup, it is the home page of the application.

In addition to the "`standard`" static resource locations listed earlier, a special case is made for https://www.webjars.org/[Webjars content].
Any resources with a path in `+/webjars/**+` are served from jar files if they are packaged in the Webjars format.

TIP: Spring WebFlux applications do not strictly depend on the Servlet API, so they cannot be deployed as war files and do not use the `src/main/webapp` directory.



[[boot-features-webflux-template-engines]]
==== Template Engines
As well as REST web services, you can also use Spring WebFlux to serve dynamic HTML content.
Spring WebFlux supports a variety of templating technologies, including Thymeleaf, FreeMarker, and Mustache.

Spring Boot includes auto-configuration support for the following templating engines:

 * https://freemarker.apache.org/docs/[FreeMarker]
 * https://www.thymeleaf.org[Thymeleaf]
 * https://mustache.github.io/[Mustache]

When you use one of these templating engines with the default configuration, your templates are picked up automatically from `src/main/resources/templates`.



[[boot-features-webflux-error-handling]]
==== Error Handling
Spring Boot provides a `WebExceptionHandler` that handles all errors in a sensible way.
Its position in the processing order is immediately before the handlers provided by WebFlux, which are considered last.
For machine clients, it produces a JSON response with details of the error, the HTTP status, and the exception message.
For browser clients, there is a "`whitelabel`" error handler that renders the same data in HTML format.
You can also provide your own HTML templates to display errors (see the <<boot-features-webflux-error-handling-custom-error-pages,next section>>).

The first step to customizing this feature often involves using the existing mechanism but replacing or augmenting the error contents.
For that, you can add a bean of type`ErrorAttributes`.

To change the error handling behavior, you can implement `ErrorWebExceptionHandler` and register a bean definition of that type.
Because a `WebExceptionHandler` is quite low-level, Spring Boot also provides a convenient `AbstractErrorWebExceptionHandler` to let you handle errors in a WebFlux functional way, as shown in the following example:

[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	public class CustomErrorWebExceptionHandler extends AbstractErrorWebExceptionHandler {

		// Define constructor here

		@Override
		protected RouterFunction<ServerResponse> getRoutingFunction(ErrorAttributes errorAttributes) {

			return RouterFunctions
					.route(aPredicate, aHandler)
					.andRoute(anotherPredicate, anotherHandler);
		}

	}
----

For a more complete picture, you can also subclass `DefaultErrorWebExceptionHandler` directly and override specific methods.



[[boot-features-webflux-error-handling-custom-error-pages]]
===== Custom Error Pages
If you want to display a custom HTML error page for a given status code, you can add a file to an `/error` folder.
Error pages can either be static HTML (that is, added under any of the static resource folders) or built with templates.
The name of the file should be the exact status code or a series mask.

For example, to map `404` to a static HTML file, your folder structure would be as follows:

[source,indent=0,subs="verbatim,quotes,attributes"]
----
	src/
	 +- main/
	     +- java/
	     |   + <source code>
	     +- resources/
	         +- public/
	             +- error/
	             |   +- 404.html
	             +- <other public assets>
----

To map all `5xx` errors by using a Mustache template, your folder structure would be as follows:

[source,indent=0,subs="verbatim,quotes,attributes"]
----
	src/
	 +- main/
	     +- java/
	     |   + <source code>
	     +- resources/
	         +- templates/
	             +- error/
	             |   +- 5xx.mustache
	             +- <other templates>
----



[[boot-features-webflux-web-filters]]
==== Web Filters
Spring WebFlux provides a `WebFilter` interface that can be implemented to filter HTTP request-response exchanges.
`WebFilter` beans found in the application context will be automatically used to filter each exchange.

Where the order of the filters is important they can implement `Ordered` or be annotated with `@Order`.
Spring Boot auto-configuration may configure web filters for you.
When it does so, the orders shown in the following table will be used:

|===
| Web Filter | Order

| `MetricsWebFilter`
| `Ordered.HIGHEST_PRECEDENCE + 1`

| `WebFilterChainProxy` (Spring Security)
| `-100`

| `HttpTraceWebFilter`
| `Ordered.LOWEST_PRECEDENCE - 10`
|===



[[boot-features-jersey]]
=== JAX-RS and Jersey
If you prefer the JAX-RS programming model for REST endpoints, you can use one of the available implementations instead of Spring MVC.
https://jersey.github.io/[Jersey] and https://cxf.apache.org/[Apache CXF] work quite well out of the box.
CXF requires you to register its `Servlet` or `Filter` as a `@Bean` in your application context.
Jersey has some native Spring support, so we also provide auto-configuration support for it in Spring Boot, together with a starter.

To get started with Jersey, include the `spring-boot-starter-jersey` as a dependency and then you need one `@Bean` of type `ResourceConfig` in which you register all the endpoints, as shown in the following example:

[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	@Component
	public class JerseyConfig extends ResourceConfig {

		public JerseyConfig() {
			register(Endpoint.class);
		}

	}
----

WARNING: Jersey's support for scanning executable archives is rather limited.
For example, it cannot scan for endpoints in a package found in a <<deployment.adoc#deployment-install, fully executable jar file>> or in `WEB-INF/classes` when running an executable war file.
To avoid this limitation, the `packages` method should not be used, and endpoints should be registered individually by using the `register` method, as shown in the preceding example.

For more advanced customizations, you can also register an arbitrary number of beans that implement `ResourceConfigCustomizer`.

All the registered endpoints should be `@Components` with HTTP resource annotations (`@GET` and others), as shown in the following example:

[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	@Component
	@Path("/hello")
	public class Endpoint {

		@GET
		public String message() {
			return "Hello";
		}

	}
----

Since the `Endpoint` is a Spring `@Component`, its lifecycle is managed by Spring and you can use the `@Autowired` annotation to inject dependencies and use the `@Value` annotation to inject external configuration.
By default, the Jersey servlet is registered and mapped to `/*`.
You can change the mapping by adding `@ApplicationPath` to your `ResourceConfig`.

By default, Jersey is set up as a Servlet in a `@Bean` of type `ServletRegistrationBean` named `jerseyServletRegistration`.
By default, the servlet is initialized lazily, but you can customize that behavior by setting `spring.jersey.servlet.load-on-startup`.
You can disable or override that bean by creating one of your own with the same name.
You can also use a filter instead of a servlet by setting `spring.jersey.type=filter` (in which case, the `@Bean` to replace or override is `jerseyFilterRegistration`).
The filter has an `@Order`, which you can set with `spring.jersey.filter.order`.
Both the servlet and the filter registrations can be given init parameters by using `spring.jersey.init.*` to specify a map of properties.



[[boot-features-embedded-container]]
=== Embedded Servlet Container Support
Spring Boot includes support for embedded https://tomcat.apache.org/[Tomcat], https://www.eclipse.org/jetty/[Jetty], and https://github.com/undertow-io/undertow[Undertow] servers.
Most developers use the appropriate "`Starter`" to obtain a fully configured instance.
By default, the embedded server listens for HTTP requests on port `8080`.



[[boot-features-embedded-container-servlets-filters-listeners]]
==== Servlets, Filters, and listeners
When using an embedded servlet container, you can register servlets, filters, and all the listeners (such as `HttpSessionListener`) from the Servlet spec, either by using Spring beans or by scanning for Servlet components.



[[boot-features-embedded-container-servlets-filters-listeners-beans]]
===== Registering Servlets, Filters, and Listeners as Spring Beans
Any `Servlet`, `Filter`, or servlet `*Listener` instance that is a Spring bean is registered with the embedded container.
This can be particularly convenient if you want to refer to a value from your `application.properties` during configuration.

By default, if the context contains only a single Servlet, it is mapped to `/`.
In the case of multiple servlet beans, the bean name is used as a path prefix.
Filters map to `+/*+`.

If convention-based mapping is not flexible enough, you can use the `ServletRegistrationBean`, `FilterRegistrationBean`, and `ServletListenerRegistrationBean` classes for complete control.

It is usually safe to leave Filter beans unordered.
If a specific order is required, you should annotate the `Filter` with `@Order` or make it implement `Ordered`.
You cannot configure the order of a `Filter` by annotating its bean method with `@Order`.
If you cannot change the `Filter` class to add `@Order` or implement `Ordered`, you must define a `FilterRegistrationBean` for the `Filter` and set the registration bean's order using the `setOrder(int)` method.
Avoid configuring a Filter that reads the request body at `Ordered.HIGHEST_PRECEDENCE`, since it might go against the character encoding configuration of your application.
If a Servlet filter wraps the request, it should be configured with an order that is less than or equal to `OrderedFilter.REQUEST_WRAPPER_FILTER_MAX_ORDER`.

TIP: To see the order of every `Filter` in your application, enable debug level logging for the `web` <<boot-features-custom-log-groups,logging group>> (`logging.level.web=debug`).
Details of the registered filters, including their order and URL patterns, will then be logged at startup.

WARNING: Take care when registering `Filter` beans since they are initialized very early in the application lifectyle.
If you need to register a `Filter` that interacts with other beans, consider using a {spring-boot-module-api}/web/servlet/DelegatingFilterProxyRegistrationBean.html[`DelegatingFilterProxyRegistrationBean`] instead.



[[boot-features-embedded-container-context-initializer]]
==== Servlet Context Initialization
Embedded servlet containers do not directly execute the Servlet 3.0+ `javax.servlet.ServletContainerInitializer` interface or Spring's `org.springframework.web.WebApplicationInitializer` interface.
This is an intentional design decision intended to reduce the risk that third party libraries designed to run inside a war may break Spring Boot applications.

If you need to perform servlet context initialization in a Spring Boot application, you should register a bean that implements the `org.springframework.boot.web.servlet.ServletContextInitializer` interface.
The single `onStartup` method provides access to the `ServletContext` and, if necessary, can easily be used as an adapter to an existing `WebApplicationInitializer`.



[[boot-features-embedded-container-servlets-filters-listeners-scanning]]
===== Scanning for Servlets, Filters, and listeners
When using an embedded container, automatic registration of classes annotated with `@WebServlet`, `@WebFilter`, and `@WebListener` can be enabled by using `@ServletComponentScan`.

TIP: `@ServletComponentScan` has no effect in a standalone container, where the container's built-in discovery mechanisms are used instead.



[[boot-features-embedded-container-application-context]]
==== The ServletWebServerApplicationContext
Under the hood, Spring Boot uses a different type of `ApplicationContext` for embedded servlet container support.
The `ServletWebServerApplicationContext` is a special type of `WebApplicationContext` that bootstraps itself by searching for a single `ServletWebServerFactory` bean.
Usually a `TomcatServletWebServerFactory`, `JettyServletWebServerFactory`, or `UndertowServletWebServerFactory` has been auto-configured.

NOTE: You usually do not need to be aware of these implementation classes.
Most applications are auto-configured, and the appropriate `ApplicationContext` and `ServletWebServerFactory` are created on your behalf.



[[boot-features-customizing-embedded-containers]]
==== Customizing Embedded Servlet Containers
Common servlet container settings can be configured by using Spring `Environment` properties.
Usually, you would define the properties in your `application.properties` file.

Common server settings include:

* Network settings: Listen port for incoming HTTP requests (`server.port`), interface address to bind to `server.address`, and so on.
* Session settings: Whether the session is persistent (`server.servlet.session.persistent`), session timeout (`server.servlet.session.timeout`), location of session data (`server.servlet.session.store-dir`), and session-cookie configuration (`server.servlet.session.cookie.*`).
* Error management: Location of the error page (`server.error.path`) and so on.
* <<howto.adoc#howto-configure-ssl,SSL>>
* <<howto.adoc#how-to-enable-http-response-compression,HTTP compression>>

Spring Boot tries as much as possible to expose common settings, but this is not always possible.
For those cases, dedicated namespaces offer server-specific customizations (see `server.tomcat` and `server.undertow`).
For instance, <<howto.adoc#howto-configure-accesslogs,access logs>> can be configured with specific features of the embedded servlet container.

TIP: See the {spring-boot-autoconfigure-module-code}/web/ServerProperties.java[`ServerProperties`] class for a complete list.



[[boot-features-programmatic-embedded-container-customization]]
===== Programmatic Customization
If you need to programmatically configure your embedded servlet container, you can register a Spring bean that implements the `WebServerFactoryCustomizer` interface.
`WebServerFactoryCustomizer` provides access to the `ConfigurableServletWebServerFactory`, which includes numerous customization setter methods.
The following example shows programmatically setting the port:

[source,java,indent=0]
----
	import org.springframework.boot.web.server.WebServerFactoryCustomizer;
	import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;
	import org.springframework.stereotype.Component;

	@Component
	public class CustomizationBean implements WebServerFactoryCustomizer<ConfigurableServletWebServerFactory> {

		@Override
		public void customize(ConfigurableServletWebServerFactory server) {
			server.setPort(9000);
		}

	}
----

NOTE: `TomcatServletWebServerFactory`, `JettyServletWebServerFactory` and `UndertowServletWebServerFactory` are dedicated variants of `ConfigurableServletWebServerFactory` that have additional customization setter methods for Tomcat, Jetty and Undertow respectively.



[[boot-features-customizing-configurableservletwebserverfactory-directly]]
===== Customizing ConfigurableServletWebServerFactory Directly
If the preceding customization techniques are too limited, you can register the `TomcatServletWebServerFactory`, `JettyServletWebServerFactory`, or `UndertowServletWebServerFactory` bean yourself.

[source,java,indent=0]
----
	@Bean
	public ConfigurableServletWebServerFactory webServerFactory() {
		TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();
		factory.setPort(9000);
		factory.setSessionTimeout(10, TimeUnit.MINUTES);
		factory.addErrorPages(new ErrorPage(HttpStatus.NOT_FOUND, "/notfound.html"));
		return factory;
	}
----

Setters are provided for many configuration options.
Several protected method "`hooks`" are also provided should you need to do something more exotic.
See the {spring-boot-module-api}/web/servlet/server/ConfigurableServletWebServerFactory.html[source code documentation] for details.



[[boot-features-jsp-limitations]]
==== JSP Limitations
When running a Spring Boot application that uses an embedded servlet container (and is packaged as an executable archive), there are some limitations in the JSP support.

* With Jetty and Tomcat, it should work if you use war packaging.
  An executable war will work when launched with `java -jar`, and will also be deployable to any standard container.
  JSPs are not supported when using an executable jar.

* Undertow does not support JSPs.

* Creating a custom `error.jsp` page does not override the default view for <<boot-features-error-handling,error handling>>.
  <<boot-features-error-handling-custom-error-pages,Custom error pages>> should be used instead.



[[boot-features-reactive-server]]
=== Embedded Reactive Server Support
Spring Boot includes support for the following embedded reactive web servers: Reactor Netty, Tomcat, Jetty, and Undertow.
Most developers use the appropriate “Starter” to obtain a fully configured instance.
By default, the embedded server listens for HTTP requests on port 8080.



[[boot-features-reactive-server-resources]]
=== Reactive Server Resources Configuration
When auto-configuring a Reactor Netty or Jetty server, Spring Boot will create specific beans that will provide HTTP resources to the server instance: `ReactorResourceFactory` or `JettyResourceFactory`.

By default, those resources will be also shared with the Reactor Netty and Jetty clients for optimal performances, given:

* the same technology is used for server and client
* the client instance is built using the `WebClient.Builder` bean auto-configured by Spring Boot

Developers can override the resource configuration for Jetty and Reactor Netty by providing a custom `ReactorResourceFactory` or `JettyResourceFactory` bean - this will be applied to both clients and servers.

You can learn more about the resource configuration on the client side in the <<boot-features-webclient-runtime, WebClient Runtime section>>.



[[boot-features-rsocket]]
== RSocket
https://rsocket.io[RSocket] is a binary protocol for use on byte stream transports.
It enables symmetric interaction models via async message passing over a single connection.


The `spring-messaging` module of the Spring Framework provides support for RSocket requesters and responders, both on the client and on the server side.
See the {spring-framework-docs}web-reactive.html#rsocket-spring[RSocket section] of the Spring Framework reference for more details, including an overview of the RSocket protocol.


[[boot-features-rsocket-strategies-auto-configuration]]
=== RSocket Strategies Auto-configuration
Spring Boot auto-configures an `RSocketStrategies` bean that provides all the required infrastructure for encoding and decoding RSocket payloads.
By default, the auto-configuration will try to configure the following (in order):

. https://cbor.io/[CBOR] codecs with Jackson
. JSON codecs with Jackson

The `spring-boot-starter-rsocket` starter provides both dependencies.
Check out the <<boot-features-json-jackson,Jackson support section>> to know more about customization possibilities.

Developers can customize the `RSocketStrategies` component by creating beans that implement the `RSocketStrategiesCustomizer` interface.
Note that their `@Order` is important, as it determines the order of codecs.


[[boot-features-rsocket-server-auto-configuration]]
=== RSocket server Auto-configuration
Spring Boot provides RSocket server auto-configuration.
The required dependencies are provided by the `spring-boot-starter-rsocket`.

Spring Boot allows exposing RSocket over WebSocket from a WebFlux server, or standing up an independent RSocket server.
This depends on the type of application and its configuration.

For WebFlux application (i.e. of type `WebApplicationType.REACTIVE`), the RSocket server will be plugged into the Web Server only if the following properties match:

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	spring.rsocket.server.mapping-path=/rsocket # a mapping path is defined
	spring.rsocket.server.transport=websocket # websocket is chosen as a transport
	#spring.rsocket.server.port= # no port is defined
----

WARNING: Plugging RSocket into a web server is only supported with Reactor Netty, as RSocket itself is built with that library.

Alternatively, an RSocket TCP or websocket server is started as an independent, embedded server.
Besides the dependency requirements, the only required configuration is to define a port for that server:

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	spring.rsocket.server.port=9898 # the only required configuration
	spring.rsocket.server.transport=tcp # you're free to configure other properties
----



[[boot-features-rsocket-messaging]]
=== Spring Messaging RSocket support
Spring Boot will auto-configure the Spring Messaging infrastructure for RSocket.

This means that Spring Boot will create a `RSocketMessageHandler` bean that will handle RSocket requests to your application.


[[boot-features-rsocket-requester]]
=== Calling RSocket Services with `RSocketRequester`
Once the `RSocket` channel is established between server and client, any party can send or receive requests to the other.

As a server, you can get injected with an `RSocketRequester` instance on any handler method of an RSocket `@Controller`.
As a client, you need to configure and establish an RSocket connection first.
Spring Boot auto-configures an `RSocketRequester.Builder` for such cases with the expected codecs.

The `RSocketRequester.Builder` instance is a prototype bean, meaning each injection point will provide you with a new instance .
This is done on purpose since this builder is stateful and you shouldn't create requesters with different setups using the same instance.

The following code shows a typical example:

[source,java,indent=0]
----
	@Service
	public class MyService {

		private final RSocketRequester rsocketRequester;

		public MyService(RSocketRequester.Builder rsocketRequesterBuilder) {
			this.rsocketRequester = rsocketRequesterBuilder
					.connectTcp("example.org", 9898).block();
		}

		public Mono<User> someRSocketCall(String name) {
			return this.requester.route("user").data(name)
					.retrieveMono(User.class);
		}

	}
----



[[boot-features-security]]
== Security
If {spring-security}[Spring Security] is on the classpath, then web applications are secured by default.
Spring Boot relies on Spring Security’s content-negotiation strategy to determine whether to use `httpBasic` or `formLogin`.
To add method-level security to a web application, you can also add `@EnableGlobalMethodSecurity` with your desired settings.
Additional information can be found in the {spring-security-docs}#jc-method[Spring Security Reference Guide].

The default `UserDetailsService` has a single user.
The user name is `user`, and the password is random and is printed at INFO level when the application starts, as shown in the following example:

[indent=0]
----
	Using generated security password: 78fa095d-3f4c-48b1-ad50-e24c31d5cf35
----

NOTE: If you fine-tune your logging configuration, ensure that the `org.springframework.boot.autoconfigure.security` category is set to log `INFO`-level messages.
Otherwise, the default password is not printed.

You can change the username and password by providing a `spring.security.user.name` and `spring.security.user.password`.

The basic features you get by default in a web application are:

* A `UserDetailsService` (or `ReactiveUserDetailsService` in case of a WebFlux application) bean with in-memory store and a single user with a generated password (see {spring-boot-module-api}/autoconfigure/security/SecurityProperties.User.html[`SecurityProperties.User`] for the properties of the user).
* Form-based login or HTTP Basic security (depending on the `Accept` header in the request) for the entire application (including actuator endpoints if actuator is on the classpath).
* A `DefaultAuthenticationEventPublisher` for publishing authentication events.

You can provide a different `AuthenticationEventPublisher` by adding a bean for it.



[[boot-features-security-mvc]]
=== MVC Security
The default security configuration is implemented in `SecurityAutoConfiguration` and `UserDetailsServiceAutoConfiguration`.
`SecurityAutoConfiguration` imports `SpringBootWebSecurityConfiguration` for web security and `UserDetailsServiceAutoConfiguration` configures authentication, which is also relevant in non-web applications.
To switch off the default web application security configuration completely or to combine multiple Spring Security components such as OAuth 2 Client and Resource Server, add a bean of type `WebSecurityConfigurerAdapter` (doing so does not disable the `UserDetailsService` configuration or Actuator's security).

To also switch off the `UserDetailsService` configuration, you can add a bean of type `UserDetailsService`, `AuthenticationProvider`, or `AuthenticationManager`.

Access rules can be overridden by adding a custom `WebSecurityConfigurerAdapter`.
Spring Boot provides convenience methods that can be used to override access rules for actuator endpoints and static resources.
`EndpointRequest` can be used to create a `RequestMatcher` that is based on the configprop:management.endpoints.web.base-path[] property.
`PathRequest` can be used to create a `RequestMatcher` for resources in commonly used locations.



[[boot-features-security-webflux]]
=== WebFlux Security
Similar to Spring MVC applications, you can secure your WebFlux applications by adding the `spring-boot-starter-security` dependency.
The default security configuration is implemented in `ReactiveSecurityAutoConfiguration` and `UserDetailsServiceAutoConfiguration`.
`ReactiveSecurityAutoConfiguration` imports `WebFluxSecurityConfiguration` for web security and `UserDetailsServiceAutoConfiguration` configures authentication, which is also relevant in non-web applications.
To switch off the default web application security configuration completely, you can add a bean of type `WebFilterChainProxy` (doing so does not disable the `UserDetailsService` configuration or Actuator's security).

To also switch off the `UserDetailsService` configuration, you can add a bean of type `ReactiveUserDetailsService` or `ReactiveAuthenticationManager`.

Access rules and the use of multiple Spring Security components such as OAuth 2 Client and Resource Server can be configured by adding a custom `SecurityWebFilterChain` bean.
Spring Boot provides convenience methods that can be used to override access rules for actuator endpoints and static resources.
`EndpointRequest` can be used to create a `ServerWebExchangeMatcher` that is based on the configprop:management.endpoints.web.base-path[] property.

`PathRequest` can be used to create a `ServerWebExchangeMatcher` for resources in commonly used locations.

For example, you can customize your security configuration by adding something like:

[source,java,indent=0]
----
include::{code-examples}/web/security/CustomWebFluxSecurityExample.java[tag=configuration]
----



[[boot-features-security-oauth2]]
=== OAuth2
https://oauth.net/2/[OAuth2] is a widely used authorization framework that is supported by Spring.



[[boot-features-security-oauth2-client]]
==== Client
If you have `spring-security-oauth2-client` on your classpath, you can take advantage of some auto-configuration to make it easy to set up an OAuth2/Open ID Connect clients.
This configuration makes use of the properties under `OAuth2ClientProperties`.
The same properties are applicable to both servlet and reactive applications.

You can register multiple OAuth2 clients and providers under the `spring.security.oauth2.client` prefix, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.security.oauth2.client.registration.my-client-1.client-id=abcd
	spring.security.oauth2.client.registration.my-client-1.client-secret=password
	spring.security.oauth2.client.registration.my-client-1.client-name=Client for user scope
	spring.security.oauth2.client.registration.my-client-1.provider=my-oauth-provider
	spring.security.oauth2.client.registration.my-client-1.scope=user
	spring.security.oauth2.client.registration.my-client-1.redirect-uri=https://my-redirect-uri.com
	spring.security.oauth2.client.registration.my-client-1.client-authentication-method=basic
	spring.security.oauth2.client.registration.my-client-1.authorization-grant-type=authorization_code

	spring.security.oauth2.client.registration.my-client-2.client-id=abcd
	spring.security.oauth2.client.registration.my-client-2.client-secret=password
	spring.security.oauth2.client.registration.my-client-2.client-name=Client for email scope
	spring.security.oauth2.client.registration.my-client-2.provider=my-oauth-provider
	spring.security.oauth2.client.registration.my-client-2.scope=email
	spring.security.oauth2.client.registration.my-client-2.redirect-uri=https://my-redirect-uri.com
	spring.security.oauth2.client.registration.my-client-2.client-authentication-method=basic
	spring.security.oauth2.client.registration.my-client-2.authorization-grant-type=authorization_code

	spring.security.oauth2.client.provider.my-oauth-provider.authorization-uri=https://my-auth-server/oauth/authorize
	spring.security.oauth2.client.provider.my-oauth-provider.token-uri=https://my-auth-server/oauth/token
	spring.security.oauth2.client.provider.my-oauth-provider.user-info-uri=https://my-auth-server/userinfo
	spring.security.oauth2.client.provider.my-oauth-provider.user-info-authentication-method=header
	spring.security.oauth2.client.provider.my-oauth-provider.jwk-set-uri=https://my-auth-server/token_keys
	spring.security.oauth2.client.provider.my-oauth-provider.user-name-attribute=name
----

For OpenID Connect providers that support https://openid.net/specs/openid-connect-discovery-1_0.html[OpenID Connect discovery], the configuration can be further simplified.
The provider needs to be configured with an `issuer-uri` which is the URI that the it asserts as its Issuer Identifier.
For example, if the `issuer-uri` provided is "https://example.com", then an `OpenID Provider Configuration Request` will be made to "https://example.com/.well-known/openid-configuration".
The result is expected to be an `OpenID Provider Configuration Response`.
The following example shows how an OpenID Connect Provider can be configured with the `issuer-uri`:

[source,properties,indent=0,configprops]
----
	spring.security.oauth2.client.provider.oidc-provider.issuer-uri=https://dev-123456.oktapreview.com/oauth2/default/
----

By default, Spring Security's `OAuth2LoginAuthenticationFilter` only processes URLs matching `/login/oauth2/code/*`.
If you want to customize the `redirect-uri` to use a different pattern, you need to provide configuration to process that custom pattern.
For example, for servlet applications, you can add your own `WebSecurityConfigurerAdapter` that resembles the following:

[source,java,indent=0]
----
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.authorizeRequests()
				.anyRequest().authenticated()
				.and()
			.oauth2Login()
				.redirectionEndpoint()
					.baseUri("/custom-callback");
	}
}
----



[[boot-features-security-oauth2-common-providers]]
===== OAuth2 client registration for common providers
For common OAuth2 and OpenID providers, including Google, Github, Facebook, and Okta, we provide a set of provider defaults (`google`, `github`, `facebook`, and `okta`, respectively).

If you do not need to customize these providers, you can set the `provider` attribute to the one for which you need to infer defaults.
Also, if the key for the client registration matches a default supported provider, Spring Boot infers that as well.

In other words, the two configurations in the following example use the Google provider:

[source,properties,indent=0,configprops]
----
	spring.security.oauth2.client.registration.my-client.client-id=abcd
	spring.security.oauth2.client.registration.my-client.client-secret=password
	spring.security.oauth2.client.registration.my-client.provider=google

	spring.security.oauth2.client.registration.google.client-id=abcd
	spring.security.oauth2.client.registration.google.client-secret=password
----



[[boot-features-security-oauth2-server]]
==== Resource Server
If you have `spring-security-oauth2-resource-server` on your classpath, Spring Boot can set up an OAuth2 Resource Server.
For JWT configuration, a JWK Set URI or OIDC Issuer URI needs to be specified, as shown in the following examples:

[source,properties,indent=0,configprops]
----
	spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://example.com/oauth2/default/v1/keys
----

[source,properties,indent=0,configprops]
----
	spring.security.oauth2.resourceserver.jwt.issuer-uri=https://dev-123456.oktapreview.com/oauth2/default/
----

NOTE: If the authorization server does not support a JWK Set URI, you can configure the resource server with the Public Key used for verifying the signature of the JWT.
This can be done using the configprop:spring.security.oauth2.resourceserver.jwt.public-key-location[] property, where the value needs to point to a file containing the public key in the PEM-encoded x509 format.

The same properties are applicable for both servlet and reactive applications.

Alternatively, you can define your own `JwtDecoder` bean for servlet applications or a `ReactiveJwtDecoder` for reactive applications.

In cases where opaque tokens are used instead of JWTs, you can configure the following properties to validate tokens via introspection:

[source,properties,indent=0,configprops]
----
	spring.security.oauth2.resourceserver.opaquetoken.introspection-uri=https://example.com/check-token
	spring.security.oauth2.resourceserver.opaquetoken.client-id=my-client-id
	spring.security.oauth2.resourceserver.opaquetoken.client-secret=my-client-secret
----

Again, the same properties are applicable for both servlet and reactive applications.

Alternatively, you can define your own `OpaqueTokenIntrospector` bean for servlet applications or a `ReactiveOpaqueTokenIntrospector` for reactive applications.



==== Authorization Server
Currently, Spring Security does not provide support for implementing an OAuth 2.0 Authorization Server.
However, this functionality is available from the {spring-security-oauth2}[Spring Security OAuth] project, which will eventually be superseded by Spring Security completely.
Until then, you can use the `spring-security-oauth2-autoconfigure` module to easily set up an OAuth 2.0 authorization server; see its https://docs.spring.io/spring-security-oauth2-boot[documentation] for instructions.


[[boot-features-security-saml]]
=== SAML 2.0



[[boot-features-security-saml2-relying-party]]
==== Relying Party
If you have `spring-security-saml2-service-provider` on your classpath, you can take advantage of some auto-configuration to make it easy to set up a SAML 2.0 Relying Party.
This configuration makes use of the properties under `Saml2RelyingPartyProperties`.

A relying party registration represents a paired configuration between an Identity Provider, IDP, and a Service Provider, SP.
You can register multiple relying parties under the `spring.security.saml2.relyingparty` prefix, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.security.saml2.relyingparty.registration.my-relying-party1.signing.credentials[0].private-key-location=path-to-private-key
	spring.security.saml2.relyingparty.registration.my-relying-party1.signing.credentials[0].certificate-location=path-to-certificate
	spring.security.saml2.relyingparty.registration.my-relying-party1.identityprovider.verification.credentials[0].certificate-location=path-to-verification-cert
	spring.security.saml2.relyingparty.registration.my-relying-party1.identityprovider.entity-id=remote-idp-entity-id1
	spring.security.saml2.relyingparty.registration.my-relying-party1.identityprovider.sso-url=https://remoteidp1.sso.url

	spring.security.saml2.relyingparty.registration.my-relying-party2.signing.credentials[0].private-key-location=path-to-private-key
    spring.security.saml2.relyingparty.registration.my-relying-party2.signing.credentials[0].certificate-location=path-to-certificate
    spring.security.saml2.relyingparty.registration.my-relying-party2.identityprovider.verification.credentials[0].certificate-location=path-to-other-verification-cert
    spring.security.saml2.relyingparty.registration.my-relying-party2.identityprovider.entity-id=remote-idp-entity-id2
    spring.security.saml2.relyingparty.registration.my-relying-party2.identityprovider.sso-url=https://remoteidp2.sso.url
----



[[boot-features-security-actuator]]
=== Actuator Security
For security purposes, all actuators other than `/health` and `/info` are disabled by default.
The configprop:management.endpoints.web.exposure.include[] property can be used to enable the actuators.

If Spring Security is on the classpath and no other WebSecurityConfigurerAdapter is present, all actuators other than `/health` and `/info` are secured by Spring Boot auto-configuration.
If you define a custom `WebSecurityConfigurerAdapter`, Spring Boot auto-configuration will back off and you will be in full control of actuator access rules.

NOTE: Before setting the `management.endpoints.web.exposure.include`, ensure that the exposed actuators do not contain sensitive information and/or are secured by placing them behind a firewall or by something like Spring Security.



[[boot-features-security-csrf]]
==== Cross Site Request Forgery Protection
Since Spring Boot relies on Spring Security's defaults, CSRF protection is turned on by default.
This means that the actuator endpoints that require a `POST` (shutdown and loggers endpoints), `PUT` or `DELETE` will get a 403 forbidden error when the default security configuration is in use.

NOTE: We recommend disabling CSRF protection completely only if you are creating a service that is used by non-browser clients.

Additional information about CSRF protection can be found in the {spring-security-docs}#csrf[Spring Security Reference Guide].



[[boot-features-sql]]
== Working with SQL Databases
The {spring-framework}[Spring Framework] provides extensive support for working with SQL databases, from direct JDBC access using `JdbcTemplate` to complete "`object relational mapping`" technologies such as Hibernate.
{spring-data}[Spring Data] provides an additional level of functionality: creating `Repository` implementations directly from interfaces and using conventions to generate queries from your method names.



[[boot-features-configure-datasource]]
=== Configure a DataSource
Java's `javax.sql.DataSource` interface provides a standard method of working with database connections.
Traditionally, a 'DataSource' uses a `URL` along with some credentials to establish a database connection.

TIP: See <<howto.adoc#howto-configure-a-datasource,the "`How-to`" section>> for more advanced examples, typically to take full control over the configuration of the DataSource.



[[boot-features-embedded-database-support]]
==== Embedded Database Support
It is often convenient to develop applications by using an in-memory embedded database.
Obviously, in-memory databases do not provide persistent storage.
You need to populate your database when your application starts and be prepared to throw away data when your application ends.

TIP: The "`How-to`" section includes a <<howto.adoc#howto-database-initialization, section on how to initialize a database>>.

Spring Boot can auto-configure embedded https://www.h2database.com[H2], http://hsqldb.org/[HSQL], and https://db.apache.org/derby/[Derby] databases.
You need not provide any connection URLs.
You need only include a build dependency to the embedded database that you want to use.

[NOTE]
====
If you are using this feature in your tests, you may notice that the same database is reused by your whole test suite regardless of the number of application contexts that you use.
If you want to make sure that each context has a separate embedded database, you should set `spring.datasource.generate-unique-name` to `true`.
====

For example, the typical POM dependencies would be as follows:

[source,xml,indent=0]
----
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-data-jpa</artifactId>
	</dependency>
	<dependency>
		<groupId>org.hsqldb</groupId>
		<artifactId>hsqldb</artifactId>
		<scope>runtime</scope>
	</dependency>
----

NOTE: You need a dependency on `spring-jdbc` for an embedded database to be auto-configured.
In this example, it is pulled in transitively through `spring-boot-starter-data-jpa`.

TIP: If, for whatever reason, you do configure the connection URL for an embedded database, take care to ensure that the database's automatic shutdown is disabled.
If you use H2, you should use `DB_CLOSE_ON_EXIT=FALSE` to do so.
If you use HSQLDB, you should ensure that `shutdown=true` is not used.
Disabling the database's automatic shutdown lets Spring Boot control when the database is closed, thereby ensuring that it happens once access to the database is no longer needed.



[[boot-features-connect-to-production-database]]
==== Connection to a Production Database
Production database connections can also be auto-configured by using a pooling `DataSource`.
Spring Boot uses the following algorithm for choosing a specific implementation:

. We prefer https://github.com/brettwooldridge/HikariCP[HikariCP] for its performance and concurrency.
  If HikariCP is available, we always choose it.
. Otherwise, if the Tomcat pooling `DataSource` is available, we use it.
. If neither HikariCP nor the Tomcat pooling datasource are available and if https://commons.apache.org/proper/commons-dbcp/[Commons DBCP2] is available, we use it.

If you use the `spring-boot-starter-jdbc` or `spring-boot-starter-data-jpa` "`starters`", you automatically get a dependency to `HikariCP`.

NOTE: You can bypass that algorithm completely and specify the connection pool to use by setting the configprop:spring.datasource.type[] property.
This is especially important if you run your application in a Tomcat container, as `tomcat-jdbc` is provided by default.

TIP: Additional connection pools can always be configured manually.
If you define your own `DataSource` bean, auto-configuration does not occur.

DataSource configuration is controlled by external configuration properties in `+spring.datasource.*+`.
For example, you might declare the following section in `application.properties`:

[source,properties,indent=0,configprops]
----
	spring.datasource.url=jdbc:mysql://localhost/test
	spring.datasource.username=dbuser
	spring.datasource.password=dbpass
	spring.datasource.driver-class-name=com.mysql.jdbc.Driver
----

NOTE: You should at least specify the URL by setting the configprop:spring.datasource.url[] property.
Otherwise, Spring Boot tries to auto-configure an embedded database.

TIP: You often do not need to specify the `driver-class-name`, since Spring Boot can deduce it for most databases from the `url`.

NOTE: For a pooling `DataSource` to be created, we need to be able to verify that a valid `Driver` class is available, so we check for that before doing anything.
In other words, if you set `spring.datasource.driver-class-name=com.mysql.jdbc.Driver`, then that class has to be loadable.

See {spring-boot-autoconfigure-module-code}/jdbc/DataSourceProperties.java[`DataSourceProperties`] for more of the supported options.
These are the standard options that work regardless of the actual implementation.
It is also possible to fine-tune implementation-specific settings by using their respective prefix (`+spring.datasource.hikari.*+`, `+spring.datasource.tomcat.*+`, and `+spring.datasource.dbcp2.*+`).
Refer to the documentation of the connection pool implementation you are using for more details.

For instance, if you use the https://tomcat.apache.org/tomcat-8.0-doc/jdbc-pool.html#Common_Attributes[Tomcat connection pool], you could customize many additional settings, as shown in the following example:

[source,properties,indent=0,configprops]
----
	# Number of ms to wait before throwing an exception if no connection is available.
	spring.datasource.tomcat.max-wait=10000

	# Maximum number of active connections that can be allocated from this pool at the same time.
	spring.datasource.tomcat.max-active=50

	# Validate the connection before borrowing it from the pool.
	spring.datasource.tomcat.test-on-borrow=true
----



[[boot-features-connecting-to-a-jndi-datasource]]
==== Connection to a JNDI DataSource
If you deploy your Spring Boot application to an Application Server, you might want to configure and manage your DataSource by using your Application Server's built-in features and access it by using JNDI.

The configprop:spring.datasource.jndi-name[] property can be used as an alternative to the configprop:spring.datasource.url[], configprop:spring.datasource.username[], and configprop:spring.datasource.password[] properties to access the `DataSource` from a specific JNDI location.
For example, the following section in `application.properties` shows how you can access a JBoss AS defined `DataSource`:

[source,properties,indent=0,configprops]
----
	spring.datasource.jndi-name=java:jboss/datasources/customers
----



[[boot-features-using-jdbc-template]]
=== Using JdbcTemplate
Spring's `JdbcTemplate` and `NamedParameterJdbcTemplate` classes are auto-configured, and you can `@Autowire` them directly into your own beans, as shown in the following example:

[source,java,indent=0]
----
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.jdbc.core.JdbcTemplate;
	import org.springframework.stereotype.Component;

	@Component
	public class MyBean {

		private final JdbcTemplate jdbcTemplate;

		@Autowired
		public MyBean(JdbcTemplate jdbcTemplate) {
			this.jdbcTemplate = jdbcTemplate;
		}

		// ...

	}
----

You can customize some properties of the template by using the `spring.jdbc.template.*` properties, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.jdbc.template.max-rows=500
----

NOTE: The `NamedParameterJdbcTemplate` reuses the same `JdbcTemplate` instance behind the scenes.
If more than one `JdbcTemplate` is defined and no primary candidate exists, the `NamedParameterJdbcTemplate` is not auto-configured.



[[boot-features-jpa-and-spring-data]]
=== JPA and Spring Data JPA
The Java Persistence API is a standard technology that lets you "`map`" objects to relational databases.
The `spring-boot-starter-data-jpa` POM provides a quick way to get started.
It provides the following key dependencies:

* Hibernate: One of the most popular JPA implementations.
* Spring Data JPA: Makes it easy to implement JPA-based repositories.
* Spring ORMs: Core ORM support from the Spring Framework.

TIP: We do not go into too many details of JPA or {spring-data}[Spring Data] here.
You can follow the https://spring.io/guides/gs/accessing-data-jpa/["`Accessing Data with JPA`"] guide from https://spring.io and read the {spring-data-jpa}[Spring Data JPA] and https://hibernate.org/orm/documentation/[Hibernate] reference documentation.



[[boot-features-entity-classes]]
==== Entity Classes
Traditionally, JPA "`Entity`" classes are specified in a `persistence.xml` file.
With Spring Boot, this file is not necessary and "`Entity Scanning`" is used instead.
By default, all packages below your main configuration class (the one annotated with `@EnableAutoConfiguration` or `@SpringBootApplication`) are searched.

Any classes annotated with `@Entity`, `@Embeddable`, or `@MappedSuperclass` are considered.
A typical entity class resembles the following example:

[source,java,indent=0]
----
	package com.example.myapp.domain;

	import java.io.Serializable;
	import javax.persistence.*;

	@Entity
	public class City implements Serializable {

		@Id
		@GeneratedValue
		private Long id;

		@Column(nullable = false)
		private String name;

		@Column(nullable = false)
		private String state;

		// ... additional members, often include @OneToMany mappings

		protected City() {
			// no-args constructor required by JPA spec
			// this one is protected since it shouldn't be used directly
		}

		public City(String name, String state) {
			this.name = name;
			this.state = state;
		}

		public String getName() {
			return this.name;
		}

		public String getState() {
			return this.state;
		}

		// ... etc

	}
----

TIP: You can customize entity scanning locations by using the `@EntityScan` annotation.
See the "`<<howto.adoc#howto-separate-entity-definitions-from-spring-configuration>>`" how-to.



[[boot-features-spring-data-jpa-repositories]]
==== Spring Data JPA Repositories
{spring-data-jpa}[Spring Data JPA] repositories are interfaces that you can define to access data.
JPA queries are created automatically from your method names.
For example, a `CityRepository` interface might declare a `findAllByState(String state)` method to find all the cities in a given state.

For more complex queries, you can annotate your method with Spring Data's {spring-data-jpa-api}/repository/Query.html[`Query`] annotation.

Spring Data repositories usually extend from the {spring-data-commons-api}/repository/Repository.html[`Repository`] or {spring-data-commons-api}/repository/CrudRepository.html[`CrudRepository`] interfaces.
If you use auto-configuration, repositories are searched from the package containing your main configuration class (the one annotated with `@EnableAutoConfiguration` or `@SpringBootApplication`) down.

The following example shows a typical Spring Data repository interface definition:

[source,java,indent=0]
----
	package com.example.myapp.domain;

	import org.springframework.data.domain.*;
	import org.springframework.data.repository.*;

	public interface CityRepository extends Repository<City, Long> {

		Page<City> findAll(Pageable pageable);

		City findByNameAndStateAllIgnoringCase(String name, String state);

	}
----

Spring Data JPA repositories support three different modes of bootstrapping: default, deferred, and lazy.
To enable deferred or lazy bootstrapping, set the configprop:spring.data.jpa.repositories.bootstrap-mode[] property to `deferred` or `lazy` respectively.
When using deferred or lazy bootstrapping, the auto-configured `EntityManagerFactoryBuilder` will use the context's `AsyncTaskExecutor`, if any, as the bootstrap executor.
If more than one exists, the one named `applicationTaskExecutor` will be used.

TIP: We have barely scratched the surface of Spring Data JPA.
For complete details, see the {spring-data-jdbc-docs}[Spring Data JPA reference documentation].



[[boot-features-creating-and-dropping-jpa-databases]]
==== Creating and Dropping JPA Databases
By default, JPA databases are automatically created *only* if you use an embedded database (H2, HSQL, or Derby).
You can explicitly configure JPA settings by using `+spring.jpa.*+` properties.
For example, to create and drop tables you can add the following line to your `application.properties`:

[indent=0]
----
	spring.jpa.hibernate.ddl-auto=create-drop
----

NOTE: Hibernate's own internal property name for this (if you happen to remember it better) is `hibernate.hbm2ddl.auto`.
You can set it, along with other Hibernate native properties, by using `+spring.jpa.properties.*+` (the prefix is stripped before adding them to the entity manager).
The following line shows an example of setting JPA properties for Hibernate:

[indent=0]
----
	spring.jpa.properties.hibernate.globally_quoted_identifiers=true
----

The line in the preceding example passes a value of `true` for the `hibernate.globally_quoted_identifiers` property to the Hibernate entity manager.

By default, the DDL execution (or validation) is deferred until the `ApplicationContext` has started.
There is also a `spring.jpa.generate-ddl` flag, but it is not used if Hibernate auto-configuration is active, because the `ddl-auto` settings are more fine-grained.



[[boot-features-jpa-in-web-environment]]
==== Open EntityManager in View
If you are running a web application, Spring Boot by default registers {spring-framework-api}/orm/jpa/support/OpenEntityManagerInViewInterceptor.html[`OpenEntityManagerInViewInterceptor`] to apply the "`Open EntityManager in View`" pattern, to allow for lazy loading in web views.
If you do not want this behavior, you should set `spring.jpa.open-in-view` to `false` in your `application.properties`.



[[boot-features-data-jdbc]]
=== Spring Data JDBC
Spring Data includes repository support for JDBC and will automatically generate SQL for the methods on `CrudRepository`.
For more advanced queries, a `@Query` annotation is provided.

Spring Boot will auto-configure Spring Data's JDBC repositories when the necessary dependencies are on the classpath.
They can be added to your project with a single dependency on `spring-boot-starter-data-jdbc`.
If necessary, you can take control of Spring Data JDBC's configuration by adding the `@EnableJdbcRepositories` annotation or a `JdbcConfiguration` subclass to your application.

TIP: For complete details of Spring Data JDBC, please refer to the {spring-data-jdbc-docs}[reference documentation].



[[boot-features-sql-h2-console]]
=== Using H2's Web Console
The https://www.h2database.com[H2 database] provides a https://www.h2database.com/html/quickstart.html#h2_console[browser-based console] that Spring Boot can auto-configure for you.
The console is auto-configured when the following conditions are met:

* You are developing a servlet-based web application.
* `com.h2database:h2` is on the classpath.
* You are using <<using-spring-boot.adoc#using-boot-devtools,Spring Boot's developer tools>>.

TIP: If you are not using Spring Boot's developer tools but would still like to make use of H2's console, you can configure the configprop:spring.h2.console.enabled[] property with a value of `true`.

NOTE: The H2 console is only intended for use during development, so you should take care to ensure that `spring.h2.console.enabled` is not set to `true` in production.



[[boot-features-sql-h2-console-custom-path]]
==== Changing the H2 Console's Path
By default, the console is available at `/h2-console`.
You can customize the console's path by using the configprop:spring.h2.console.path[] property.



[[boot-features-jooq]]
=== Using jOOQ
jOOQ Object Oriented Querying (https://www.jooq.org/[jOOQ]) is a popular product from https://www.datageekery.com/[Data Geekery] which generates Java code from your database and lets you build type-safe SQL queries through its fluent API.
Both the commercial and open source editions can be used with Spring Boot.



==== Code Generation
In order to use jOOQ type-safe queries, you need to generate Java classes from your database schema.
You can follow the instructions in the {jooq-docs}/#jooq-in-7-steps-step3[jOOQ user manual].
If you use the `jooq-codegen-maven` plugin and you also use the `spring-boot-starter-parent` "`parent POM`", you can safely omit the plugin's `<version>` tag.
You can also use Spring Boot-defined version variables (such as `h2.version`) to declare the plugin's database dependency.
The following listing shows an example:

[source,xml,indent=0]
----
	<plugin>
		<groupId>org.jooq</groupId>
		<artifactId>jooq-codegen-maven</artifactId>
		<executions>
			...
		</executions>
		<dependencies>
			<dependency>
				<groupId>com.h2database</groupId>
				<artifactId>h2</artifactId>
				<version>${h2.version}</version>
			</dependency>
		</dependencies>
		<configuration>
			<jdbc>
				<driver>org.h2.Driver</driver>
				<url>jdbc:h2:~/yourdatabase</url>
			</jdbc>
			<generator>
				...
			</generator>
		</configuration>
	</plugin>
----



==== Using DSLContext
The fluent API offered by jOOQ is initiated through the `org.jooq.DSLContext` interface.
Spring Boot auto-configures a `DSLContext` as a Spring Bean and connects it to your application `DataSource`.
To use the `DSLContext`, you can `@Autowire` it, as shown in the following example:

[source,java,indent=0]
----
	@Component
	public class JooqExample implements CommandLineRunner {

		private final DSLContext create;

		@Autowired
		public JooqExample(DSLContext dslContext) {
			this.create = dslContext;
		}

	}
----

TIP: The jOOQ manual tends to use a variable named `create` to hold the `DSLContext`.

You can then use the `DSLContext` to construct your queries, as shown in the following example:

[source,java,indent=0]
----
	public List<GregorianCalendar> authorsBornAfter1980() {
		return this.create.selectFrom(AUTHOR)
			.where(AUTHOR.DATE_OF_BIRTH.greaterThan(new GregorianCalendar(1980, 0, 1)))
			.fetch(AUTHOR.DATE_OF_BIRTH);
	}
----



==== jOOQ SQL Dialect
Unless the configprop:spring.jooq.sql-dialect[] property has been configured, Spring Boot determines the SQL dialect to use for your datasource.
If Spring Boot could not detect the dialect, it uses `DEFAULT`.

NOTE: Spring Boot can only auto-configure dialects supported by the open source version of jOOQ.



==== Customizing jOOQ
More advanced customizations can be achieved by defining your own `@Bean` definitions, which is used when the jOOQ `Configuration` is created.
You can define beans for the following jOOQ Types:

* `ConnectionProvider`
* `ExecutorProvider`
* `TransactionProvider`
* `RecordMapperProvider`
* `RecordUnmapperProvider`
* `Settings`
* `RecordListenerProvider`
* `ExecuteListenerProvider`
* `VisitListenerProvider`
* `TransactionListenerProvider`

You can also create your own `org.jooq.Configuration` `@Bean` if you want to take complete control of the jOOQ configuration.



[[boot-features-nosql]]
== Working with NoSQL Technologies
Spring Data provides additional projects that help you access a variety of NoSQL technologies, including:

* {spring-data-mongodb}[MongoDB]
* {spring-data-neo4j}[Neo4J]
* {spring-data-elasticsearch}[Elasticsearch]
* {spring-data-solr}[Solr]
* {spring-data-redis}[Redis]
* {spring-data-gemfire}[GemFire] or {spring-data-geode}[Geode]
* {spring-data-cassandra}[Cassandra]
* {spring-data-couchbase}[Couchbase]
* {spring-data-ldap}[LDAP]

Spring Boot provides auto-configuration for Redis, MongoDB, Neo4j, Elasticsearch, Solr Cassandra, Couchbase, and LDAP.
You can make use of the other projects, but you must configure them yourself.
Refer to the appropriate reference documentation at {spring-data}.



[[boot-features-redis]]
=== Redis
https://redis.io/[Redis] is a cache, message broker, and richly-featured key-value store.
Spring Boot offers basic auto-configuration for the https://github.com/lettuce-io/lettuce-core/[Lettuce] and https://github.com/xetorthio/jedis/[Jedis] client libraries and the abstractions on top of them provided by https://github.com/spring-projects/spring-data-redis[Spring Data Redis].

There is a `spring-boot-starter-data-redis` "`Starter`" for collecting the dependencies in a convenient way.
By default, it uses https://github.com/lettuce-io/lettuce-core/[Lettuce].
That starter handles both traditional and reactive applications.

TIP: we also provide a `spring-boot-starter-data-redis-reactive` "`Starter`" for consistency with the other stores with reactive support.



[[boot-features-connecting-to-redis]]
==== Connecting to Redis
You can inject an auto-configured `RedisConnectionFactory`, `StringRedisTemplate`, or vanilla `RedisTemplate` instance as you would any other Spring Bean.
By default, the instance tries to connect to a Redis server at `localhost:6379`.
The following listing shows an example of such a bean:

[source,java,indent=0]
----
	@Component
	public class MyBean {

		private StringRedisTemplate template;

		@Autowired
		public MyBean(StringRedisTemplate template) {
			this.template = template;
		}

		// ...

	}
----

TIP: You can also register an arbitrary number of beans that implement `LettuceClientConfigurationBuilderCustomizer` for more advanced customizations.
If you use Jedis, `JedisClientConfigurationBuilderCustomizer` is also available.

If you add your own `@Bean` of any of the auto-configured types, it replaces the default (except in the case of `RedisTemplate`, when the exclusion is based on the bean name, `redisTemplate`, not its type).
By default, if `commons-pool2` is on the classpath, you get a pooled connection factory.



[[boot-features-mongodb]]
=== MongoDB
https://www.mongodb.com/[MongoDB] is an open-source NoSQL document database that uses a JSON-like schema instead of traditional table-based relational data.
Spring Boot offers several conveniences for working with MongoDB, including the `spring-boot-starter-data-mongodb` and `spring-boot-starter-data-mongodb-reactive` "`Starters`".



[[boot-features-connecting-to-mongodb]]
==== Connecting to a MongoDB Database
To access Mongo databases, you can inject an auto-configured `org.springframework.data.mongodb.MongoDbFactory`.
By default, the instance tries to connect to a MongoDB server at `mongodb://localhost/test`.
The following example shows how to connect to a MongoDB database:

[source,java,indent=0]
----
	import org.springframework.data.mongodb.MongoDbFactory;
	import com.mongodb.DB;

	@Component
	public class MyBean {

		private final MongoDbFactory mongo;

		@Autowired
		public MyBean(MongoDbFactory mongo) {
			this.mongo = mongo;
		}

		// ...

		public void example() {
			DB db = mongo.getDb();
			// ...
		}

	}
----

You can set the configprop:spring.data.mongodb.uri[] property to change the URL and configure additional settings such as the _replica set_, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.data.mongodb.uri=mongodb://user:secret@mongo1.example.com:12345,mongo2.example.com:23456/test
----

Alternatively, as long as you use Mongo 2.x, you can specify a `host`/`port`.
For example, you might declare the following settings in your `application.properties`:

[source,properties,indent=0,configprops]
----
	spring.data.mongodb.host=mongoserver
	spring.data.mongodb.port=27017
----

If you have defined your own `MongoClient`, it will be used to auto-configure a suitable `MongoDbFactory`.
Both `com.mongodb.MongoClient` and `com.mongodb.client.MongoClient` are supported.

NOTE: If you use the Mongo 3.0 Java driver, `spring.data.mongodb.host` and `spring.data.mongodb.port` are not supported.
In such cases, `spring.data.mongodb.uri` should be used to provide all of the configuration.

TIP: If `spring.data.mongodb.port` is not specified, the default of `27017` is used.
You could delete this line from the example shown earlier.

TIP: If you do not use Spring Data Mongo, you can inject `com.mongodb.MongoClient` beans instead of using `MongoDbFactory`.
If you want to take complete control of establishing the MongoDB connection, you can also declare your own `MongoDbFactory` or `MongoClient` bean.

NOTE: If you are using the reactive driver, Netty is required for SSL.
The auto-configuration configures this factory automatically if Netty is available and the factory to use hasn't been customized already.



[[boot-features-mongo-template]]
==== MongoTemplate
{spring-data-mongodb}[Spring Data MongoDB] provides a {spring-data-mongodb-api}/core/MongoTemplate.html[`MongoTemplate`] class that is very similar in its design to Spring's `JdbcTemplate`.
As with `JdbcTemplate`, Spring Boot auto-configures a bean for you to inject the template, as follows:

[source,java,indent=0]
----
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.data.mongodb.core.MongoTemplate;
	import org.springframework.stereotype.Component;

	@Component
	public class MyBean {

		private final MongoTemplate mongoTemplate;

		@Autowired
		public MyBean(MongoTemplate mongoTemplate) {
			this.mongoTemplate = mongoTemplate;
		}

		// ...

	}
----

See the {spring-data-mongodb-api}/core/MongoOperations.html[`MongoOperations` Javadoc] for complete details.



[[boot-features-spring-data-mongo-repositories]]
[[boot-features-spring-data-mongodb-repositories]]
==== Spring Data MongoDB Repositories
Spring Data includes repository support for MongoDB.
As with the JPA repositories discussed earlier, the basic principle is that queries are constructed automatically, based on method names.

In fact, both Spring Data JPA and Spring Data MongoDB share the same common infrastructure.
You could take the JPA example from earlier and, assuming that `City` is now a Mongo data class rather than a JPA `@Entity`, it works in the same way, as shown in the following example:

[source,java,indent=0]
----
	package com.example.myapp.domain;

	import org.springframework.data.domain.*;
	import org.springframework.data.repository.*;

	public interface CityRepository extends Repository<City, Long> {

		Page<City> findAll(Pageable pageable);

		City findByNameAndStateAllIgnoringCase(String name, String state);

	}
----

TIP: You can customize document scanning locations by using the `@EntityScan` annotation.

TIP: For complete details of Spring Data MongoDB, including its rich object mapping technologies, refer to its {spring-data-mongodb}[reference documentation].



[[boot-features-mongo-embedded]]
==== Embedded Mongo
Spring Boot offers auto-configuration for https://github.com/flapdoodle-oss/de.flapdoodle.embed.mongo[Embedded Mongo].
To use it in your Spring Boot application, add a dependency on `de.flapdoodle.embed:de.flapdoodle.embed.mongo`.

The port that Mongo listens on can be configured by setting the configprop:spring.data.mongodb.port[] property.
To use a randomly allocated free port, use a value of 0.
The `MongoClient` created by `MongoAutoConfiguration` is automatically configured to use the randomly allocated port.

NOTE: If you do not configure a custom port, the embedded support uses a random port (rather than 27017) by default.

If you have SLF4J on the classpath, the output produced by Mongo is automatically routed to a logger named `org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongo`.

You can declare your own `IMongodConfig` and `IRuntimeConfig` beans to take control of the Mongo instance's configuration and logging routing.
The download configuration can be customized by declaring a `DownloadConfigBuilderCustomizer` bean.



[[boot-features-neo4j]]
=== Neo4j
https://neo4j.com/[Neo4j] is an open-source NoSQL graph database that uses a rich data model of nodes connected by first class relationships, which is better suited for connected big data than traditional RDBMS approaches.
Spring Boot offers several conveniences for working with Neo4j, including the `spring-boot-starter-data-neo4j` "`Starter`".



[[boot-features-connecting-to-neo4j]]
==== Connecting to a Neo4j Database
To access a Neo4j server, you can inject an auto-configured `org.neo4j.ogm.session.Session`.
By default, the instance tries to connect to a Neo4j server at `localhost:7687` using the Bolt protocol.
The following example shows how to inject a Neo4j `Session`:

[source,java,indent=0]
----
	@Component
	public class MyBean {

		private final Session session;

		@Autowired
		public MyBean(Session session) {
			this.session = session;
		}

		// ...

	}
----

You can configure the uri and credentials to use by setting the `spring.data.neo4j.*` properties, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.data.neo4j.uri=bolt://my-server:7687
	spring.data.neo4j.username=neo4j
	spring.data.neo4j.password=secret
----

You can take full control over the session creation by adding either an `org.neo4j.ogm.config.Configuration` bean or an `org.neo4j.ogm.session.SessionFactory` bean.



[[boot-features-connecting-to-neo4j-embedded]]
==== Using the Embedded Mode
If you add `org.neo4j:neo4j-ogm-embedded-driver` to the dependencies of your application, Spring Boot automatically configures an in-process embedded instance of Neo4j that does not persist any data when your application shuts down.

NOTE: As the embedded Neo4j OGM  driver  does not provide the Neo4j kernel itself, you have to declare `org.neo4j:neo4j` as dependency yourself.
Refer to https://neo4j.com/docs/ogm-manual/current/reference/#reference:getting-started[the Neo4j OGM documentation] for a list of compatible versions.

The embedded driver takes precedence over the other drivers when there are multiple drivers on the classpath.
You can explicitly disable the embedded mode by setting `spring.data.neo4j.embedded.enabled=false`.

<<boot-features-testing-spring-boot-applications-testing-autoconfigured-neo4j-test,Data Neo4j Tests>> automatically make use of an embedded Neo4j instance if the embedded driver and Neo4j kernel are on the classpath as described above.

NOTE: You can enable persistence for the embedded mode by providing a path to a database file in your configuration, e.g. `spring.data.neo4j.uri=file://var/tmp/graph.db`.



[[boot-features-neo4j-ogm-native-types]]
==== Using Native Types
Neo4j-OGM can map some types, like those in `java.time.*`, to `String`-based properties or to one of the native types that Neo4j provides.
For backwards compatibility reasons the default for Neo4j-OGM is to use a `String`-based representation.
To use native types, add a dependency on either `org.neo4j:neo4j-ogm-bolt-native-types` or `org.neo4j:neo4j-ogm-embedded-native-types`, and configure the configprop:spring.data.neo4j.use-native-types[] property as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.data.neo4j.use-native-types=true
----



[[boot-features-neo4j-ogm-session]]
==== Neo4jSession
By default, if you are running a web application, the session is bound to the thread for the entire processing of the request (that is, it uses the "Open Session in View" pattern).
If you do not want this behavior, add the following line to your `application.properties` file:

[source,properties,indent=0,configprops]
----
	spring.data.neo4j.open-in-view=false
----



[[boot-features-spring-data-neo4j-repositories]]
==== Spring Data Neo4j Repositories
Spring Data includes repository support for Neo4j.

Spring Data Neo4j shares the common infrastructure with Spring Data JPA as many other Spring Data modules do.
You could take the JPA example from earlier and define `City` as Neo4j OGM `@NodeEntity` rather than JPA `@Entity` and the repository abstraction works in the same way, as shown in the following example:

[source,java,indent=0]
----
	package com.example.myapp.domain;

	import java.util.Optional;

	import org.springframework.data.neo4j.repository.*;

	public interface CityRepository extends Neo4jRepository<City, Long> {

		Optional<City> findOneByNameAndState(String name, String state);

	}
----

The `spring-boot-starter-data-neo4j` "`Starter`" enables the repository support as well as transaction management.
You can customize the locations to look for repositories and entities by using `@EnableNeo4jRepositories` and `@EntityScan` respectively on a `@Configuration`-bean.

TIP: For complete details of Spring Data Neo4j, including its object mapping technologies, refer to the {spring-data-neo4j-docs}[reference documentation].



[[boot-features-solr]]
=== Solr
https://lucene.apache.org/solr/[Apache Solr] is a search engine.
Spring Boot offers basic auto-configuration for the Solr 5 client library and the abstractions on top of it provided by https://github.com/spring-projects/spring-data-solr[Spring Data Solr].
There is a `spring-boot-starter-data-solr` "`Starter`" for collecting the dependencies in a convenient way.



[[boot-features-connecting-to-solr]]
==== Connecting to Solr
You can inject an auto-configured `SolrClient` instance as you would any other Spring bean.
By default, the instance tries to connect to a server at `http://localhost:8983/solr`.
The following example shows how to inject a Solr bean:

[source,java,indent=0]
----
	@Component
	public class MyBean {

		private SolrClient solr;

		@Autowired
		public MyBean(SolrClient solr) {
			this.solr = solr;
		}

		// ...

	}
----

If you add your own `@Bean` of type `SolrClient`, it replaces the default.



[[boot-features-spring-data-solr-repositories]]
==== Spring Data Solr Repositories
Spring Data includes repository support for Apache Solr.
As with the JPA repositories discussed earlier, the basic principle is that queries are automatically constructed for you based on method names.

In fact, both Spring Data JPA and Spring Data Solr share the same common infrastructure.
You could take the JPA example from earlier and, assuming that `City` is now a `@SolrDocument` class rather than a JPA `@Entity`, it works in the same way.

IP: For complete details of Spring Data Solr, refer to the {spring-data-solr-docs}[reference documentation].



[[boot-features-elasticsearch]]
=== Elasticsearch
https://www.elastic.co/products/elasticsearch[Elasticsearch] is an open source, distributed, RESTful search and analytics engine.
Spring Boot offers basic auto-configuration for Elasticsearch.

Spring Boot supports several clients:

* The official Java "Low Level" and "High Level" REST clients
* The `ReactiveElasticsearchClient` provided by Spring Data Elasticsearch

The transport client is still available but its support has been deprecated in https://github.com/spring-projects/spring-data-elasticsearch[Spring Data Elasticsearch] and Elasticsearch itself.
It will be removed in a future release.
Spring Boot provides a dedicated "`Starter`", `spring-boot-starter-data-elasticsearch`.

The https://github.com/searchbox-io/Jest[Jest] client has been deprecated as well, since both Elasticsearch and Spring Data Elasticsearch provide official support for REST clients.



[[boot-features-connecting-to-elasticsearch-rest]]
==== Connecting to Elasticsearch using REST clients
Elasticsearch ships https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/index.html[two different REST clients] that you can use to query a cluster: the "Low Level" client and the "High Level" client.

If you have the `org.elasticsearch.client:elasticsearch-rest-client` dependency on the classpath, Spring Boot will auto-configure and register a `RestClient` bean that by default targets `http://localhost:9200`.
You can further tune how `RestClient` is configured, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.elasticsearch.rest.uris=https://search.example.com:9200
	spring.elasticsearch.rest.read-timeout=10s
	spring.elasticsearch.rest.username=user
	spring.elasticsearch.rest.password=secret
----

You can also register an arbitrary number of beans that implement `RestClientBuilderCustomizer` for more advanced customizations.
To take full control over the registration, define a `RestClient` bean.

If you have the `org.elasticsearch.client:elasticsearch-rest-high-level-client` dependency on the classpath, Spring Boot will auto-configure a `RestHighLevelClient`, which wraps any existing `RestClient` bean, reusing its HTTP configuration.


[[boot-features-connecting-to-elasticsearch-reactive-rest]]
==== Connecting to Elasticsearch using Reactive REST clients
{spring-data-elasticsearch}[Spring Data Elasticsearch] ships `ReactiveElasticsearchClient` for querying Elasticsearch instances in a reactive fashion.
It is built on top of WebFlux's `WebClient`, so both `spring-boot-starter-elasticsearch` and `spring-boot-starter-webflux` dependencies are useful to enable this support.

By default, Spring Boot will auto-configure and register a `ReactiveElasticsearchClient`
bean that targets `http://localhost:9200`.
You can further tune how it is configured, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.data.elasticsearch.client.reactive.endpoints=search.example.com:9200
	spring.data.elasticsearch.client.reactive.use-ssl=true
	spring.data.elasticsearch.client.reactive.socket-timeout=10s
	spring.data.elasticsearch.client.reactive.username=user
	spring.data.elasticsearch.client.reactive.password=secret
----

If the configuration properties are not enough and you'd like to fully control the client
configuration, you can register a custom `ClientConfiguration` bean.

[[boot-features-connecting-to-elasticsearch-jest]]
==== Connecting to Elasticsearch using Jest
Now that Spring Boot supports the official `RestHighLevelClient`, Jest support is deprecated.

If you have `Jest` on the classpath, you can inject an auto-configured `JestClient` that by default targets `http://localhost:9200`.
You can further tune how the client is configured, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.elasticsearch.jest.uris=https://search.example.com:9200
	spring.elasticsearch.jest.read-timeout=10000
	spring.elasticsearch.jest.username=user
	spring.elasticsearch.jest.password=secret
----

You can also register an arbitrary number of beans that implement `HttpClientConfigBuilderCustomizer` for more advanced customizations.
The following example tunes additional HTTP settings:

[source,java,indent=0]
----
include::{code-examples}/elasticsearch/jest/JestClientCustomizationExample.java[tag=customizer]
----

To take full control over the registration, define a `JestClient` bean.



[[boot-features-connecting-to-elasticsearch-spring-data]]
==== Connecting to Elasticsearch by Using Spring Data
To connect to Elasticsearch, a `RestHighLevelClient` bean must be defined,
auto-configured by Spring Boot or manually provided by the application (see previous sections).
With this configuration in place, an
`ElasticsearchRestTemplate` can be injected like any other Spring bean,
as shown in the following example:

[source,java,indent=0]
----
	@Component
	public class MyBean {

		private final ElasticsearchRestTemplate template;

		public MyBean(ElasticsearchRestTemplate template) {
			this.template = template;
		}

		// ...

	}
----

In the presence of `spring-data-elasticsearch` and the required dependencies for using a `WebClient` (typically `spring-boot-starter-webflux`), Spring Boot can also auto-configure a <<boot-features-connecting-to-elasticsearch-reactive-rest,ReactiveElasticsearchClient>> and a `ReactiveElasticsearchTemplate` as beans.
They are the reactive equivalent of the other REST clients.



[[boot-features-spring-data-elasticsearch-repositories]]
==== Spring Data Elasticsearch Repositories
Spring Data includes repository support for Elasticsearch.
As with the JPA repositories discussed earlier, the basic principle is that queries are constructed for you automatically based on method names.

In fact, both Spring Data JPA and Spring Data Elasticsearch share the same common infrastructure.
You could take the JPA example from earlier and, assuming that `City` is now an Elasticsearch `@Document` class rather than a JPA `@Entity`, it works in the same way.

TIP: For complete details of Spring Data Elasticsearch, refer to the {spring-data-elasticsearch-docs}[reference documentation].

Spring Boot supports both classic and reactive Elasticsearch repositories, using the `ElasticsearchRestTemplate` or `ReactiveElasticsearchTemplate` beans.
Most likely those beans are auto-configured by Spring Boot given the required dependencies are present.

If you wish to use your own template for backing the Elasticsearch repositories, you can add your own `ElasticsearchRestTemplate` or `ElasticsearchOperations` `@Bean`, as long as it is named `"elasticsearchTemplate"`.
Same applies to `ReactiveElasticsearchTemplate` and `ReactiveElasticsearchOperations`, with the bean name `"reactiveElasticsearchTemplate"`.

You can choose to disable the repositories support with the following property:

[source,properties,indent=0,configprops]
----
    spring.data.elasticsearch.repositories.enabled=false
----


[[boot-features-cassandra]]
=== Cassandra
https://cassandra.apache.org/[Cassandra] is an open source, distributed database management system designed to handle large amounts of data across many commodity servers.
Spring Boot offers auto-configuration for Cassandra and the abstractions on top of it provided by https://github.com/spring-projects/spring-data-cassandra[Spring Data Cassandra].
There is a `spring-boot-starter-data-cassandra` "`Starter`" for collecting the dependencies in a convenient way.



[[boot-features-connecting-to-cassandra]]
==== Connecting to Cassandra
You can inject an auto-configured `CassandraTemplate` or a Cassandra `Session` instance as you would with any other Spring Bean.
The `spring.data.cassandra.*` properties can be used to customize the connection.
Generally, you provide `keyspace-name` and `contact-points` properties, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.data.cassandra.keyspace-name=mykeyspace
	spring.data.cassandra.contact-points=cassandrahost1,cassandrahost2
----

You can also register an arbitrary number of beans that implement `ClusterBuilderCustomizer` for more advanced customizations.

The following code listing shows how to inject a Cassandra bean:

[source,java,indent=0]
----
	@Component
	public class MyBean {

		private CassandraTemplate template;

		@Autowired
		public MyBean(CassandraTemplate template) {
			this.template = template;
		}

		// ...

	}
----

If you add your own `@Bean` of type `CassandraTemplate`, it replaces the default.



[[boot-features-spring-data-cassandra-repositories]]
==== Spring Data Cassandra Repositories
Spring Data includes basic repository support for Cassandra.
Currently, this is more limited than the JPA repositories discussed earlier and needs to annotate finder methods with `@Query`.

TIP: For complete details of Spring Data Cassandra, refer to the https://docs.spring.io/spring-data/cassandra/docs/[reference documentation].



[[boot-features-couchbase]]
=== Couchbase
https://www.couchbase.com/[Couchbase] is an open-source, distributed, multi-model NoSQL document-oriented database that is optimized for interactive applications.
Spring Boot offers auto-configuration for Couchbase and the abstractions on top of it provided by https://github.com/spring-projects/spring-data-couchbase[Spring Data Couchbase].
There are `spring-boot-starter-data-couchbase` and `spring-boot-starter-data-couchbase-reactive` "`Starters`" for collecting the dependencies in a convenient way.



[[boot-features-connecting-to-couchbase]]
==== Connecting to Couchbase
You can get a `Bucket` and `Cluster` by adding the Couchbase SDK and some configuration.
The `spring.couchbase.*` properties can be used to customize the connection.
Generally, you provide the bootstrap hosts, bucket name, and password, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.couchbase.bootstrap-hosts=my-host-1,192.168.1.123
	spring.couchbase.bucket.name=my-bucket
	spring.couchbase.bucket.password=secret
----

TIP: You need to provide _at least_ the bootstrap host(s), in which case the bucket name is `default` and the password is an empty String.
Alternatively, you can define your own `org.springframework.data.couchbase.config.CouchbaseConfigurer` `@Bean` to take control over the whole configuration.

It is also possible to customize some of the `CouchbaseEnvironment` settings.
For instance, the following configuration changes the timeout to use to open a new `Bucket` and enables SSL support:

[source,properties,indent=0,configprops]
----
	spring.couchbase.env.timeouts.connect=3000
	spring.couchbase.env.ssl.key-store=/location/of/keystore.jks
	spring.couchbase.env.ssl.key-store-password=secret
----

Check the `spring.couchbase.env.*` properties for more details.



[[boot-features-spring-data-couchbase-repositories]]
==== Spring Data Couchbase Repositories
Spring Data includes repository support for Couchbase.
For complete details of Spring Data Couchbase, refer to the https://docs.spring.io/spring-data/couchbase/docs/current/reference/html/[reference documentation].

You can inject an auto-configured `CouchbaseTemplate` instance as you would with any other Spring Bean, provided a _default_ `CouchbaseConfigurer` is available (which happens when you enable Couchbase support, as explained earlier).

The following examples shows how to inject a Couchbase bean:

[source,java,indent=0]
----
	@Component
	public class MyBean {

		private final CouchbaseTemplate template;

		@Autowired
		public MyBean(CouchbaseTemplate template) {
			this.template = template;
		}

		// ...

	}
----

There are a few beans that you can define in your own configuration to override those provided by the auto-configuration:

* A `CouchbaseTemplate` `@Bean` with a name of `couchbaseTemplate`.
* An `IndexManager` `@Bean` with a name of `couchbaseIndexManager`.
* A `CustomConversions` `@Bean` with a name of `couchbaseCustomConversions`.

To avoid hard-coding those names in your own config, you can reuse `BeanNames` provided by Spring Data Couchbase.
For instance, you can customize the converters to use, as follows:

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	public class SomeConfiguration {

		@Bean(BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)
		public CustomConversions myCustomConversions() {
			return new CustomConversions(...);
		}

		// ...

	}
----

TIP: If you want to fully bypass the auto-configuration for Spring Data Couchbase, provide your own implementation of `org.springframework.data.couchbase.config.AbstractCouchbaseDataConfiguration`.



[[boot-features-ldap]]
=== LDAP
https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol[LDAP] (Lightweight Directory Access Protocol) is an open, vendor-neutral, industry standard application protocol for accessing and maintaining distributed directory information services over an IP network.
Spring Boot offers auto-configuration for any compliant LDAP server as well as support for the embedded in-memory LDAP server from https://www.ldap.com/unboundid-ldap-sdk-for-java[UnboundID].

LDAP abstractions are provided by https://github.com/spring-projects/spring-data-ldap[Spring Data LDAP].
There is a `spring-boot-starter-data-ldap` "`Starter`" for collecting the dependencies in a convenient way.



[[boot-features-ldap-connecting]]
==== Connecting to an LDAP Server
To connect to an LDAP server, make sure you declare a dependency on the `spring-boot-starter-data-ldap` "`Starter`" or `spring-ldap-core` and then declare the URLs of your server in your application.properties, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.ldap.urls=ldap://myserver:1235
	spring.ldap.username=admin
	spring.ldap.password=secret
----

If you need to customize connection settings, you can use the `spring.ldap.base` and `spring.ldap.base-environment` properties.

An `LdapContextSource` is auto-configured based on these settings.
If you need to customize it, for instance to use a `PooledContextSource`, you can still inject the auto-configured `LdapContextSource`.
Make sure to flag your customized `ContextSource` as `@Primary` so that the auto-configured `LdapTemplate` uses it.



[[boot-features-ldap-spring-data-repositories]]
==== Spring Data LDAP Repositories
Spring Data includes repository support for LDAP.
For complete details of Spring Data LDAP, refer to the https://docs.spring.io/spring-data/ldap/docs/1.0.x/reference/html/[reference documentation].

You can also inject an auto-configured `LdapTemplate` instance as you would with any other Spring Bean, as shown in the following example:


[source,java,indent=0]
----
	@Component
	public class MyBean {

		private final LdapTemplate template;

		@Autowired
		public MyBean(LdapTemplate template) {
			this.template = template;
		}

		// ...

	}
----



[[boot-features-ldap-embedded]]
==== Embedded In-memory LDAP Server
For testing purposes, Spring Boot supports auto-configuration of an in-memory LDAP server from https://www.ldap.com/unboundid-ldap-sdk-for-java[UnboundID].
To configure the server, add a dependency to `com.unboundid:unboundid-ldapsdk` and declare a configprop:spring.ldap.embedded.base-dn[] property, as follows:

[source,properties,indent=0,configprops]
----
	spring.ldap.embedded.base-dn=dc=spring,dc=io
----

[NOTE]
====
It is possible to define multiple base-dn values, however, since distinguished names usually contain commas, they must be defined using the correct notation.

In yaml files, you can use the yaml list notation:

[source,yaml,indent=0]
----
	spring.ldap.embedded.base-dn:
	  - dc=spring,dc=io
	  - dc=pivotal,dc=io
----

In properties files, you must include the index as part of the property name:

[source,properties,indent=0,configprops]
----
	spring.ldap.embedded.base-dn[0]=dc=spring,dc=io
	spring.ldap.embedded.base-dn[1]=dc=pivotal,dc=io
----

====

By default, the server starts on a random port and triggers the regular LDAP support.
There is no need to specify a configprop:spring.ldap.urls[] property.

If there is a `schema.ldif` file on your classpath, it is used to initialize the server.
If you want to load the initialization script from a different resource, you can also use the configprop:spring.ldap.embedded.ldif[] property.

By default, a standard schema is used to validate `LDIF` files.
You can turn off validation altogether by setting the configprop:spring.ldap.embedded.validation.enabled[] property.
If you have custom attributes, you can use configprop:spring.ldap.embedded.validation.schema[] to define your custom attribute types or object classes.



[[boot-features-influxdb]]
=== InfluxDB
https://www.influxdata.com/[InfluxDB] is an open-source time series database optimized for fast, high-availability storage and retrieval of time series data in fields such as operations monitoring, application metrics, Internet-of-Things sensor data, and real-time analytics.



[[boot-features-connecting-to-influxdb]]
==== Connecting to InfluxDB
Spring Boot auto-configures an `InfluxDB` instance, provided the `influxdb-java` client is on the classpath and the URL of the database is set, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.influx.url=https://172.0.0.1:8086
----

If the connection to InfluxDB requires a user and password, you can set the `spring.influx.user` and `spring.influx.password` properties accordingly.

InfluxDB relies on OkHttp.
If you need to tune the http client `InfluxDB` uses behind the scenes, you can register an `InfluxDbOkHttpClientBuilderProvider` bean.



[[boot-features-caching]]
== Caching
The Spring Framework provides support for transparently adding caching to an application.
At its core, the abstraction applies caching to methods, thus reducing the number of executions based on the information available in the cache.
The caching logic is applied transparently, without any interference to the invoker.
Spring Boot auto-configures the cache infrastructure as long as caching support is enabled via the `@EnableCaching` annotation.

NOTE: Check the {spring-framework-docs}integration.html#cache[relevant section] of the Spring Framework reference for more details.

In a nutshell, adding caching to an operation of your service is as easy as adding the relevant annotation to its method, as shown in the following example:

[source,java,indent=0]
----
	import org.springframework.cache.annotation.Cacheable;
	import org.springframework.stereotype.Component;

	@Component
	public class MathService {

		@Cacheable("piDecimals")
		public int computePiDecimal(int i) {
			// ...
		}

	}
----

This example demonstrates the use of caching on a potentially costly operation.
Before invoking `computePiDecimal`, the abstraction looks for an entry in the `piDecimals` cache that matches the `i` argument.
If an entry is found, the content in the cache is immediately returned to the caller, and the method is not invoked.
Otherwise, the method is invoked, and the cache is updated before returning the value.

CAUTION: You can also use the standard JSR-107 (JCache) annotations (such as `@CacheResult`) transparently.
However, we strongly advise you to not mix and match the Spring Cache and JCache annotations.

If you do not add any specific cache library, Spring Boot auto-configures a <<boot-features-caching-provider-simple,simple provider>> that uses concurrent maps in memory.
When a cache is required (such as `piDecimals` in the preceding example), this provider creates it for you.
The simple provider is not really recommended for production usage, but it is great for getting started and making sure that you understand the features.
When you have made up your mind about the cache provider to use, please make sure to read its documentation to figure out how to configure the caches that your application uses.
Nearly all providers require you to explicitly configure every cache that you use in the application.
Some offer a way to customize the default caches defined by the configprop:spring.cache.cache-names[] property.

TIP: It is also possible to transparently {spring-framework-docs}integration.html#cache-annotations-put[update] or {spring-framework-docs}integration.html#cache-annotations-evict[evict] data from the cache.



[[boot-features-caching-provider]]
=== Supported Cache Providers
The cache abstraction does not provide an actual store and relies on abstraction materialized by the `org.springframework.cache.Cache` and `org.springframework.cache.CacheManager` interfaces.

If you have not defined a bean of type `CacheManager` or a `CacheResolver` named `cacheResolver` (see {spring-framework-api}/cache/annotation/CachingConfigurer.html[`CachingConfigurer`]), Spring Boot tries to detect the following providers (in the indicated order):

. <<boot-features-caching-provider-generic,Generic>>
. <<boot-features-caching-provider-jcache,JCache (JSR-107)>> (EhCache 3, Hazelcast, Infinispan, and others)
. <<boot-features-caching-provider-ehcache2,EhCache 2.x>>
. <<boot-features-caching-provider-hazelcast,Hazelcast>>
. <<boot-features-caching-provider-infinispan,Infinispan>>
. <<boot-features-caching-provider-couchbase,Couchbase>>
. <<boot-features-caching-provider-redis,Redis>>
. <<boot-features-caching-provider-caffeine,Caffeine>>
. <<boot-features-caching-provider-simple,Simple>>

TIP: It is also possible to _force_ a particular cache provider by setting the configprop:spring.cache.type[] property.
Use this property if you need to <<boot-features-caching-provider-none,disable caching altogether>> in certain environment (such as tests).

TIP: Use the `spring-boot-starter-cache` "`Starter`" to quickly add basic caching dependencies.
The starter brings in `spring-context-support`.
If you add dependencies manually, you must include `spring-context-support` in order to use the JCache, EhCache 2.x, or Caffeine support.

If the `CacheManager` is auto-configured by Spring Boot, you can further tune its configuration before it is fully initialized by exposing a bean that implements the `CacheManagerCustomizer` interface.
The following example sets a flag to say that `null` values should be passed down to the underlying map:

[source,java,indent=0]
----
	@Bean
	public CacheManagerCustomizer<ConcurrentMapCacheManager> cacheManagerCustomizer() {
		return new CacheManagerCustomizer<ConcurrentMapCacheManager>() {
			@Override
			public void customize(ConcurrentMapCacheManager cacheManager) {
				cacheManager.setAllowNullValues(false);
			}
		};
	}
----

NOTE: In the preceding example, an auto-configured `ConcurrentMapCacheManager` is expected.
If that is not the case (either you provided your own config or a different cache provider was auto-configured), the customizer is not invoked at all.
You can have as many customizers as you want, and you can also order them by using `@Order` or `Ordered`.



[[boot-features-caching-provider-generic]]
==== Generic
Generic caching is used if the context defines _at least_ one `org.springframework.cache.Cache` bean.
A `CacheManager` wrapping all beans of that type is created.



[[boot-features-caching-provider-jcache]]
==== JCache (JSR-107)
https://jcp.org/en/jsr/detail?id=107[JCache] is bootstrapped through the presence of a `javax.cache.spi.CachingProvider` on the classpath (that is, a JSR-107 compliant caching library exists on the classpath), and the `JCacheCacheManager` is provided by the `spring-boot-starter-cache` "`Starter`".
Various compliant libraries are available, and Spring Boot provides dependency management for Ehcache 3, Hazelcast, and Infinispan.
Any other compliant library can be added as well.

It might happen that more than one provider is present, in which case the provider must be explicitly specified.
Even if the JSR-107 standard does not enforce a standardized way to define the location of the configuration file, Spring Boot does its best to accommodate setting a cache with implementation details, as shown in the following example:

[source,properties,indent=0,configprops]
----
    # Only necessary if more than one provider is present
	spring.cache.jcache.provider=com.acme.MyCachingProvider
	spring.cache.jcache.config=classpath:acme.xml
----

NOTE: When a cache library offers both a native implementation and JSR-107 support, Spring Boot prefers the JSR-107 support, so that the same features are available if you switch to a different JSR-107 implementation.

TIP: Spring Boot has <<boot-features-hazelcast,general support for Hazelcast>>.
If a single `HazelcastInstance` is available, it is automatically reused for the `CacheManager` as well, unless the configprop:spring.cache.jcache.config[] property is specified.

There are two ways to customize the underlying `javax.cache.cacheManager`:

* Caches can be created on startup by setting the configprop:spring.cache.cache-names[] property.
  If a custom `javax.cache.configuration.Configuration` bean is defined, it is used to customize them.
* `org.springframework.boot.autoconfigure.cache.JCacheManagerCustomizer` beans are invoked with the reference of the `CacheManager` for full customization.

TIP: If a standard `javax.cache.CacheManager` bean is defined, it is wrapped automatically in an `org.springframework.cache.CacheManager` implementation that the abstraction expects.
No further customization is applied to it.



[[boot-features-caching-provider-ehcache2]]
==== EhCache 2.x
https://www.ehcache.org/[EhCache] 2.x is used if a file named `ehcache.xml` can be found at the root of the classpath.
If EhCache 2.x is found, the `EhCacheCacheManager` provided by the `spring-boot-starter-cache` "`Starter`" is used to bootstrap the cache manager.
An alternate configuration file can be provided as well, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.cache.ehcache.config=classpath:config/another-config.xml
----



[[boot-features-caching-provider-hazelcast]]
==== Hazelcast
Spring Boot has <<boot-features-hazelcast,general support for Hazelcast>>.
If a `HazelcastInstance` has been auto-configured, it is automatically wrapped in a `CacheManager`.



[[boot-features-caching-provider-infinispan]]
==== Infinispan
https://infinispan.org/[Infinispan] has no default configuration file location, so it must be specified explicitly.
Otherwise, the default bootstrap is used.

[source,properties,indent=0,configprops]
----
	spring.cache.infinispan.config=infinispan.xml
----

Caches can be created on startup by setting the configprop:spring.cache.cache-names[] property.
If a custom `ConfigurationBuilder` bean is defined, it is used to customize the caches.

NOTE: The support of Infinispan in Spring Boot is restricted to the embedded mode and is quite basic.
If you want more options, you should use the official Infinispan Spring Boot starter instead.
See https://github.com/infinispan/infinispan-spring-boot[Infinispan's documentation] for more details.



[[boot-features-caching-provider-couchbase]]
==== Couchbase
If the https://www.couchbase.com/[Couchbase] Java client and the `couchbase-spring-cache` implementation are available and Couchbase is <<boot-features-couchbase,configured>>, a `CouchbaseCacheManager` is auto-configured.
It is also possible to create additional caches on startup by setting the configprop:spring.cache.cache-names[] property.
These caches operate on the `Bucket` that was auto-configured.
You can _also_ create additional caches on another `Bucket` by using the customizer.
Assume you need two caches (`cache1` and `cache2`) on the "main" `Bucket` and one (`cache3`) cache with a custom time to live of 2 seconds on the "`another`" `Bucket`.
You can create the first two caches through configuration, as follows:

[source,properties,indent=0,configprops]
----
	spring.cache.cache-names=cache1,cache2
----

Then you can define a `@Configuration` class to configure the extra `Bucket` and the `cache3` cache, as follows:

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	public class CouchbaseCacheConfiguration {

		private final Cluster cluster;

		public CouchbaseCacheConfiguration(Cluster cluster) {
			this.cluster = cluster;
		}

		@Bean
		public Bucket anotherBucket() {
			return this.cluster.openBucket("another", "secret");
		}

		@Bean
		public CacheManagerCustomizer<CouchbaseCacheManager> cacheManagerCustomizer() {
			return c -> {
				c.prepareCache("cache3", CacheBuilder.newInstance(anotherBucket())
						.withExpiration(2));
			};
		}

	}
----

This sample configuration reuses the `Cluster` that was created through auto-configuration.



[[boot-features-caching-provider-redis]]
==== Redis
If https://redis.io/[Redis] is available and configured, a `RedisCacheManager` is auto-configured.
It is possible to create additional caches on startup by setting the configprop:spring.cache.cache-names[] property and cache defaults can be configured by using `spring.cache.redis.*` properties.
For instance, the following configuration creates `cache1` and `cache2` caches with a _time to live_ of 10 minutes:

[source,properties,indent=0,configprops]
----
	spring.cache.cache-names=cache1,cache2
	spring.cache.redis.time-to-live=600000
----

NOTE: By default, a key prefix is added so that, if two separate caches use the same key, Redis does not have overlapping keys and cannot return invalid values.
We strongly recommend keeping this setting enabled if you create your own `RedisCacheManager`.

TIP: You can take full control of the configuration by adding a `RedisCacheConfiguration` `@Bean` of your own.
This can be useful if you're looking for customizing the serialization strategy.



[[boot-features-caching-provider-caffeine]]
==== Caffeine
https://github.com/ben-manes/caffeine[Caffeine] is a Java 8 rewrite of Guava's cache that supersedes support for Guava.
If Caffeine is present, a `CaffeineCacheManager` (provided by the `spring-boot-starter-cache` "`Starter`") is auto-configured.
Caches can be created on startup by setting the configprop:spring.cache.cache-names[] property and can be customized by one of the following (in the indicated order):

. A cache spec defined by `spring.cache.caffeine.spec`
. A `com.github.benmanes.caffeine.cache.CaffeineSpec` bean is defined
. A `com.github.benmanes.caffeine.cache.Caffeine` bean is defined

For instance, the following configuration creates `cache1` and `cache2` caches with a maximum size of 500 and a _time to live_ of 10 minutes

[source,properties,indent=0,configprops]
----
	spring.cache.cache-names=cache1,cache2
	spring.cache.caffeine.spec=maximumSize=500,expireAfterAccess=600s
----

If a `com.github.benmanes.caffeine.cache.CacheLoader` bean is defined, it is automatically associated to the `CaffeineCacheManager`.
Since the `CacheLoader` is going to be associated with _all_ caches managed by the cache manager, it must be defined as `CacheLoader<Object, Object>`.
The auto-configuration ignores any other generic type.



[[boot-features-caching-provider-simple]]
==== Simple
If none of the other providers can be found, a simple implementation using a `ConcurrentHashMap` as the cache store is configured.
This is the default if no caching library is present in your application.
By default, caches are created as needed, but you can restrict the list of available caches by setting the `cache-names` property.
For instance, if you want only `cache1` and `cache2` caches, set the `cache-names` property as follows:

[source,properties,indent=0,configprops]
----
	spring.cache.cache-names=cache1,cache2
----

If you do so and your application uses a cache not listed, then it fails at runtime when the cache is needed, but not on startup.
This is similar to the way the "real" cache providers behave if you use an undeclared cache.



[[boot-features-caching-provider-none]]
==== None
When `@EnableCaching` is present in your configuration, a suitable cache configuration is expected as well.
If you need to disable caching altogether in certain environments, force the cache type to `none` to use a no-op implementation, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.cache.type=none
----



[[boot-features-messaging]]
== Messaging
The Spring Framework provides extensive support for integrating with messaging systems, from simplified use of the JMS API using `JmsTemplate` to a complete infrastructure to receive messages asynchronously.
Spring AMQP provides a similar feature set for the Advanced Message Queuing Protocol.
Spring Boot also provides auto-configuration options for `RabbitTemplate` and RabbitMQ.
Spring WebSocket natively includes support for STOMP messaging, and Spring Boot has support for that through starters and a small amount of auto-configuration.
Spring Boot also has support for Apache Kafka.



[[boot-features-jms]]
=== JMS
The `javax.jms.ConnectionFactory` interface provides a standard method of creating a `javax.jms.Connection` for interacting with a JMS broker.
Although Spring needs a `ConnectionFactory` to work with JMS, you generally need not use it directly yourself and can instead rely on higher level messaging abstractions.
(See the {spring-framework-docs}integration.html#jms[relevant section] of the Spring Framework reference documentation for details.)
Spring Boot also auto-configures the necessary infrastructure to send and receive messages.



[[boot-features-activemq]]
==== ActiveMQ Support
When https://activemq.apache.org/[ActiveMQ] is available on the classpath, Spring Boot can also configure a `ConnectionFactory`.
If the broker is present, an embedded broker is automatically started and configured (provided no broker URL is specified through configuration).

NOTE: If you use `spring-boot-starter-activemq`, the necessary dependencies to connect or embed an ActiveMQ instance are provided, as is the Spring infrastructure to integrate with JMS.

ActiveMQ configuration is controlled by external configuration properties in `+spring.activemq.*+`.
For example, you might declare the following section in `application.properties`:

[source,properties,indent=0,configprops]
----
	spring.activemq.broker-url=tcp://192.168.1.210:9876
	spring.activemq.user=admin
	spring.activemq.password=secret
----

By default, a `CachingConnectionFactory` wraps the native `ConnectionFactory` with sensible settings that you can control by external configuration properties in `+spring.jms.*+`:

[source,properties,indent=0,configprops]
----
	spring.jms.cache.session-cache-size=5
----

If you'd rather use native pooling, you can do so by adding a dependency to `org.messaginghub:pooled-jms` and configuring the `JmsPoolConnectionFactory` accordingly, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.activemq.pool.enabled=true
	spring.activemq.pool.max-connections=50
----

TIP: See {spring-boot-autoconfigure-module-code}/jms/activemq/ActiveMQProperties.java[`ActiveMQProperties`] for more of the supported options.
You can also register an arbitrary number of beans that implement `ActiveMQConnectionFactoryCustomizer` for more advanced customizations.

By default, ActiveMQ creates a destination if it does not yet exist so that destinations are resolved against their provided names.



[[boot-features-artemis]]
==== Artemis Support
Spring Boot can auto-configure a `ConnectionFactory` when it detects that https://activemq.apache.org/artemis/[Artemis] is available on the classpath.
If the broker is present, an embedded broker is automatically started and configured (unless the mode property has been explicitly set).
The supported modes are `embedded` (to make explicit that an embedded broker is required and that an error should occur if the broker is not available on the classpath) and `native` (to connect to a broker using the `netty` transport protocol).
When the latter is configured, Spring Boot configures a `ConnectionFactory` that connects to a broker running on the local machine with the default settings.

NOTE: If you use `spring-boot-starter-artemis`, the necessary dependencies to connect to an existing Artemis instance are provided, as well as the Spring infrastructure to integrate with JMS.
Adding `org.apache.activemq:artemis-jms-server` to your application lets you use embedded mode.

Artemis configuration is controlled by external configuration properties in `+spring.artemis.*+`.
For example, you might declare the following section in `application.properties`:

[source,properties,indent=0,configprops]
----
	spring.artemis.mode=native
	spring.artemis.host=192.168.1.210
	spring.artemis.port=9876
	spring.artemis.user=admin
	spring.artemis.password=secret
----

When embedding the broker, you can choose if you want to enable persistence and list the destinations that should be made available.
These can be specified as a comma-separated list to create them with the default options, or you can define bean(s) of type `org.apache.activemq.artemis.jms.server.config.JMSQueueConfiguration` or `org.apache.activemq.artemis.jms.server.config.TopicConfiguration`, for advanced queue and topic configurations, respectively.

By default, a `CachingConnectionFactory` wraps the native `ConnectionFactory` with sensible settings that you can control by external configuration properties in `+spring.jms.*+`:

[source,properties,indent=0,configprops]
----
	spring.jms.cache.session-cache-size=5
----

If you'd rather use native pooling, you can do so by adding a dependency to `org.messaginghub:pooled-jms` and configuring the `JmsPoolConnectionFactory` accordingly, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.artemis.pool.enabled=true
	spring.artemis.pool.max-connections=50
----

See {spring-boot-autoconfigure-module-code}/jms/artemis/ArtemisProperties.java[`ArtemisProperties`] for more supported options.

No JNDI lookup is involved, and destinations are resolved against their names, using either the `name` attribute in the Artemis configuration or the names provided through configuration.



[[boot-features-jms-jndi]]
==== Using a JNDI ConnectionFactory
If you are running your application in an application server, Spring Boot tries to locate a JMS `ConnectionFactory` by using JNDI.
By default, the `java:/JmsXA` and `java:/XAConnectionFactory` location are checked.
You can use the configprop:spring.jms.jndi-name[] property if you need to specify an alternative location, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.jms.jndi-name=java:/MyConnectionFactory
----



[[boot-features-using-jms-sending]]
==== Sending a Message
Spring's `JmsTemplate` is auto-configured, and you can autowire it directly into your own beans, as shown in the following example:

[source,java,indent=0]
----
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.jms.core.JmsTemplate;
	import org.springframework.stereotype.Component;

	@Component
	public class MyBean {

		private final JmsTemplate jmsTemplate;

		@Autowired
		public MyBean(JmsTemplate jmsTemplate) {
			this.jmsTemplate = jmsTemplate;
		}

		// ...

	}
----

NOTE: {spring-framework-api}/jms/core/JmsMessagingTemplate.html[`JmsMessagingTemplate`] can be injected in a similar manner.
If a `DestinationResolver` or a `MessageConverter` bean is defined, it is associated automatically to the auto-configured `JmsTemplate`.



[[boot-features-using-jms-receiving]]
==== Receiving a Message
When the JMS infrastructure is present, any bean can be annotated with `@JmsListener` to create a listener endpoint.
If no `JmsListenerContainerFactory` has been defined, a default one is configured automatically.
If a `DestinationResolver` or a `MessageConverter` beans is defined, it is associated automatically to the default factory.

By default, the default factory is transactional.
If you run in an infrastructure where a `JtaTransactionManager` is present, it is associated to the listener container by default.
If not, the `sessionTransacted` flag is enabled.
In that latter scenario, you can associate your local data store transaction to the processing of an incoming message by adding `@Transactional` on your listener method (or a delegate thereof).
This ensures that the incoming message is acknowledged, once the local transaction has completed.
This also includes sending response messages that have been performed on the same JMS session.

The following component creates a listener endpoint on the `someQueue` destination:

[source,java,indent=0]
----
	@Component
	public class MyBean {

		@JmsListener(destination = "someQueue")
		public void processMessage(String content) {
			// ...
		}

	}
----

TIP: See {spring-framework-api}/jms/annotation/EnableJms.html[the Javadoc of `@EnableJms`] for more details.

If you need to create more `JmsListenerContainerFactory` instances or if you want to override the default, Spring Boot provides a `DefaultJmsListenerContainerFactoryConfigurer` that you can use to initialize a `DefaultJmsListenerContainerFactory` with the same settings as the one that is auto-configured.

For instance, the following example exposes another factory that uses a specific `MessageConverter`:

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	static class JmsConfiguration {

		@Bean
		public DefaultJmsListenerContainerFactory myFactory(
				DefaultJmsListenerContainerFactoryConfigurer configurer) {
			DefaultJmsListenerContainerFactory factory =
					new DefaultJmsListenerContainerFactory();
			configurer.configure(factory, connectionFactory());
			factory.setMessageConverter(myMessageConverter());
			return factory;
		}

	}
----

Then you can use the factory in any `@JmsListener`-annotated method as follows:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Component
	public class MyBean {

		@JmsListener(destination = "someQueue", **containerFactory="myFactory"**)
		public void processMessage(String content) {
			// ...
		}

	}
----



[[boot-features-amqp]]
=== AMQP
The Advanced Message Queuing Protocol (AMQP) is a platform-neutral, wire-level protocol for message-oriented middleware.
The Spring AMQP project applies core Spring concepts to the development of AMQP-based messaging solutions.
Spring Boot offers several conveniences for working with AMQP through RabbitMQ, including the `spring-boot-starter-amqp` "`Starter`".



[[boot-features-rabbitmq]]
==== RabbitMQ support
https://www.rabbitmq.com/[RabbitMQ] is a lightweight, reliable, scalable, and portable message broker based on the AMQP protocol.
Spring uses `RabbitMQ` to communicate through the AMQP protocol.

RabbitMQ configuration is controlled by external configuration properties in `+spring.rabbitmq.*+`.
For example, you might declare the following section in `application.properties`:

[source,properties,indent=0,configprops]
----
	spring.rabbitmq.host=localhost
	spring.rabbitmq.port=5672
	spring.rabbitmq.username=admin
	spring.rabbitmq.password=secret
----

Alternatively, you could configure the same connection using the `addresses` attributes:

[source,properties,indent=0]
----
	spring.rabbitmq.addresses=amqp://admin:secret@localhost
----

If a `ConnectionNameStrategy` bean exists in the context, it will be automatically used to name connections created by the auto-configured `ConnectionFactory`.
See {spring-boot-autoconfigure-module-code}/amqp/RabbitProperties.java[`RabbitProperties`] for more of the supported options.

TIP: See https://spring.io/blog/2010/06/14/understanding-amqp-the-protocol-used-by-rabbitmq/[Understanding AMQP, the protocol used by RabbitMQ] for more details.



[[boot-features-using-amqp-sending]]
==== Sending a Message
Spring's `AmqpTemplate` and `AmqpAdmin` are auto-configured, and you can autowire them directly into your own beans, as shown in the following example:

[source,java,indent=0]
----
	import org.springframework.amqp.core.AmqpAdmin;
	import org.springframework.amqp.core.AmqpTemplate;
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.stereotype.Component;

	@Component
	public class MyBean {

		private final AmqpAdmin amqpAdmin;
		private final AmqpTemplate amqpTemplate;

		@Autowired
		public MyBean(AmqpAdmin amqpAdmin, AmqpTemplate amqpTemplate) {
			this.amqpAdmin = amqpAdmin;
			this.amqpTemplate = amqpTemplate;
		}

		// ...

	}
----

NOTE: {spring-amqp-api}/rabbit/core/RabbitMessagingTemplate.html[`RabbitMessagingTemplate`] can be injected in a similar manner.
If a `MessageConverter` bean is defined, it is associated automatically to the auto-configured `AmqpTemplate`.

If necessary, any `org.springframework.amqp.core.Queue` that is defined as a bean is automatically used to declare a corresponding queue on the RabbitMQ instance.

To retry operations, you can enable retries on the `AmqpTemplate` (for example, in the event that the broker connection is lost):

[source,properties,indent=0,configprops]
----
	spring.rabbitmq.template.retry.enabled=true
	spring.rabbitmq.template.retry.initial-interval=2s
----

Retries are disabled by default.
You can also customize the `RetryTemplate` programmatically by declaring a `RabbitRetryTemplateCustomizer` bean.



[[boot-features-using-amqp-receiving]]
==== Receiving a Message
When the Rabbit infrastructure is present, any bean can be annotated with `@RabbitListener` to create a listener endpoint.
If no `RabbitListenerContainerFactory` has been defined, a default `SimpleRabbitListenerContainerFactory` is automatically configured and you can switch to a direct container using the configprop:spring.rabbitmq.listener.type[] property.
If a `MessageConverter` or a `MessageRecoverer` bean is defined, it is automatically associated with the default factory.

The following sample component creates a listener endpoint on the `someQueue` queue:

[source,java,indent=0]
----
	@Component
	public class MyBean {

		@RabbitListener(queues = "someQueue")
		public void processMessage(String content) {
			// ...
		}

	}
----

TIP: See {spring-amqp-api}/rabbit/annotation/EnableRabbit.html[the Javadoc of `@EnableRabbit`] for more details.

If you need to create more `RabbitListenerContainerFactory` instances or if you want to override the default, Spring Boot provides a `SimpleRabbitListenerContainerFactoryConfigurer` and a `DirectRabbitListenerContainerFactoryConfigurer` that you can use to initialize a `SimpleRabbitListenerContainerFactory` and a `DirectRabbitListenerContainerFactory` with the same settings as the factories used by the auto-configuration.

TIP: It does not matter which container type you chose.
Those two beans are exposed by the auto-configuration.

For instance, the following configuration class exposes another factory that uses a specific `MessageConverter`:

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	static class RabbitConfiguration {

		@Bean
		public SimpleRabbitListenerContainerFactory myFactory(
				SimpleRabbitListenerContainerFactoryConfigurer configurer) {
			SimpleRabbitListenerContainerFactory factory =
					new SimpleRabbitListenerContainerFactory();
			configurer.configure(factory, connectionFactory);
			factory.setMessageConverter(myMessageConverter());
			return factory;
		}

	}
----

Then you can use the factory in any `@RabbitListener`-annotated method, as follows:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Component
	public class MyBean {

		@RabbitListener(queues = "someQueue", **containerFactory="myFactory"**)
		public void processMessage(String content) {
			// ...
		}

	}
----

You can enable retries to handle situations where your listener throws an exception.
By default, `RejectAndDontRequeueRecoverer` is used, but you can define a `MessageRecoverer` of your own.
When retries are exhausted, the message is rejected and either dropped or routed to a dead-letter exchange if the broker is configured to do so.
By default, retries are disabled.
You can also customize the `RetryTemplate` programmatically by declaring a `RabbitRetryTemplateCustomizer` bean.

IMPORTANT: By default, if retries are disabled and the listener throws an exception, the delivery is retried indefinitely.
You can modify this behavior in two ways: Set the `defaultRequeueRejected` property to `false` so that zero re-deliveries are attempted or throw an `AmqpRejectAndDontRequeueException` to signal the message should be rejected.
The latter is the mechanism used when retries are enabled and the maximum number of delivery attempts is reached.



[[boot-features-kafka]]
=== Apache Kafka Support
https://kafka.apache.org/[Apache Kafka] is supported by providing auto-configuration of the `spring-kafka` project.

Kafka configuration is controlled by external configuration properties in `spring.kafka.*`.
For example, you might declare the following section in `application.properties`:

[source,properties,indent=0,configprops]
----
	spring.kafka.bootstrap-servers=localhost:9092
	spring.kafka.consumer.group-id=myGroup
----

TIP: To create a topic on startup, add a bean of type `NewTopic`.
If the topic already exists, the bean is ignored.

See {spring-boot-autoconfigure-module-code}/kafka/KafkaProperties.java[`KafkaProperties`] for more supported options.



[[boot-features-kafka-sending-a-message]]
==== Sending a Message
Spring's `KafkaTemplate` is auto-configured, and you can autowire it directly in your own beans, as shown in the following example:

[source,java,indent=0]
----
@Component
public class MyBean {

	private final KafkaTemplate kafkaTemplate;

	@Autowired
	public MyBean(KafkaTemplate kafkaTemplate) {
		this.kafkaTemplate = kafkaTemplate;
	}

	// ...

}
----

NOTE: If the property configprop:spring.kafka.producer.transaction-id-prefix[] is defined, a `KafkaTransactionManager` is automatically configured.
Also, if a `RecordMessageConverter` bean is defined, it is automatically associated to the auto-configured `KafkaTemplate`.



[[boot-features-kafka-receiving-a-message]]
==== Receiving a Message
When the Apache Kafka infrastructure is present, any bean can be annotated with `@KafkaListener` to create a listener endpoint.
If no `KafkaListenerContainerFactory` has been defined, a default one is automatically configured with keys defined in `spring.kafka.listener.*`.

The following component creates a listener endpoint on the `someTopic` topic:

[source,java,indent=0]
----
	@Component
	public class MyBean {

		@KafkaListener(topics = "someTopic")
		public void processMessage(String content) {
			// ...
		}

	}
----

If a `KafkaTransactionManager` bean is defined, it is automatically associated to the container factory.
Similarly, if a `ErrorHandler`, `AfterRollbackProcessor` or `ConsumerAwareRebalanceListener` bean is defined, it is automatically associated to the default factory.

Depending on the listener type, a `RecordMessageConverter` or `BatchMessageConverter` bean is associated to the default factory.
If only a `RecordMessageConverter` bean is present for a batch listener, it is wrapped in a `BatchMessageConverter`.

TIP: A custom `ChainedKafkaTransactionManager` must be marked `@Primary` as it usually references the auto-configured `KafkaTransactionManager` bean.



[[boot-features-kafka-streams]]
==== Kafka Streams
Spring for Apache Kafka provides a factory bean to create a `StreamsBuilder` object and manage the lifecycle of its streams.
Spring Boot auto-configures the required `KafkaStreamsConfiguration` bean as long as `kafka-streams` is on the classpath and Kafka Streams is enabled via the `@EnableKafkaStreams` annotation.

Enabling Kafka Streams means that the application id and bootstrap servers must be set.
The former can be configured using `spring.kafka.streams.application-id`, defaulting to `spring.application.name` if not set.
The latter can be set globally or specifically overridden just for streams.

Several additional properties are available using dedicated properties; other arbitrary Kafka properties can be set using the `spring.kafka.streams.properties` namespace.
See also <<boot-features-kafka-extra-props>> for more information.

To use the factory bean, simply wire `StreamsBuilder` into your `@Bean` as shown in the following example:

[source,java,indent=0]
----
include::{code-examples}/kafka/KafkaStreamsBeanExample.java[tag=configuration]
----

By default, the streams managed by the `StreamBuilder` object it creates are started automatically.
You can customize this behaviour using the configprop:spring.kafka.streams.auto-startup[] property.



[[boot-features-kafka-extra-props]]
==== Additional Kafka Properties
The properties supported by auto configuration are shown in <<appendix-application-properties.adoc#common-application-properties>>.
Note that, for the most part, these properties (hyphenated or camelCase) map directly to the Apache Kafka dotted properties.
Refer to the Apache Kafka documentation for details.

The first few of these properties apply to all components (producers, consumers, admins, and streams) but can be specified at the component level if you wish to use different values.
Apache Kafka designates properties with an importance of HIGH, MEDIUM, or LOW.
Spring Boot auto-configuration supports all HIGH importance properties, some selected MEDIUM and LOW properties, and any properties that do not have a default value.

Only a subset of the properties supported by Kafka are available directly through the `KafkaProperties` class.
If you wish to configure the producer or consumer with additional properties that are not directly supported, use the following properties:

[source,properties,indent=0,configprops]
----
	spring.kafka.properties.prop.one=first
	spring.kafka.admin.properties.prop.two=second
	spring.kafka.consumer.properties.prop.three=third
	spring.kafka.producer.properties.prop.four=fourth
	spring.kafka.streams.properties.prop.five=fifth
----

This sets the common `prop.one` Kafka property to `first` (applies to producers, consumers and admins), the `prop.two` admin property to `second`, the `prop.three` consumer property to `third`, the `prop.four` producer property to `fourth` and the `prop.five` streams property to `fifth`.

You can also configure the Spring Kafka `JsonDeserializer` as follows:

[source,properties,indent=0,configprops]
----
	spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer
	spring.kafka.consumer.properties.spring.json.value.default.type=com.example.Invoice
	spring.kafka.consumer.properties.spring.json.trusted.packages=com.example,org.acme
----

Similarly, you can disable the `JsonSerializer` default behavior of sending type information in headers:

[source,properties,indent=0,configprops]
----
	spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer
	spring.kafka.producer.properties.spring.json.add.type.headers=false
----

IMPORTANT: Properties set in this way override any configuration item that Spring Boot explicitly supports.



[[boot-features-embedded-kafka]]
==== Testing with Embedded Kafka
Spring for Apache Kafka provides a convenient way to test projects with an embedded Apache Kafka broker.
To use this feature, annotate a test class with `@EmbeddedKafka` from the `spring-kafka-test` module.
For more information, please see the Spring for Apache Kafka https://docs.spring.io/spring-kafka/docs/current/reference/html/#embedded-kafka-annotation[reference manual].

To make Spring Boot auto-configuration work with the aforementioned embedded Apache Kafka broker, you need to remap a system property for embedded broker addresses (populated by the `EmbeddedKafkaBroker`) into the Spring Boot configuration property for Apache Kafka.
There are several ways to do that:

* Provide a system property to map embedded broker addresses into configprop:spring.kafka.bootstrap-servers[] in the test class:

[source,java,indent=0]
----
static {
    System.setProperty(EmbeddedKafkaBroker.BROKER_LIST_PROPERTY, "spring.kafka.bootstrap-servers");
}
----

* Configure a property name on the `@EmbeddedKafka` annotation:

[source,java,indent=0]
----
@EmbeddedKafka(topics = "someTopic",
        bootstrapServersProperty = "spring.kafka.bootstrap-servers")
----

* Use a placeholder in configuration properties:

[source,properties,indent=0,configprops]
----
spring.kafka.bootstrap-servers=${spring.embedded.kafka.brokers}
----



[[boot-features-resttemplate]]
== Calling REST Services with `RestTemplate`
If you need to call remote REST services from your application, you can use the Spring Framework's {spring-framework-api}/web/client/RestTemplate.html[`RestTemplate`] class.
Since `RestTemplate` instances often need to be customized before being used, Spring Boot does not provide any single auto-configured `RestTemplate` bean.
It does, however, auto-configure a `RestTemplateBuilder`, which can be used to create `RestTemplate` instances when needed.
The auto-configured `RestTemplateBuilder` ensures that sensible `HttpMessageConverters` are applied to `RestTemplate` instances.

The following code shows a typical example:

[source,java,indent=0]
----
	@Service
	public class MyService {

		private final RestTemplate restTemplate;

		public MyService(RestTemplateBuilder restTemplateBuilder) {
			this.restTemplate = restTemplateBuilder.build();
		}

		public Details someRestCall(String name) {
			return this.restTemplate.getForObject("/{name}/details", Details.class, name);
		}

	}
----

TIP: `RestTemplateBuilder` includes a number of useful methods that can be used to quickly configure a `RestTemplate`.
For example, to add BASIC auth support, you can use `builder.basicAuthentication("user", "password").build()`.



[[boot-features-resttemplate-customization]]
=== RestTemplate Customization
There are three main approaches to `RestTemplate` customization, depending on how broadly you want the customizations to apply.

To make the scope of any customizations as narrow as possible, inject the auto-configured `RestTemplateBuilder` and then call its methods as required.
Each method call returns a new `RestTemplateBuilder` instance, so the customizations only affect this use of the builder.

To make an application-wide, additive customization, use a `RestTemplateCustomizer` bean.
All such beans are automatically registered with the auto-configured `RestTemplateBuilder` and are applied to any templates that are built with it.

The following example shows a customizer that configures the use of a proxy for all hosts except `192.168.0.5`:

[source,java,indent=0]
----
include::{code-examples}/web/client/RestTemplateProxyCustomizationExample.java[tag=customizer]
----

Finally, the most extreme (and rarely used) option is to create your own `RestTemplateBuilder` bean.
Doing so switches off the auto-configuration of a `RestTemplateBuilder` and prevents any `RestTemplateCustomizer` beans from being used.



[[boot-features-webclient]]
== Calling REST Services with `WebClient`
If you have Spring WebFlux on your classpath, you can also choose to use `WebClient` to call remote REST services.
Compared to `RestTemplate`, this client has a more functional feel and is fully reactive.
You can learn more about the `WebClient` in the dedicated {spring-framework-docs}web-reactive.html#webflux-client[section in the Spring Framework docs].

Spring Boot creates and pre-configures a `WebClient.Builder` for you; it is strongly advised to inject it in your components and use it to create `WebClient` instances.
Spring Boot is configuring that builder to share HTTP resources, reflect codecs setup in the same fashion as the server ones (see <<boot-features-webflux-httpcodecs,WebFlux HTTP codecs auto-configuration>>), and more.

The following code shows a typical example:

[source,java,indent=0]
----
	@Service
	public class MyService {

		private final WebClient webClient;

		public MyService(WebClient.Builder webClientBuilder) {
			this.webClient = webClientBuilder.baseUrl("https://example.org").build();
		}

		public Mono<Details> someRestCall(String name) {
			return this.webClient.get().uri("/{name}/details", name)
							.retrieve().bodyToMono(Details.class);
		}

	}
----



[[boot-features-webclient-runtime]]
=== WebClient Runtime
Spring Boot will auto-detect which `ClientHttpConnector` to use to drive `WebClient`, depending on the libraries available on the application classpath.
For now, Reactor Netty and Jetty RS client are supported.

The `spring-boot-starter-webflux` starter depends on `io.projectreactor.netty:reactor-netty` by default, which brings both server and client implementations.
If you choose to use Jetty as a reactive server instead, you should add a dependency on the Jetty Reactive HTTP client library, `org.eclipse.jetty:jetty-reactive-httpclient`.
Using the same technology for server and client has it advantages, as it will automatically share HTTP resources between client and server.

Developers can override the resource configuration for Jetty and Reactor Netty by providing a custom `ReactorResourceFactory` or `JettyResourceFactory` bean - this will be applied to both clients and servers.

If you wish to override that choice for the client, you can define your own `ClientHttpConnector` bean and have full control over the client configuration.

You can learn more about the {spring-framework-docs}web-reactive.html#webflux-client-builder[`WebClient` configuration options in the Spring Framework reference documentation].



[[boot-features-webclient-customization]]
=== WebClient Customization
There are three main approaches to `WebClient` customization, depending on how broadly you want the customizations to apply.

To make the scope of any customizations as narrow as possible, inject the auto-configured `WebClient.Builder` and then call its methods as required.
`WebClient.Builder` instances are stateful: Any change on the builder is reflected in all clients subsequently created with it.
If you want to create several clients with the same builder, you can also consider cloning the builder with `WebClient.Builder other = builder.clone();`.

To make an application-wide, additive customization to all `WebClient.Builder` instances, you can declare `WebClientCustomizer` beans and change the `WebClient.Builder` locally at the point of injection.

Finally, you can fall back to the original API and use `WebClient.create()`.
In that case, no auto-configuration or `WebClientCustomizer` is applied.



[[boot-features-validation]]
== Validation
The method validation feature supported by Bean Validation 1.1 is automatically enabled as long as a JSR-303 implementation (such as Hibernate validator) is on the classpath.
This lets bean methods be annotated with `javax.validation` constraints on their parameters and/or on their return value.
Target classes with such annotated methods need to be annotated with the `@Validated` annotation at the type level for their methods to be searched for inline constraint annotations.

For instance, the following service triggers the validation of the first argument, making sure its size is between 8 and 10:

[source,java,indent=0]
----
	@Service
	@Validated
	public class MyBean {

		public Archive findByCodeAndAuthor(@Size(min = 8, max = 10) String code,
				Author author) {
			...
		}

	}
----



[[boot-features-email]]
== Sending Email
The Spring Framework provides an easy abstraction for sending email by using the `JavaMailSender` interface, and Spring Boot provides auto-configuration for it as well as a starter module.

TIP: See the {spring-framework-docs}integration.html#mail[reference documentation] for a detailed explanation of how you can use `JavaMailSender`.

If `spring.mail.host` and the relevant libraries (as defined by `spring-boot-starter-mail`) are available, a default `JavaMailSender` is created if none exists.
The sender can be further customized by configuration items from the `spring.mail` namespace.
See {spring-boot-autoconfigure-module-code}/mail/MailProperties.java[`MailProperties`] for more details.

In particular, certain default timeout values are infinite, and you may want to change that to avoid having a thread blocked by an unresponsive mail server, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.mail.properties.mail.smtp.connectiontimeout=5000
	spring.mail.properties.mail.smtp.timeout=3000
	spring.mail.properties.mail.smtp.writetimeout=5000
----

It is also possible to configure a `JavaMailSender` with an existing `Session` from JNDI:

[source,properties,indent=0,configprops]
----
	spring.mail.jndi-name=mail/Session
----

When a `jndi-name` is set, it takes precedence over all other Session-related settings.



[[boot-features-jta]]
== Distributed Transactions with JTA
Spring Boot supports distributed JTA transactions across multiple XA resources by using either an https://www.atomikos.com/[Atomikos] or https://github.com/bitronix/btm[Bitronix] embedded transaction manager.
JTA transactions are also supported when deploying to a suitable Java EE Application Server.

When a JTA environment is detected, Spring's `JtaTransactionManager` is used to manage transactions.
Auto-configured JMS, DataSource, and JPA beans are upgraded to support XA transactions.
You can use standard Spring idioms, such as `@Transactional`, to participate in a distributed transaction.
If you are within a JTA environment and still want to use local transactions, you can set the configprop:spring.jta.enabled[] property to `false` to disable the JTA auto-configuration.



[[boot-features-jta-atomikos]]
=== Using an Atomikos Transaction Manager
https://www.atomikos.com/[Atomikos] is a popular open source transaction manager which can be embedded into your Spring Boot application.
You can use the `spring-boot-starter-jta-atomikos` starter to pull in the appropriate Atomikos libraries.
Spring Boot auto-configures Atomikos and ensures that appropriate `depends-on` settings are applied to your Spring beans for correct startup and shutdown ordering.

By default, Atomikos transaction logs are written to a `transaction-logs` directory in your application's home directory (the directory in which your application jar file resides).
You can customize the location of this directory by setting a configprop:spring.jta.log-dir[] property in your `application.properties` file.
Properties starting with `spring.jta.atomikos.properties` can also be used to customize the Atomikos `UserTransactionServiceImp`.
See the {spring-boot-module-api}/jta/atomikos/AtomikosProperties.html[`AtomikosProperties` Javadoc] for complete details.

NOTE: To ensure that multiple transaction managers can safely coordinate the same resource managers, each Atomikos instance must be configured with a unique ID.
By default, this ID is the IP address of the machine on which Atomikos is running.
To ensure uniqueness in production, you should configure the configprop:spring.jta.transaction-manager-id[] property with a different value for each instance of your application.



[[boot-features-jta-bitronix]]
=== Using a Bitronix Transaction Manager
https://github.com/bitronix/btm[Bitronix] is a popular open-source JTA transaction manager implementation.
You can use the `spring-boot-starter-jta-bitronix` starter to add the appropriate Bitronix dependencies to your project.
As with Atomikos, Spring Boot automatically configures Bitronix and post-processes your beans to ensure that startup and shutdown ordering is correct.

By default, Bitronix transaction log files (`part1.btm` and `part2.btm`) are written to a `transaction-logs` directory in your application home directory.
You can customize the location of this directory by setting the configprop:spring.jta.log-dir[] property.
Properties starting with `spring.jta.bitronix.properties` are also bound to the `bitronix.tm.Configuration` bean, allowing for complete customization.
See the https://github.com/bitronix/btm/wiki/Transaction-manager-configuration[Bitronix documentation] for details.

NOTE: To ensure that multiple transaction managers can safely coordinate the same resource managers, each Bitronix instance must be configured with a unique ID.
By default, this ID is the IP address of the machine on which Bitronix is running.
To ensure uniqueness in production, you should configure the configprop:spring.jta.transaction-manager-id[] property with a different value for each instance of your application.



[[boot-features-jta-javaee]]
=== Using a Java EE Managed Transaction Manager
If you package your Spring Boot application as a `war` or `ear` file and deploy it to a Java EE application server, you can use your application server's built-in transaction manager.
Spring Boot tries to auto-configure a transaction manager by looking at common JNDI locations (`java:comp/UserTransaction`, `java:comp/TransactionManager`, and so on).
If you use a transaction service provided by your application server, you generally also want to ensure that all resources are managed by the server and exposed over JNDI.
Spring Boot tries to auto-configure JMS by looking for a `ConnectionFactory` at the JNDI path (`java:/JmsXA` or `java:/XAConnectionFactory`), and you can use the <<boot-features-connecting-to-a-jndi-datasource, configprop:spring.datasource.jndi-name[] property>> to configure your `DataSource`.



[[boot-features-jta-mixed-jms]]
=== Mixing XA and Non-XA JMS Connections
When using JTA, the primary JMS `ConnectionFactory` bean is XA-aware and participates in distributed transactions.
In some situations, you might want to process certain JMS messages by using a non-XA `ConnectionFactory`.
For example, your JMS processing logic might take longer than the XA timeout.

If you want to use a non-XA `ConnectionFactory`, you can inject the `nonXaJmsConnectionFactory` bean rather than the `@Primary` `jmsConnectionFactory` bean.
For consistency, the `jmsConnectionFactory` bean is also provided by using the bean alias `xaJmsConnectionFactory`.

The following example shows how to inject `ConnectionFactory` instances:

[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	// Inject the primary (XA aware) ConnectionFactory
	@Autowired
	private ConnectionFactory defaultConnectionFactory;

	// Inject the XA aware ConnectionFactory (uses the alias and injects the same as above)
	@Autowired
	@Qualifier("xaJmsConnectionFactory")
	private ConnectionFactory xaConnectionFactory;

	// Inject the non-XA aware ConnectionFactory
	@Autowired
	@Qualifier("nonXaJmsConnectionFactory")
	private ConnectionFactory nonXaConnectionFactory;
----



[[boot-features-jta-supporting-alternative-embedded]]
=== Supporting an Alternative Embedded Transaction Manager
The {spring-boot-module-code}/jms/XAConnectionFactoryWrapper.java[`XAConnectionFactoryWrapper`] and {spring-boot-module-code}/jdbc/XADataSourceWrapper.java[`XADataSourceWrapper`] interfaces can be used to support alternative embedded transaction managers.
The interfaces are responsible for wrapping `XAConnectionFactory` and `XADataSource` beans and exposing them as regular `ConnectionFactory` and `DataSource` beans, which transparently enroll in the distributed transaction.
DataSource and JMS auto-configuration use JTA variants, provided you have a `JtaTransactionManager` bean and appropriate XA wrapper beans registered within your `ApplicationContext`.

The {spring-boot-module-code}/jta/bitronix/BitronixXAConnectionFactoryWrapper.java[BitronixXAConnectionFactoryWrapper] and {spring-boot-module-code}/jta/bitronix/BitronixXADataSourceWrapper.java[BitronixXADataSourceWrapper] provide good examples of how to write XA wrappers.



[[boot-features-hazelcast]]
== Hazelcast
If https://hazelcast.com/[Hazelcast] is on the classpath and a suitable configuration is found, Spring Boot auto-configures a `HazelcastInstance` that you can inject in your application.

If you define a `com.hazelcast.config.Config` bean, Spring Boot uses that.
If your configuration defines an instance name, Spring Boot tries to locate an existing instance rather than creating a new one.

If you define a `com.hazelcast.config.Config` bean, Spring Boot uses that.
If your configuration defines an instance name, Spring Boot tries to locate an existing instance rather than creating a new one.

You could also specify the Hazelcast configuration file to use through configuration, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.hazelcast.config=classpath:config/my-hazelcast.xml
----

Otherwise, Spring Boot tries to find the Hazelcast configuration from the default locations: `hazelcast.xml` in the working directory or at the root of the classpath, or a `.yaml` counterpart in the same locations.
We also check if the `hazelcast.config` system property is set.
See the https://docs.hazelcast.org/docs/latest/manual/html-single/[Hazelcast documentation] for more details.

If `hazelcast-client` is present on the classpath, Spring Boot first attempts to create a client by checking the following configuration options:

* The presence of a `com.hazelcast.client.config.ClientConfig` bean.
* A configuration file defined by the configprop:spring.hazelcast.config[] property.
* The presence of the `hazelcast.client.config` system property.
* A `hazelcast-client.xml` in the working directory or at the root of the classpath.
* A `hazelcast-client.yaml` in the working directory or at the root of the classpath.

NOTE: Spring Boot also has <<boot-features-caching-provider-hazelcast,explicit caching support for Hazelcast>>.
If caching is enabled, the `HazelcastInstance` is automatically wrapped in a `CacheManager` implementation.



[[boot-features-quartz]]
== Quartz Scheduler
Spring Boot offers several conveniences for working with the https://www.quartz-scheduler.org/[Quartz scheduler], including the `spring-boot-starter-quartz` "`Starter`".
If Quartz is available, a `Scheduler` is auto-configured (through the `SchedulerFactoryBean` abstraction).

Beans of the following types are automatically picked up and associated with the `Scheduler`:

* `JobDetail`: defines a particular Job.
  `JobDetail` instances can be built with the `JobBuilder` API.
* `Calendar`.
* `Trigger`: defines when a particular job is triggered.

By default, an in-memory `JobStore` is used.
However, it is possible to configure a JDBC-based store if a `DataSource` bean is available in your application and if the configprop:spring.quartz.job-store-type[] property is configured accordingly, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.quartz.job-store-type=jdbc
----

When the JDBC store is used, the schema can be initialized on startup, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.quartz.jdbc.initialize-schema=always
----

WARNING: By default, the database is detected and initialized by using the standard scripts provided with the Quartz library.
These scripts drop existing tables, deleting all triggers on every restart.
It is also possible to provide a custom script by setting the configprop:spring.quartz.jdbc.schema[] property.

To have Quartz use a `DataSource` other than the application's main `DataSource`, declare a `DataSource` bean, annotating its `@Bean` method with `@QuartzDataSource`.
Doing so ensures that the Quartz-specific `DataSource` is used by both the `SchedulerFactoryBean` and for schema initialization.

By default, jobs created by configuration will not overwrite already registered jobs that have been read from a persistent job store.
To enable overwriting existing job definitions set the configprop:spring.quartz.overwrite-existing-jobs[] property.

Quartz Scheduler configuration can be customized using `spring.quartz` properties and `SchedulerFactoryBeanCustomizer` beans, which allow programmatic `SchedulerFactoryBean` customization.
Advanced Quartz configuration properties can be customized using `spring.quartz.properties.*`.

NOTE: In particular, an `Executor` bean is not associated with the scheduler as Quartz offers a way to configure the scheduler via `spring.quartz.properties`.
If you need to customize the task executor, consider implementing `SchedulerFactoryBeanCustomizer`.

Jobs can define setters to inject data map properties.
Regular beans can also be injected in a similar manner, as shown in the following example:

[source,java,indent=0]
----
	public class SampleJob extends QuartzJobBean {

		private MyService myService;

		private String name;

		// Inject "MyService" bean
		public void setMyService(MyService myService) { ... }

		// Inject the "name" job data property
		public void setName(String name) { ... }

		@Override
		protected void executeInternal(JobExecutionContext context)
				throws JobExecutionException {
			...
		}

	}
----



[[boot-features-task-execution-scheduling]]
== Task Execution and Scheduling
In the absence of an `Executor` bean in the context, Spring Boot auto-configures a `ThreadPoolTaskExecutor` with sensible defaults that can be automatically associated to asynchronous task execution (`@EnableAsync`) and Spring MVC asynchronous request processing.

[TIP]
====
If you have defined a custom `Executor` in the context, regular task execution (i.e. `@EnableAsync`) will use it transparently but the Spring MVC support will not be configured as it requires an `AsyncTaskExecutor` implementation (named `applicationTaskExecutor`).
Depending on your target arrangement, you could change your `Executor` into a `ThreadPoolTaskExecutor` or define both a `ThreadPoolTaskExecutor` and an `AsyncConfigurer` wrapping your custom `Executor`.

The auto-configured `TaskExecutorBuilder` allows you to easily create instances that reproduce what the auto-configuration does by default.
====

The thread pool uses 8 core threads that can grow and shrink according to the load.
Those default settings can be fine-tuned using the `spring.task.execution` namespace as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.task.execution.pool.max-size=16
	spring.task.execution.pool.queue-capacity=100
	spring.task.execution.pool.keep-alive=10s
----

This changes the thread pool to use a bounded queue so that when the queue is full (100 tasks), the thread pool increases to maximum 16 threads.
Shrinking of the pool is more aggressive as threads are reclaimed when they are idle for 10 seconds (rather than 60 seconds by default).

A `ThreadPoolTaskScheduler` can also be auto-configured if need to be associated to scheduled task execution (`@EnableScheduling`).
The thread pool uses one thread by default and those settings can be fine-tuned using the `spring.task.scheduling` namespace.

Both a `TaskExecutorBuilder` bean and a `TaskSchedulerBuilder` bean are made available in the context if a custom executor or scheduler needs to be created.



[[boot-features-integration]]
== Spring Integration
Spring Boot offers several conveniences for working with {spring-integration}[Spring Integration], including the `spring-boot-starter-integration` "`Starter`".
Spring Integration provides abstractions over messaging and also other transports such as HTTP, TCP, and others.
If Spring Integration is available on your classpath, it is initialized through the `@EnableIntegration` annotation.

Spring Boot also configures some features that are triggered by the presence of additional Spring Integration modules.
If `spring-integration-jmx` is also on the classpath, message processing statistics are published over JMX.
If `spring-integration-jdbc` is available, the default database schema can be created on startup, as shown in the following line:

[source,properties,indent=0,configprops]
----
	spring.integration.jdbc.initialize-schema=always
----

See the {spring-boot-autoconfigure-module-code}/integration/IntegrationAutoConfiguration.java[`IntegrationAutoConfiguration`] and {spring-boot-autoconfigure-module-code}/integration/IntegrationProperties.java[`IntegrationProperties`] classes for more details.

By default, if a Micrometer `meterRegistry` bean is present, Spring Integration metrics will be managed by Micrometer.
If you wish to use legacy Spring Integration metrics, add a `DefaultMetricsFactory` bean to the application context.



[[boot-features-session]]
== Spring Session
Spring Boot provides {spring-session}[Spring Session] auto-configuration for a wide range of data stores.
When building a Servlet web application, the following stores can be auto-configured:

* JDBC
* Redis
* Hazelcast
* MongoDB

When building a reactive web application, the following stores can be auto-configured:

* Redis
* MongoDB

If a single Spring Session module is present on the classpath, Spring Boot uses that store implementation automatically.
If you have more than one implementation, you must choose the {spring-boot-autoconfigure-module-code}/session/StoreType.java[`StoreType`] that you wish to use to store the sessions.
For instance, to use JDBC as the back-end store, you can configure your application as follows:

[source,properties,indent=0,configprops]
----
    spring.session.store-type=jdbc
----

TIP: You can disable Spring Session by setting the `store-type` to `none`.

Each store has specific additional settings.
For instance, it is possible to customize the name of the table for the JDBC store, as shown in the following example:

[source,properties,indent=0,configprops]
----
    spring.session.jdbc.table-name=SESSIONS
----

For setting the timeout of the session you can use the configprop:spring.session.timeout[] property.
If that property is not set, the auto-configuration falls back to the value of configprop:server.servlet.session.timeout[].



[[boot-features-jmx]]
== Monitoring and Management over JMX
Java Management Extensions (JMX) provide a standard mechanism to monitor and manage applications.
Spring Boot exposes the most suitable `MBeanServer` as a bean with an ID of `mbeanServer`.
Any of your beans that are annotated with Spring JMX annotations (`@ManagedResource`, `@ManagedAttribute`, or `@ManagedOperation`) are exposed to it.

If your platform provides a standard `MBeanServer`, Spring Boot will use that and default to the VM `MBeanServer` if necessary.
If all that fails, a new `MBeanServer` will be created.

See the {spring-boot-autoconfigure-module-code}/jmx/JmxAutoConfiguration.java[`JmxAutoConfiguration`] class for more details.



[[boot-features-testing]]
== Testing
Spring Boot provides a number of utilities and annotations to help when testing your application.
Test support is provided by two modules: `spring-boot-test` contains core items, and `spring-boot-test-autoconfigure` supports auto-configuration for tests.

Most developers use the `spring-boot-starter-test` "`Starter`", which imports both Spring Boot test modules as well as JUnit Jupiter, AssertJ, Hamcrest, and a number of other useful libraries.

[TIP]
====
The starter also brings the vintage engine so that you can run both JUnit 4 and JUnit 5 tests.
If you have migrated your tests to JUnit 5, you should exclude JUnit 4 support, as shown in the following example:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-test</artifactId>
		<scope>test</scope>
		<exclusions>
			<exclusion>
				<groupId>org.junit.vintage</groupId>
				<artifactId>junit-vintage-engine</artifactId>
			</exclusion>
		</exclusions>
	</dependency>
----
====



[[boot-features-test-scope-dependencies]]
=== Test Scope Dependencies
The `spring-boot-starter-test` "`Starter`" (in the `test` `scope`) contains the following provided libraries:

* https://junit.org/junit5[JUnit 5] (including the vintage engine for backward compatibility with JUnit 4): The de-facto standard for unit testing Java applications.
* {spring-framework-docs}testing.html#integration-testing[Spring Test] & Spring Boot Test: Utilities and integration test support for Spring Boot applications.
* https://joel-costigliola.github.io/assertj/[AssertJ]: A fluent assertion library.
* https://github.com/hamcrest/JavaHamcrest[Hamcrest]: A library of matcher objects (also known as constraints or predicates).
* https://mockito.github.io[Mockito]: A Java mocking framework.
* https://github.com/skyscreamer/JSONassert[JSONassert]: An assertion library for JSON.
* https://github.com/jayway/JsonPath[JsonPath]: XPath for JSON.

We generally find these common libraries to be useful when writing tests.
If these libraries do not suit your needs, you can add additional test dependencies of your own.



[[boot-features-testing-spring-applications]]
=== Testing Spring Applications
One of the major advantages of dependency injection is that it should make your code easier to unit test.
You can instantiate objects by using the `new` operator without even involving Spring.
You can also use _mock objects_ instead of real dependencies.

Often, you need to move beyond unit testing and start integration testing (with a Spring `ApplicationContext`).
It is useful to be able to perform integration testing without requiring deployment of your application or needing to connect to other infrastructure.

The Spring Framework includes a dedicated test module for such integration testing.
You can declare a dependency directly to `org.springframework:spring-test` or use the `spring-boot-starter-test` "`Starter`" to pull it in transitively.

If you have not used the `spring-test` module before, you should start by reading the {spring-framework-docs}testing.html#testing[relevant section] of the Spring Framework reference documentation.



[[boot-features-testing-spring-boot-applications]]
=== Testing Spring Boot Applications
A Spring Boot application is a Spring `ApplicationContext`, so nothing very special has to be done to test it beyond what you would normally do with a vanilla Spring context.

NOTE: External properties, logging, and other features of Spring Boot are installed in the context by default only if you use `SpringApplication` to create it.

Spring Boot provides a `@SpringBootTest` annotation, which can be used as an alternative to the standard `spring-test` `@ContextConfiguration` annotation when you need Spring Boot features.
The annotation works by <<boot-features-testing-spring-boot-applications-detecting-config,creating the `ApplicationContext` used in your tests through `SpringApplication`>>.
In addition to `@SpringBootTest` a number of other annotations are also provided for <<boot-features-testing-spring-boot-applications-testing-autoconfigured-tests,testing more specific slices>> of an application.

TIP: If you are using JUnit 4, don't forget to also add `@RunWith(SpringRunner.class)` to your test, otherwise the annotations will be ignored.
If you are using JUnit 5, there's no need to add the equivalent `@ExtendWith(SpringExtension.class)` as `@SpringBootTest` and the other `@…Test` annotations are already annotated with it.

By default, `@SpringBootTest` will not start a server.
You can use the `webEnvironment` attribute of `@SpringBootTest` to further refine how your tests run:

* `MOCK`(Default) : Loads a web `ApplicationContext` and provides a mock web environment.
  Embedded servers are not started when using this annotation.
	If a web environment is not available on your classpath, this mode transparently falls back to creating a regular non-web `ApplicationContext`.
	It can be used in conjunction with <<boot-features-testing-spring-boot-applications-testing-with-mock-environment, `@AutoConfigureMockMvc` or `@AutoConfigureWebTestClient`>> for mock-based testing of your web application.
* `RANDOM_PORT`: Loads a `WebServerApplicationContext` and provides a real web environment.
  Embedded servers are started and listen on a random port.
* `DEFINED_PORT`: Loads a `WebServerApplicationContext` and provides a real web environment.
  Embedded servers are started and listen on a defined port (from your `application.properties`) or on the default port of `8080`.
* `NONE`: Loads an `ApplicationContext` by using `SpringApplication` but does not provide _any_ web environment (mock or otherwise).

NOTE: If your test is `@Transactional`, it rolls back the transaction at the end of each test method by default.
However, as using this arrangement with either `RANDOM_PORT` or `DEFINED_PORT` implicitly provides a real servlet environment, the HTTP client and server run in separate threads and, thus, in separate transactions.
Any transaction initiated on the server does not roll back in this case.

NOTE: `@SpringBootTest` with `webEnvironment = WebEnvironment.RANDOM_PORT` will also start the management server on a separate random port if your application uses a different port for the management server.



[[boot-features-testing-spring-boot-applications-detecting-web-app-type]]
==== Detecting Web Application Type
If Spring MVC is available, a regular MVC-based application context is configured.
If you have only Spring WebFlux, we'll detect that and configure a WebFlux-based application context instead.

If both are present, Spring MVC takes precedence.
If you want to test a reactive web application in this scenario, you must set the configprop:spring.main.web-application-type[] property:

[source,java,indent=0]
----
	@SpringBootTest(properties = "spring.main.web-application-type=reactive")
	class MyWebFluxTests { ... }
----



[[boot-features-testing-spring-boot-applications-detecting-config]]
==== Detecting Test Configuration
If you are familiar with the Spring Test Framework, you may be used to using `@ContextConfiguration(classes=...)` in order to specify which Spring `@Configuration` to load.
Alternatively, you might have often used nested `@Configuration` classes within your test.

When testing Spring Boot applications, this is often not required.
Spring Boot's `@*Test` annotations search for your primary configuration automatically whenever you do not explicitly define one.

The search algorithm works up from the package that contains the test until it finds a class annotated with `@SpringBootApplication` or `@SpringBootConfiguration`.
As long as you <<using-spring-boot.adoc#using-boot-structuring-your-code, structured your code>> in a sensible way, your main configuration is usually found.

[NOTE]
====
If you use a <<boot-features-testing-spring-boot-applications-testing-autoconfigured-tests, test annotation to test a more specific slice of your application>>, you should avoid adding configuration settings that are specific to a particular area on the <<boot-features-testing-spring-boot-applications-testing-user-configuration, main method's application class>>.

The underlying component scan configuration of `@SpringBootApplication` defines exclude filters that are used to make sure slicing works as expected.
If you are using an explicit `@ComponentScan` directive on your `@SpringBootApplication`-annotated class, be aware that those filters will be disabled.
If you are using slicing, you should define them again.
====

If you want to customize the primary configuration, you can use a nested `@TestConfiguration` class.
Unlike a nested `@Configuration` class, which would be used instead of your application's primary configuration, a nested `@TestConfiguration` class is used in addition to your application's primary configuration.

NOTE: Spring's test framework caches application contexts between tests.
Therefore, as long as your tests share the same configuration (no matter how it is discovered), the potentially time-consuming process of loading the context happens only once.



[[boot-features-testing-spring-boot-applications-excluding-config]]
==== Excluding Test Configuration
If your application uses component scanning (for example, if you use `@SpringBootApplication` or `@ComponentScan`), you may find top-level configuration classes that you created only for specific tests accidentally get picked up everywhere.

As we <<boot-features-testing-spring-boot-applications-detecting-config,have seen earlier>>, `@TestConfiguration` can be used on an inner class of a test to customize the primary configuration.
When placed on a top-level class, `@TestConfiguration` indicates that classes in `src/test/java` should not be picked up by scanning.
You can then import that class explicitly where it is required, as shown in the following example:

[source,java,indent=0]
----
	@SpringBootTest
	@Import(MyTestsConfiguration.class)
	class MyTests {

		@Test
		void exampleTest() {
			...
		}

	}
----

NOTE: If you directly use `@ComponentScan` (that is, not through `@SpringBootApplication`) you need to register the `TypeExcludeFilter` with it.
See {spring-boot-module-api}/context/TypeExcludeFilter.html[the Javadoc] for details.




[[boot-features-testing-spring-boot-application-arguments]]
==== Using Application Arguments
If your application expects <<boot-features-application-arguments,arguments>>, you can
have `@SpringBootTest` inject them using the `args` attribute.

[source,java,indent=0]
----
include::{code-examples}/test/context/ApplicationArgumentsExampleTests.java[tag=example]
----



[[boot-features-testing-spring-boot-applications-testing-with-mock-environment]]
==== Testing with a mock environment
By default, `@SpringBootTest` does not start the server.
If you have web endpoints that you want to test against this mock environment, you can additionally configure {spring-framework-docs}/testing.html#spring-mvc-test-framework[`MockMvc`] as shown in the following example:

[source,java,indent=0]
----
include::{code-examples}/test/web/MockMvcExampleTests.java[tag=test-mock-mvc]
----

TIP: If you want to focus only on the web layer and not start a complete `ApplicationContext`, consider <<boot-features-testing-spring-boot-applications-testing-autoconfigured-mvc-tests,using `@WebMvcTest` instead>>.

Alternatively, you can configure a {spring-framework-docs}testing.html#webtestclient-tests[`WebTestClient`] as shown in the following example:

[source,java,indent=0]
----
include::{code-examples}/test/web/MockWebTestClientExampleTests.java[tag=test-mock-web-test-client]
----

[TIP]
====
Testing within a mocked environment is usually faster than running with a full Servlet container.
However, since mocking occurs at the Spring MVC layer, code that relies on lower-level Servlet container behavior cannot be directly tested with MockMvc.

For example, Spring Boot's error handling is based on the "`error page`" support provided by the Servlet container.
This means that, whilst you can test your MVC layer throws and handles exceptions as expected, you cannot directly test that a specific <<boot-features-error-handling-custom-error-pages, custom error page>> is rendered.
If you need to test these lower-level concerns, you can start a fully running server as described in the next section.
====



[[boot-features-testing-spring-boot-applications-testing-with-running-server]]
==== Testing with a running server
If you need to start a full running server, we recommend that you use random ports.
If you use `@SpringBootTest(webEnvironment=WebEnvironment.RANDOM_PORT)`, an available port is picked at random each time your test runs.

The `@LocalServerPort` annotation can be used to <<howto.adoc#howto-discover-the-http-port-at-runtime,inject the actual port used>> into your test.
For convenience, tests that need to make REST calls to the started server can additionally `@Autowire` a {spring-framework-docs}testing.html#webtestclient-tests[`WebTestClient`], which resolves relative links to the running server and comes with a dedicated API for verifying responses, as shown in the following example:

[source,java,indent=0]
----
include::{code-examples}/test/web/RandomPortWebTestClientExampleTests.java[tag=test-random-port]
----

This setup requires `spring-webflux` on the classpath.
If you can't or won't add webflux, Spring Boot also provides a `TestRestTemplate` facility:

[source,java,indent=0]
----
include::{code-examples}/test/web/RandomPortTestRestTemplateExampleTests.java[tag=test-random-port]
----



[[boot-features-testing-spring-boot-applications-customizing-web-test-client]]
==== Customizing WebTestClient
To customize the `WebTestClient` bean, configure a `WebTestClientBuilderCustomizer` bean.
Any such beans are called with the `WebTestClient.Builder` that is used to create the `WebTestClient`.



[[boot-features-testing-spring-boot-applications-jmx]]
==== Using JMX
As the test context framework caches context, JMX is disabled by default to prevent identical components to register on the same domain.
If such test needs access to an `MBeanServer`, consider marking it dirty as well:

[source,java,indent=0]
----
include::{test-examples}/jmx/SampleJmxTests.java[tag=test]
----



[[boot-features-testing-spring-boot-applications-mocking-beans]]
==== Mocking and Spying Beans
When running tests, it is sometimes necessary to mock certain components within your application context.
For example, you may have a facade over some remote service that is unavailable during development.
Mocking can also be useful when you want to simulate failures that might be hard to trigger in a real environment.

Spring Boot includes a `@MockBean` annotation that can be used to define a Mockito mock for a bean inside your `ApplicationContext`.
You can use the annotation to add new beans or replace a single existing bean definition.
The annotation can be used directly on test classes, on fields within your test, or on `@Configuration` classes and fields.
When used on a field, the instance of the created mock is also injected.
Mock beans are automatically reset after each test method.

[NOTE]
====
If your test uses one of Spring Boot's test annotations (such as `@SpringBootTest`), this feature is automatically enabled.
To use this feature with a different arrangement, a listener must be explicitly added, as shown in the following example:

[source,java,indent=0]
----
	@TestExecutionListeners(MockitoTestExecutionListener.class)
----

====

The following example replaces an existing `RemoteService` bean with a mock implementation:

[source,java,indent=0]
----
	import org.junit.jupiter.api.Test;
	import org.springframework.beans.factory.annotation.*;
	import org.springframework.boot.test.context.*;
	import org.springframework.boot.test.mock.mockito.*;

	import static org.assertj.core.api.Assertions.*;
	import static org.mockito.BDDMockito.*;

	@SpringBootTest
	class MyTests {

		@MockBean
		private RemoteService remoteService;

		@Autowired
		private Reverser reverser;

		@Test
		void exampleTest() {
			// RemoteService has been injected into the reverser bean
			given(this.remoteService.someCall()).willReturn("mock");
			String reverse = reverser.reverseSomeCall();
			assertThat(reverse).isEqualTo("kcom");
		}

	}
----

NOTE: `@MockBean` cannot be used to mock the behavior of a bean that's exercised during application context refresh.
By the time the test is executed, the application context refresh has completed and it is too late to configure the mocked behavior.
We recommend using a `@Bean` method to create and configure the mock in this situation.

Additionally, you can use `@SpyBean` to wrap any existing bean with a Mockito `spy`.
See the {spring-boot-test-module-api}/mock/mockito/SpyBean.html[Javadoc] for full details.

NOTE: CGLib proxies, such as those created for scoped beans, declare the proxied methods as `final`.
This stops Mockito from functioning correctly as it cannot mock or spy on `final` methods in its default configuration.
If you want to mock or spy on such a bean, configure Mockito to use its inline mock maker by adding `org.mockito:mockito-inline` to your application's test dependencies.
This allows Mockito to mock and spy on `final` methods.

NOTE: While Spring's test framework caches application contexts between tests and reuses a context for tests sharing the same configuration, the use of `@MockBean` or `@SpyBean` influences the cache key, which will most likely increase the number of contexts.

TIP: If you are using `@SpyBean` to spy on a bean with `@Cacheable` methods that refer to parameters by name, your application must be compiled with `-parameters`.
This ensures that the parameter names are available to the caching infrastructure once the bean has been spied upon.



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-tests]]
==== Auto-configured Tests
Spring Boot's auto-configuration system works well for applications but can sometimes be a little too much for tests.
It often helps to load only the parts of the configuration that are required to test a "`slice`" of your application.
For example, you might want to test that Spring MVC controllers are mapping URLs correctly, and you do not want to involve database calls in those tests, or you might want to test JPA entities, and you are not interested in the web layer when those tests run.

The `spring-boot-test-autoconfigure` module includes a number of annotations that can be used to automatically configure such "`slices`".
Each of them works in a similar way, providing a `@...Test` annotation that loads the `ApplicationContext` and one or more `@AutoConfigure...` annotations that can be used to customize auto-configuration settings.

NOTE: Each slice restricts component scan to appropriate components and loads a very restricted set of auto-configuration classes.
If you need to exclude one of them, most `@...Test` annotations provide an `excludeAutoConfiguration` attribute.
Alternatively, you can use `@ImportAutoConfiguration#exclude`.

NOTE: Including multiple "`slices`" by using several `@...Test` annotations in one test is not supported.
If you need multiple "`slices`", pick one of the `@...Test` annotations and include the `@AutoConfigure...` annotations of the other "`slices`" by hand.

TIP: It is also possible to use the `@AutoConfigure...` annotations with the standard `@SpringBootTest` annotation.
You can use this combination if you are not interested in "`slicing`" your application but you want some of the auto-configured test beans.



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-json-tests]]
==== Auto-configured JSON Tests
To test that object JSON serialization and deserialization is working as expected, you can use the `@JsonTest` annotation.
`@JsonTest` auto-configures the available supported JSON mapper, which can be one of the following libraries:

* Jackson `ObjectMapper`, any `@JsonComponent` beans and any Jackson ``Module``s
* `Gson`
* `Jsonb`

TIP: A list of the auto-configurations that are enabled by `@JsonTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

If you need to configure elements of the auto-configuration, you can use the `@AutoConfigureJsonTesters` annotation.

Spring Boot includes AssertJ-based helpers that work with the JSONAssert and JsonPath libraries to check that JSON appears as expected.
The `JacksonTester`, `GsonTester`, `JsonbTester`, and `BasicJsonTester` classes can be used for Jackson, Gson, Jsonb, and Strings respectively.
Any helper fields on the test class can be `@Autowired` when using `@JsonTest`.
The following example shows a test class for Jackson:

[source,java,indent=0]
----
	import org.junit.jupiter.api.Test;
	import org.springframework.beans.factory.annotation.*;
	import org.springframework.boot.test.autoconfigure.json.*;
	import org.springframework.boot.test.context.*;
	import org.springframework.boot.test.json.*;

	import static org.assertj.core.api.Assertions.*;

	@JsonTest
	class MyJsonTests {

		@Autowired
		private JacksonTester<VehicleDetails> json;

		@Test
		void testSerialize() throws Exception {
			VehicleDetails details = new VehicleDetails("Honda", "Civic");
			// Assert against a `.json` file in the same package as the test
			assertThat(this.json.write(details)).isEqualToJson("expected.json");
			// Or use JSON path based assertions
			assertThat(this.json.write(details)).hasJsonPathStringValue("@.make");
			assertThat(this.json.write(details)).extractingJsonPathStringValue("@.make")
					.isEqualTo("Honda");
		}

		@Test
		void testDeserialize() throws Exception {
			String content = "{\"make\":\"Ford\",\"model\":\"Focus\"}";
			assertThat(this.json.parse(content))
					.isEqualTo(new VehicleDetails("Ford", "Focus"));
			assertThat(this.json.parseObject(content).getMake()).isEqualTo("Ford");
		}

	}
----

NOTE: JSON helper classes can also be used directly in standard unit tests.
To do so, call the `initFields` method of the helper in your `@Before` method if you do not use `@JsonTest`.

If you're using Spring Boot's AssertJ-based helpers to assert on a number value at a given JSON path, you might not be able to use `isEqualTo` depending on the type.
Instead, you can use AssertJ's `satisfies` to assert that the value matches the given condition.
For instance, the following example asserts that the actual number is a float value close to `0.15` within an offset of `0.01`.

[source,java,indent=0]
----
assertThat(json.write(message))
    .extractingJsonPathNumberValue("@.test.numberValue")
    .satisfies((number) -> assertThat(number.floatValue()).isCloseTo(0.15f, within(0.01f)));
----



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-mvc-tests]]
==== Auto-configured Spring MVC Tests
To test whether Spring MVC controllers are working as expected, use the `@WebMvcTest` annotation.
`@WebMvcTest` auto-configures the Spring MVC infrastructure and limits scanned beans to `@Controller`, `@ControllerAdvice`, `@JsonComponent`, `Converter`, `GenericConverter`, `Filter`, `HandlerInterceptor`, `WebMvcConfigurer`, and `HandlerMethodArgumentResolver`.
Regular `@Component` beans are not scanned when using this annotation.

TIP: A list of the auto-configuration settings that are enabled by `@WebMvcTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

TIP: If you need to register extra components, such as the Jackson `Module`, you can import additional configuration classes by using `@Import` on your test.

Often, `@WebMvcTest` is limited to a single controller and is used in combination with `@MockBean` to provide mock implementations for required collaborators.

`@WebMvcTest` also auto-configures `MockMvc`.
Mock MVC offers a powerful way to quickly test MVC controllers without needing to start a full HTTP server.

TIP: You can also auto-configure `MockMvc` in a non-`@WebMvcTest` (such as `@SpringBootTest`) by annotating it with `@AutoConfigureMockMvc`.
The following example uses `MockMvc`:

[source,java,indent=0]
----
	import org.junit.jupiter.api.*;
	import org.springframework.beans.factory.annotation.*;
	import org.springframework.boot.test.autoconfigure.web.servlet.*;
	import org.springframework.boot.test.mock.mockito.*;

	import static org.assertj.core.api.Assertions.*;
	import static org.mockito.BDDMockito.*;
	import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
	import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

	@WebMvcTest(UserVehicleController.class)
	class MyControllerTests {

		@Autowired
		private MockMvc mvc;

		@MockBean
		private UserVehicleService userVehicleService;

		@Test
		void testExample() throws Exception {
			given(this.userVehicleService.getVehicleDetails("sboot"))
					.willReturn(new VehicleDetails("Honda", "Civic"));
			this.mvc.perform(get("/sboot/vehicle").accept(MediaType.TEXT_PLAIN))
					.andExpect(status().isOk()).andExpect(content().string("Honda Civic"));
		}

	}
----

TIP: If you need to configure elements of the auto-configuration (for example, when servlet filters should be applied) you can use attributes in the `@AutoConfigureMockMvc` annotation.

If you use HtmlUnit or Selenium, auto-configuration also provides an HtmlUnit `WebClient` bean and/or a Selenium `WebDriver` bean.
The following example uses HtmlUnit:

[source,java,indent=0]
----
	import com.gargoylesoftware.htmlunit.*;
	import org.junit.jupiter.api.*;
	import org.springframework.beans.factory.annotation.*;
	import org.springframework.boot.test.autoconfigure.web.servlet.*;
	import org.springframework.boot.test.mock.mockito.*;

	import static org.assertj.core.api.Assertions.*;
	import static org.mockito.BDDMockito.*;

	@WebMvcTest(UserVehicleController.class)
	class MyHtmlUnitTests {

		@Autowired
		private WebClient webClient;

		@MockBean
		private UserVehicleService userVehicleService;

		@Test
		void testExample() throws Exception {
			given(this.userVehicleService.getVehicleDetails("sboot"))
					.willReturn(new VehicleDetails("Honda", "Civic"));
			HtmlPage page = this.webClient.getPage("/sboot/vehicle.html");
			assertThat(page.getBody().getTextContent()).isEqualTo("Honda Civic");
		}

	}
----

NOTE: By default, Spring Boot puts `WebDriver` beans in a special "`scope`" to ensure that the driver exits after each test and that a new instance is injected.
If you do not want this behavior, you can add `@Scope("singleton")` to your `WebDriver` `@Bean` definition.

WARNING: The `webDriver` scope created by Spring Boot will replace any user defined scope of the same name.
If you define your own `webDriver` scope you may find it stops working when you use `@WebMvcTest`.

If you have Spring Security on the classpath, `@WebMvcTest` will also scan `WebSecurityConfigurer` beans.
Instead of disabling security completely for such tests, you can use Spring Security's test support.
More details on how to use Spring Security's `MockMvc` support can be found in this _<<howto.adoc#howto-use-test-with-spring-security>>_ how-to section.

TIP: Sometimes writing Spring MVC tests is not enough; Spring Boot can help you run <<boot-features-testing-spring-boot-applications-testing-with-running-server, full end-to-end tests with an actual server>>.



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-webflux-tests]]
==== Auto-configured Spring WebFlux Tests
To test that {spring-framework-docs}/web-reactive.html[Spring WebFlux] controllers are working as expected, you can use the `@WebFluxTest` annotation.
`@WebFluxTest` auto-configures the Spring WebFlux infrastructure and limits scanned beans to `@Controller`, `@ControllerAdvice`, `@JsonComponent`, `Converter`, `GenericConverter`, `WebFilter`, and `WebFluxConfigurer`.
Regular `@Component` beans are not scanned when the `@WebFluxTest` annotation is used.

TIP: A list of the auto-configurations that are enabled by `@WebFluxTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

TIP: If you need to register extra components, such as Jackson `Module`, you can import additional configuration classes using `@Import` on your test.

Often, `@WebFluxTest` is limited to a single controller and used in combination with the `@MockBean` annotation to provide mock implementations for required collaborators.

`@WebFluxTest` also auto-configures {spring-framework-docs}testing.html#webtestclient[`WebTestClient`], which offers a powerful way to quickly test WebFlux controllers without needing to start a full HTTP server.

TIP: You can also auto-configure `WebTestClient` in a non-`@WebFluxTest` (such as `@SpringBootTest`) by annotating it with `@AutoConfigureWebTestClient`.
The following example shows a class that uses both `@WebFluxTest` and a `WebTestClient`:

[source,java,indent=0]
----
	import org.junit.jupiter.api.Test;

	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest;
	import org.springframework.http.MediaType;
	import org.springframework.test.web.reactive.server.WebTestClient;

	@WebFluxTest(UserVehicleController.class)
	class MyControllerTests {

		@Autowired
		private WebTestClient webClient;

		@MockBean
		private UserVehicleService userVehicleService;

		@Test
		void testExample() throws Exception {
			given(this.userVehicleService.getVehicleDetails("sboot"))
					.willReturn(new VehicleDetails("Honda", "Civic"));
			this.webClient.get().uri("/sboot/vehicle").accept(MediaType.TEXT_PLAIN)
					.exchange()
					.expectStatus().isOk()
					.expectBody(String.class).isEqualTo("Honda Civic");
		}

	}
----

TIP: This setup is only supported by WebFlux applications as using `WebTestClient` in a mocked web application only works with WebFlux at the moment.

NOTE: `@WebFluxTest` cannot detect routes registered via the functional web framework.
For testing `RouterFunction` beans in the context, consider importing your `RouterFunction` yourself via `@Import` or using `@SpringBootTest`.

NOTE: `@WebFluxTest` cannot detect custom security configuration registered via a `@Bean` of type `SecurityWebFilterChain`.
To include that in your test, you will need to import the configuration that registers the bean via `@Import` or use `@SpringBootTest`.

TIP: Sometimes writing Spring WebFlux tests is not enough; Spring Boot can help you run <<boot-features-testing-spring-boot-applications-testing-with-running-server, full end-to-end tests with an actual server>>.



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-jpa-test]]
==== Auto-configured Data JPA Tests
You can use the `@DataJpaTest` annotation to test JPA applications.
By default, it scans for `@Entity` classes and configures Spring Data JPA repositories.
If an embedded database is available on the classpath, it configures one as well.
Regular `@Component` beans are not loaded into the `ApplicationContext`.

TIP: A list of the auto-configuration settings that are enabled by `@DataJpaTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

By default, data JPA tests are transactional and roll back at the end of each test.
See the {spring-framework-docs}testing.html#testcontext-tx-enabling-transactions[relevant section] in the Spring Framework Reference Documentation for more details.
If that is not what you want, you can disable transaction management for a test or for the whole class as follows:

[source,java,indent=0]
----
	import org.junit.jupiter.api.Test;
	import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
	import org.springframework.transaction.annotation.Propagation;
	import org.springframework.transaction.annotation.Transactional;

	@DataJpaTest
	@Transactional(propagation = Propagation.NOT_SUPPORTED)
	class ExampleNonTransactionalTests {

	}
----

Data JPA tests may also inject a {spring-boot-test-autoconfigure-module-code}/orm/jpa/TestEntityManager.java[`TestEntityManager`] bean, which provides an alternative to the standard JPA `EntityManager` that is specifically designed for tests.
If you want to use `TestEntityManager` outside of `@DataJpaTest` instances, you can also use the `@AutoConfigureTestEntityManager` annotation.
A `JdbcTemplate` is also available if you need that.
The following example shows the `@DataJpaTest` annotation in use:

[source,java,indent=0]
----
	import org.junit.jupiter.api.Test;
	import org.springframework.boot.test.autoconfigure.orm.jpa.*;

	import static org.assertj.core.api.Assertions.*;

	@DataJpaTest
	class ExampleRepositoryTests {

		@Autowired
		private TestEntityManager entityManager;

		@Autowired
		private UserRepository repository;

		@Test
		void testExample() throws Exception {
			this.entityManager.persist(new User("sboot", "1234"));
			User user = this.repository.findByUsername("sboot");
			assertThat(user.getUsername()).isEqualTo("sboot");
			assertThat(user.getVin()).isEqualTo("1234");
		}

	}
----

In-memory embedded databases generally work well for tests, since they are fast and do not require any installation.
If, however, you prefer to run tests against a real database you can use the `@AutoConfigureTestDatabase` annotation, as shown in the following example:

[source,java,indent=0]
----
	@DataJpaTest
	@AutoConfigureTestDatabase(replace=Replace.NONE)
	class ExampleRepositoryTests {

		// ...

	}
----



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-jdbc-test]]
==== Auto-configured JDBC Tests
`@JdbcTest` is similar to `@DataJpaTest` but is for tests that only require a `DataSource` and do not use Spring Data JDBC.
By default, it configures an in-memory embedded database and a `JdbcTemplate`.
Regular `@Component` beans are not loaded into the `ApplicationContext`.

TIP: A list of the auto-configurations that are enabled by `@JdbcTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

By default, JDBC tests are transactional and roll back at the end of each test.
See the {spring-framework-docs}testing.html#testcontext-tx-enabling-transactions[relevant section] in the Spring Framework Reference Documentation for more details.
If that is not what you want, you can disable transaction management for a test or for the whole class, as follows:

[source,java,indent=0]
----
	import org.junit.jupiter.api.Test;
	import org.springframework.boot.test.autoconfigure.jdbc.JdbcTest;
	import org.springframework.transaction.annotation.Propagation;
	import org.springframework.transaction.annotation.Transactional;

	@JdbcTest
	@Transactional(propagation = Propagation.NOT_SUPPORTED)
	class ExampleNonTransactionalTests {

	}
----

If you prefer your test to run against a real database, you can use the `@AutoConfigureTestDatabase` annotation in the same way as for `DataJpaTest`.
(See "<<boot-features-testing-spring-boot-applications-testing-autoconfigured-jpa-test>>".)



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-data-jdbc-test]]
==== Auto-configured Data JDBC Tests
`@DataJdbcTest` is similar to `@JdbcTest` but is for tests that use Spring Data JDBC repositories.
By default, it configures an in-memory embedded database, a `JdbcTemplate`, and Spring Data JDBC repositories.
Regular `@Component` beans are not loaded into the `ApplicationContext`.

TIP: A list of the auto-configurations that are enabled by `@DataJdbcTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

By default, Data JDBC tests are transactional and roll back at the end of each test.
See the {spring-framework-docs}testing.html#testcontext-tx-enabling-transactions[relevant section] in the Spring Framework Reference Documentation for more details.
If that is not what you want, you can disable transaction management for a test or for the whole test class as <<boot-features-testing-spring-boot-applications-testing-autoconfigured-jdbc-test,shown in the JDBC example>>.

If you prefer your test to run against a real database, you can use the `@AutoConfigureTestDatabase` annotation in the same way as for `DataJpaTest`.
(See "<<boot-features-testing-spring-boot-applications-testing-autoconfigured-jpa-test>>".)



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-jooq-test]]
==== Auto-configured jOOQ Tests
You can use `@JooqTest` in a similar fashion as `@JdbcTest` but for jOOQ-related tests.
As jOOQ relies heavily on a Java-based schema that corresponds with the database schema, the existing `DataSource` is used.
If you want to replace it with an in-memory database, you can use `@AutoConfigureTestDatabase` to override those settings.
(For more about using jOOQ with Spring Boot, see "<<boot-features-jooq>>", earlier in this chapter.)
Regular `@Component` beans are not loaded into the `ApplicationContext`.

TIP: A list of the auto-configurations that are enabled by `@JooqTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

`@JooqTest` configures a `DSLContext`.
Regular `@Component` beans are not loaded into the `ApplicationContext`.
The following example shows the `@JooqTest` annotation in use:

[source,java,indent=0]
----
	import org.jooq.DSLContext;
	import org.junit.jupiter.api.Test;
	import org.springframework.boot.test.autoconfigure.jooq.JooqTest;

	@JooqTest
	class ExampleJooqTests {

		@Autowired
		private DSLContext dslContext;
	}
----

JOOQ tests are transactional and roll back at the end of each test by default.
If that is not what you want, you can disable transaction management for a test or for the whole test class as <<boot-features-testing-spring-boot-applications-testing-autoconfigured-jdbc-test,shown in the JDBC example>>.



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-mongo-test]]
==== Auto-configured Data MongoDB Tests
You can use `@DataMongoTest` to test MongoDB applications.
By default, it configures an in-memory embedded MongoDB (if available), configures a `MongoTemplate`, scans for `@Document` classes, and configures Spring Data MongoDB repositories.
Regular `@Component` beans are not loaded into the `ApplicationContext`.
(For more about using MongoDB with Spring Boot, see "<<boot-features-mongodb>>", earlier in this chapter.)

TIP: A list of the auto-configuration settings that are enabled by `@DataMongoTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

The following class shows the `@DataMongoTest` annotation in use:

[source,java,indent=0]
----
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest;
	import org.springframework.data.mongodb.core.MongoTemplate;

	@DataMongoTest
	class ExampleDataMongoTests {

		@Autowired
		private MongoTemplate mongoTemplate;

		//
	}
----

In-memory embedded MongoDB generally works well for tests, since it is fast and does not require any developer installation.
If, however, you prefer to run tests against a real MongoDB server, you should exclude the embedded MongoDB auto-configuration, as shown in the following example:

[source,java,indent=0]
----
	import org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration;
	import org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest;

	@DataMongoTest(excludeAutoConfiguration = EmbeddedMongoAutoConfiguration.class)
	class ExampleDataMongoNonEmbeddedTests {

	}
----



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-neo4j-test]]
==== Auto-configured Data Neo4j Tests
You can use `@DataNeo4jTest` to test Neo4j applications.
By default, it uses an in-memory embedded Neo4j (if the embedded driver is available), scans for `@NodeEntity` classes, and configures Spring Data Neo4j repositories.
Regular `@Component` beans are not loaded into the `ApplicationContext`.
(For more about using Neo4J with Spring Boot, see "<<boot-features-neo4j>>", earlier in this chapter.)

TIP: A list of the auto-configuration settings that are enabled by `@DataNeo4jTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

The following example shows a typical setup for using Neo4J tests in Spring Boot:

[source,java,indent=0]
----
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest;

	@DataNeo4jTest
	class ExampleDataNeo4jTests {

		@Autowired
		private YourRepository repository;

		//
	}
----

By default, Data Neo4j tests are transactional and roll back at the end of each test.
See the {spring-framework-docs}testing.html#testcontext-tx-enabling-transactions[relevant section] in the Spring Framework Reference Documentation for more details.
If that is not what you want, you can disable transaction management for a test or for the whole class, as follows:

[source,java,indent=0]
----
	import org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest;
	import org.springframework.transaction.annotation.Propagation;
	import org.springframework.transaction.annotation.Transactional;

	@DataNeo4jTest
	@Transactional(propagation = Propagation.NOT_SUPPORTED)
	class ExampleNonTransactionalTests {

	}
----



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-redis-test]]
==== Auto-configured Data Redis Tests
You can use `@DataRedisTest` to test Redis applications.
By default, it scans for `@RedisHash` classes and configures Spring Data Redis repositories.
Regular `@Component` beans are not loaded into the `ApplicationContext`.
(For more about using Redis with Spring Boot, see "<<boot-features-redis>>", earlier in this chapter.)

TIP: A list of the auto-configuration settings that are enabled by `@DataRedisTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

The following example shows the `@DataRedisTest` annotation in use:

[source,java,indent=0]
----
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.boot.test.autoconfigure.data.redis.DataRedisTest;

	@DataRedisTest
	class ExampleDataRedisTests {

		@Autowired
		private YourRepository repository;

		//
	}
----



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-ldap-test]]
==== Auto-configured Data LDAP Tests
You can use `@DataLdapTest` to test LDAP applications.
By default, it configures an in-memory embedded LDAP (if available), configures an `LdapTemplate`, scans for `@Entry` classes, and configures Spring Data LDAP repositories.
Regular `@Component` beans are not loaded into the `ApplicationContext`.
(For more about using LDAP with Spring Boot, see "<<boot-features-ldap>>", earlier in this chapter.)

TIP: A list of the auto-configuration settings that are enabled by `@DataLdapTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

The following example shows the `@DataLdapTest` annotation in use:

[source,java,indent=0]
----
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest;
	import org.springframework.ldap.core.LdapTemplate;

	@DataLdapTest
	class ExampleDataLdapTests {

		@Autowired
		private LdapTemplate ldapTemplate;

		//
	}
----

In-memory embedded LDAP generally works well for tests, since it is fast and does not require any developer installation.
If, however, you prefer to run tests against a real LDAP server, you should exclude the embedded LDAP auto-configuration, as shown in the following example:

[source,java,indent=0]
----
	import org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration;
	import org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest;

	@DataLdapTest(excludeAutoConfiguration = EmbeddedLdapAutoConfiguration.class)
	class ExampleDataLdapNonEmbeddedTests {

	}
----



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-rest-client]]
==== Auto-configured REST Clients
You can use the `@RestClientTest` annotation to test REST clients.
By default, it auto-configures Jackson, GSON, and Jsonb support, configures a `RestTemplateBuilder`, and adds support for `MockRestServiceServer`.
Regular `@Component` beans are not loaded into the `ApplicationContext`.

TIP: A list of the auto-configuration settings that are enabled by `@RestClientTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

The specific beans that you want to test should be specified by using the `value` or `components` attribute of `@RestClientTest`, as shown in the following example:

[source,java,indent=0]
----
	@RestClientTest(RemoteVehicleDetailsService.class)
	class ExampleRestClientTest {

		@Autowired
		private RemoteVehicleDetailsService service;

		@Autowired
		private MockRestServiceServer server;

		@Test
		void getVehicleDetailsWhenResultIsSuccessShouldReturnDetails()
				throws Exception {
			this.server.expect(requestTo("/greet/details"))
					.andRespond(withSuccess("hello", MediaType.TEXT_PLAIN));
			String greeting = this.service.callRestService();
			assertThat(greeting).isEqualTo("hello");
		}

	}
----



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-rest-docs]]
==== Auto-configured Spring REST Docs Tests
You can use the `@AutoConfigureRestDocs` annotation to use {spring-restdocs}[Spring REST Docs] in your tests with Mock MVC, REST Assured, or WebTestClient.
It removes the need for the JUnit extension in Spring REST Docs.

`@AutoConfigureRestDocs` can be used to override the default output directory (`target/generated-snippets` if you are using Maven or `build/generated-snippets` if you are using Gradle).
It can also be used to configure the host, scheme, and port that appears in any documented URIs.



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-rest-docs-mock-mvc]]
===== Auto-configured Spring REST Docs Tests with Mock MVC
`@AutoConfigureRestDocs` customizes the `MockMvc` bean to use Spring REST Docs.
You can inject it by using `@Autowired` and use it in your tests as you normally would when using Mock MVC and Spring REST Docs, as shown in the following example:

[source,java,indent=0]
----
	import org.junit.jupiter.api.Test;

	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
	import org.springframework.http.MediaType;
	import org.springframework.test.web.servlet.MockMvc;

	import static org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.document;
	import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
	import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

	@WebMvcTest(UserController.class)
	@AutoConfigureRestDocs
	class UserDocumentationTests {

		@Autowired
		private MockMvc mvc;

		@Test
		void listUsers() throws Exception {
			this.mvc.perform(get("/users").accept(MediaType.TEXT_PLAIN))
					.andExpect(status().isOk())
					.andDo(document("list-users"));
		}

	}
----

If you require more control over Spring REST Docs configuration than offered by the attributes of `@AutoConfigureRestDocs`, you can use a `RestDocsMockMvcConfigurationCustomizer` bean, as shown in the following example:

[source,java,indent=0]
----
	@TestConfiguration
	static class CustomizationConfiguration
			implements RestDocsMockMvcConfigurationCustomizer {

		@Override
		public void customize(MockMvcRestDocumentationConfigurer configurer) {
			configurer.snippets().withTemplateFormat(TemplateFormats.markdown());
		}

	}
----

If you want to make use of Spring REST Docs support for a parameterized output directory, you can create a `RestDocumentationResultHandler` bean.
The auto-configuration calls `alwaysDo` with this result handler, thereby causing each `MockMvc` call to automatically generate the default snippets.
The following example shows a `RestDocumentationResultHandler` being defined:

[source,java,indent=0]
----
	@TestConfiguration(proxyBeanMethods = false)
	static class ResultHandlerConfiguration {

		@Bean
		public RestDocumentationResultHandler restDocumentation() {
			return MockMvcRestDocumentation.document("{method-name}");
		}

	}
----



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-rest-docs-web-test-client]]
===== Auto-configured Spring REST Docs Tests with WebTestClient
`@AutoConfigureRestDocs` can also be used with `WebTestClient`.
You can inject it by using `@Autowired` and use it in your tests as you normally would when using `@WebFluxTest` and Spring REST Docs, as shown in the following example:

[source,java,indent=0]
----
include::{code-examples}/test/autoconfigure/restdocs/webclient/UsersDocumentationTests.java[tag=source]
----

If you require more control over Spring REST Docs configuration than offered by the attributes of `@AutoConfigureRestDocs`, you can use a `RestDocsWebTestClientConfigurationCustomizer` bean, as shown in the following example:

[source,java,indent=0]
----
include::{code-examples}/test/autoconfigure/restdocs/webclient/AdvancedConfigurationExample.java[tag=configuration]
----



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-rest-docs-rest-assured]]
===== Auto-configured Spring REST Docs Tests with REST Assured
`@AutoConfigureRestDocs` makes a `RequestSpecification` bean, preconfigured to use Spring REST Docs, available to your tests.
You can inject it by using `@Autowired` and use it in your tests as you normally would when using REST Assured and Spring REST Docs, as shown in the following example:

[source,java,indent=0]
----
include::{code-examples}/test/autoconfigure/restdocs/restassured/UserDocumentationTests.java[tag=source]
----

If you require more control over Spring REST Docs configuration than offered by the attributes of `@AutoConfigureRestDocs`, a `RestDocsRestAssuredConfigurationCustomizer` bean can be used, as shown in the following example:

[source,java,indent=0]
----
include::{code-examples}/test/autoconfigure/restdocs/restassured/AdvancedConfigurationExample.java[tag=configuration]
----



[[boot-features-testing-spring-boot-applications-testing-auto-configured-additional-auto-config]]
==== Additional Auto-configuration and Slicing
Each slice provides one or more `@AutoConfigure...` annotations that namely defines the auto-configurations that should be included as part of a slice.
Additional auto-configurations can be added by creating a custom `@AutoConfigure...` annotation or simply by adding `@ImportAutoConfiguration` to the test as shown in the following example:

[source,java,indent=0]
----
	@JdbcTest
	@ImportAutoConfiguration(IntegrationAutoConfiguration.class)
	class ExampleJdbcTests {

	}
----

NOTE: Make sure to not use the regular `@Import` annotation to import auto-configurations as they are handled in a specific way by Spring Boot.



[[boot-features-testing-spring-boot-applications-testing-user-configuration]]
==== User Configuration and Slicing
If you <<using-boot-structuring-your-code, structure your code>> in a sensible way, your `@SpringBootApplication` class is <<boot-features-testing-spring-boot-applications-detecting-config, used by default>> as the configuration of your tests.

It then becomes important not to litter the application's main class with configuration settings that are specific to a particular area of its functionality.

Assume that you are using Spring Batch and you rely on the auto-configuration for it.
You could define your `@SpringBootApplication` as follows:

[source,java,indent=0]
----
	@SpringBootApplication
	@EnableBatchProcessing
	public class SampleApplication { ... }
----

Because this class is the source configuration for the test, any slice test actually tries to start Spring Batch, which is definitely not what you want to do.
A recommended approach is to move that area-specific configuration to a separate `@Configuration` class at the same level as your application, as shown in the following example:

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	@EnableBatchProcessing
	public class BatchConfiguration { ... }
----

NOTE: Depending on the complexity of your application, you may either have a single `@Configuration` class for your customizations or one class per domain area.
The latter approach lets you enable it in one of your tests, if necessary, with the `@Import` annotation.

Test slices exclude `@Configuration` classes from scanning.
For example, for a `@WebMvcTest`, the following configuration will not include the given `WebMvcConfigurer` bean in the application context loaded by the test slice:

[source,java,indent=0]
----
	@Configuration
	public class WebConfiguration {
		@Bean
		public WebMvcConfigurer testConfigurer() {
			return new WebMvcConfigurer() {
				...
			};
		}
	}
----

The configuration below will, however, cause the custom `WebMvcConfigurer` to be loaded by the test slice.

[source,java,indent=0]
----
	@Component
	public class TestWebMvcConfigurer implements WebMvcConfigurer {
		...
	}
----

Another source of confusion is classpath scanning.
Assume that, while you structured your code in a sensible way, you need to scan an additional package.
Your application may resemble the following code:

[source,java,indent=0]
----
	@SpringBootApplication
	@ComponentScan({ "com.example.app", "org.acme.another" })
	public class SampleApplication { ... }
----

Doing so effectively overrides the default component scan directive with the side effect of scanning those two packages regardless of the slice that you chose.
For instance, a `@DataJpaTest` seems to suddenly scan components and user configurations of your application.
Again, moving the custom directive to a separate class is a good way to fix this issue.

TIP: If this is not an option for you, you can create a `@SpringBootConfiguration` somewhere in the hierarchy of your test so that it is used instead.
Alternatively, you can specify a source for your test, which disables the behavior of finding a default one.



[[boot-features-testing-spring-boot-applications-with-spock]]
==== Using Spock to Test Spring Boot Applications
If you wish to use Spock to test a Spring Boot application, you should add a dependency on Spock's `spock-spring` module to your application's build.
`spock-spring` integrates Spring's test framework into Spock.
It is recommended that you use Spock 1.2 or later to benefit from a number of improvements to Spock's Spring Framework and Spring Boot integration.
See http://spockframework.org/spock/docs/1.2/modules.html#_spring_module[the documentation for Spock's Spring module] for further details.



[[boot-features-test-utilities]]
=== Test Utilities
A few test utility classes that are generally useful when testing your application are packaged as part of `spring-boot`.



[[boot-features-configfileapplicationcontextinitializer-test-utility]]
==== ConfigFileApplicationContextInitializer
`ConfigFileApplicationContextInitializer` is an `ApplicationContextInitializer` that you can apply to your tests to load Spring Boot `application.properties` files.
You can use it when you do not need the full set of features provided by `@SpringBootTest`, as shown in the following example:

[source,java,indent=0]
----
	@ContextConfiguration(classes = Config.class,
		initializers = ConfigFileApplicationContextInitializer.class)
----

NOTE: Using `ConfigFileApplicationContextInitializer` alone does not provide support for `@Value("${...}")` injection.
Its only job is to ensure that `application.properties` files are loaded into Spring's `Environment`.
For `@Value` support, you need to either additionally configure a `PropertySourcesPlaceholderConfigurer` or use `@SpringBootTest`, which auto-configures one for you.



[[boot-features-test-property-values]]
==== TestPropertyValues
`TestPropertyValues` lets you quickly add properties to a `ConfigurableEnvironment` or `ConfigurableApplicationContext`.
You can call it with `key=value` strings, as follows:

[source,java,indent=0]
----
	TestPropertyValues.of("org=Spring", "name=Boot").applyTo(env);
----



[[boot-features-output-capture-test-utility]]
==== OutputCapture
`OutputCapture` is a JUnit `Extension` that you can use to capture `System.out` and `System.err` output.
To use add `@ExtendWith(OutputCaptureExtension.class)` and inject `CapturedOutput` as an argument to your test class constructor or test method as follows:

[source,java,indent=0]
----
include::{test-examples}/test/system/OutputCaptureTests.java[tag=test]
----



[[boot-features-rest-templates-test-utility]]
==== TestRestTemplate
`TestRestTemplate` is a convenience alternative to Spring's `RestTemplate` that is useful in integration tests.
You can get a vanilla template or one that sends Basic HTTP authentication (with a username and password).
In either case, the template behaves in a test-friendly way by not throwing exceptions on server-side errors.

TIP: Spring Framework 5.0 provides a new `WebTestClient` that works for <<boot-features-testing-spring-boot-applications-testing-autoconfigured-webflux-tests, WebFlux integration tests>> and both <<boot-features-testing-spring-boot-applications-testing-with-running-server, WebFlux and MVC end-to-end testing>>.
It provides a fluent API for assertions, unlike `TestRestTemplate`.

It is recommended, but not mandatory, to use the Apache HTTP Client (version 4.3.2 or better).
If you have that on your classpath, the `TestRestTemplate` responds by configuring the client appropriately.
If you do use Apache's HTTP client, some additional test-friendly features are enabled:

* Redirects are not followed (so you can assert the response location).
* Cookies are ignored (so the template is stateless).

`TestRestTemplate` can be instantiated directly in your integration tests, as shown in the following example:

[source,java,indent=0]
----
	public class MyTest {

		private TestRestTemplate template = new TestRestTemplate();

		@Test
		public void testRequest() throws Exception {
			HttpHeaders headers = this.template.getForEntity(
					"https://myhost.example.com/example", String.class).getHeaders();
			assertThat(headers.getLocation()).hasHost("other.example.com");
		}

	}
----

Alternatively, if you use the `@SpringBootTest` annotation with `WebEnvironment.RANDOM_PORT` or `WebEnvironment.DEFINED_PORT`, you can inject a fully configured `TestRestTemplate` and start using it.
If necessary, additional customizations can be applied through the `RestTemplateBuilder` bean.
Any URLs that do not specify a host and port automatically connect to the embedded server, as shown in the following example:

[source,java,indent=0]
----
include::{test-examples}/web/client/SampleWebClientTests.java[tag=test]
----



[[boot-features-websockets]]
== WebSockets
Spring Boot provides WebSockets auto-configuration for embedded Tomcat, Jetty, and Undertow.
If you deploy a war file to a standalone container, Spring Boot assumes that the container is responsible for the configuration of its WebSocket support.

Spring Framework provides {spring-framework-docs}web.html#websocket[rich WebSocket support] for MVC web applications that can be easily accessed through the `spring-boot-starter-websocket` module.

WebSocket support is also available for {spring-framework-docs}web-reactive.html#webflux-websocket[reactive web applications] and requires to include the WebSocket API alongside `spring-boot-starter-webflux`:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<dependency>
		<groupId>javax.websocket</groupId>
		<artifactId>javax.websocket-api</artifactId>
	</dependency>
----



[[boot-features-webservices]]
== Web Services
Spring Boot provides Web Services auto-configuration so that all you must do is define your `Endpoints`.

The {spring-webservices-docs}[Spring Web Services features] can be easily accessed with the `spring-boot-starter-webservices` module.

`SimpleWsdl11Definition` and `SimpleXsdSchema` beans can be automatically created for your WSDLs and XSDs respectively.
To do so, configure their location, as shown in the following example:


[source,properties,indent=0,configprops]
----
	spring.webservices.wsdl-locations=classpath:/wsdl
----



[[boot-features-webservices-template]]
=== Calling Web Services with `WebServiceTemplate`
If you need to call remote Web services from your application, you can use the {spring-webservices-docs}#client-web-service-template[`WebServiceTemplate`] class.
Since `WebServiceTemplate` instances often need to be customized before being used, Spring Boot does not provide any single auto-configured `WebServiceTemplate` bean.
It does, however, auto-configure a `WebServiceTemplateBuilder`, which can be used to create `WebServiceTemplate` instances when needed.

The following code shows a typical example:

[source,java,indent=0]
----
	@Service
	public class MyService {

		private final WebServiceTemplate webServiceTemplate;

		public MyService(WebServiceTemplateBuilder webServiceTemplateBuilder) {
			this.webServiceTemplate = webServiceTemplateBuilder.build();
		}

		public DetailsResp someWsCall(DetailsReq detailsReq) {
			 return (DetailsResp) this.webServiceTemplate.marshalSendAndReceive(detailsReq, new SoapActionCallback(ACTION));
		}

	}
----

By default, `WebServiceTemplateBuilder` detects a suitable HTTP-based `WebServiceMessageSender` using the available HTTP client libraries on the classpath.
You can also customize read and connection timeouts as follows:

[source,java,indent=0]
----
	@Bean
	public WebServiceTemplate webServiceTemplate(WebServiceTemplateBuilder builder) {
		return builder.messageSenders(new HttpWebServiceMessageSenderBuilder()
				.setConnectTimeout(5000).setReadTimeout(2000).build()).build();
	}
----



[[boot-features-developing-auto-configuration]]
== Creating Your Own Auto-configuration
If you work in a company that develops shared libraries, or if you work on an open-source or commercial library, you might want to develop your own auto-configuration.
Auto-configuration classes can be bundled in external jars and still be picked-up by Spring Boot.

Auto-configuration can be associated to a "`starter`" that provides the auto-configuration code as well as the typical libraries that you would use with it.
We first cover what you need to know to build your own auto-configuration and then we move on to the <<boot-features-custom-starter,typical steps required to create a custom starter>>.

TIP: A https://github.com/snicoll-demos/spring-boot-master-auto-configuration[demo project] is available to showcase how you can create a starter step-by-step.



[[boot-features-understanding-auto-configured-beans]]
=== Understanding Auto-configured Beans
Under the hood, auto-configuration is implemented with standard `@Configuration` classes.
Additional `@Conditional` annotations are used to constrain when the auto-configuration should apply.
Usually, auto-configuration classes use `@ConditionalOnClass` and `@ConditionalOnMissingBean` annotations.
This ensures that auto-configuration applies only when relevant classes are found and when you have not declared your own `@Configuration`.

You can browse the source code of {spring-boot-autoconfigure-module-code}[`spring-boot-autoconfigure`] to see the `@Configuration` classes that Spring provides (see the {spring-boot-code}/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories[`META-INF/spring.factories`] file).



[[boot-features-locating-auto-configuration-candidates]]
=== Locating Auto-configuration Candidates
Spring Boot checks for the presence of a `META-INF/spring.factories` file within your published jar.
The file should list your configuration classes under the `EnableAutoConfiguration` key, as shown in the following example:

[indent=0]
----
	org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
	com.mycorp.libx.autoconfigure.LibXAutoConfiguration,\
	com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration
----

NOTE: Auto-configurations must be loaded that way _only_.
Make sure that they are defined in a specific package space and that they are never the target of component scanning.
Furthermore, auto-configuration classes should not enable component scanning to find additional components.
Specific ``@Import``s should be used instead.

You can use the {spring-boot-autoconfigure-module-code}/AutoConfigureAfter.java[`@AutoConfigureAfter`] or {spring-boot-autoconfigure-module-code}/AutoConfigureBefore.java[`@AutoConfigureBefore`] annotations if your configuration needs to be applied in a specific order.
For example, if you provide web-specific configuration, your class may need to be applied after `WebMvcAutoConfiguration`.

If you want to order certain auto-configurations that should not have any direct knowledge of each other, you can also use `@AutoConfigureOrder`.
That annotation has the same semantic as the regular `@Order` annotation but provides a dedicated order for auto-configuration classes.



[[boot-features-condition-annotations]]
=== Condition Annotations
You almost always want to include one or more `@Conditional` annotations on your auto-configuration class.
The `@ConditionalOnMissingBean` annotation is one common example that is used to allow developers to override auto-configuration if they are not happy with your defaults.

Spring Boot includes a number of `@Conditional` annotations that you can reuse in your own code by annotating `@Configuration` classes or individual `@Bean` methods.
These annotations include:

* <<boot-features-class-conditions>>
* <<boot-features-bean-conditions>>
* <<boot-features-property-conditions>>
* <<boot-features-resource-conditions>>
* <<boot-features-web-application-conditions>>
* <<boot-features-spel-conditions>>



[[boot-features-class-conditions]]
==== Class Conditions
The `@ConditionalOnClass` and `@ConditionalOnMissingClass` annotations let `@Configuration` classes be included based on the presence or absence of specific classes.
Due to the fact that annotation metadata is parsed by using https://asm.ow2.org/[ASM], you can use the `value` attribute to refer to the real class, even though that class might not actually appear on the running application classpath.
You can also use the `name` attribute if you prefer to specify the class name by using a `String` value.

This mechanism does not apply the same way to `@Bean` methods where typically the return type is the target of the condition: before the condition on the method applies, the JVM will have loaded the class and potentially processed method references which will fail if the class is not present.

To handle this scenario, a separate `@Configuration` class can be used to isolate the condition, as shown in the following example:

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	// Some conditions
	public class MyAutoConfiguration {

		// Auto-configured beans

		@Configuration(proxyBeanMethods = false)
		@ConditionalOnClass(EmbeddedAcmeService.class)
		static class EmbeddedConfiguration {

			@Bean
			@ConditionalOnMissingBean
			public EmbeddedAcmeService embeddedAcmeService() { ... }

		}

	}
----

TIP: If you use `@ConditionalOnClass` or `@ConditionalOnMissingClass` as a part of a meta-annotation to compose your own composed annotations, you must use `name` as referring to the class in such a case is not handled.



[[boot-features-bean-conditions]]
==== Bean Conditions
The `@ConditionalOnBean` and `@ConditionalOnMissingBean` annotations let a bean be included based on the presence or absence of specific beans.
You can use the `value` attribute to specify beans by type or `name` to specify beans by name.
The `search` attribute lets you limit the `ApplicationContext` hierarchy that should be considered when searching for beans.

When placed on a `@Bean` method, the target type defaults to the return type of the method, as shown in the following example:

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	public class MyAutoConfiguration {

		@Bean
		@ConditionalOnMissingBean
		public MyService myService() { ... }

	}
----

In the preceding example, the `myService` bean is going to be created if no bean of type `MyService` is already contained in the `ApplicationContext`.

TIP: You need to be very careful about the order in which bean definitions are added, as these conditions are evaluated based on what has been processed so far.
For this reason, we recommend using only `@ConditionalOnBean` and `@ConditionalOnMissingBean` annotations on auto-configuration classes (since these are guaranteed to load after any user-defined bean definitions have been added).

NOTE: `@ConditionalOnBean` and `@ConditionalOnMissingBean` do not prevent `@Configuration` classes from being created.
The only difference between using these conditions at the class level and marking each contained `@Bean` method with the annotation is that the former prevents registration of the `@Configuration` class as a bean if the condition does not match.



[[boot-features-property-conditions]]
==== Property Conditions
The `@ConditionalOnProperty` annotation lets configuration be included based on a Spring Environment property.
Use the `prefix` and `name` attributes to specify the property that should be checked.
By default, any property that exists and is not equal to `false` is matched.
You can also create more advanced checks by using the `havingValue` and `matchIfMissing` attributes.



[[boot-features-resource-conditions]]
==== Resource Conditions
The `@ConditionalOnResource` annotation lets configuration be included only when a specific resource is present.
Resources can be specified by using the usual Spring conventions, as shown in the following example: `file:/home/user/test.dat`.



[[boot-features-web-application-conditions]]
==== Web Application Conditions
The `@ConditionalOnWebApplication` and `@ConditionalOnNotWebApplication` annotations let configuration be included depending on whether the application is a "`web application`".
A servlet-based web application is any application that uses a Spring `WebApplicationContext`, defines a `session` scope, or has a `ConfigurableWebEnvironment`.
A reactive web application is any application that uses a `ReactiveWebApplicationContext`, or has a `ConfigurableReactiveWebEnvironment`.



[[boot-features-spel-conditions]]
==== SpEL Expression Conditions
The `@ConditionalOnExpression` annotation lets configuration be included based on the result of a {spring-framework-docs}core.html#expressions[SpEL expression].



[[boot-features-test-autoconfig]]
=== Testing your Auto-configuration
An auto-configuration can be affected by many factors: user configuration (`@Bean` definition and `Environment` customization), condition evaluation (presence of a particular library), and others.
Concretely, each test should create a well defined `ApplicationContext` that represents a combination of those customizations.
`ApplicationContextRunner` provides a great way to achieve that.

`ApplicationContextRunner` is usually defined as a field of the test class to gather the base, common configuration.
The following example makes sure that `UserServiceAutoConfiguration` is always invoked:

[source,java,indent=0]
----
include::{test-examples}/autoconfigure/UserServiceAutoConfigurationTests.java[tag=runner]
----

TIP: If multiple auto-configurations have to be defined, there is no need to order their declarations as they are invoked in the exact same order as when running the application.

Each test can use the runner to represent a particular use case.
For instance, the sample below invokes a user configuration (`UserConfiguration`) and checks that the auto-configuration backs off properly.
Invoking `run` provides a callback context that can be used with `Assert4J`.

[source,java,indent=0]
----
include::{test-examples}/autoconfigure/UserServiceAutoConfigurationTests.java[tag=test-user-config]
----

It is also possible to easily customize the `Environment`, as shown in the following example:

[source,java,indent=0]
----
include::{test-examples}/autoconfigure/UserServiceAutoConfigurationTests.java[tag=test-env]
----

The runner can also be used to display the `ConditionEvaluationReport`.
The report can be printed at `INFO` or `DEBUG` level.
The following example shows how to use the `ConditionEvaluationReportLoggingListener` to print the report in auto-configuration tests.

[source,java,indent=0]
----
	@Test
	public void autoConfigTest {
		ConditionEvaluationReportLoggingListener initializer = new ConditionEvaluationReportLoggingListener(
				LogLevel.INFO);
		ApplicationContextRunner contextRunner = new ApplicationContextRunner()
				.withInitializer(initializer).run((context) -> {
						// Do something...
				});
	}
----



==== Simulating a Web Context
If you need to test an auto-configuration that only operates in a Servlet or Reactive web application context, use the `WebApplicationContextRunner` or `ReactiveWebApplicationContextRunner` respectively.



==== Overriding the Classpath
It is also possible to test what happens when a particular class and/or package is not present at runtime.
Spring Boot ships with a `FilteredClassLoader` that can easily be used by the runner.
In the following example, we assert that if `UserService` is not present, the auto-configuration is properly disabled:

[source,java,indent=0]
----
include::{test-examples}/autoconfigure/UserServiceAutoConfigurationTests.java[tag=test-classloader]
----



[[boot-features-custom-starter]]
=== Creating Your Own Starter
A full Spring Boot starter for a library may contain the following components:

* The `autoconfigure` module that contains the auto-configuration code.
* The `starter` module that provides a dependency to the `autoconfigure` module as well as the library and any additional dependencies that are typically useful.
In a nutshell, adding the starter should provide everything needed to start using that library.

TIP: You may combine the auto-configuration code and the dependency management in a single module if you do not need to separate those two concerns.



[[boot-features-custom-starter-naming]]
==== Naming
You should make sure to provide a proper namespace for your starter.
Do not start your module names with `spring-boot`, even if you use a different Maven `groupId`.
We may offer official support for the thing you auto-configure in the future.

As a rule of thumb, you should name a combined module after the starter.
For example, assume that you are creating a starter for "acme" and that you name the auto-configure module `acme-spring-boot-autoconfigure` and the starter `acme-spring-boot-starter`.
If you only have one module that combines the two, name it `acme-spring-boot-starter`.



[[boot-features-custom-starter-configuration-keys]]
==== Configuration keys
If your starter provides configuration keys, use a unique namespace for them.
In particular, do not include your keys in the namespaces that Spring Boot uses (such as `server`, `management`, `spring`, and so on).
If you use the same namespace, we may modify these namespaces in the future in ways that break your modules.
As a rule of thumb, prefix all your keys with a namespace that you own (e.g. `acme`).

Make sure that configuration keys are documented by adding field javadoc for each property, as shown in the following example:

[source,java,indent=0]
----
	@ConfigurationProperties("acme")
	public class AcmeProperties {

		/**
		 * Whether to check the location of acme resources.
		 */
		private boolean checkLocation = true;

		/**
		 * Timeout for establishing a connection to the acme server.
		 */
		private Duration loginTimeout = Duration.ofSeconds(3);

		// getters & setters

	}
----

NOTE: You should only use simple text with `@ConfigurationProperties` field Javadoc, since they are not processed before being added to the JSON.

Here are some rules we follow internally to make sure descriptions are consistent:

* Do not start the description by "The" or "A".
* For `boolean` types, start the description with "Whether" or "Enable".
* For collection-based types, start the description with "Comma-separated list"
* Use `java.time.Duration` rather than `long` and describe the default unit if it differs from milliseconds, e.g. "If a duration suffix is not specified, seconds will be used".
* Do not provide the default value in the description unless it has to be determined at runtime.

Make sure to <<appendix-configuration-metadata.adoc#configuration-metadata-annotation-processor,trigger meta-data generation>> so that IDE assistance is available for your keys as well.
You may want to review the generated metadata (`META-INF/spring-configuration-metadata.json`) to make sure your keys are properly documented.
Using your own starter in a compatible IDE is also a good idea to validate that quality of the metadata.



[[boot-features-custom-starter-module-autoconfigure]]
==== `autoconfigure` Module
The `autoconfigure` module contains everything that is necessary to get started with the library.
It may also contain configuration key definitions (such as `@ConfigurationProperties`) and any callback interface that can be used to further customize how the components are initialized.

TIP: You should mark the dependencies to the library as optional so that you can include the `autoconfigure` module in your projects more easily.
If you do it that way, the library is not provided and, by default, Spring Boot backs off.

Spring Boot uses an annotation processor to collect the conditions on auto-configurations in a metadata file (`META-INF/spring-autoconfigure-metadata.properties`).
If that file is present, it is used to eagerly filter auto-configurations that do not match, which will improve startup time.
It is recommended to add the following dependency in a module that contains auto-configurations:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-autoconfigure-processor</artifactId>
		<optional>true</optional>
	</dependency>
----

With Gradle 4.5 and earlier, the dependency should be declared in the `compileOnly` configuration, as shown in the following example:

[source,groovy,indent=0,subs="verbatim,quotes,attributes"]
----
	dependencies {
		compileOnly "org.springframework.boot:spring-boot-autoconfigure-processor"
	}
----

With Gradle 4.6 and later, the dependency should be declared in the `annotationProcessor` configuration, as shown in the following example:

[source,groovy,indent=0,subs="verbatim,quotes,attributes"]
----
	dependencies {
		annotationProcessor "org.springframework.boot:spring-boot-autoconfigure-processor"
	}
----



[[boot-features-custom-starter-module-starter]]
==== Starter Module
The starter is really an empty jar.
Its only purpose is to provide the necessary dependencies to work with the library.
You can think of it as an opinionated view of what is required to get started.

Do not make assumptions about the project in which your starter is added.
If the library you are auto-configuring typically requires other starters, mention them as well.
Providing a proper set of _default_ dependencies may be hard if the number of optional dependencies is high, as you should avoid including dependencies that are unnecessary for a typical usage of the library.
In other words, you should not include optional dependencies.

NOTE: Either way, your starter must reference the core Spring Boot starter (`spring-boot-starter`) directly or indirectly (i.e. no need to add it if your starter relies on another starter).
If a project is created with only your custom starter, Spring Boot's core features will be honoured by the presence of the core starter.



[[boot-features-kotlin]]
== Kotlin support
https://kotlinlang.org[Kotlin] is a statically-typed language targeting the JVM (and other platforms) which allows writing concise and elegant code while providing {kotlin-docs}java-interop.html[interoperability] with existing libraries written in Java.

Spring Boot provides Kotlin support by leveraging the support in other Spring projects such as Spring Framework, Spring Data, and Reactor.
See the {spring-framework-docs}languages.html#kotlin[Spring Framework Kotlin support documentation] for more information.

The easiest way to start with Spring Boot and Kotlin is to follow https://spring.io/guides/tutorials/spring-boot-kotlin/[this comprehensive tutorial].
You can create new Kotlin projects via https://start.spring.io/#!language=kotlin[start.spring.io].
Feel free to join the #spring channel of https://slack.kotlinlang.org/[Kotlin Slack] or ask a question with the `spring` and `kotlin` tags on https://stackoverflow.com/questions/tagged/spring+kotlin[Stack Overflow] if you need support.



[[boot-features-kotlin-requirements]]
=== Requirements
Spring Boot supports Kotlin 1.3.x.
To use Kotlin, `org.jetbrains.kotlin:kotlin-stdlib` and `org.jetbrains.kotlin:kotlin-reflect` must be present on the classpath.
The `kotlin-stdlib` variants `kotlin-stdlib-jdk7` and `kotlin-stdlib-jdk8` can also be used.

Since https://discuss.kotlinlang.org/t/classes-final-by-default/166[Kotlin classes are final by default], you are likely to want to configure {kotlin-docs}compiler-plugins.html#spring-support[kotlin-spring] plugin in order to automatically open Spring-annotated classes so that they can be proxied.

https://github.com/FasterXML/jackson-module-kotlin[Jackson's Kotlin module] is required for serializing / deserializing JSON data in Kotlin.
It is automatically registered when found on the classpath.
A warning message is logged if Jackson and Kotlin are present but the Jackson Kotlin module is not.

TIP: These dependencies and plugins are provided by default if one bootstraps a Kotlin project on https://start.spring.io/#!language=kotlin[start.spring.io].



[[boot-features-kotlin-null-safety]]
=== Null-safety
One of Kotlin's key features is {kotlin-docs}null-safety.html[null-safety].
It deals with `null` values at compile time rather than deferring the problem to runtime and encountering a `NullPointerException`.
This helps to eliminate a common source of bugs without paying the cost of wrappers like `Optional`.
Kotlin also allows using functional constructs with nullable values as described in this https://www.baeldung.com/kotlin-null-safety[comprehensive guide to null-safety in Kotlin].

Although Java does not allow one to express null-safety in its type system, Spring Framework, Spring Data, and Reactor now provide null-safety of their API via tooling-friendly annotations.
By default, types from Java APIs used in Kotlin are recognized as {kotlin-docs}java-interop.html#null-safety-and-platform-types[platform types] for which null-checks are relaxed.
{kotlin-docs}java-interop.html#jsr-305-support[Kotlin's support for JSR 305 annotations] combined with nullability annotations provide null-safety for the related Spring API in Kotlin.

The JSR 305 checks can be configured by adding the `-Xjsr305` compiler flag with the following options: `-Xjsr305={strict|warn|ignore}`.
The default behavior is the same as `-Xjsr305=warn`.
The `strict` value is required to have null-safety taken in account in Kotlin types inferred from Spring API but should be used with the knowledge that Spring API nullability declaration could evolve even between minor releases and more checks may be added in the future).

WARNING: Generic type arguments, varargs and array elements nullability are not yet supported.
See https://jira.spring.io/browse/SPR-15942[SPR-15942] for up-to-date information.
Also be aware that Spring Boot's own API is {github-issues}10712[not yet annotated].



[[boot-features-kotlin-api]]
=== Kotlin API



[[boot-features-kotlin-api-runapplication]]
==== runApplication
Spring Boot provides an idiomatic way to run an application with `runApplication<MyApplication>(*args)` as shown in the following example:

[source,kotlin,indent=0]
----
	import org.springframework.boot.autoconfigure.SpringBootApplication
	import org.springframework.boot.runApplication

	@SpringBootApplication
	class MyApplication

	fun main(args: Array<String>) {
		runApplication<MyApplication>(*args)
	}
----

This is a drop-in replacement for `SpringApplication.run(MyApplication::class.java, *args)`.
It also allows customization of the application as shown in the following example:

[source,kotlin,indent=0]
----
	runApplication<MyApplication>(*args) {
		setBannerMode(OFF)
	}
----



[[boot-features-kotlin-api-extensions]]
==== Extensions
Kotlin {kotlin-docs}extensions.html[extensions] provide the ability to extend existing classes with additional functionality.
The Spring Boot Kotlin API makes use of these extensions to add new Kotlin specific conveniences to existing APIs.

`TestRestTemplate` extensions, similar to those provided by Spring Framework for `RestOperations` in Spring Framework, are provided.
Among other things, the extensions make it possible to take advantage of Kotlin reified type parameters.



[[boot-features-kotlin-dependency-management]]
=== Dependency management
In order to avoid mixing different versions of Kotlin dependencies on the classpath, Spring Boot imports the Kotlin BOM.

With Maven, the Kotlin version can be customized via the `kotlin.version` property and plugin management is provided for `kotlin-maven-plugin`.
With Gradle, the Spring Boot plugin automatically aligns the `kotlin.version` with the version of the Kotlin plugin.

Spring Boot also manages the version of Coroutines dependencies by importing the Kotlin Coroutines BOM.
The version can be customized via the `kotlin-coroutines.version` property.

TIP: `org.jetbrains.kotlinx:kotlinx-coroutines-reactor` dependency is provided by default if one bootstraps a Kotlin project with at least one reactive dependency on https://start.spring.io/#!language=kotlin[start.spring.io].


[[boot-features-kotlin-configuration-properties]]
=== `@ConfigurationProperties`
`@ConfigurationProperties` when used in combination with <<boot-features-external-config-constructor-binding,`@ConstructorBinding`>> supports classes with immutable `val` properties as shown in the following example:

[source,kotlin,indent=0]
----
@ConstructorBinding
@ConfigurationProperties("example.kotlin")
data class KotlinExampleProperties(
		val name: String,
		val description: String,
		val myService: MyService) {

	data class MyService(
			val apiToken: String,
			val uri: URI
	)
}
----

TIP: To generate <<appendix-configuration-metadata.adoc#configuration-metadata-annotation-processor,your own metadata>> using the annotation processor, {kotlin-docs}kapt.html[`kapt` should be configured] with the `spring-boot-configuration-processor` dependency.
Note that some features (such as detecting the default value or deprecated items) are not working due to limitations in the model kapt provides.



[[boot-features-kotlin-testing]]
=== Testing
While it is possible to use JUnit 4 to test Kotlin code, JUnit 5 is provided by default and is recommended.
JUnit 5 enables a test class to be instantiated once and reused for all of the class's tests.
This makes it possible to use `@BeforeClass` and `@AfterClass` annotations on non-static methods, which is a good fit for Kotlin.

JUnit 5 is the default and the vintage engine is provided for backward compatibility with JUnit 4.
If you don't use it, exclude `org.junit.vintange:junit-vintage-engine`.
You also need to {junit5-docs}/#writing-tests-test-instance-lifecycle-changing-default[switch test instance lifecycle to "per-class"].

To mock Kotlin classes, https://mockk.io/[MockK] is recommended.
If you need the `Mockk` equivalent of the Mockito specific <<boot-features-testing-spring-boot-applications-mocking-beans,`@MockBean` and `@SpyBean` annotations>>, you can use https://github.com/Ninja-Squad/springmockk[SpringMockK] which provides similar `@MockkBean` and `@SpykBean` annotations.



[[boot-features-kotlin-resources]]
=== Resources



[[boot-features-kotlin-resources-further-reading]]
==== Further reading
* {kotlin-docs}[Kotlin language reference]
* https://slack.kotlinlang.org/[Kotlin Slack] (with a dedicated #spring channel)
* https://stackoverflow.com/questions/tagged/spring+kotlin[Stackoverflow with `spring` and `kotlin` tags]
* https://try.kotlinlang.org/[Try Kotlin in your browser]
* https://blog.jetbrains.com/kotlin/[Kotlin blog]
* https://kotlin.link/[Awesome Kotlin]
* https://spring.io/guides/tutorials/spring-boot-kotlin/[Tutorial: building web applications with Spring Boot and Kotlin]
* https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin[Developing Spring Boot applications with Kotlin]
* https://spring.io/blog/2016/03/20/a-geospatial-messenger-with-kotlin-spring-boot-and-postgresql[A Geospatial Messenger with Kotlin, Spring Boot and PostgreSQL]
* https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0[Introducing Kotlin support in Spring Framework 5.0]
* https://spring.io/blog/2017/08/01/spring-framework-5-kotlin-apis-the-functional-way[Spring Framework 5 Kotlin APIs, the functional way]



[[boot-features-kotlin-resources-examples]]
==== Examples
* https://github.com/sdeleuze/spring-boot-kotlin-demo[spring-boot-kotlin-demo]: regular Spring Boot + Spring Data JPA project
* https://github.com/mixitconf/mixit[mixit]: Spring Boot 2 + WebFlux + Reactive Spring Data MongoDB
* https://github.com/sdeleuze/spring-kotlin-fullstack[spring-kotlin-fullstack]: WebFlux Kotlin fullstack example with Kotlin2js for frontend instead of JavaScript or TypeScript
* https://github.com/spring-petclinic/spring-petclinic-kotlin[spring-petclinic-kotlin]: Kotlin version of the Spring PetClinic Sample Application
* https://github.com/sdeleuze/spring-kotlin-deepdive[spring-kotlin-deepdive]: a step by step migration for Boot 1.0 + Java to Boot 2.0 + Kotlin
* https://github.com/sdeleuze/spring-boot-coroutines-demo[spring-boot-coroutines-demo]: Coroutines sample project



[[boot-features-whats-next]]
== What to Read Next
If you want to learn more about any of the classes discussed in this section, you can check out the {spring-boot-api}[Spring Boot API documentation] or you can browse the {spring-boot-code}[source code directly].
If you have specific questions, take a look at the <<howto.adoc#howto, how-to>> section.

If you are comfortable with Spring Boot's core features, you can continue on and read about <<production-ready-features.adoc#production-ready, production-ready features>>.
