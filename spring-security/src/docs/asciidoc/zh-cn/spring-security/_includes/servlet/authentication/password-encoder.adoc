[[core-services-password-encoding]]
== 密码编码器

Spring Security的 PasswordEncoder接口用于支持密码以某种方式在持久存储中进行编码。你不应该在纯文本中存储密码。总是使用单向密码算法如BCrypt使用内置的混淆值，对于每个存储的密码都是不同的。不要使用普通的哈希函数，如MD5或SHA，甚至是一个混淆的版本。
BCrypt是故意设计成慢，用于阻碍离线密码破解，而标准的散列算法是快速和能轻易地被用来测试在并行密码定制的硬件上。你可能会认为这并不适用于你，因为你的密码数据库是安全的，和离线攻击不是一个风险线上的。
如果是这样的话，做一些研究并阅读所有的高知名度、一直被嘲笑存储密码不安全并已妥协的网站。

Spring Security的 `PasswordEncoder` 接口用于对密码进行单向转换，以确保密码可以安全地存储。
鉴于PasswordEncoder是一种单向转换，因此当密码转换需要采用两种方式（即存储用于向数据库进行身份验证的凭据）时，则不打算使用它。 通常，`PasswordEncoder` 用于存储需要在身份验证时与用户提供的密码进行比较的密码。

[[pe-history]]
=== Password 发展历史



[[pe-dpe]]
=== DelegatingPasswordEncoder



[[pe-dpe-format]]
==== 密码存储格式

密码的一般格式是：

[source,text]
----
{id}encodedPassword
----

这样 `id` 是用于查找应该使用 `PasswordEncoder` 的标识符，`encodedPassword` 是所选 `PasswordEncoder` 的原始编码密码。 `id` 必须位于密码的开头，以 `{` 开头，以 `}` 结束。如果找不到 `id`，则 `id` 将为 `null`。例如，以下可能是使用不同 `id` 编码的密码列表。所有原始密码都是 "password".。


[source,text]
----
{bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG // <1>
{noop}password // <2>
{pbkdf2}5d923b44a6d129f3ddf3e3c8d29412723dcbde72445e8ef6bf3b508fbf17fa4ed4d6b99ca763d8dc // <3>
{scrypt}$e0801$8bWJaSu2IKSn9Z9kM+TPXfOc/9bdYSrN1oD9qfVThWEwdRTnO7re7Ei+fUZRJ68k9lTyuTeUp4of4g24hHnazw==$OAOec05+bXxvuu/1qZ6NUR+xQYvYv7BeL1QxwRpY5Pc=  // <4>
{sha256}97cde38028ad898ebc02e690819fa220e88c62e0699403e94fff291cfffaf8410849f27605abcbc0 // <5>
----

一些用户可能担心为潜在的黑客提供存储格式。这不是问题，因为密码的存储不依赖于算法是 secret。此外，大多数格式很容易让攻击者在没有前缀的情况下弄清楚。例如，BCrypt 密码通常以$2a$开头。

<1> 第一个密码是 id 为 `bcrypt` 的 `PasswordEncoder`，encodedPassword 为 `$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG`。匹配时会委托给 `BCryptPasswordEncoder`
<2> 第二个密码是 id 为 `noop` 的 `PasswordEncoder`，encodedPassword 为 `password`。匹配时会委托给 `NoOpPasswordEncoder`
<3> 第三个密码是 id 为 `pbkdf2` 的 `PasswordEncoder`，encodedPassword 为 `5d923b44a6d129f3ddf3e3c8d29412723dcbde72445e8ef6bf3b508fbf17fa4ed4d6b99ca763d8dc`。匹配时会委托给 `Pbkdf2PasswordEncoder`
<4> 第四个密码是 id 为 `scrypt` 的 `PasswordEncoder`，encodedPassword 为 `$e0801$8bWJaSu2IKSn9Z9kM+TPXfOc/9bdYSrN1oD9qfVThWEwdRTnO7re7Ei+fUZRJ68k9lTyuTeUp4of4g24hHnazw==$OAOec05+bXxvuu/1qZ6NUR+xQYvYv7BeL1QxwRpY5Pc=` ,匹配时它将委托给 `SCryptPasswordEncoder`
<5> 最后一个密码是 id 为 `sha256`  的 `PasswordEncoder` ，encodedPassword 为 `97cde38028ad898ebc02e690819fa220e88c62e0699403e94fff291cfffaf8410849f27605abcbc0`。匹配时会委托给 `StandardPasswordEncoder`


[NOTE]
====
一些用户可能担心为潜在的黑客提供存储格式。这不是问题，因为密码的存储不依赖于算法是 secret。此外，大多数格式很容易让攻击者在没有前缀的情况下弄清楚。例如，BCrypt 密码通常以 `$2a$` 开头。
====

==== 密码编码


[source,text]
----
{bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG
----

==== 密码匹配

匹配是基于 `{id}` 以及构造函数中提供的 `id` 到 `PasswordEncoder` 的映射完成的。我们在<<Password Storage Format,密码存储格式>> 一节中的 example 提供了一个如何完成的工作示例。默认情况下，使用密码调用 `matches(CharSequence, String)` 和未映射的id(包括空 `id`)的结果将导致 `IllegalArgumentException`。
可以使用 `DelegatingPasswordEncoder.setDefaultPasswordEncoderForMatches(PasswordEncoder)` 自定义此行为。

通过使用 `id`，我们可以匹配任何密码编码，但使用最现代的密码编码。这很重要，
因为与加密不同，密码哈希的设计使得没有简单的方法来恢复明文。由于无法恢复明文，因此难以迁移密码。虽然用户很容易迁移 `NoOpPasswordEncoder`，但我们默认选择将其包含在内，但不是默认的 `PasswordEncoder`. 以便简化入门体验。

==== 入门体验

如果您要编写演示或示例，则花一些时间来对用户密码进行哈希运算会很麻烦。 有一些便利机制可以简化此过程，但这仍然不适合生产。

[source,java]
----
User user = User.withDefaultPasswordEncoder()
  .username("user")
  .password("password")
  .roles("user")
  .build();
System.out.println(user.getPassword());
// {bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG
----

如果要创建多个用户，则还可以重复使用该构建器。

[source,java]
----
UserBuilder users = User.withDefaultPasswordEncoder();
User user = users
  .username("user")
  .password("password")
  .roles("USER")
  .build();
User admin = users
  .username("admin")
  .password("password")
  .roles("USER","ADMIN")
  .build();
----

这会散列存储的密码，但是密码仍在内存和已编译的源代码中公开。 因此，对于生产环境它仍然不被认为是安全的。 对于生产，您应该在外部对密码进行哈希处理。

==== 故障排除

如果 <<pe-dpe-format,密码存储格式>> 一节中描述的其中一个密码没有 id，则会发生以下错误。.

----
java.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id "null"
	at org.springframework.security.crypto.password.DelegatingPasswordEncoder$UnmappedIdPasswordEncoder.matches(DelegatingPasswordEncoder.java:233)
	at org.springframework.security.crypto.password.DelegatingPasswordEncoder.matches(DelegatingPasswordEncoder.java:196)
----

解决错误的最简单方法是切换到显式提供密码编码的 `PasswordEncoder`。解决问题的最简单方法是弄清楚当前如何存储密码并明确提供正确的 `PasswordEncoder`。
如果要从 Spring Security 4.2.x 进行迁移，则可以通过公开 `NoOpPasswordEncoder` bean 恢复到先前的行为。例如，如果您使用的是 Java Configuration，则可以创建一个如下所示的 configuration：

[WARNING]
====
恢复为 `NoOpPasswordEncoder` 被认为是不安全的。 相反，您应该迁移到使用 `DelegatingPasswordEncoder` 支持安全密码编码。
====

[source,java]
----
@Bean
public static NoOpPasswordEncoder passwordEncoder() {
    return NoOpPasswordEncoder.getInstance();
}
----

如果您使用的是XML配置，则可以公开一个ID为 `passwordEncoder` 的 `PasswordEncoder`：

[source,xml]
----
<b:bean id="passwordEncoder"
        class="org.springframework.security.crypto.password.NoOpPasswordEncoder" factory-method="getInstance"/>
----


或者，您可以为所有密码加上正确的ID前缀，然后继续使用 `DelegatingPasswordEncoder`。 例如，如果您使用的是 `BCrypt`，则可以从以下方式迁移密码：

----
$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG
----

to

----
{bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG
----

有关映射的完整列表，请参阅 https://docs.spring.io/spring-security/site/docs/5.0.x/api/org/springframework/security/crypto/factory/PasswordEncoderFactories.html[PasswordEncoderFactories] 上的Javadoc。
.

[[pe-bcpe]]
=== BCryptPasswordEncoder

`BCryptPasswordEncoder` 实现使用广泛支持的 https://en.wikipedia.org/wiki/Bcrypt[bcrypt] 算法对密码进行哈希处理。 为了使其更能抵抗密码破解，`bcrypt` 故意降低了速度。 与其他自适应单向功能一样，应将其调整为大约1秒钟，以验证系统上的密码。

[source,java]
----
// Create an encoder with strength 16
BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(16);
String result = encoder.encode("myPassword");
assertTrue(encoder.matches("myPassword", result));
----

[[pe-a2pe]]
=== Argon2PasswordEncoder

`Argon2PasswordEncoder` 实现使用 Argon2 算法对密码进行哈希处理。 https://en.wikipedia.org/wiki/Argon2[Argon2] 是 https://en.wikipedia.org/wiki/Password_Hashing_Competition[Password Hashing Competition] 的获胜者。 为了克服自定义硬件上的密码破解问题，`Argon2` 是一种故意慢速的算法，需要大量内存。
与其他自适应单向功能一样，应将其调整为大约1秒钟，以验证系统上的密码。 如果 `Argon2PasswordEncoder` 需要 BouncyCastle，则为当前实现。

[source,java]
----
// Create an encoder with all the defaults
Argon2PasswordEncoder encoder = new Argon2PasswordEncoder();
String result = encoder.encode("myPassword");
assertTrue(encoder.matches("myPassword", result));
----

[[pe-pbkdf2pe]]
=== Pbkdf2PasswordEncoder


[source,java]
----
// Create an encoder with all the defaults
Pbkdf2PasswordEncoder encoder = new Pbkdf2PasswordEncoder();
String result = encoder.encode("myPassword");
assertTrue(encoder.matches("myPassword", result));
----

[[pe-scpe]]
=== SCryptPasswordEncoder


[source,java]
----
// Create an encoder with all the defaults
SCryptPasswordEncoder encoder = new SCryptPasswordEncoder();
String result = encoder.encode("myPassword");
assertTrue(encoder.matches("myPassword", result));
----

=== 其他的 PasswordEncoders


[[ns-password-encoder]]
=== Password Encoder XML 配置
密码应始终使用安全哈希算法（而不是诸如SHA或MD5的标准算法）进行编码。`<password-encoder>` 元素支持此功能。 使用 bcrypt 编码的密码，原始身份验证提供程序配置将如下所示：

[source,xml]
----
<beans:bean name="bcryptEncoder"
	class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"/>

<authentication-manager>
<authentication-provider>
	<password-encoder ref="bcryptEncoder"/>
	<user-service>
	<user name="jimi" password="$2a$10$ddEWZUl8aU0GdZPPpy7wbu82dvEw/pBpbRvDQRqA41y6mK1CoH00m"
			authorities="ROLE_USER, ROLE_ADMIN" />
	<user name="bob" password="$2a$10$/elFpMBnAYYig6KRR5bvOOYeZr1ie1hSogJryg9qDlhza4oCw1Qka"
			authorities="ROLE_USER" />
	</user-service>
</authentication-provider>
</authentication-manager>

----

在大多数情况下，bcrypt是一个不错的选择，除非您有一个旧系统迫使您使用其他算法。 如果您使用的是简单的哈希算法，或者更糟的是存储纯文本密码，则应考虑迁移到更安全的选项，例如bcrypt。