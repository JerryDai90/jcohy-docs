[[redis]]
= Redis 支持
:referenceDir: .

Spring Data 支持的 key-value 存储之一是 Redis. 下面这句话引用自 https://redis.io[Redis] 项目主页:

[quote]
Redis 是高级键值存储. 它类似于 memcached,但数据集是不易失的,值可以是字符串,就像在 memcached 中一样,也可以是列表,集合和有序集合.
所有这些数据类型都可以通过原子操作进行操作,以 push/pop 元素, add/remove 元素,包括 union,intersection,集合之间的差异等. Redis 支持不同种类的排序功能.

Spring Data Redis 提供了简单的配置,并可以从 Spring 应用程序访问 Redis. 它提供了与 store 交互的低层和高层抽象,使用户摆脱了基础配置的困扰.

[[redis:requirements]]
== Redis 要求

Spring Redis 需要 Redis 2.6 或更高版本,Spring Data Redis 与 https://github.com/lettuce-io/lettuce-core[Lettuce] 和 https://github.com/xetorthio/jedis[Jedis] 集成,这是两个流行的 Redis 开源 Java 库.

[[redis:architecture]]
== Redis 支持高级视图

Redis 提供了几个组件. 对于大多数任务,高级抽象和支持服务是最佳选择. 请注意,您可以随时在视图之间移动. 例如,您可以获得底层连接(甚至本地库)以直接与 Redis 通信.

[[redis:connectors]]
== 连接到 Redis

使用 Redis 和 Spring 时的首要任务之一是通过IoC容器连接到 store. 为此,需要 Java 连接器(或绑定). 无论选择哪种库,您都只需要使用一组 Spring Data Redis API(在所有连接器上都保持一致):
使用 `org.springframework.data.redis.connection` 包下的 `RedisConnection` 和 `RedisConnectionFactory` 接口即可自动检索 与 Redis 的活动连接.

[[redis:connectors:connection]]
=== RedisConnection 和 RedisConnectionFactory

`RedisConnection` 提供了 Redis 通信的核心模块,因为它处理与 Redis 服务端的通信. 它还会自动将底层连接库异常转换为 Spring 的 DAO 异常 https://docs.spring.io/spring/docs/{springVersion}/spring-framework-reference/data-access.html#dao-exceptions[层次结构],以便您可以在不更改任何代码的情况下切换连接器,因为操作语义保持不变.

NOTE: 对于需要本地库API的特殊情况,`RedisConnection` 提供了专用方法(`getNativeConnection`),该方法返回用于通信的原始底层对象.

激活的 `RedisConnection` 对象是通过 `RedisConnectionFactory` 创建的. 另外,工厂还充当 `PersistenceExceptionTranslator` 对象,这意味着一旦声明,它们就可以让您进行透明的异常转换.
例如,您可以使用 `@Repository` 注解和AOP进行异常转换. 有关更多信息,请参见 Spring Framework 文档中的 https://docs.spring.io/spring/docs/{springVersion}/spring-framework-reference/data-access.html#orm-exception-translation[相关部分].

NOTE: 根据底层配置,工厂可以返回新连接或现有连接(使用池或共享本地连接时).

使用 `RedisConnectionFactory` 的最简单方法是通过IoC容器配置适当的连接器,并将其注入 using 类.

IMPORTANT: 不幸的是,当前,并非所有连接器都支持所有 Redis 功能. 在底层库不支持的 Connection API 上调用方法时,将抛出 `UnsupportedOperationException`.

[[redis:connectors:lettuce]]
=== 配置 Lettuce 连接器

https://github.com/lettuce-io/lettuce-core[Lettuce] 是一个基于 https://netty.io/[Netty] 的 开源连接器。Spring Data Redis 通过 `org.springframework.data.redis.connection.lettuce` 包提供支持。 以下示例显示了如何创建新的 Lettuce 连接工厂：

[source,java]
----
@Configuration
class AppConfig {

  @Bean
  public LettuceConnectionFactory redisConnectionFactory() {

    return new LettuceConnectionFactory(new RedisStandaloneConfiguration("server", 6379));
  }
}
----

还可以调整  Lettuce 连接参数。`LettuceConnectionFactory` 创建的所有 `LettuceConnection` 实例并且对于所有非阻塞和非事务操作共享相同的线程安全本机连接。 要每次使用特定连接，请将 `shareNativeConnection` 设置为 `false`。
如果将 `shareNativeConnection` 设置为 `false`，则还可以将 `LettuceConnectionFactory` 配置为使用 `LettucePool` 来池化阻塞和事务连接或所有连接。

Lettuce 与 Netty 的 https://netty.io/wiki/native-transports.html[native transports] 集成，可让您使用Unix域套接字与Redis通信。 确保包括与您的运行时环境匹配的适当的本机传输依赖项。 以下示例显示了如何在 `/var/run/redis.sock` 上为Unix域套接字创建 Lettuce Connection 工厂：

[source,java]
----
@Configuration
class AppConfig {

  @Bean
  public LettuceConnectionFactory redisConnectionFactory() {

    return new LettuceConnectionFactory(new RedisSocketConfiguration("/var/run/redis.sock"));
  }
}
----

NOTE: Netty 当前支持用于OS本地传输的epoll（Linux）和 kqueue (BSD/macOS)接口。

[[redis:connectors:jedis]]
=== 配置Jedis连接器

Jedis 是一个社区驱动的连接器， Spring Data Redis 模块通过 `org.springframework.data.redis.connection.jedis` 包支持。 Jedis配置以最简单的形式如下所示：

[source,java]
----
@Configuration
class AppConfig {

  @Bean
  public JedisConnectionFactory redisConnectionFactory() {
    return new JedisConnectionFactory();
  }
}
----

但是，对于生产用途，您可能想要调整主机或密码等设置，如以下示例所示：

[source,java]
----
@Configuration
class RedisConfiguration {

  @Bean
  public JedisConnectionFactory redisConnectionFactory() {

    RedisStandaloneConfiguration config = new RedisStandaloneConfiguration("server", 6379);
    return new JedisConnectionFactory(config);
  }
}
----

[[redis:write-to-master-read-from-replica]]
=== Write to Master, Read from Replica

The Redis Master/Replica setup -- without automatic failover (for automatic failover see: <<redis:sentinel, Sentinel>>) -- not only allows data to be safely stored at more nodes. It also allows, by using <<redis:connectors:lettuce, Lettuce>>, reading data from replicas while pushing writes to the master. You can set the read/write strategy to be used by using `LettuceClientConfiguration`, as shown in the following example:

[source,java]
----
@Configuration
class WriteToMasterReadFromReplicaConfiguration {

  @Bean
  public LettuceConnectionFactory redisConnectionFactory() {

    LettuceClientConfiguration clientConfig = LettuceClientConfiguration.builder()
      .readFrom(SLAVE_PREFERRED)
      .build();

    RedisStandaloneConfiguration serverConfig = new RedisStandaloneConfiguration("server", 6379);

    return new LettuceConnectionFactory(serverConfig, clientConfig);
  }
}
----

TIP: For environments reporting non-public addresses through the `INFO` command (for example, when using AWS), use `RedisStaticMasterReplicaConfiguration` instead of `RedisStandaloneConfiguration`. Please note that `RedisStaticMasterReplicaConfiguration` does not support Pub/Sub because of missing Pub/Sub message propagation across individual servers.

[[redis:sentinel]]
== Redis Sentinel Support

For dealing with high-availability Redis, Spring Data Redis has support for https://redis.io/topics/sentinel[Redis Sentinel], using `RedisSentinelConfiguration`, as shown in the following example:

[source,java]
----
/**
 * Jedis
 */
@Bean
public RedisConnectionFactory jedisConnectionFactory() {
  RedisSentinelConfiguration sentinelConfig = new RedisSentinelConfiguration()
  .master("mymaster")
  .sentinel("127.0.0.1", 26379)
  .sentinel("127.0.0.1", 26380);
  return new JedisConnectionFactory(sentinelConfig);
}

/**
 * Lettuce
 */
@Bean
public RedisConnectionFactory lettuceConnectionFactory() {
  RedisSentinelConfiguration sentinelConfig = new RedisSentinelConfiguration()
  .master("mymaster")
  .sentinel("127.0.0.1", 26379)
  .sentinel("127.0.0.1", 26380);
  return new LettuceConnectionFactory(sentinelConfig);
}
----

[TIP]
====
`RedisSentinelConfiguration` can also be defined with a `PropertySource`, which lets you set the following properties:

.Configuration Properties
* `spring.redis.sentinel.master`: name of the master node.
* `spring.redis.sentinel.nodes`: Comma delimited list of host:port pairs.
* `spring.redis.sentinel.password`: The password to apply when authenticating with Redis Sentinel
====

Sometimes, direct interaction with one of the Sentinels is required. Using `RedisConnectionFactory.getSentinelConnection()` or `RedisConnection.getSentinelCommands()` gives you access to the first active Sentinel configured.

[NOTE]
====
Sentinel authentication is only available using https://lettuce.io/[Lettuce].
====

[[redis:template]]
== Working with Objects through RedisTemplate

Most users are likely to use `RedisTemplate` and its corresponding package, `org.springframework.data.redis.core`. The template is, in fact, the central class of the Redis module, due to its rich feature set. The template offers a high-level abstraction for Redis interactions. While `RedisConnection` offers low-level methods that accept and return binary values (`byte` arrays), the template takes care of serialization and connection management, freeing the user from dealing with such details.

Moreover, the template provides operations views (following the grouping from the Redis command https://redis.io/commands[reference]) that offer rich, generified interfaces for working against a certain type or certain key (through the `KeyBound` interfaces) as described in the following table:

.Operational views
[width="80%",cols="<1,<2",options="header"]
|====
|Interface
|Description

2+^|_Key Type Operations_

|`GeoOperations`
|Redis geospatial operations, such as `GEOADD`, `GEORADIUS`,...

|`HashOperations`
|Redis hash operations

|`HyperLogLogOperations`
|Redis HyperLogLog operations, such as `PFADD`, `PFCOUNT`,...

|`ListOperations`
|Redis list operations

|`SetOperations`
|Redis set operations

|`ValueOperations`
|Redis string (or value) operations

|`ZSetOperations`
|Redis zset (or sorted set) operations

2+^|_Key Bound Operations_

|`BoundGeoOperations`
|Redis key bound geospatial operations

|`BoundHashOperations`
|Redis hash key bound operations

|`BoundKeyOperations`
|Redis key bound operations

|`BoundListOperations`
|Redis list key bound operations

|`BoundSetOperations`
|Redis set key bound operations

|`BoundValueOperations`
|Redis string (or value) key bound operations

|`BoundZSetOperations`
|Redis zset (or sorted set) key bound operations

|====

Once configured, the template is thread-safe and can be reused across multiple instances.

`RedisTemplate` uses a Java-based serializer for most of its operations. This means that any object written or read by the template is serialized and deserialized through Java. You can change the serialization mechanism on the template, and the Redis module offers several implementations, which are available in the `org.springframework.data.redis.serializer` package. See <<redis:serializer>> for more information. You can also set any of the serializers to null and use RedisTemplate with raw byte arrays by setting the `enableDefaultSerializer` property to `false`. Note that the template requires all keys to be non-null. However, values can be null as long as the underlying serializer accepts them. Read the Javadoc of each serializer for more information.

For cases where you need a certain template view, declare the view as a dependency and inject the template. The container automatically performs the conversion, eliminating the `opsFor[X]` calls, as shown in the following example:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:p="http://www.springframework.org/schema/p"
  xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd">

  <bean id="jedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" p:use-pool="true"/>
  <!-- redis template definition -->
  <bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate" p:connection-factory-ref="jedisConnectionFactory"/>
  ...

</beans>
----

[source,java]
----
public class Example {

  // inject the actual template
  @Autowired
  private RedisTemplate<String, String> template;

  // inject the template as ListOperations
  @Resource(name="redisTemplate")
  private ListOperations<String, String> listOps;

  public void addLink(String userId, URL url) {
    listOps.leftPush(userId, url.toExternalForm());
  }
}
----

[[redis:string]]
== String-focused Convenience Classes

Since it is quite common for the keys and values stored in Redis to be `java.lang.String`, the Redis modules provides two extensions to `RedisConnection` and `RedisTemplate`, respectively the `StringRedisConnection` (and its `DefaultStringRedisConnection` implementation) and `StringRedisTemplate` as a convenient one-stop solution for intensive String operations. In addition to being bound to `String` keys, the template and the connection use the `StringRedisSerializer` underneath, which means the stored keys and values are human-readable (assuming the same encoding is used both in Redis and your code). The following listings show an example:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:p="http://www.springframework.org/schema/p"
  xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd">

  <bean id="jedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" p:use-pool="true"/>

  <bean id="stringRedisTemplate" class="org.springframework.data.redis.core.StringRedisTemplate" p:connection-factory-ref="jedisConnectionFactory"/>
  ...
</beans>
----

[source,java]
----
public class Example {

  @Autowired
  private StringRedisTemplate redisTemplate;

  public void addLink(String userId, URL url) {
    redisTemplate.opsForList().leftPush(userId, url.toExternalForm());
  }
}
----

As with the other Spring templates, `RedisTemplate` and `StringRedisTemplate` let you talk directly to Redis through the `RedisCallback` interface. This feature gives complete control to you, as it talks directly to the `RedisConnection`. Note that the callback receives an instance of `StringRedisConnection` when a `StringRedisTemplate` is used. The following example shows how to use the `RedisCallback` interface:

[source,java]
----
public void useCallback() {

  redisTemplate.execute(new RedisCallback<Object>() {
    public Object doInRedis(RedisConnection connection) throws DataAccessException {
      Long size = connection.dbSize();
      // Can cast to StringRedisConnection if using a StringRedisTemplate
      ((StringRedisConnection)connection).set("key", "value");
    }
   });
}
----

[[redis:serializer]]
== Serializers

From the framework perspective, the data stored in Redis is only bytes. While Redis itself supports various types, for the most part, these refer to the way the data is stored rather than what it represents. It is up to the user to decide whether the information gets translated into strings or any other objects.

In Spring Data, the conversion between the user (custom) types and raw data (and vice-versa) is handled Redis in the `org.springframework.data.redis.serializer` package.

This package contains two types of serializers that, as the name implies, take care of the serialization process:

* Two-way serializers based on ``RedisSerializer``.
* Element readers and writers that use `RedisElementReader` and ``RedisElementWriter``.

The main difference between these variants is that `RedisSerializer` primarily serializes to `byte[]` while readers and writers use `ByteBuffer`.

Multiple implementations are available (including two that have been already mentioned in this documentation):

* `JdkSerializationRedisSerializer`, which is used by default for `RedisCache` and `RedisTemplate`.
* the `StringRedisSerializer`.

However one can use `OxmSerializer` for Object/XML mapping through Spring https://docs.spring.io/spring/docs/{springVersion}/spring-framework-reference/data-access.html#oxm[OXM] support or `Jackson2JsonRedisSerializer` or `GenericJackson2JsonRedisSerializer` for storing data in https://en.wikipedia.org/wiki/JSON[JSON] format.

Do note that the storage format is not limited only to values. It can be used for keys, values, or hashes without any restrictions.

[WARNING]
====
By default, `RedisCache` and `RedisTemplate` are configured to use Java native serialization. Java native serialization is known for allowing remote code execution caused by payloads that exploit vulnerable libraries and classes injecting unverified bytecode. Manipulated input could lead to unwanted code execution in the application during the deserialization step. As a consequence, do not use serialization in untrusted environments. In general, we strongly recommend any other message format (such as JSON) instead.

If you are concerned about security vulnerabilities due to Java serialization, consider the general-purpose serialization filter mechanism at the core JVM level, originally developed for JDK 9 but backported to JDK 8, 7, and 6:

* https://blogs.oracle.com/java-platform-group/entry/incoming_filter_serialization_data_a[Filter Incoming Serialization Data].
* https://openjdk.java.net/jeps/290[JEP 290].
* https://www.owasp.org/index.php/Deserialization_of_untrusted_data[OWASP: Deserialization of untrusted data].
====

[[redis.hashmappers.root]]
== Hash mapping

Data can be stored by using various data structures within Redis. `Jackson2JsonRedisSerializer` can convert objects in https://en.wikipedia.org/wiki/JSON[JSON] format. Ideally, JSON can be stored as a value by using plain keys. You can achieve a more sophisticated mapping of structured objects by using Redis hashes. Spring Data Redis offers various strategies for mapping data to hashes (depending on the use case):

* Direct mapping, by using `HashOperations` and a <<redis:serializer,serializer>>
* Using <<redis.repositories>>
* Using `HashMapper` and `HashOperations`

=== Hash Mappers

Hash mappers are converters of map objects to a `Map<K, V>` and back. `HashMapper` is intended for using with Redis Hashes.

Multiple implementations are available:

* `BeanUtilsHashMapper` using Spring's https://docs.spring.io/spring/docs/{springVersion}/javadoc-api/org/springframework/beans/BeanUtils.html[BeanUtils].
* `ObjectHashMapper` using <<redis.repositories.mapping>>.
* <<redis.hashmappers.jackson2,`Jackson2HashMapper`>> using https://github.com/FasterXML/jackson[FasterXML Jackson].

The following example shows one way to implement hash mapping:

[source,java]
----
public class Person {
  String firstname;
  String lastname;

  // …
}

public class HashMapping {

  @Autowired
  HashOperations<String, byte[], byte[]> hashOperations;

  HashMapper<Object, byte[], byte[]> mapper = new ObjectHashMapper();

  public void writeHash(String key, Person person) {

    Map<byte[], byte[]> mappedHash = mapper.toHash(person);
    hashOperations.putAll(key, mappedHash);
  }

  public Person loadHash(String key) {

    Map<byte[], byte[]> loadedHash = hashOperations.entries("key");
    return (Person) mapper.fromHash(loadedHash);
  }
}
----

[[redis.hashmappers.jackson2]]
=== Jackson2HashMapper

`Jackson2HashMapper` provides Redis Hash mapping for domain objects by using https://github.com/FasterXML/jackson[FasterXML Jackson].
`Jackson2HashMapper` can map top-level properties as Hash field names and, optionally, flatten the structure.
Simple types map to simple values. Complex types (nested objects, collections, maps, and so on) are represented as nested JSON.

Flattening creates individual hash entries for all nested properties and resolves complex types into simple types, as far as possible.

Consider the following class and the data structure it contains:

[source,java]
----
public class Person {
  String firstname;
  String lastname;
  Address address;
  Date date;
  LocalDateTime localDateTime;
}

public class Address {
  String city;
  String country;
}
----

The following table shows how the data in the preceding class would appear in normal mapping:

.Normal Mapping
[width="80%",cols="<1,<2",options="header"]
|====
|Hash Field
|Value

|firstname
|`Jon`

|lastname
|`Snow`

|address
|`{ "city" : "Castle Black", "country" : "The North" }`

|date
|`1561543964015`

|localDateTime
|`2018-01-02T12:13:14`
|====

The following table shows how the data in the preceding class would appear in flat mapping:

.Flat Mapping
[width="80%",cols="<1,<2",options="header"]
|====
|Hash Field
|Value

|firstname
|`Jon`

|lastname
|`Snow`

|address.city
|`Castle Black`

|address.country
|`The North`

|date
|`1561543964015`

|localDateTime
|`2018-01-02T12:13:14`
|====

NOTE: Flattening requires all property names to not interfere with the JSON path. Using dots or brackets in map keys or as property names is not supported when you use flattening. The resulting hash cannot be mapped back into an Object.

NOTE: `java.util.Date` and `java.util.Calendar` are represented with milliseconds. JSR-310 Date/Time types are serialized to their `toString` form if  `jackson-datatype-jsr310` is on the class path.

:leveloffset: 2
include::{referenceDir}/redis-messaging.adoc[]

include::{referenceDir}/redis-streams.adoc[]

include::{referenceDir}/redis-transactions.adoc[]

include::{referenceDir}/pipelining.adoc[]

include::{referenceDir}/redis-scripting.adoc[]

:leveloffset: 1
[[redis:support]]
== Support Classes

Package `org.springframework.data.redis.support` offers various reusable components that rely on Redis as a backing store. Currently, the package contains various JDK-based interface implementations on top of Redis, such as https://download.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/package-summary.html[atomic] counters and JDK https://download.oracle.com/javase/8/docs/api/java/util/Collection.html[Collections].

The atomic counters make it easy to wrap Redis key incrementation while the collections allow easy management of Redis keys with minimal storage exposure or API leakage. In particular, the `RedisSet` and `RedisZSet` interfaces offer easy access to the set operations supported by Redis, such as `intersection` and `union`. `RedisList` implements the `List`, `Queue`, and `Deque` contracts (and their equivalent blocking siblings) on top of Redis, exposing the storage as a FIFO (First-In-First-Out), LIFO (Last-In-First-Out) or capped collection with minimal configuration. The following example shows the configuration for a bean that uses a `RedisList`:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="
  http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd">

  <bean id="queue" class="org.springframework.data.redis.support.collections.DefaultRedisList">
    <constructor-arg ref="redisTemplate"/>
    <constructor-arg value="queue-key"/>
  </bean>

</beans>
----

The following example shows a Java configuration example for a `Deque`:

[source,java]
----
public class AnotherExample {

  // injected
  private Deque<String> queue;

  public void addTag(String tag) {
    queue.push(tag);
  }
}
----

As shown in the preceding example, the consuming code is decoupled from the actual storage implementation. In fact, there is no indication that Redis is used underneath. This makes moving from development to production environments transparent and highly increases testability (the Redis implementation can be replaced with an in-memory one).

[[redis:support:cache-abstraction]]
=== Support for the Spring Cache Abstraction

NOTE: Changed in 2.0

Spring Redis provides an implementation for the Spring https://docs.spring.io/spring/docs/{springVersion}/spring-framework-reference/integration.html#cache[cache abstraction] through the `org.springframework.data.redis.cache` package. To use Redis as a backing implementation, add `RedisCacheManager` to your configuration, as follows:

[source,java]
----
@Bean
public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {
	return RedisCacheManager.create(connectionFactory);
}
----

`RedisCacheManager` behavior can be configured with `RedisCacheManagerBuilder`, letting you set the default `RedisCacheConfiguration`, transaction behavior, and predefined caches.

[source,java]
----
RedisCacheManager cm = RedisCacheManager.builder(connectionFactory)
	.cacheDefaults(defaultCacheConfig())
	.withInitialCacheConfigurations(singletonMap("predefined", defaultCacheConfig().disableCachingNullValues()))
	.transactionAware()
	.build();
----

As shown in the preceding example, `RedisCacheManager` allows definition of configurations on a per-cache basis.

The behavior of `RedisCache` created with `RedisCacheManager` is defined with `RedisCacheConfiguration`. The configuration lets you set key expiration times, prefixes, and ``RedisSerializer`` implementations for converting to and from the binary storage format, as shown in the following example:

[source,java]
----
RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
    .entryTtl(Duration.ofSeconds(1))
	.disableCachingNullValues();
----

`RedisCacheManager` defaults to a lock-free `RedisCacheWriter` for reading and writing binary values. Lock-free caching improves throughput. The lack of entry locking can lead to overlapping, non-atomic commands for the `putIfAbsent` and `clean` methods, as those require multiple commands to be sent to Redis. The locking counterpart prevents command overlap by setting an explicit lock key and checking against presence of this key, which leads to additional requests and potential command wait times.

It is possible to opt in to the locking behavior as follows:

[source,java]
----
RedisCacheManager cm = RedisCacheManager.build(RedisCacheWriter.lockingRedisCacheWriter())
	.cacheDefaults(defaultCacheConfig())
	...
----

By default, any `key` for a cache entry gets prefixed with the actual cache name followed by two colons.
This behavior can be changed to a static as well as a computed prefix.

The following example shows how to set a static prefix:

[source,java]
----
// static key prefix
RedisCacheConfiguration.defaultCacheConfig().prefixKeysWith("( ͡° ᴥ ͡°)");

The following example shows how to set a computed prefix:

// computed key prefix
RedisCacheConfiguration.defaultCacheConfig().computePrefixWith(cacheName -> "¯\_(ツ)_/¯" + cacheName);
----

The following table lists the default settings for `RedisCacheManager`:

.`RedisCacheManager` defaults
[width="80%",cols="<1,<2",options="header"]
|====
|Setting
|Value

|Cache Writer
|Non-locking

|Cache Configuration
|`RedisCacheConfiguration#defaultConfiguration`

|Initial Caches
|None

|Trasaction Aware
|No
|====

The following table lists the default settings for `RedisCacheConfiguration`:

.RedisCacheConfiguration defaults
[width="80%",cols="<1,<2",options="header"]
|====
|Key Expiration
|None

|Cache `null`
|Yes

|Prefix Keys
|Yes

|Default Prefix
|The actual cache name

|Key Serializer
|`StringRedisSerializer`

|Value Serializer
|`JdkSerializationRedisSerializer`

|Conversion Service
|`DefaultFormattingConversionService` with default cache key converters
|====
