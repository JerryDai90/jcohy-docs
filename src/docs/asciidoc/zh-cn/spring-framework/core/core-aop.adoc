[[aop]]
= 使用Spring面向切面编程

面向切面编程(Aspect-oriented Programming 简称AOPAOP) ,是相对面向对象编程(Object-oriented Programming 简称OOP)的框架,作为OOP的一种功能补充. OOP主要的模块单元是类(class)。而AOP则是切面（aspect）。切面会将诸如事务管理这样跨越多个类型和对象的关注点模块化（在AOP的语义中，这类关注点被称为横切关注点（crosscutting））。

AOP是Spring框架重要的组件，虽然Spring IoC容器没有依赖AOP，因此Spring不会强迫开发者使用AOP。但AOP提供了非常棒的功能，用做对Spring IoC的补充。

.Spring AOP 具有 AspectJ 切点
****
Spring引入了一种更简单、更强大的方式用来自定义切面，开发者可以选择使用基于模式 <<aop-schema, schema-based approach>> 的方式或使用<<aop-ataspectj, @AspectJ >>注解风格方式来定义。
这两种方式都完全支持通知（Advice）类型和AspectJ的切点语义，虽然实际上仍然是使用Spring AOP织入（weaving）的。

本章主要讨论Spring 框架对基于模式和基于@AspectJ的AOP支持。<<aop-api, 下一章>>，将讨论底层的AOP支持.
****

AOP在Spring Framework中用于:

* 提供声明式企业服务，特别是用于替代EJB的声明式服务。最重要的服务是<<data-access.adoc#transaction-declarative, 声明式事务管理>>，这个服务建立在Spring的抽象事务管理之上。
* 允许开发者实现自定义切面，使用AOP来完善OOP的功能。

NOTE: 如果只打算使用通用的声明式服务或者已有的声明式中间件服务，例如缓冲池（pooling）那么可以不直接使用AOP，也可以忽略本章大部分内容。

[[aop-introduction-defn]]
== AOP 概念

让我们从定义一些核心AOP概念和术语开始。 这些术语不是特定于Spring的。 不幸的是，AOP术语不是特别直观。 但是，如果Spring使用自己的术语，那将更加令人困惑。

* Aspect(切面): 指关注点模块化，这个关注点可能会横切多个对象。事务管理是企业级Java应用中有关横切关注点的例子。 在Spring AOP中，切面可以使用通用类 <<aop-schema, 基于schema的方式>>的方式或者在普通类中以<<aop-ataspectj, `@AspectJ`>>注解来实现。
* Join point(连接点):在程序执行过程中某个特定的点，例如某个方法调用的时间点或者处理异常的时间点。在Spring AOP中，一个连接点总是代表一个方法的执行。
* Advice(通知): 在切面的某个特定的连接点上执行的动作。通知有多种类型，包括 "`around`", "`before`" 和 "`after`" 等等。通知的类型将在后面的章节进行讨论。 许多AOP框架，包括Spring在内，都是以拦截器做通知模型的，并维护着一个以连接点为中心的拦截器链。
* Pointcut(切点): 匹配连接点的断言。通知和切点表达式相关联，并在满足这个切点的连接点上运行（例如，当执行某个特定名称的方法时）。切点表达式如何和连接点匹配是AOP的核心：Spring默认使用AspectJ切点语义。
* Introduction(引入): 声明额外的方法或者某个类型的字段。Spring允许引入新的接口（以及一个对应的实现）到任何被通知的对象上。例如，可以使用引入来使bean实现 `IsModified` 接口， 以便简化缓存机制（在AspectJ社区，引入也被称为内部类型声明（inter））。
* Target object(目标对象): 被一个或者多个切面所通知的对象。也被称作被通知（advised）对象。既然Spring AOP是通过运行时代理实现的，那么这个对象永远是一个被代理（proxied）的对象。
* AOP proxy(AOP代理): AOP框架创建的对象，用来实现切面契约（aspect contract）（包括通知方法执行等功能）。在Spring中，AOP代理可以是JDK动态代理或CGLIB代理。
* Weaving(织入): 把切面连接到其它的应用程序类型或者对象上，并创建一个被被通知的对象的过程。这个过程可以在编译时（例如使用AspectJ编译器）、类加载时或运行时中完成。 Spring和其他纯Java AOP框架一样，是在运行时完成织入的。

Spring AOP包含以下类型的通知:

* Before advice(前置通知): 在连接点之前运行但无法阻止执行流程进入连接点的通知（除非它引发异常）。
* After returning advice(后置返回通知): 在连接点正常完成后执行的通知（例如，当方法没有抛出任何异常并正常返回时）。
* After throwing advice(后置异常通知): 在方法抛出异常退出时执行的通知。
* After (finally) advice(后置通知（总会执行）):  当连接点退出的时候执行的通知（无论是正常返回还是异常退出）。
* Around advice(环绕通知): 环绕连接点的通知，例如方法调用。这是最强大的一种通知类型，。环绕通知可以在方法调用前后完成自定义的行为。它可以选择是否继续执行连接点或直接返回自定义的返回值又或抛出异常将执行结束。

环绕通知是最常用的一种通知类型。与AspectJ一样，在选择Spring提供的通知类型时，团队推荐开发者尽量使用简单的通知类型来实现需要的功能。例如， 如果只是需要使用方法的返回值来作缓存更新，虽然使用环绕通知也能完成同样的事情，但是仍然推荐使用后置返回通知来代替。
使用最合适的通知类型可以让编程模型变得简单， 还能避免很多潜在的错误。例如，开发者无需调用于环绕通知（用 `JoinPoint`）的 `proceed()` 方法，也就不会产生调用的问题。

所有通知参数都是静态类型的，因此您可以使用相应类型的通知参数（例如，方法执行的返回值的类型）而不是 `Object` 数组。

切点和连接点匹配是AOP的关键概念，这个概念让AOP不同于其它仅仅提供拦截功能的旧技术。切入点使得通知可以独立于面向对象的层次结构进行定向。 例如，您可以将一个提供声明式事务管理的通知应用于跨多个对象（例如服务层中的所有业务操作）的一组方法。

[[aop-introduction-spring-defn]]
== Spring AOP的功能和目标

Spring AOP是用纯Java实现的。 不需要特殊的编译过程。 Spring AOP不需要控制类加载器层次结构，因此适合在servlet容器或应用程序服务器中使用。

Spring目前仅支持方法调用的方式作为连接点（在Spring bean上通知方法的执行）。虽然可以在不影响到Spring AOP核心API的情况下加入对成员变量拦截器支持， 但Spring并没有实现成员变量拦截器。如果需要通知对成员变量的访问和更新连接点，可以考虑其它语言，例如AspectJ。

Spring实现AOP的方法与其他的框架不同，Spring并不是要尝试提供最完整的AOP实现（尽管Spring AOP有这个能力），相反地，它其实侧重于提供一种AOP与Spring IoC容器的整合的实现，用于帮助解决在企业级开发中的常见问题。

因此，例如，Spring Framework的AOP功能通常与Spring IoC容器一起使用。通过使用普通bean定义语法来配置切面（尽管Spring提供了强大的“自动代理”功能）。 这是与其他AOP实现的重要区别。 使用Spring AOP无法轻松或高效地完成某些操作，例如建议非常细粒度的对象（通常是域对象）。 在这种情况下，AspectJ是最佳选择。 但是，我们的经验是，Spring AOP为适合AOP的企业Java应用程序中的大多数问题提供了出色的解决方案。

Spring AOP从来没有打算通过提供一种全面的AOP解决方案用于取代AspectJ，我们相信，基于代理的框架（如Spring AOP）和完整的框架（如AspectJ）都很有价值，而且它们是互补的，而不是竞争。 Spring将Spring AOP和IoC与AspectJ无缝集成，使得所有的AOP功能完全融入基于Spring的应用体系。这样的集成不会影响Spring AOP API或者AOP Alliance API。
Spring AOP仍然向后兼容。 有关Spring AOP API的讨论，请参阅 <<aop-api, 以下章节>>。

[NOTE]
====
Spring框架的一个核心原则是非侵入性。这意味着开发者无需在自身的业务/域模型上被迫引入框架特定的类和接口。然而，有些时候，Spring框架可以让开发者选择引入Spring框架特定的依赖关系到业务代码。 给予这种选择的理由是因为在某些情况下它可能是更易读或易于编写某些特定功能。Spring框架（几乎）总能给出这样的选择，开发者可以自由地做出明智的决定，选择最适合的特定用例或场景。

与本章相关的一个选择是选择哪种AOP框架（以及哪种AOP样式）。您可以选择AspectJ，Spring AOP或两者。也可以选择@AspectJ注解式的方法或Spring的XML配置方式。 事实上，本章以介绍@AspectJ方式为先不应该被视为Spring团队倾向于@AspectJ的方式胜过Spring的XML配置方式。

请参阅<<aop-choosing,选择要使用的AOP声明样式>>，以更全面地讨论每种样式的“为什么和如何进行”。
====




[[aop-introduction-proxies]]
== AOP 代理

Spring默认使用标准的JDK动态代理来作为AOP的代理。这样任何接口（或者接口的set）都可以被代理。

Spring也支持使用CGLIB代理。对于需要代理类而不是代理接口的时候CGLIB代理是很有必要的。如果业务对象并没有实现接口，默认就会使用CGLIB代理 。此外，面向接口编程也是最佳实践，业务对象通常都会实现一个或多个接口。
此外，还可以<<aop-proxying, 强制的使用CGLIB代理>>， 在那些（希望是罕见的）需要通知没有在接口中声明的方法时，或者当需要传递一个代理对象作为一种具体类型到方法的情况下。

掌握Spring AOP是基于代理的这一事实非常重要。 请参阅 <<aop-understanding-aop-proxies,AOP代理>>，以全面了解此实现细节的实际含义。.

[[aop-ataspectj]]
== @AspectJ 注解支持

@AspectJ 会将切面声明为常规Java类的注解类型。 https://www.eclipse.org/aspectj[AspectJ project] 引入了@AspectJ风格，并作为AspectJ 5发行版的一部分。Spring使用的注解类似于AspectJ 5， 使用AspectJ提供的库用来解析和匹配切点。AOP运行时仍然是纯粹的Spring AOP，并不依赖AspectJ编译器或编织器。

NOTE: 使用AspectJ编译器和织入并允许使用全部基于AspectJ语言，并在<<aop-using-aspectj>>进行了讨论。

[[aop-aspectj-support]]
=== 启用 @AspectJ 支持

要在Spring配置中使用@AspectJ切面，需要启用Spring支持，用于根据@AspectJ切面配置Spring AOP，并根据这些切面自动代理bean（事先判断是否在通知的范围内）。 通过自动代理的意思是：如果Spring确定一个bean是由一个或多个切面处理的，将据此为bean自动生成代理bean，并以拦截方法调用并确保需要执行的通知。

可以使用XML或Java配置的方式启用@AspectJ支持。不管哪一种方式，您还需要确保AspectJ的 `aspectjweaver.jar` 库位于应用程序的类路径中（版本1.8或更高版本）。此库可在AspectJ分发的 `lib` 目录中或Maven Central存储库中找到。


[[aop-enable-aspectj-java]]
==== 使用Java配置启用@AspectJ支持

要使用Java `@Configuration` 启用 `@AspectJ` 支持，请添加 `@EnableAspectJAutoProxy` 注解，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableAspectJAutoProxy
	public class AppConfig {

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableAspectJAutoProxy
	class AppConfig
----

[[aop-enable-aspectj-xml]]
==== 使用XML配置启用@AspectJ支持

要使用基于XML的配置启用@AspectJ支持，请使用 `aop:aspectj-autoproxy` 元素，如以下示例所示：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:aspectj-autoproxy/>
----

这假设您使用<<core.adoc#xsd-schemas, 基于 XML Schema 配置>>中描述的schema支持。 有关如何在 `aop` 命名空间中导入标签，请参阅 <<core.adoc#xsd-schemas-aop,  AOP schema>>。

[[aop-at-aspectj]]
=== 声明切面

启用了 `@AspectJ` 支持后，在应用程序上下文中定义的任意bean（有 `@Aspect` 注解）的类都将被Spring自动检测，并用于配置Spring AOP。 接下来的两个示例显示了非常有用的方面所需的最小定义。

这两个示例中的第一个示例在应用程序上下文中显示了一个常规bean定义，该定义指向具有 `@Aspect` 注解的bean类：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="myAspect" class="org.xyz.NotVeryUsefulAspect">
		<!-- configure properties of the aspect here -->
	</bean>
----

这两个示例中的第二个显示了 `NotVeryUsefulAspect` 类定义，该定义使用 `org.aspectj.lang.annotation.Aspect` 注解进行注解:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package org.xyz;
	import org.aspectj.lang.annotation.Aspect;

	@Aspect
	public class NotVeryUsefulAspect {

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package org.xyz

	import org.aspectj.lang.annotation.Aspect;

	@Aspect
	class NotVeryUsefulAspect
----

切面（使用 `@Aspect` 的类）可以拥有方法和属性，与其他类并无不同。也可以包括切点、通知和内置类型（即引入）声明。

.通过组件扫描自动检测切面
NOTE: 您可以在Spring XML配置中将切面类注册为常规bean，或者通过类路径扫描自动检测它们 - 与任何其他Spring管理的bean相同。然而注意到 `@Aspect` 注解对于类的自动探测是不够的， 为此，需要单独添加 `@Component` ，注解（或自定义注解声明，用作Spring组件扫描器的规则之一）。

.是否可以作为其他切面的切面通知?
NOTE: 在Spring AOP中，不可能将切面本身被作为其他切面的目标。类上的 `@Aspect` 注解表明他是一个切面并且排除在自动代理的范围之外。

[[aop-pointcuts]]
=== 声明切点

切点决定了匹配的连接点，从而使我们能够控制通知何时执行。Spring AOP只支持使用Spring bean的方法执行连接点，所以可以将切点看出是匹配Spring bean上方法的执行。 切点的声明包含两个部分：包含名称和任意参数的签名，以及明确需要匹配的方式执行的切点表达式。
在@AspectJ注解方式的AOP中，一个切点的签名由常规方法定义来提供， 并且切点表达式使用 `@Pointcut` 注解指定（方法作为切点签名必须有类型为 `void` 的返回）。

使用例子有助于更好地区分切点签名和切点表达式之间的关系。以下示例定义名为 `anyOldTransfer` 的切点，该切点与名为 `transfer` 的任何方法的执行相匹配：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Pointcut("execution(* transfer(..))") // the pointcut expression
	private void anyOldTransfer() {} // the pointcut signature
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Pointcut("execution(* transfer(..))") // the pointcut expression
	private fun anyOldTransfer() {} // the pointcut signature
----

切点表达式由 `@Pointcut` 注解的值是常规的AspectJ 5切点表达式。关于AspectJ切点语言的描述，见 https://www.eclipse.org/aspectj/doc/released/progguide/index.html[AspectJ
Programming Guide] （作为扩展， 请参考https://www.eclipse.org/aspectj/doc/released/adk15notebook/index.html[AspectJ 5
Developer's Notebook]）或者Colyer著的关于AspectJ的书籍。 例如， _Eclipse AspectJ_，或者参看Ramnivas Laddad的 _AspectJ in Action_。

[[aop-pointcuts-designators]]
==== 支持切点标识符

Spring AOP支持使用以下AspectJ切点标识符(PCD),用于切点表达式：

* `execution`: 用于匹配方法执行连接点。 这是使用Spring AOP时使用的主要切点标识符。
* `within`: 限制匹配特定类型中的连接点（在使用Spring AOP时，只需执行在匹配类型中声明的方法）。
* `this`: 在bean引用（Spring AOP代理）是给定类型的实例的情况下，限制匹配连接点（使用Spring AOP时方法的执行）。
* `target`: 限制匹配到连接点（使用Spring AOP时方法的执行），其中目标对象（正在代理的应用程序对象）是给定类型的实例。
* `args`: 限制与连接点的匹配（使用Spring AOP时方法的执行），其中变量是给定类型的实例。
* `@target`: 限制与连接点的匹配（使用Spring AOP时方法的执行），其中执行对象的类具有给定类型的注解。
* `@args`: 限制匹配连接点（使用Spring AOP时方法的执行），其中传递的实际参数的运行时类型具有给定类型的注解。
* `@within`: 限制与具有给定注解的类型中的连接点匹配（使用Spring AOP时在具有给定注解的类型中声明的方法的执行）。
* `@annotation`: 限制匹配连接点（在Spring AOP中执行的方法具有给定的注解）。

.其他切点类型
****
Spring并没有完全地支持AspectJ切点语言声明的切点标识符，包括 `call`, `get`, `set`, `preinitialization`,
`staticinitialization`, `initialization`, `handler`, `adviceexecution`, `withincode`, `cflow`,`cflowbelow`, `if`, `@this`, 和 `@withincode`。在由Spring AOP解释的切点表达式中，使用这些切点标识符将导致 `IllegalArgumentException` 异常。

Spring AOP支持的切点标识符可以在将来的版本中扩展，以支持更多的AspectJ切点标识符。
****

因为Spring AOP限制了只匹配方法的连接点执行，所以上面的切点标识符的讨论比在AspectJ编程指南中找到的定义要窄。另外，AspectJ本身具有基于类型的语义，
并且在执行连接点上，`this` 和 `target` 都指向同一个对象-即执行方法的对象。Spring AOP是一个基于代理的系统，区分代理对象本身（绑定到 `this`）和代理（绑定到 `target`）后的目标对象。

[NOTE]
====
由于Spring AOP框架是基于代理的特性，定义的protected方法将不会被处理，不管是JDK的代理（做不到）还是CGLIB代理（有技术可以实现但是不建议）。 因此，任何给定的切点将只能与public方法匹配。

请注意，切点定义通常与任何截获的方法匹配。 如果切点严格意义上是公开的，即使在通过代理进行潜在非公共交互的CGLIB代理方案中，也需要相应地定义切点。

如果需要拦截包括protected和private方法甚至是构造函数，请考虑使用基于Spring驱动的<<aop-aj-ltw, 本地AspectJ织入>>而不是Spring的基于代理的AOP框架。 这构成了不同特性的AOP使用模式，所以在做出决定之前一定要先熟悉一下编织。
====

Spring AOP支持更多的PCD命名 `bean`。PCD允许将连接点的匹配限制为特定的Spring `bean` 或一系列Spring `bean`。 bean PCD具有以下形式：:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	bean(idOrNameOfBean)
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	bean(idOrNameOfBean)
----

`idOrNameOfBean` 标识可以是任意符合Spring bean的名字， 提供了使用 `*` 字符的有限通配符支持，因此，如果为Spring `bean` 建立了一些命名约定，则可以编写bean PCD表达式来选择它们。 与其他切点标识符的情况一样，PCD bean可以是 `&&` (and), `||` (or), and `!`(negation)。

[NOTE]
====
`bean`PCD仅在Spring AOP中受支持，而在本机AspectJ编织中不受支持。 它是AspectJ定义的标准PCD的Spring特定扩展，因此不适用于 `@Aspect` 模型中声明的切面。

`bean` PCD 运行在实例级别上（基于Spring bean名称概念构建），而不是仅在类型级别（这是基于编织的AOP所限制的）。 基于实例的切点标识符是Spring基于代理的AOP框架的特殊功能，它与Spring bean工厂紧密集成，通过名称识别特定的bean是自然而直接的。
====


[[aop-pointcuts-combining]]
==== 合并切点表达式

您可以使用 `&&,` `||` 和 `!` 等符号进行合并操作。也可以通过名字来指向切点表达式。 以下示例显示了三个切入点表达式：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Pointcut("execution(public * *(..))")
	private void anyPublicOperation() {} // <1>

	@Pointcut("within(com.xyz.someapp.trading..*)")
	private void inTrading() {} // <2>

	@Pointcut("anyPublicOperation() && inTrading()")
	private void tradingOperation() {} // <3>
----
<1> `anyPublicOperation` 如果方法执行连接点表示任何公共方法的执行，则匹配
<2> `inTrading` 如果方法执行在 trading 中，则匹配.
<3> `tradingOperation` 如果方法执行表示trading中的任何公共方法，则匹配。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Pointcut("execution(public * *(..))")
	private fun anyPublicOperation() {} // <1>

	@Pointcut("within(com.xyz.someapp.trading..*)")
	private fun inTrading() {} // <2>

	@Pointcut("anyPublicOperation() && inTrading()")
	private fun tradingOperation() {} // <3>
----
<1> `anyPublicOperation` 如果方法执行连接点表示任何公共方法的执行，则匹配
<2> `inTrading` 如果方法执行在 trading 中，则匹配.
<3> `tradingOperation` 如果方法执行表示trading中的任何公共方法，则匹配。

如上所示，用更小的命名组件构建更复杂的切入点表达式是最佳实践。当按名称引用切点时，将应用普通的Java可见性规则（可以看到相同类型的私有切点，层次结构中受保护的切点，任何位置的公共切点等）。可见性并不影响切点匹配。


[[aop-common-pointcuts]]
==== 共享通用的切点定义

在处理企业应用程序时，通常需要从几个切面来引用应用程序的模块和特定的操作集。建议定义一个“SystemArchitecture” 切面，以此为目的捕获通用的切点表达式。这样的切面通常类似于以下示例：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package com.xyz.someapp;

	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.Pointcut;

	@Aspect
	public class SystemArchitecture {

		/**
		 * A join point is in the web layer if the method is defined
		 * in a type in the com.xyz.someapp.web package or any sub-package
		 * under that.
		 */
		@Pointcut("within(com.xyz.someapp.web..*)")
		public void inWebLayer() {}

		/**
		 * A join point is in the service layer if the method is defined
		 * in a type in the com.xyz.someapp.service package or any sub-package
		 * under that.
		 */
		@Pointcut("within(com.xyz.someapp.service..*)")
		public void inServiceLayer() {}

		/**
		 * A join point is in the data access layer if the method is defined
		 * in a type in the com.xyz.someapp.dao package or any sub-package
		 * under that.
		 */
		@Pointcut("within(com.xyz.someapp.dao..*)")
		public void inDataAccessLayer() {}

		/**
		 * A business service is the execution of any method defined on a service
		 * interface. This definition assumes that interfaces are placed in the
		 * "service" package, and that implementation types are in sub-packages.
		 *
		 * If you group service interfaces by functional area (for example,
		 * in packages com.xyz.someapp.abc.service and com.xyz.someapp.def.service) then
		 * the pointcut expression "execution(* com.xyz.someapp..service.*.*(..))"
		 * could be used instead.
		 *
		 * Alternatively, you can write the expression using the 'bean'
		 * PCD, like so "bean(*Service)". (This assumes that you have
		 * named your Spring service beans in a consistent fashion.)
		 */
		@Pointcut("execution(* com.xyz.someapp..service.*.*(..))")
		public void businessService() {}

		/**
		 * A data access operation is the execution of any method defined on a
		 * dao interface. This definition assumes that interfaces are placed in the
		 * "dao" package, and that implementation types are in sub-packages.
		 */
		@Pointcut("execution(* com.xyz.someapp.dao.*.*(..))")
		public void dataAccessOperation() {}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package com.xyz.someapp

	import org.aspectj.lang.annotation.Aspect
	import org.aspectj.lang.annotation.Pointcut

	import org.springframework.aop.Pointcut

	@Aspect
	class SystemArchitecture {

		/**
		* A join point is in the web layer if the method is defined
		* in a type in the com.xyz.someapp.web package or any sub-package
		* under that.
		*/
		@Pointcut("within(com.xyz.someapp.web..*)")
		fun inWebLayer() {
		}

		/**
		* A join point is in the service layer if the method is defined
		* in a type in the com.xyz.someapp.service package or any sub-package
		* under that.
		*/
		@Pointcut("within(com.xyz.someapp.service..*)")
		fun inServiceLayer() {
		}

		/**
		* A join point is in the data access layer if the method is defined
		* in a type in the com.xyz.someapp.dao package or any sub-package
		* under that.
		*/
		@Pointcut("within(com.xyz.someapp.dao..*)")
		fun inDataAccessLayer() {
		}

		/**
		* A business service is the execution of any method defined on a service
		* interface. This definition assumes that interfaces are placed in the
		* "service" package, and that implementation types are in sub-packages.
		*
		* If you group service interfaces by functional area (for example,
		* in packages com.xyz.someapp.abc.service and com.xyz.someapp.def.service) then
		* the pointcut expression "execution(* com.xyz.someapp..service.*.*(..))"
		* could be used instead.
		*
		* Alternatively, you can write the expression using the 'bean'
		* PCD, like so "bean(*Service)". (This assumes that you have
		* named your Spring service beans in a consistent fashion.)
		*/
		@Pointcut("execution(* com.xyz.someapp..service.*.*(..))")
		fun businessService() {
		}

		/**
		* A data access operation is the execution of any method defined on a
		* dao interface. This definition assumes that interfaces are placed in the
		* "dao" package, and that implementation types are in sub-packages.
		*/
		@Pointcut("execution(* com.xyz.someapp.dao.*.*(..))")
		fun dataAccessOperation() {
		}

	}
----

像这样定义的切点可以用在任何需要切点表达式的地方， 例如，要使服务层具有事务性，您可以编写以下内容：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:config>
		<aop:advisor
			pointcut="com.xyz.someapp.SystemArchitecture.businessService()"
			advice-ref="tx-advice"/>
	</aop:config>

	<tx:advice id="tx-advice">
		<tx:attributes>
			<tx:method name="*" propagation="REQUIRED"/>
		</tx:attributes>
	</tx:advice>
----

`<aop:config>` 和 `<aop:advisor>` 元素在 <<aop-schema,基于Schema>>的AOP 支持中进行了讨论。  <<data-access.adoc#transaction,  事务管理>>中讨论了事务元素。


[[aop-pointcuts-examples]]
==== Examples

Spring AOP用户可能最常使用 `execution` 切点标识符 ，执行表达式的格式为：

[literal,subs="verbatim,quotes"]
----
	execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)
				throws-pattern?)
----

除返回类型模式（上面片段中的 `ret-type-pattern` ）以外的所有部件、名称模式和参数模式都是可选的。返回类型模式确定要匹配的连接点的方法的返回类型必须是什么。 通常，可以使用 `{asterisk}` 作为返回类型模式，它匹配任何返回类型。只有当方法返回给定类型时，完全限定的类型名称才会匹配。名称模式与方法名称匹配，可以将 `{asterisk}` 通配符用作名称模式的全部或部分。 如果指定声明类型模式，则需要有后缀 .将其加入到名称模式组件中。
参数模式稍微复杂一点。`()` 匹配没有参数的方法。 `(..)` 匹配任意个数的参数（0个或多个）。 ( `{asterisk}` )匹配任何类型的单个参数。`(*,String)` 匹配有两个参数而且第一个参数是任意类型，第二个必须是 `String` 的方法。有关更多信息，请参阅AspectJ编程指南的https://www.eclipse.org/aspectj/doc/released/progguide/semantics-pointcuts.html[Language
Semantics]部分。

以下示例显示了一些常见的切点表达式：

* 匹配任意公共方法的执行:
+
[literal,subs="verbatim,quotes"]
----
	execution(public * *(..))
----

* 匹配任意以 `set` 开始的方法:
+
[literal,subs="verbatim,quotes"]
----
	execution(* set*(..))
----

* 匹配定义了 `AccountService` 接口的任意方法:
+
[literal,subs="verbatim,quotes"]
----
	execution(* com.xyz.service.AccountService.*(..))
----

* 匹配定义在 `service` 包中的任意方法:
+
[literal,subs="verbatim,quotes"]
----
	execution(* com.xyz.service.*.*(..))
----

* 匹配定义在service包和其子包中的任意方法:
+
[literal,subs="verbatim,quotes"]
----
	execution(* com.xyz.service..*.*(..))
----

* 匹配在service包中的任意连接点（只在Spring AOP中的方法执行）:
+
[literal,subs="verbatim,quotes"]
----
	within(com.xyz.service.*)
----

* 匹配在service包及其子包中的任意连接点（只在Spring AOP中的方法执行）
+
[literal,subs="verbatim,quotes"]
----
	within(com.xyz.service..*)
----

* 匹配代理实现了 `AccountService` 接口的任意连接点（只在Spring AOP中的方法执行）：
+
[literal,subs="verbatim,quotes"]
----
	this(com.xyz.service.AccountService)
----
+
NOTE: 'this' 常常以捆绑的形式出现.  见后续的章节讨论如何在<<aop-advice,声明通知>>中使用代理对象。

* 匹配当目标对象实现了 `AccountService` 接口的任意连接点（只在Spring AOP中的方法执行）:
+
[literal,subs="verbatim,quotes"]
----
	target(com.xyz.service.AccountService)
----
+
NOTE: 'target' 常常以捆绑的形式出现. 见后续的章节讨论如何在<<aop-advice,声明通知>>中使用目标对象。

* 匹配使用了单一的参数，并且参数在运行时被传递时可以 `Serializable` 的任意连接点（只在Spring的AOP中的方法执行）:
+
[literal,subs="verbatim,quotes"]
----
	args(java.io.Serializable)
----
+
NOTE: 'args' 常常以捆绑的形式出现.见后续的章节讨论如何在<<aop-advice,声明通知>>中使用方法参数。
+
注意在这个例子中给定的切点不同于 `execution(* *(java.io.Serializable))`. 如果在运行时传递的参数是可序列化的，则与 `execution` 匹配，如果方法签名声明单个参数类型可序列化，则与args匹配。

* 匹配当目标对象有 `@Transactional` 注解时的任意连接点（只在Spring AOP中的方法执行）。
+
[literal,subs="verbatim,quotes"]
----
	@target(org.springframework.transaction.annotation.Transactional)
----
+
NOTE: '@target' 也可以以捆绑的形式使用.见后续的章节讨论如何在<<aop-advice,声明通知>>中使用注解对象。

* 匹配当目标对象的定义类型有 `@Transactional` 注解时的任意连接点（只在Spring的AOP中的方法执行）
+
[literal,subs="verbatim,quotes"]
----
	@within(org.springframework.transaction.annotation.Transactional)
----
+
NOTE: `'@within'` 也可以以捆绑的形式使用.见后续的章节讨论如何在<<aop-advice,声明通知>>中使用注解对象。

* 匹配当执行的方法有 `@Transactional` 注解的任意连接点（只在Spring AOP中的方法执行）:
+
[literal,subs="verbatim,quotes"]
----
	@annotation(org.springframework.transaction.annotation.Transactional)
----
+
NOTE: '@annotation' 也可以以捆绑的形式使用.见后续的章节讨论如何在<<aop-advice,声明通知>>中使用注解对象。

* 匹配有单一的参数并且在运行时传入的参数类型有 `@Classified` 注解的任意连接点（只在Spring AOP中的方法执行）:
+
[literal,subs="verbatim,quotes"]
----
	@args(com.xyz.security.Classified)
----
+
NOTE: '@args' 也可以以捆绑的形式使用.见后续的章节讨论如何在<<aop-advice,声明通知>>中使用注解对象。

* 匹配在名为 `tradeService` 的Spring bean上的任意连接点（只在Spring AOP中的方法执行）:
+
[literal,subs="verbatim,quotes"]
----
	bean(tradeService)
----

* 匹配以 `*Service` 结尾的Spring bean上的任意连接点（只在Spring AOP中方法执行） :
+
[literal,subs="verbatim,quotes"]
----
	bean(*Service)
----


[[writing-good-pointcuts]]
==== 编写好的切点

在编译过程中，AspectJ会尝试和优化匹配性能来处理切点。检查代码并确定每个连接点是否匹配（静态或动态）给定切点是一个代价高昂的过程。（动态匹配意味着无法从静态分析中完全确定匹配， 并且将在代码中放置测试，以确定在运行代码时是否存在实际匹配）。在第一次遇到切点声明时，AspectJ会将它重写为匹配过程的最佳形式。这是什么意思？基本上，切点是在DNF（析取范式）中重写的 ，切点的组成部分会被排序，以便先检查那些比较明确的组件。这意味着开发者不必担心各种切点标识符的性能，并且可以在切点声明中以任何顺序编写。

但是，AspectJ只能与被它指定的内容协同工作，并且为了获得最佳的匹配性能，开发者应该考虑它们试图实现的目标，并在定义中尽可能缩小匹配的搜索空间。 现有的标识符会自动选择下面三个中的一个 kinded, scoping, 和 contextual:

* Kinded选择特定类型的连接点的标识符:
`execution`, `get`, `set`, `call`, 和 `handler`.
* Scoping选择一组连接点的匹配 （可能是许多种类）: `within` 和 `withincode`
* Contextual基于上下文匹配 （或可选绑定）的标识符:
`this`, `target`, 和 `@annotation`

一个写得很好的切入点应该至少包括前两种类型（kinded和scoping）。同时contextual标识符或许会被包括如果希望匹配基于连接点上下文或绑定在通知中使用的上下文。 只是提供kinded标识符或只提供contextual标识符器也能够工作，但是可能影响处理性能（时间和内存的使用），浪费了额外的处理和分析时间或空间。scoping标识符可以快速匹配并且使用AspectJ可以快速排除不会被处理的连接点组， 这也说明编写好的切点表达式是很重要的（因为没有明确指定时，它就会Loop Lookup循环匹配）。



[[aop-advice]]
=== 声明通知

通知是与切点表达式相关联的概念，可以在切点匹配的方法之前、之后或之间执行。切点表达式可以是对命名切点的简单引用，也可以是即时声明的切点表达式。


[[aop-advice-before]]
==== 前置通知

您可以使用 `@Before` 注解在切面中的通知之前声明：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.Before;

	@Aspect
	public class BeforeExample {

		@Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
		public void doAccessCheck() {
			// ...
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.aspectj.lang.annotation.Aspect
	import org.aspectj.lang.annotation.Before

	@Aspect
	class BeforeExample {

		@Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
		fun doAccessCheck() {
			// ...
		}

	}
----

如果使用内置切点表达式，我们可以重写前面的示例，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.Before;

	@Aspect
	public class BeforeExample {

		@Before("execution(* com.xyz.myapp.dao.*.*(..))")
		public void doAccessCheck() {
			// ...
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.aspectj.lang.annotation.Aspect
	import org.aspectj.lang.annotation.Before

	@Aspect
	class BeforeExample {

		@Before("execution(* com.xyz.myapp.dao.*.*(..))")
		fun doAccessCheck() {
			// ...
		}

	}
----


[[aop-advice-after-returning]]
==== 后置返回通知

要想用后置返回通知可以在切面上添加 `@AfterReturning` 注解:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.AfterReturning;

	@Aspect
	public class AfterReturningExample {

		@AfterReturning("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
		public void doAccessCheck() {
			// ...
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.aspectj.lang.annotation.Aspect
	import org.aspectj.lang.annotation.AfterReturning

	@Aspect
	class AfterReturningExample {

		@AfterReturning("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
		fun doAccessCheck() {
			// ...
		}

----

NOTE: 在同一切面中当然可以声明多个通知。在此只是为了迎合讨论的主题而只涉及单个通知。

有些时候需要在通知中获取实际的返回值。可以使用 `@AfterReturning` ，并指定 `returning` 字段如下:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.AfterReturning;

	@Aspect
	public class AfterReturningExample {

		@AfterReturning(
			pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()",
			returning="retVal")
		public void doAccessCheck(Object retVal) {
			// ...
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.aspectj.lang.annotation.Aspect
	import org.aspectj.lang.annotation.AfterReturning

	@Aspect
	class AfterReturningExample {

		@AfterReturning(pointcut = "com.xyz.myapp.SystemArchitecture.dataAccessOperation()", returning = "retVal")
		fun doAccessCheck(retVal: Any) {
			// ...
		}

	}
----

在 `returning` 属性中使用的名字必须和通知方法中的参数名相关，方法执行返回时，返回值作为相应的参数值传递给advice方法。`returning` 子句还限制只匹配那些返回指定类型的值的方法执行（在本例中为 `Object`，它匹配任何返回值对象）。

请注意，当使用after-returning的通知时。不能返回不同的引用。


[[aop-advice-after-throwing]]
==== 后置异常通知

当方法执行并抛出异常时后置异常通知会被执行，需要使用 `@AfterThrowing` 注解来定义。如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.AfterThrowing;

	@Aspect
	public class AfterThrowingExample {

		@AfterThrowing("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
		public void doRecoveryActions() {
			// ...
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.aspectj.lang.annotation.Aspect
	import org.aspectj.lang.annotation.AfterThrowing

	@Aspect
	class AfterThrowingExample {

		@AfterThrowing("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
		fun doRecoveryActions() {
			// ...
		}

	}
----

开发者常常希望当给定类型的异常被抛出时执行通知，并且也需要在通知中访问抛出的异常。使用 `throwing` 属性来限制匹配（如果需要，使用 `Throwable` 作为异常类型），并将引发的异常绑定到通知参数。以下示例显示了如何执行此操作：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.AfterThrowing;

	@Aspect
	public class AfterThrowingExample {

		@AfterThrowing(
			pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()",
			throwing="ex")
		public void doRecoveryActions(DataAccessException ex) {
			// ...
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.aspectj.lang.annotation.Aspect
	import org.aspectj.lang.annotation.AfterThrowing

	@Aspect
	class AfterThrowingExample {

		@AfterThrowing(pointcut = "com.xyz.myapp.SystemArchitecture.dataAccessOperation()", throwing = "ex")
		fun doRecoveryActions(ex: DataAccessException) {
			// ...
		}

	}
----

`throwing` 属性中使用的名字必须和通知方法中的参数名相关。当方法执行并抛出异常时，异常将会传递给通知方法作为相关的参数值。 抛出子句还限制与只引发指定类型的异常（在本例中为 `DataAccessException`）的方法执行的匹配。


[[aop-advice-after-finally]]
==== 后置通知(总会执行)

当匹配方法执行之后后置通知（总会执行）会被执行。这种情况使用 `@After` 注解来定义。后置通知必须被准备来处理正常或异常的返回条件。通常用于释放资源等等:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.After;

	@Aspect
	public class AfterFinallyExample {

		@After("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
		public void doReleaseLock() {
			// ...
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.aspectj.lang.annotation.Aspect
	import org.aspectj.lang.annotation.After

	@Aspect
	class AfterFinallyExample {

		@After("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
		fun doReleaseLock() {
			// ...
		}

	}
----


[[aop-ataspectj-around-advice]]
==== 环绕通知

最后一种通知是环绕通知，环绕通知围绕方法执行。可以在方法执行之前和执行之后执行，并且定义何时做什么，甚至是否真正得到执行。如果需要在方法执行之前和之后以线程安全的方式 （例如启动和停止计时器） 共享状态， 则通常会使用环绕通知。总是建议使用最适合要求的通知（即可以用前置通知解决的就不要用环绕通知了）。

使用 `@Around` 注解来定义环绕通知，第一个参数必须是 `ProceedingJoinPoint` 类型的。在通知中调用 `ProceedingJoinPoint` 中的 `proceed()` 方法来引用执行的方法。`proceed` 方法也可以被调用传递数组对象- 数组的值将会被当作参数在方法执行时被使用。
`proceed` 方法也可以传入 `Object[]`。 数组中的值在进行时用作方法执行的参数。


NOTE: 在使用 `Object[]` 调用时 `proceed` 的行为与在AspectJ编译器编译的环绕通知进行的行为略有不同。对于使用传统AspectJ语言编写的通知， 传递给 `proceed` 的参数数必须与传递给环绕通知的参数数量（不是被连接点处理的参数的数目）匹配，并且传递的值将 `proceed` 在给定的参数位置取代该值绑定到的实体的连接点的原始值（如果现在无法理解 ，请不要担心）。
Spring处理的方式是简单的并且基于代理的，会生成更好的匹配语义。现在只需意识到这两种是有这么一点的不同的即可。有一种方法可以编写出100%兼容Spring AOP和AspectJ的匹配， 在后续的章节中将会讨论<<aop-ataspectj-advice-params, 通知的参数>>。

以下示例显示如何使用around通知：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.Around;
	import org.aspectj.lang.ProceedingJoinPoint;

	@Aspect
	public class AroundExample {

		@Around("com.xyz.myapp.SystemArchitecture.businessService()")
		public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {
			// start stopwatch
			Object retVal = pjp.proceed();
			// stop stopwatch
			return retVal;
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.aspectj.lang.annotation.Aspect
	import org.aspectj.lang.annotation.Around
	import org.aspectj.lang.ProceedingJoinPoint

	@Aspect
	class AroundExample {

		@Around("com.xyz.myapp.SystemArchitecture.businessService()")
		fun doBasicProfiling(pjp: ProceedingJoinPoint): Any {
			// start stopwatch
			val retVal = pjp.proceed()
			// stop stopwatch
			return pjp.proceed()
		}

	}
----

环绕通知返回的值将会被调用的方法看到，例如，一个简单的缓存切面可以从缓存中返回一个值（如果有的话），如果没有则调用 `proceed()`。 请注意，可以在around通知的主体内调用一次，多次或根本不调用。 所有这些都是合法的。


[[aop-ataspectj-advice-params]]
==== 通知的参数

Spring提供了全部类型的通知，这意味着需在通知签名中声明所需的参数（正如上面返回和异常的示例），而不是一直使用 `Object[]` 数组。接着将会看到怎么声明参数以及上下文的值是如何在通知实体中被使用的。 首先，来看看如何编写一般的通知，找出编写通知的法子。

[[aop-ataspectj-advice-params-the-joinpoint]]
===== 访问当前的 `JoinPoint`

任何通知方法都可以声明一个类型为 `org.aspectj.lang.JoinPoint` 的参数作为其第一个参数（注意，需要使用 环绕通知来声明一个类型为 `ProceedingJoinPoint` 的第一个参数， 它是 `JoinPoint` 的一个子类。`JoinPoint` 接口提供很多有用的方法：:

* `getArgs()`: 返回方法参数.
* `getThis()`: 返回代理对象.
* `getTarget()`: 返回目标对象.
* `getSignature()`: 返回正在通知的方法的描述.
* `toString()`: 打印方法被通知的有用描述.

See the https://www.eclipse.org/aspectj/doc/released/runtime-api/org/aspectj/lang/JoinPoint.html[javadoc] for more detail.

[[aop-ataspectj-advice-params-passing]]
===== 传递参数给通知

我们已经看到了如何绑定返回的值或异常值（在返回之后和抛出通知之后使用）。为了在通知代码段中使用参数值，可以使用绑定 `args` 的形式。如果在参数表达式中使用参数名代替类型名称， 则在调用通知时，要将相关的参数值当作参数传递。例如，假如在dao操作时将 `Account` 对象作为第一个参数传递给通知，并且需要在通知代码段内访问 `Account`，可以这样写:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation() && args(account,..)")
	public void validateAccount(Account account) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation() && args(account,..)")
	fun validateAccount(account: Account) {
		// ...
	}
----

切点表达式的 `args(account,..)` 部分有两个目的。p它严格匹配了至少带一个参数的执行方法，并且传递给传递的参数是 `Account` 实例。 第二，它使得实际的 `Account` 对象通过 `account` 参数提供给通知。

另一个方法写法就是先定义切点，然后， "`provides`" `Account` 对象给匹配的连接点，有了连接点，那么引用连接点作为切点的通知就能获得 `Account` 对象的值。这看起来如下：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Pointcut("com.xyz.myapp.SystemArchitecture.dataAccessOperation() && args(account,..)")
	private void accountDataAccessOperation(Account account) {}

	@Before("accountDataAccessOperation(account)")
	public void validateAccount(Account account) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Pointcut("com.xyz.myapp.SystemArchitecture.dataAccessOperation() && args(account,..)")
	private fun accountDataAccessOperation(account: Account) {
	}

	@Before("accountDataAccessOperation(account)")
	fun validateAccount(account: Account) {
		// ...
	}
----

有关更多详细信息，请参阅AspectJ编程指南。

代理对象( `this`)，目标对象 ( `target`)和注解 ( `@within`, `@target`, `@annotation`, 和 `@args`)都可以以类似的方式绑定。接下来的两个示例显示如何匹配带有 `@Auditable` 注解的注解方法的执行并获取audit代码代码:

首先是 `@Auditable` 注解的定义:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Retention(RetentionPolicy.RUNTIME)
	@Target(ElementType.METHOD)
	public @interface Auditable {
		AuditCode value();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Retention(AnnotationRetention.RUNTIME)
	@Target(AnnotationTarget.FUNCTION)
	annotation class Auditable(val value: AuditCode)
----

然后是匹配 `@Auditable` 方法通知的执行

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Before("com.xyz.lib.Pointcuts.anyPublicMethod() && @annotation(auditable)")
	public void audit(Auditable auditable) {
		AuditCode code = auditable.value();
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Before("com.xyz.lib.Pointcuts.anyPublicMethod() && @annotation(auditable)")
	fun audit(auditable: Auditable) {
		val code = auditable.value()
		// ...
	}
----

[[aop-ataspectj-advice-params-generics]]
===== 通知参数和泛型

Spring AOP可以处理类声明和方法参数中使用的泛型。假设如下泛型类型:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public interface Sample<T> {
		void sampleGenericMethod(T param);
		void sampleGenericCollectionMethod(Collection<T> param);
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	interface Sample<T> {
		fun sampleGenericMethod(param: T)
		fun sampleGenericCollectionMethod(param: Collection<T>)
	}
----

只需将通知参数键入要拦截方法的参数类型，就可以将方法类型的检测限制为某些参数类型:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Before("execution(* ..Sample+.sampleGenericMethod(*)) && args(param)")
	public void beforeSampleMethod(MyType param) {
		// Advice implementation
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Before("execution(* ..Sample+.sampleGenericMethod(*)) && args(param)")
	fun beforeSampleMethod(param: MyType) {
		// Advice implementation
	}
----

此方法不适用于泛型集合。 因此，您无法按如下方式定义切点:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Before("execution(* ..Sample+.sampleGenericCollectionMethod(*)) && args(param)")
	public void beforeSampleMethod(Collection<MyType> param) {
		// Advice implementation
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Before("execution(* ..Sample+.sampleGenericCollectionMethod(*)) && args(param)")
	fun beforeSampleMethod(param: Collection<MyType>) {
		// Advice implementation
	}
----

为了使这项工作，我们必须检查集合的每个元素，这是不合理的，因为我们也无法决定如何处理 `null` 值。 要实现与此类似的操作，您必须将参数键入 `Collection<?>` 并手动检查元素的类型。

[[aop-ataspectj-advice-params-names]]
===== 声明参数的名字

参数在通知中的绑定依赖于名字匹配，重点在切点表达式中定义的参数名的方法签名上（通知和切点）。参数名称不能通过Java反射获得，因此Spring AOP使用以下策略来确定参数名称：

* 如果用户已明确指定参数名称，则使用指定的参数名称。通知和切点注解都有一个可选的 `argNames` 属性，您可以使用该属性指定带注解的方法的参数名称。 这些参数名称在运行时可用。 以下示例显示如何使用 `argNames` 属性:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Before(value="com.xyz.lib.Pointcuts.anyPublicMethod() && target(bean) && @annotation(auditable)",
			argNames="bean,auditable")
	public void audit(Object bean, Auditable auditable) {
		AuditCode code = auditable.value();
		// ... use code and bean
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Before(value = "com.xyz.lib.Pointcuts.anyPublicMethod() && target(bean) && @annotation(auditable)", argNames = "bean,auditable")
	fun audit(bean: Any, auditable: Auditable) {
		val code = auditable.value()
		// ... use code and bean
	}
----

如果第一个参数是 `JoinPoint`, `ProceedingJoinPoint`, 或 `JoinPoint.StaticPart` 类型，则可以从 `argNames` 属性的值中省略参数的名称。 例如，如果修改前面的通知以接收连接点对象，则 `argNames` 属性不需要包含它:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Before(value="com.xyz.lib.Pointcuts.anyPublicMethod() && target(bean) && @annotation(auditable)",
			argNames="bean,auditable")
	public void audit(JoinPoint jp, Object bean, Auditable auditable) {
		AuditCode code = auditable.value();
		// ... use code, bean, and jp
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Before(value = "com.xyz.lib.Pointcuts.anyPublicMethod() && target(bean) && @annotation(auditable)", argNames = "bean,auditable")
	fun audit(jp: JoinPoint, bean: Any, auditable: Auditable) {
		val code = auditable.value()
		// ... use code, bean, and jp
	}
----

对 `JoinPoint`,`ProceedingJoinPoint`, 和 `JoinPoint.StaticPart` 类型的第一个参数的特殊处理方便不收集任何其他连接点上下文的通知。 在这种情况下，可以简单地省略 `argNames` 属性。例如，以下建议无需声明 `argNames` 属性:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Before("com.xyz.lib.Pointcuts.anyPublicMethod()")
	public void audit(JoinPoint jp) {
		// ... use jp
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Before("com.xyz.lib.Pointcuts.anyPublicMethod()")
	fun audit(jp: JoinPoint) {
		// ... use jp
	}
----

* 使用 `'argNames'` 属性有点笨拙，所以如果没有指定 `'argNames'` 属性，Spring AOP会查看该类的调试信息，并尝试从局部变量表中确定参数名称。只要使用调试信息( `'-g:vars'` ）编译类， 就会出现此信息。
使用此标志进行编译的后果是：(1).您的代码将容易被理解(逆向工程。(2). 类文件的大小将会有些大(通常不是什么事)。(3). 对非使用本地变量的优化将不会应用于你的编译器。 换句话说，通过使用此标志构建，您应该不会遇到任何困难。
+
NOTE: 如果即使没有调试信息，AspectJ编译器（ajc）也编译了@AspectJ方面，则无需添加 `argNames` 属性，因为编译器会保留所需的信息。

* 如果代码是在没有必要的调试信息的情况下编译的，那么Spring AOP将尝试推断绑定变量与参数的配对（例如，如果在切点表达式中只绑定了一个变量，并且该通知方法只需要一个参数，此时两者匹配是明显的）。 如果给定了可用信息，变量的绑定是不明确的话，则会引发 `AmbiguousBindingException` 异常。
* 如果上述所有策略都失败，则抛出 `IllegalArgumentException` 异常。

[[aop-ataspectj-advice-proceeding-with-the-call]]
===== 处理参数

前面说过。将描述如何用在Spring AOP和AspectJ中一致的参数中编写 `proceed` 处理函数。解决方案是确保建议签名按顺序绑定每个方法参数。 以下示例显示了如何执行此操作：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Around("execution(List<Account> find*(..)) && " +
			"com.xyz.myapp.SystemArchitecture.inDataAccessLayer() && " +
			"args(accountHolderNamePattern)")
	public Object preProcessQueryPattern(ProceedingJoinPoint pjp,
			String accountHolderNamePattern) throws Throwable {
		String newPattern = preProcess(accountHolderNamePattern);
		return pjp.proceed(new Object[] {newPattern});
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Around("execution(List<Account> find*(..)) && " +
			"com.xyz.myapp.SystemArchitecture.inDataAccessLayer() && " +
			"args(accountHolderNamePattern)")
	fun preProcessQueryPattern(pjp: ProceedingJoinPoint,
							accountHolderNamePattern: String): Any {
		val newPattern = preProcess(accountHolderNamePattern)
		return pjp.proceed(arrayOf<Any>(newPattern))
	}
----

在许多情况下，无论如何都要执行此绑定（如前面的示例所示）。


[[aop-ataspectj-advice-ordering]]
==== 通知的顺序

当多个通知都希望在同一连接点上运行时会发生什么情况？Spring AOP遵循与AspectJ相同的优先级规则来确定通知执行的顺序。拥有最高优先权的通知会途中先"进入"（因此，给定两条前置通知，优先级最高的通知首先运行）。 从连接点"退出"，拥有最高优先级的通知最后才运行（退出）（（因此，如果有两个后置通知，那么拥有最高优先级的将在最后运行（退出））。

如果在不同切面定义的两个通知都需要在同一个连接点运行，那么除非开发者指定运行的先后，否则执行的顺序是未定义的。 可以通过指定优先级来控制执行顺序。这也是Spring推荐的方式，通过在切面类实现 `org.springframework.core.Ordered` 接口或使用 `Order` 对其进行注解即可。
如果有两个切面，从 `Ordered.getValue()`（或注解值）返回较低值的方面具有较高的优先级。

当在同一切面定义的两条通知都需要在同一个连接点上运行时，排序也是未定义的（因为没有办法通过反射检索Javac编译的类的声明顺序） 。考虑将通知方法与一个通知方法合并，根据每个连接点在每个切面类或将通知切分为切面类，可以在切面级别指定顺序。



[[aop-introductions]]
=== 引入

引入（作为AspectJ中内部类型的声明）允许切面定义通知的对象实现给定的接口,并代表这些对象提供该接口的实现.

引入使用 `@DeclareParents` 注解来定义,这个注解用于声明匹配拥有新的父类的类型（因此得名）。例如， 给定名为 `UsageTracked` 的接口和名为 `DefaultUsageTracked` 的接口的实现，以下切面声明服务接口的所有实现者也实现 `UsageTracked` 接口（例如，通过JMX公开统计信息）:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Aspect
	public class UsageTracking {

		@DeclareParents(value="com.xzy.myapp.service.*+", defaultImpl=DefaultUsageTracked.class)
		public static UsageTracked mixin;

		@Before("com.xyz.myapp.SystemArchitecture.businessService() && this(usageTracked)")
		public void recordUsage(UsageTracked usageTracked) {
			usageTracked.incrementUseCount();
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Aspect
	class UsageTracking {

		companion object {
			@DeclareParents(value = "com.xzy.myapp.service.*+", defaultImpl = DefaultUsageTracked::class)
			lateinit var mixin: UsageTracked
		}

		@Before("com.xyz.myapp.SystemArchitecture.businessService() && this(usageTracked)")
		fun recordUsage(usageTracked: UsageTracked) {
			usageTracked.incrementUseCount()
		}
	}
----

要实现的接口由注解属性的类型来确定。 `@DeclareParents` 注解的 `value` 值是AspectJ类型模式引过来的。注意上面例子中的前置通知， 服务bean可以直接作为 `UsageTracked` 接口的实现，如果以编程方式访问bean，您将编写以下内容：:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	UsageTracked usageTracked = (UsageTracked) context.getBean("myService");
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val usageTracked = context.getBean("myService") as UsageTracked
----


[[aop-instantiation-models]]
=== 切面实例化模型

NOTE: 这是一个高级主题。 如果您刚刚开始使用AOP，您可以跳过它直到稍后再了解。

默认情况下，应用程序上下文中的每个切面都有一个实例。AspectJ将其称为单例实例化模型。 可以使用交替生命周期定义切面。 Spring支持AspectJ的 `perthis` 和 `pertarget` 实例化模型（目前不支持 `percflow`, `percflowbelow`, 和 `pertypewithin`）。

您可以通过在 `@Aspect` 注解中指定 `perthis` 子句来声明相关方面。 请考虑以下示例:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Aspect("perthis(com.xyz.myapp.SystemArchitecture.businessService())")
	public class MyAspect {

		private int someState;

		@Before(com.xyz.myapp.SystemArchitecture.businessService())
		public void recordServiceUsage() {
			// ...
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Aspect("perthis(com.xyz.myapp.SystemArchitecture.businessService())")
	class MyAspect {

		private val someState: Int = 0

		@Before(com.xyz.myapp.SystemArchitecture.businessService())
		fun recordServiceUsage() {
			// ...
		}

	}
----

在前面的示例中，`'perthis'` 子句的作用是为执行业务服务的每个唯一服务对象创建一个切面实例（每个唯一对象在由切点表达式匹配的连接点处绑定到'this'）。 方法实例是在第一次在服务对象上调用方法时创建的。
当服务对象超出范围时，该切面也将超出范围。在创建切面实例之前，它包含的任意通知都不会执行。在创建了切面实例后， 其中声明的通知将在匹配的连接点中执行，但仅当服务对象是此切面关联的通知时才会运行。有关 `per` 子句的更多信息，请参阅AspectJ编程指南。

`pertarget` 实例化模型的工作方式与 `perthis` 完全相同，但它为匹配的连接点处的每个唯一目标对象创建一个切面实例。



[[aop-ataspectj-example]]
=== AOP 例子

现在您已经了解了所有组成部分的工作原理，我们可以将它们放在一起做一些有用的事情.

由于并发问题（例如，死锁失败者），业务服务的执行有时会失败。如果重试该操作，则可能在下次尝试时成功。对于适合在这种情况下重试的业务服务（不需要返回给用户来解决冲突的幂等操作）。 希望透明地重试该操作，以避免客户端看到 `PessimisticLockingFailureException` 异常。这个需求很明显，它跨越了服务层中的多个服务，因此非常适合通过切面来实现。

因为我们想要重试操作，所以我们需要使用环绕通知，以便我们可以多次调用 `proceed`。 以下清单显示了基本方面的实现:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Aspect
	public class ConcurrentOperationExecutor implements Ordered {

		private static final int DEFAULT_MAX_RETRIES = 2;

		private int maxRetries = DEFAULT_MAX_RETRIES;
		private int order = 1;

		public void setMaxRetries(int maxRetries) {
			this.maxRetries = maxRetries;
		}

		public int getOrder() {
			return this.order;
		}

		public void setOrder(int order) {
			this.order = order;
		}

		@Around("com.xyz.myapp.SystemArchitecture.businessService()")
		public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {
			int numAttempts = 0;
			PessimisticLockingFailureException lockFailureException;
			do {
				numAttempts++;
				try {
					return pjp.proceed();
				}
				catch(PessimisticLockingFailureException ex) {
					lockFailureException = ex;
				}
			} while(numAttempts <= this.maxRetries);
			throw lockFailureException;
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Aspect
	class ConcurrentOperationExecutor : Ordered {

		private val DEFAULT_MAX_RETRIES = 2
		private var maxRetries = DEFAULT_MAX_RETRIES
		private var order = 1

		fun setMaxRetries(maxRetries: Int) {
			this.maxRetries = maxRetries
		}

		override fun getOrder(): Int {
			return this.order
		}

		fun setOrder(order: Int) {
			this.order = order
		}

		@Around("com.xyz.myapp.SystemArchitecture.businessService()")
		fun doConcurrentOperation(pjp: ProceedingJoinPoint): Any {
			var numAttempts = 0
			var lockFailureException: PessimisticLockingFailureException
			do {
				numAttempts++
				try {
					return pjp.proceed()
				} catch (ex: PessimisticLockingFailureException) {
					lockFailureException = ex
				}

			} while (numAttempts <= this.maxRetries)
			throw lockFailureException
		}
	}
----

请注意，该方面实现了 `Ordered` 接口，以便我们可以将切面的优先级设置为高于事务通知（我们每次重试时都需要一个新的事务）。 `maxRetries` 和 `order` 属性都由Spring配置。主要的操作是在 `doConcurrentOperation` 的环绕通知中。
请注意，请注意，目前，我们将重试逻辑应用于每个 `businessService()`。 尝试执行时，如果失败了，将产生 `PessimisticLockingFailureException` 异常，但是不用管它，只需再次尝试执行即可，除非已经用尽所有的重试次数。

相应的Spring配置如下：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:aspectj-autoproxy/>

	<bean id="concurrentOperationExecutor" class="com.xyz.myapp.service.impl.ConcurrentOperationExecutor">
		<property name="maxRetries" value="3"/>
		<property name="order" value="100"/>
	</bean>
----

为了优化切面以便它只重试幂等操作，我们可以定义以下 `Idempotent` 注解:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Retention(RetentionPolicy.RUNTIME)
	public @interface Idempotent {
		// marker annotation
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Retention(AnnotationRetention.RUNTIME)
	annotation class Idempotent// marker annotation
----

然后使用它来注解服务操作的实现。对切面的更改只需要重试等幂运算，只需细化切点表达式，以便只匹配 `@Idempotent` 操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Around("com.xyz.myapp.SystemArchitecture.businessService() && " +
			"@annotation(com.xyz.myapp.service.Idempotent)")
	public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Around("com.xyz.myapp.SystemArchitecture.businessService() && " + "@annotation(com.xyz.myapp.service.Idempotent)")
	fun doConcurrentOperation(pjp: ProceedingJoinPoint): Any {
		// ...
	}
----



[[aop-schema]]
== Schema-based AOP Support

If you prefer an XML-based format, Spring also offers support for defining aspects
using the new `aop` namespace tags. The exact same pointcut expressions and advice kinds
as when using the @AspectJ style are supported. Hence, in this section we focus on
the new syntax and refer the reader to the discussion in the previous section
(<<aop-ataspectj>>) for an understanding of writing pointcut expressions and the binding
of advice parameters.

To use the aop namespace tags described in this section, you need to import the
`spring-aop` schema, as described in <<core.adoc#xsd-schemas,
XML Schema-based configuration>>. See <<core.adoc#xsd-schemas-aop, the AOP schema>>
for how to import the tags in the `aop` namespace.

Within your Spring configurations, all aspect and advisor elements must be placed within
an `<aop:config>` element (you can have more than one `<aop:config>` element in an
application context configuration). An `<aop:config>` element can contain pointcut,
advisor, and aspect elements (note that these must be declared in that order).

WARNING: The `<aop:config>` style of configuration makes heavy use of Spring's
<<aop-autoproxy, auto-proxying>> mechanism. This can cause issues (such as advice
not being woven) if you already use explicit auto-proxying through the use of
`BeanNameAutoProxyCreator` or something similar. The recommended usage pattern is to
use either only the `<aop:config>` style or only the `AutoProxyCreator` style and
never mix them.



[[aop-schema-declaring-an-aspect]]
=== Declaring an Aspect

When you use the schema support, an aspect is a regular Java object defined as a bean in
your Spring application context. The state and behavior are captured in the fields and
methods of the object, and the pointcut and advice information are captured in the XML.

You can declare an aspect by using the <aop:aspect> element, and reference the backing bean
by using the `ref` attribute, as the following example shows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:config>
		<aop:aspect id="myAspect" ref="aBean">
			...
		</aop:aspect>
	</aop:config>

	<bean id="aBean" class="...">
		...
	</bean>
----

The bean that backs the aspect (`aBean` in this case) can of course be configured and
dependency injected just like any other Spring bean.



[[aop-schema-pointcuts]]
=== Declaring a Pointcut

You can declare a named pointcut inside an `<aop:config>` element, letting the pointcut
definition be shared across several aspects and advisors.

A pointcut that represents the execution of any business service in the service layer can
be defined as follows:

[source,xml,indent=0,subs="verbatim"]
----
	<aop:config>

		<aop:pointcut id="businessService"
			expression="execution(* com.xyz.myapp.service.*.*(..))"/>

	</aop:config>
----

Note that the pointcut expression itself is using the same AspectJ pointcut expression
language as described in <<aop-ataspectj>>. If you use the schema based declaration
style, you can refer to named pointcuts defined in types (@Aspects) within the
pointcut expression. Another way of defining the above pointcut would be as follows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:config>

		<aop:pointcut id="businessService"
			expression="com.xyz.myapp.SystemArchitecture.businessService()"/>

	</aop:config>
----

Assume that you have a `SystemArchitecture` aspect as described in <<aop-common-pointcuts>>.

Then declaring a pointcut inside an aspect is very similar to declaring a top-level pointcut,
as the following example shows:

[source,xml,indent=0,subs="verbatim"]
----
	<aop:config>

		<aop:aspect id="myAspect" ref="aBean">

			<aop:pointcut id="businessService"
				expression="execution(* com.xyz.myapp.service.*.*(..))"/>

			...

		</aop:aspect>

	</aop:config>
----

In much the same way as an @AspectJ aspect, pointcuts declared by using the schema based
definition style can collect join point context. For example, the following pointcut
collects the `this` object as the join point context and passes it to the advice:

[source,xml,indent=0,subs="verbatim"]
----
	<aop:config>

		<aop:aspect id="myAspect" ref="aBean">

			<aop:pointcut id="businessService"
				expression="execution(* com.xyz.myapp.service.*.*(..)) &amp;&amp; this(service)"/>

			<aop:before pointcut-ref="businessService" method="monitor"/>

			...

		</aop:aspect>

	</aop:config>
----

The advice must be declared to receive the collected join point context by including
parameters of the matching names, as follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public void monitor(Object service) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun monitor(service: Any) {
		// ...
	}
----

When combining pointcut sub-expressions, `&&` is awkward within an XML document, so
you can use the `and`, `or`, and `not` keywords in place of `&&`, `||`, and `!`,
respectively. For example, the previous pointcut can be better written as follows:

[source,xml,indent=0,subs="verbatim"]
----
	<aop:config>

		<aop:aspect id="myAspect" ref="aBean">

			<aop:pointcut id="businessService"
				expression="execution(* com.xyz.myapp.service.*.*(..)) and this(service)"/>

			<aop:before pointcut-ref="businessService" method="monitor"/>

			...
		</aop:aspect>
	</aop:config>
----

Note that pointcuts defined in this way are referred to by their XML `id` and cannot be
used as named pointcuts to form composite pointcuts. The named pointcut support in the
schema-based definition style is thus more limited than that offered by the @AspectJ
style.



[[aop-schema-advice]]
=== Declaring Advice

The schema-based AOP support uses the same five kinds of advice as the @AspectJ style, and they have
exactly the same semantics.


[[aop-schema-advice-before]]
==== Before Advice

Before advice runs before a matched method execution. It is declared inside an
`<aop:aspect>` by using the <aop:before> element, as the following example shows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:aspect id="beforeExample" ref="aBean">

		<aop:before
			pointcut-ref="dataAccessOperation"
			method="doAccessCheck"/>

		...

	</aop:aspect>
----

Here, `dataAccessOperation` is the `id` of a pointcut defined at the top (`<aop:config>`)
level. To define the pointcut inline instead, replace the `pointcut-ref` attribute with
a `pointcut` attribute, as follows:

[source,xml,indent=0,subs="verbatim"]
----
	<aop:aspect id="beforeExample" ref="aBean">

		<aop:before
			pointcut="execution(* com.xyz.myapp.dao.*.*(..))"
			method="doAccessCheck"/>

		...

	</aop:aspect>
----

As we noted in the discussion of the @AspectJ style, using named pointcuts can
significantly improve the readability of your code.

The `method` attribute identifies a method (`doAccessCheck`) that provides the body of
the advice. This method must be defined for the bean referenced by the aspect element
that contains the advice. Before a data access operation is executed (a method execution
join point matched by the pointcut expression), the `doAccessCheck` method on the aspect
bean is invoked.


[[aop-schema-advice-after-returning]]
==== After Returning Advice

After returning advice runs when a matched method execution completes normally. It is
declared inside an `<aop:aspect>` in the same way as before advice. The following example
shows how to declare it:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:aspect id="afterReturningExample" ref="aBean">

		<aop:after-returning
			pointcut-ref="dataAccessOperation"
			method="doAccessCheck"/>

		...

	</aop:aspect>
----

As in the @AspectJ style, you can get the return value within the
advice body. To do so, use the returning attribute to specify the name of the parameter to which
the return value should be passed, as the following example shows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:aspect id="afterReturningExample" ref="aBean">

		<aop:after-returning
			pointcut-ref="dataAccessOperation"
			returning="retVal"
			method="doAccessCheck"/>

		...

	</aop:aspect>
----

The `doAccessCheck` method must declare a parameter named `retVal`. The type of this
parameter constrains matching in the same way as described for `@AfterReturning`. For
example, you can declare the method signature as follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public void doAccessCheck(Object retVal) {...
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun doAccessCheck(retVal: Any) {...
----


[[aop-schema-advice-after-throwing]]
==== After Throwing Advice

After throwing advice executes when a matched method execution exits by throwing an
exception. It is declared inside an `<aop:aspect>` by using the after-throwing element,
as the following example shows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:aspect id="afterThrowingExample" ref="aBean">

		<aop:after-throwing
			pointcut-ref="dataAccessOperation"
			method="doRecoveryActions"/>

		...

	</aop:aspect>
----

As in the @AspectJ style, you can get the thrown exception within
the advice body. To do so, use the throwing attribute to specify the name of the parameter to
which the exception should be passed as the following example shows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:aspect id="afterThrowingExample" ref="aBean">

		<aop:after-throwing
			pointcut-ref="dataAccessOperation"
			throwing="dataAccessEx"
			method="doRecoveryActions"/>

		...

	</aop:aspect>
----

The `doRecoveryActions` method must declare a parameter named `dataAccessEx`. The type of
this parameter constrains matching in the same way as described for `@AfterThrowing`. For
example, the method signature may be declared as follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public void doRecoveryActions(DataAccessException dataAccessEx) {...
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun doRecoveryActions(dataAccessEx: DataAccessException) {...
----


[[aop-schema-advice-after-finally]]
==== After (Finally) Advice

After (finally) advice runs no matter how a matched method execution exits. You can declare it
by using the `after` element, as the following example shows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:aspect id="afterFinallyExample" ref="aBean">

		<aop:after
			pointcut-ref="dataAccessOperation"
			method="doReleaseLock"/>

		...

	</aop:aspect>
----


[[aop-schema-advice-around]]
==== Around Advice

The last kind of advice is around advice. Around advice runs "`around`" a matched method
execution. It has the opportunity to do work both before and after the method executes
and to determine when, how, and even if the method actually gets to execute at all.
Around advice is often used to share state before and after a method
execution in a thread-safe manner (starting and stopping a timer, for example). Always
use the least powerful form of advice that meets your requirements. Do not use around
advice if before advice can do the job.

You can declare around advice by using the `aop:around` element. The first parameter of the
advice method must be of type `ProceedingJoinPoint`. Within the body of the advice,
calling `proceed()` on the `ProceedingJoinPoint` causes the underlying method to
execute. The `proceed` method may also be called with an `Object[]`. The values
in the array are used as the arguments to the method execution when it proceeds. See
<<aop-ataspectj-around-advice>> for notes on calling `proceed` with an `Object[]`.
The following example shows how to declare around advice in XML:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:aspect id="aroundExample" ref="aBean">

		<aop:around
			pointcut-ref="businessService"
			method="doBasicProfiling"/>

		...

	</aop:aspect>
----

The implementation of the `doBasicProfiling` advice can be exactly the same as in the
@AspectJ example (minus the annotation, of course), as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {
		// start stopwatch
		Object retVal = pjp.proceed();
		// stop stopwatch
		return retVal;
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun doBasicProfiling(pjp: ProceedingJoinPoint): Any {
		// start stopwatch
		val retVal = pjp.proceed()
		// stop stopwatch
		return pjp.proceed()
	}
----


[[aop-schema-params]]
==== Advice Parameters

The schema-based declaration style supports fully typed advice in the same way as
described for the @AspectJ support -- by matching pointcut parameters by name against
advice method parameters. See <<aop-ataspectj-advice-params>> for details. If you wish
to explicitly specify argument names for the advice methods (not relying on the
detection strategies previously described), you can do so by using the `arg-names`
attribute of the advice element, which is treated in the same manner as the `argNames`
attribute in an advice annotation (as described in <<aop-ataspectj-advice-params-names>>).
The following example shows how to specify an argument name in XML:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:before
		pointcut="com.xyz.lib.Pointcuts.anyPublicMethod() and @annotation(auditable)"
		method="audit"
		arg-names="auditable"/>
----

The `arg-names` attribute accepts a comma-delimited list of parameter names.

The following slightly more involved example of the XSD-based approach shows
some around advice used in conjunction with a number of strongly typed parameters:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package x.y.service;

	public interface PersonService {

		Person getPerson(String personName, int age);
	}

	public class DefaultFooService implements FooService {

		public Person getPerson(String name, int age) {
			return new Person(name, age);
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package x.y.service

	interface PersonService {

		fun getPerson(personName: String, age: Int): Person
	}

	class DefaultFooService : FooService {

		fun getPerson(name: String, age: Int): Person {
			return Person(name, age)
		}
	}
----

Next up is the aspect. Notice the fact that the `profile(..)` method accepts a number of
strongly-typed parameters, the first of which happens to be the join point used to
proceed with the method call. The presence of this parameter is an indication that the
`profile(..)` is to be used as `around` advice, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package x.y;

	import org.aspectj.lang.ProceedingJoinPoint;
	import org.springframework.util.StopWatch;

	public class SimpleProfiler {

		public Object profile(ProceedingJoinPoint call, String name, int age) throws Throwable {
			StopWatch clock = new StopWatch("Profiling for '" + name + "' and '" + age + "'");
			try {
				clock.start(call.toShortString());
				return call.proceed();
			} finally {
				clock.stop();
				System.out.println(clock.prettyPrint());
			}
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.aspectj.lang.ProceedingJoinPoint
	import org.springframework.util.StopWatch

	class SimpleProfiler {

		fun profile(call: ProceedingJoinPoint, name: String, age: Int): Any {
			val clock = StopWatch("Profiling for '$name' and '$age'")
			try {
				clock.start(call.toShortString())
				return call.proceed()
			} finally {
				clock.stop()
				println(clock.prettyPrint())
			}
		}
	}
----

Finally, the following example XML configuration effects the execution of the
preceding advice for a particular join point:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd">

		<!-- this is the object that will be proxied by Spring's AOP infrastructure -->
		<bean id="personService" class="x.y.service.DefaultPersonService"/>

		<!-- this is the actual advice itself -->
		<bean id="profiler" class="x.y.SimpleProfiler"/>

		<aop:config>
			<aop:aspect ref="profiler">

				<aop:pointcut id="theExecutionOfSomePersonServiceMethod"
					expression="execution(* x.y.service.PersonService.getPerson(String,int))
					and args(name, age)"/>

				<aop:around pointcut-ref="theExecutionOfSomePersonServiceMethod"
					method="profile"/>

			</aop:aspect>
		</aop:config>

	</beans>
----

Consider the following driver script:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.springframework.beans.factory.BeanFactory;
	import org.springframework.context.support.ClassPathXmlApplicationContext;
	import x.y.service.PersonService;

	public final class Boot {

		public static void main(final String[] args) throws Exception {
			BeanFactory ctx = new ClassPathXmlApplicationContext("x/y/plain.xml");
			PersonService person = (PersonService) ctx.getBean("personService");
			person.getPerson("Pengo", 12);
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun main() {
		val ctx = ClassPathXmlApplicationContext("x/y/plain.xml")
		val person = ctx.getBean("personService") as PersonService
		person.getPerson("Pengo", 12)
	}
----

With such a Boot class, we would get output similar to the following on standard output:

[literal,subs="verbatim,quotes"]
----
StopWatch 'Profiling for 'Pengo' and '12'': running time (millis) = 0
-----------------------------------------
ms     %     Task name
-----------------------------------------
00000  ?  execution(getFoo)
----


[[aop-ordering]]
==== Advice Ordering

When multiple advice needs to execute at the same join point (executing method) the
ordering rules are as described in <<aop-ataspectj-advice-ordering>>. The precedence
between aspects is determined by either adding the `Order` annotation to the bean
that backs the aspect or by having the bean implement the `Ordered` interface.



[[aop-schema-introductions]]
=== Introductions

Introductions (known as inter-type declarations in AspectJ) let an aspect declare
that advised objects implement a given interface and provide an implementation of
that interface on behalf of those objects.

You can make an introduction by using the `aop:declare-parents` element inside an `aop:aspect`.
You can use the `aop:declare-parents` element to declare that matching types have a new parent (hence the name).
For example, given an interface named `UsageTracked` and an implementation of that interface named
`DefaultUsageTracked`, the following aspect declares that all implementors of service
interfaces also implement the `UsageTracked` interface. (In order to expose statistics
through JMX for example.)

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:aspect id="usageTrackerAspect" ref="usageTracking">

		<aop:declare-parents
			types-matching="com.xzy.myapp.service.*+"
			implement-interface="com.xyz.myapp.service.tracking.UsageTracked"
			default-impl="com.xyz.myapp.service.tracking.DefaultUsageTracked"/>

		<aop:before
			pointcut="com.xyz.myapp.SystemArchitecture.businessService()
				and this(usageTracked)"
				method="recordUsage"/>

	</aop:aspect>
----

The class that backs the `usageTracking` bean would then contain the following method:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public void recordUsage(UsageTracked usageTracked) {
		usageTracked.incrementUseCount();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun recordUsage(usageTracked: UsageTracked) {
		usageTracked.incrementUseCount()
	}
----

The interface to be implemented is determined by the `implement-interface` attribute. The
value of the `types-matching` attribute is an AspectJ type pattern. Any bean of a
matching type implements the `UsageTracked` interface. Note that, in the before
advice of the preceding example, service beans can be directly used as implementations of
the `UsageTracked` interface. To access a bean programmatically, you could write the
following:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	UsageTracked usageTracked = (UsageTracked) context.getBean("myService");
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val usageTracked = context.getBean("myService") as UsageTracked
----



[[aop-schema-instatiation-models]]
=== Aspect Instantiation Models

The only supported instantiation model for schema-defined aspects is the singleton
model. Other instantiation models may be supported in future releases.



[[aop-schema-advisors]]
=== Advisors

The concept of "`advisors`" comes from the AOP support defined in Spring
and does not have a direct equivalent in AspectJ. An advisor is like a small
self-contained aspect that has a single piece of advice. The advice itself is
represented by a bean and must implement one of the advice interfaces described in
<<aop-api-advice-types>>. Advisors can take advantage of AspectJ pointcut expressions.

Spring supports the advisor concept with the `<aop:advisor>` element. You most
commonly see it used in conjunction with transactional advice, which also has its own
namespace support in Spring. The following example shows an advisor:

[source,xml,indent=0,subs="verbatim"]
----
	<aop:config>

		<aop:pointcut id="businessService"
			expression="execution(* com.xyz.myapp.service.*.*(..))"/>

		<aop:advisor
			pointcut-ref="businessService"
			advice-ref="tx-advice"/>

	</aop:config>

	<tx:advice id="tx-advice">
		<tx:attributes>
			<tx:method name="*" propagation="REQUIRED"/>
		</tx:attributes>
	</tx:advice>
----

As well as the `pointcut-ref` attribute used in the preceding example, you can also use the
`pointcut` attribute to define a pointcut expression inline.

To define the precedence of an advisor so that the advice can participate in ordering,
use the `order` attribute to define the `Ordered` value of the advisor.



[[aop-schema-example]]
=== An AOP Schema Example

This section shows how the concurrent locking failure retry example from
<<aop-ataspectj-example>> looks when rewritten with the schema support.

The execution of business services can sometimes fail due to concurrency issues (for
example, a deadlock loser). If the operation is retried, it is likely to succeed
on the next try. For business services where it is appropriate to retry in such
conditions (idempotent operations that do not need to go back to the user for conflict
resolution), we want to transparently retry the operation to avoid the client seeing a
`PessimisticLockingFailureException`. This is a requirement that clearly cuts across
multiple services in the service layer and, hence, is ideal for implementing through an
aspect.

Because we want to retry the operation, we need to use around advice so that we can
call `proceed` multiple times. The following listing shows the basic aspect implementation
(which is a regular Java class that uses the schema support):

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class ConcurrentOperationExecutor implements Ordered {

		private static final int DEFAULT_MAX_RETRIES = 2;

		private int maxRetries = DEFAULT_MAX_RETRIES;
		private int order = 1;

		public void setMaxRetries(int maxRetries) {
			this.maxRetries = maxRetries;
		}

		public int getOrder() {
			return this.order;
		}

		public void setOrder(int order) {
			this.order = order;
		}

		public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {
			int numAttempts = 0;
			PessimisticLockingFailureException lockFailureException;
			do {
				numAttempts++;
				try {
					return pjp.proceed();
				}
				catch(PessimisticLockingFailureException ex) {
					lockFailureException = ex;
				}
			} while(numAttempts <= this.maxRetries);
			throw lockFailureException;
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class ConcurrentOperationExecutor : Ordered {

		private val DEFAULT_MAX_RETRIES = 2
		
		private var maxRetries = DEFAULT_MAX_RETRIES
		private var order = 1

		fun setMaxRetries(maxRetries: Int) {
			this.maxRetries = maxRetries
		}

		override fun getOrder(): Int {
			return this.order
		}

		fun setOrder(order: Int) {
			this.order = order
		}
		
		fun doConcurrentOperation(pjp: ProceedingJoinPoint): Any {
			var numAttempts = 0
			var lockFailureException: PessimisticLockingFailureException
			do {
				numAttempts++
				try {
					return pjp.proceed()
				} catch (ex: PessimisticLockingFailureException) {
					lockFailureException = ex
				}

			} while (numAttempts <= this.maxRetries)
			throw lockFailureException
		}
	}
----

Note that the aspect implements the `Ordered` interface so that we can set the precedence of
the aspect higher than the transaction advice (we want a fresh transaction each time we
retry). The `maxRetries` and `order` properties are both configured by Spring. The
main action happens in the `doConcurrentOperation` around advice method. We try to
proceed. If we fail with a `PessimisticLockingFailureException`, we try again,
unless we have exhausted all of our retry attempts.

NOTE: This class is identical to the one used in the @AspectJ example, but with the
annotations removed.

The corresponding Spring configuration is as follows:

[source,xml,indent=0,subs="verbatim"]
----
	<aop:config>

		<aop:aspect id="concurrentOperationRetry" ref="concurrentOperationExecutor">

			<aop:pointcut id="idempotentOperation"
				expression="execution(* com.xyz.myapp.service.*.*(..))"/>

			<aop:around
				pointcut-ref="idempotentOperation"
				method="doConcurrentOperation"/>

		</aop:aspect>

	</aop:config>

	<bean id="concurrentOperationExecutor"
		class="com.xyz.myapp.service.impl.ConcurrentOperationExecutor">
			<property name="maxRetries" value="3"/>
			<property name="order" value="100"/>
	</bean>
----

Notice that, for the time, being we assume that all business services are idempotent. If
this is not the case, we can refine the aspect so that it retries only genuinely
idempotent operations, by introducing an `Idempotent` annotation and using the annotation
to annotate the implementation of service operations, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Retention(RetentionPolicy.RUNTIME)
	public @interface Idempotent {
		// marker annotation
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Retention(AnnotationRetention.RUNTIME)
	annotation class Idempotent {
		// marker annotation
	}
----

The
change to the aspect to retry only idempotent operations involves refining the
pointcut expression so that only `@Idempotent` operations match, as follows:

[source,xml,indent=0,subs="verbatim"]
----
	<aop:pointcut id="idempotentOperation"
			expression="execution(* com.xyz.myapp.service.*.*(..)) and
			@annotation(com.xyz.myapp.service.Idempotent)"/>
----




[[aop-choosing]]
== Choosing which AOP Declaration Style to Use

Once you have decided that an aspect is the best approach for implementing a given
requirement, how do you decide between using Spring AOP or AspectJ and between the
Aspect language (code) style, the @AspectJ annotation style, or the Spring XML style? These
decisions are influenced by a number of factors including application requirements,
development tools, and team familiarity with AOP.



[[aop-spring-or-aspectj]]
=== Spring AOP or Full AspectJ?

Use the simplest thing that can work. Spring AOP is simpler than using full AspectJ, as
there is no requirement to introduce the AspectJ compiler / weaver into your development
and build processes. If you only need to advise the execution of operations on Spring
beans, Spring AOP is the right choice. If you need to advise objects not managed by
the Spring container (such as domain objects, typically), you need to use
AspectJ. You also need to use AspectJ if you wish to advise join points other than
simple method executions (for example, field get or set join points and so on).

When you use AspectJ, you have the choice of the AspectJ language syntax (also known as
the "`code style`") or the @AspectJ annotation style. Clearly, if you do not use Java
5+, the choice has been made for you: Use the code style. If aspects play a large
role in your design, and you are able to use the https://www.eclipse.org/ajdt/[AspectJ
Development Tools (AJDT)] plugin for Eclipse, the AspectJ language syntax is the
preferred option. It is cleaner and simpler because the language was purposefully
designed for writing aspects. If you do not use Eclipse or have only a few aspects
that do not play a major role in your application, you may want to consider using
the @AspectJ style, sticking with regular Java compilation in your IDE, and adding
an aspect weaving phase to your build script.



[[aop-ataspectj-or-xml]]
=== @AspectJ or XML for Spring AOP?

If you have chosen to use Spring AOP, you have a choice of @AspectJ or XML style.
There are various tradeoffs to consider.

The XML style may most familiar to existing Spring users, and it is backed by genuine
POJOs. When using AOP as a tool to configure enterprise services, XML can be a good
choice (a good test is whether you consider the pointcut expression to be a part of your
configuration that you might want to change independently). With the XML style, it is
arguably clearer from your configuration which aspects are present in the system.

The XML style has two disadvantages. First, it does not fully encapsulate the
implementation of the requirement it addresses in a single place. The DRY principle says
that there should be a single, unambiguous, authoritative representation of any piece of
knowledge within a system. When using the XML style, the knowledge of how a requirement
is implemented is split across the declaration of the backing bean class and the XML in
the configuration file. When you use the @AspectJ style, this information is encapsulated
in a single module: the aspect. Secondly, the XML style is slightly more limited in what
it can express than the @AspectJ style: Only the "`singleton`" aspect instantiation model
is supported, and it is not possible to combine named pointcuts declared in XML.
For example, in the @AspectJ style you can write something like the following:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Pointcut("execution(* get*())")
	public void propertyAccess() {}

	@Pointcut("execution(org.xyz.Account+ *(..))")
	public void operationReturningAnAccount() {}

	@Pointcut("propertyAccess() && operationReturningAnAccount()")
	public void accountPropertyAccess() {}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Pointcut("execution(* get*())")
	fun propertyAccess() {}

	@Pointcut("execution(org.xyz.Account+ *(..))")
	fun operationReturningAnAccount() {}

	@Pointcut("propertyAccess() && operationReturningAnAccount()")
	fun accountPropertyAccess() {}
----

In the XML style you can declare the first two pointcuts:

[source,xml,indent=0,subs="verbatim"]
----
	<aop:pointcut id="propertyAccess"
			expression="execution(* get*())"/>

	<aop:pointcut id="operationReturningAnAccount"
			expression="execution(org.xyz.Account+ *(..))"/>
----

The downside of the XML approach is that you cannot define the
`accountPropertyAccess` pointcut by combining these definitions.

The @AspectJ style supports additional instantiation models and richer pointcut
composition. It has the advantage of keeping the aspect as a modular unit. It also has
the advantage that the @AspectJ aspects can be understood (and thus consumed) both by
Spring AOP and by AspectJ. So, if you later decide you need the capabilities of AspectJ
to implement additional requirements, you can easily migrate to a classic AspectJ setup.
On balance, the Spring team prefers the @AspectJ style for custom aspects beyond simple
configuration of enterprise services.




[[aop-mixing-styles]]
== Mixing Aspect Types

It is perfectly possible to mix @AspectJ style aspects by using the auto-proxying support,
schema-defined `<aop:aspect>` aspects, `<aop:advisor>` declared advisors, and even proxies
and interceptors in other styles in the same configuration. All of these are implemented
by using the same underlying support mechanism and can co-exist without any difficulty.




[[aop-proxying]]
== Proxying Mechanisms

Spring AOP uses either JDK dynamic proxies or CGLIB to create the proxy for a given
target object. JDK dynamic proxies are built into the JDK, whereas CGLIB is a common
open-source class definition library (repackaged into `spring-core`).

If the target object to be proxied implements at least one interface, a JDK dynamic
proxy is used. All of the interfaces implemented by the target type are proxied.
If the target object does not implement any interfaces, a CGLIB proxy is created.

If you want to force the use of CGLIB proxying (for example, to proxy every method
defined for the target object, not only those implemented by its interfaces),
you can do so. However, you should consider the following issues:

* With CGLIB, `final` methods cannot be advised, as they cannot be overridden in
  runtime-generated subclasses.
* As of Spring 4.0, the constructor of your proxied object is NOT called twice anymore,
  since the CGLIB proxy instance is created through Objenesis. Only if your JVM does
  not allow for constructor bypassing, you might see double invocations and
  corresponding debug log entries from Spring's AOP support.

To force the use of CGLIB proxies, set the value of the `proxy-target-class` attribute
of the `<aop:config>` element to true, as follows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:config proxy-target-class="true">
		<!-- other beans defined here... -->
	</aop:config>
----

To force CGLIB proxying when you use the @AspectJ auto-proxy support, set the
`proxy-target-class` attribute of the `<aop:aspectj-autoproxy>` element to `true`,
as follows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:aspectj-autoproxy proxy-target-class="true"/>
----

[NOTE]
====
Multiple `<aop:config/>` sections are collapsed into a single unified auto-proxy creator
at runtime, which applies the _strongest_ proxy settings that any of the
`<aop:config/>` sections (typically from different XML bean definition files) specified.
This also applies to the `<tx:annotation-driven/>` and `<aop:aspectj-autoproxy/>`
elements.

To be clear, using `proxy-target-class="true"` on `<tx:annotation-driven/>`,
`<aop:aspectj-autoproxy/>`, or `<aop:config/>` elements forces the use of CGLIB
proxies _for all three of them_.
====



[[aop-understanding-aop-proxies]]
=== Understanding AOP Proxies

Spring AOP is proxy-based. It is vitally important that you grasp the semantics of
what that last statement actually means before you write your own aspects or use any of
the Spring AOP-based aspects supplied with the Spring Framework.

Consider first the scenario where you have a plain-vanilla, un-proxied,
nothing-special-about-it, straight object reference, as the following
code snippet shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SimplePojo implements Pojo {

		public void foo() {
			// this next method invocation is a direct call on the 'this' reference
			this.bar();
		}

		public void bar() {
			// some logic...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class SimplePojo : Pojo {

		fun foo() {
			// this next method invocation is a direct call on the 'this' reference
			this.bar()
		}

		fun bar() {
			// some logic...
		}
	}
----

If you invoke a method on an object reference, the method is invoked directly on
that object reference, as the following image and listing show:

image::images/aop-proxy-plain-pojo-call.png[]

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class Main {

		public static void main(String[] args) {
			Pojo pojo = new SimplePojo();
			// this is a direct method call on the 'pojo' reference
			pojo.foo();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun main() {
		val pojo = SimplePojo()
		// this is a direct method call on the 'pojo' reference
		pojo.foo()
	}
----

Things change slightly when the reference that client code has is a proxy. Consider the
following diagram and code snippet:

image::images/aop-proxy-call.png[]

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class Main {

		public static void main(String[] args) {
			ProxyFactory factory = new ProxyFactory(new SimplePojo());
			factory.addInterface(Pojo.class);
			factory.addAdvice(new RetryAdvice());

			Pojo pojo = (Pojo) factory.getProxy();
			// this is a method call on the proxy!
			pojo.foo();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
fun main() {
	val factory = ProxyFactory(SimplePojo())
	factory.addInterface(Pojo::class.java)
	factory.addAdvice(RetryAdvice())

	val pojo = factory.proxy as Pojo
	// this is a method call on the proxy!
	pojo.foo()
}
----

The key thing to understand here is that the client code inside the `main(..)` method
of the `Main` class has a reference to the proxy. This means that method calls on that
object reference are calls on the proxy. As a result, the proxy can delegate to all of
the interceptors (advice) that are relevant to that particular method call. However,
once the call has finally reached the target object (the `SimplePojo`, reference in
this case), any method calls that it may make on itself, such as `this.bar()` or
`this.foo()`, are going to be invoked against the `this` reference, and not the proxy.
This has important implications. It means that self-invocation is not going to result
in the advice associated with a method invocation getting a chance to execute.

Okay, so what is to be done about this? The best approach (the term, "`best,`" is used
loosely here) is to refactor your code such that the self-invocation does not happen.
This does entail some work on your part, but it is the best, least-invasive approach.
The next approach is absolutely horrendous, and we hesitate to point it out, precisely
because it is so horrendous. You can (painful as it is to us) totally tie the logic
within your class to Spring AOP, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SimplePojo implements Pojo {

		public void foo() {
			// this works, but... gah!
			((Pojo) AopContext.currentProxy()).bar();
		}

		public void bar() {
			// some logic...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class SimplePojo : Pojo {

		fun foo() {
			// this works, but... gah!
			(AopContext.currentProxy() as Pojo).bar()
		}

		fun bar() {
			// some logic...
		}
	}
----

This totally couples your code to Spring AOP, and it makes the class itself aware of
the fact that it is being used in an AOP context, which flies in the face of AOP. It
also requires some additional configuration when the proxy is being created, as the
following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class Main {

		public static void main(String[] args) {
			ProxyFactory factory = new ProxyFactory(new SimplePojo());
			factory.addInterface(Pojo.class);
			factory.addAdvice(new RetryAdvice());
			factory.setExposeProxy(true);

			Pojo pojo = (Pojo) factory.getProxy();
			// this is a method call on the proxy!
			pojo.foo();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun main() {
		val factory = ProxyFactory(SimplePojo())
		factory.addInterface(Pojo::class.java)
		factory.addAdvice(RetryAdvice())
		factory.isExposeProxy = true

		val pojo = factory.proxy as Pojo
		// this is a method call on the proxy!
		pojo.foo()
	}
----

Finally, it must be noted that AspectJ does not have this self-invocation issue because
it is not a proxy-based AOP framework.




[[aop-aspectj-programmatic]]
== Programmatic Creation of @AspectJ Proxies

In addition to declaring aspects in your configuration by using either `<aop:config>`
or `<aop:aspectj-autoproxy>`, it is also possible to programmatically create proxies
that advise target objects. For the full details of Spring's AOP API, see the
<<aop-api, next chapter>>. Here, we want to focus on the ability to automatically
create proxies by using @AspectJ aspects.

You can use the `org.springframework.aop.aspectj.annotation.AspectJProxyFactory` class
to create a proxy for a target object that is advised by one or more @AspectJ aspects.
The basic usage for this class is very simple, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// create a factory that can generate a proxy for the given target object
	AspectJProxyFactory factory = new AspectJProxyFactory(targetObject);

	// add an aspect, the class must be an @AspectJ aspect
	// you can call this as many times as you need with different aspects
	factory.addAspect(SecurityManager.class);

	// you can also add existing aspect instances, the type of the object supplied must be an @AspectJ aspect
	factory.addAspect(usageTracker);

	// now get the proxy object...
	MyInterfaceType proxy = factory.getProxy();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// create a factory that can generate a proxy for the given target object
	val factory = AspectJProxyFactory(targetObject)

	// add an aspect, the class must be an @AspectJ aspect
	// you can call this as many times as you need with different aspects
	factory.addAspect(SecurityManager::class.java)

	// you can also add existing aspect instances, the type of the object supplied must be an @AspectJ aspect
	factory.addAspect(usageTracker)

	// now get the proxy object...
	val proxy = factory.getProxy<Any>()
----

See the {api-spring-framework}/aop/aspectj/annotation/AspectJProxyFactory.html[javadoc] for more information.




[[aop-using-aspectj]]
== Using AspectJ with Spring Applications

Everything we have covered so far in this chapter is pure Spring AOP. In this section,
we look at how you can use the AspectJ compiler or weaver instead of or in
addition to Spring AOP if your needs go beyond the facilities offered by Spring AOP
alone.

Spring ships with a small AspectJ aspect library, which is available stand-alone in your
distribution as `spring-aspects.jar`. You need to add this to your classpath in order
to use the aspects in it. <<aop-atconfigurable>> and <<aop-ajlib-other>> discuss the
content of this library and how you can use it. <<aop-aj-configure>> discusses how to
dependency inject AspectJ aspects that are woven using the AspectJ compiler. Finally,
<<aop-aj-ltw>> provides an introduction to load-time weaving for Spring applications
that use AspectJ.



[[aop-atconfigurable]]
=== Using AspectJ to Dependency Inject Domain Objects with Spring

The Spring container instantiates and configures beans defined in your application
context. It is also possible to ask a bean factory to configure a pre-existing
object, given the name of a bean definition that contains the configuration to be applied.
`spring-aspects.jar` contains an annotation-driven aspect that exploits this
capability to allow dependency injection of any object. The support is intended to
be used for objects created outside of the control of any container. Domain objects
often fall into this category because they are often created programmatically with the
`new` operator or by an ORM tool as a result of a database query.

The `@Configurable` annotation marks a class as being eligible for Spring-driven
configuration. In the simplest case, you can use purely it as a marker annotation, as the
following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package com.xyz.myapp.domain;

	import org.springframework.beans.factory.annotation.Configurable;

	@Configurable
	public class Account {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package com.xyz.myapp.domain

	import org.springframework.beans.factory.annotation.Configurable

	@Configurable
	class Account {
		// ...
	}
----

When used as a marker interface in this way, Spring configures new instances of the
annotated type (`Account`, in this case) by using a bean definition (typically
prototype-scoped) with the same name as the fully-qualified type name
(`com.xyz.myapp.domain.Account`). Since the default name for a bean is the
fully-qualified name of its type, a convenient way to declare the prototype definition
is to omit the `id` attribute, as the following example shows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean class="com.xyz.myapp.domain.Account" scope="prototype">
		<property name="fundsTransferService" ref="fundsTransferService"/>
	</bean>
----

If you want to explicitly specify the name of the prototype bean definition to use, you
can do so directly in the annotation, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package com.xyz.myapp.domain;

	import org.springframework.beans.factory.annotation.Configurable;

	@Configurable("account")
	public class Account {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package com.xyz.myapp.domain

	import org.springframework.beans.factory.annotation.Configurable

	@Configurable("account")
	class Account {
		// ...
	}
----

Spring now looks for a bean definition named `account` and uses that as the
definition to configure new `Account` instances.

You can also use autowiring to avoid having to specify a dedicated bean definition at
all. To have Spring apply autowiring, use the `autowire` property of the `@Configurable`
annotation. You can specify either `@Configurable(autowire=Autowire.BY_TYPE)` or
`@Configurable(autowire=Autowire.BY_NAME` for autowiring by type or by name,
respectively. As an alternative, it is preferable to specify explicit, annotation-driven
dependency injection for your `@Configurable` beans through `@Autowired` or `@Inject`
at the field or method level (see <<beans-annotation-config>> for further details).

Finally, you can enable Spring dependency checking for the object references in the newly
created and configured object by using the `dependencyCheck` attribute (for example,
`@Configurable(autowire=Autowire.BY_NAME,dependencyCheck=true)`). If this attribute is
set to `true`, Spring validates after configuration that all properties (which
are not primitives or collections) have been set.

Note that using the annotation on its own does nothing. It is the
`AnnotationBeanConfigurerAspect` in `spring-aspects.jar` that acts on the presence of
the annotation. In essence, the aspect says, "`after returning from the initialization of
a new object of a type annotated with `@Configurable`, configure the newly created object
using Spring in accordance with the properties of the annotation`". In this context,
"`initialization`" refers to newly instantiated objects (for example, objects instantiated
with the `new` operator) as well as to `Serializable` objects that are undergoing
deserialization (for example, through
https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html[readResolve()]).

[NOTE]
=====
One of the key phrases in the above paragraph is "`in essence`". For most cases, the
exact semantics of "`after returning from the initialization of a new object`" are
fine. In this context, "`after initialization`" means that the dependencies are
injected after the object has been constructed. This means that the dependencies
are not available for use in the constructor bodies of the class. If you want the
dependencies to be injected before the constructor bodies execute and thus be
available for use in the body of the constructors, you need to define this on the
`@Configurable` declaration, as follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configurable(preConstruction = true)
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configurable(preConstruction = true)
----

You can find more information about the language semantics of the various pointcut
types in AspectJ
https://www.eclipse.org/aspectj/doc/next/progguide/semantics-joinPoints.html[in this
appendix] of the https://www.eclipse.org/aspectj/doc/next/progguide/index.html[AspectJ
Programming Guide].
=====

For this to work, the annotated types must be woven with the AspectJ weaver. You can
either use a build-time Ant or Maven task to do this (see, for example, the
https://www.eclipse.org/aspectj/doc/released/devguide/antTasks.html[AspectJ Development
Environment Guide]) or load-time weaving (see <<aop-aj-ltw>>). The
`AnnotationBeanConfigurerAspect` itself needs to be configured by Spring (in order to obtain
a reference to the bean factory that is to be used to configure new objects). If you
use Java-based configuration, you can add `@EnableSpringConfigured` to any
`@Configuration` class, as follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableSpringConfigured
	public class AppConfig {
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableSpringConfigured
	class AppConfig {
	}
----

If you prefer XML based configuration, the Spring
<<core.adoc#xsd-schemas-context, `context` namespace>>
defines a convenient `context:spring-configured` element, which you can use as follows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<context:spring-configured/>
----

Instances of `@Configurable` objects created before the aspect has been configured
result in a message being issued to the debug log and no configuration of the
object taking place. An example might be a bean in the Spring configuration that creates
domain objects when it is initialized by Spring. In this case, you can use the
`depends-on` bean attribute to manually specify that the bean depends on the
configuration aspect. The following example shows how to use the `depends-on` attribute:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="myService"
			class="com.xzy.myapp.service.MyService"
			depends-on="org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect">

		<!-- ... -->

	</bean>
----

NOTE: Do not activate `@Configurable` processing through the bean configurer aspect unless you
really mean to rely on its semantics at runtime. In particular, make sure that you do
not use `@Configurable` on bean classes that are registered as regular Spring beans
with the container. Doing so results in double initialization, once through the
container and once through the aspect.


[[aop-configurable-testing]]
==== Unit Testing `@Configurable` Objects

One of the goals of the `@Configurable` support is to enable independent unit testing
of domain objects without the difficulties associated with hard-coded lookups.
If `@Configurable` types have not been woven by AspectJ, the annotation has no affect
during unit testing. You can set mock or stub property references in the object under
test and proceed as normal. If `@Configurable` types have been woven by AspectJ,
you can still unit test outside of the container as normal, but you see a warning
message each time that you construct a `@Configurable` object indicating that it has
not been configured by Spring.


[[aop-configurable-container]]
==== Working with Multiple Application Contexts

The `AnnotationBeanConfigurerAspect` that is used to implement the `@Configurable` support
is an AspectJ singleton aspect. The scope of a singleton aspect is the same as the scope
of `static` members: There is one aspect instance per classloader that defines the type.
This means that, if you define multiple application contexts within the same classloader
hierarchy, you need to consider where to define the `@EnableSpringConfigured` bean and
where to place `spring-aspects.jar` on the classpath.

Consider a typical Spring web application configuration that has a shared parent application
context that defines common business services, everything needed to support those services,
and one child application context for each servlet (which contains definitions particular
to that servlet). All of these contexts co-exist within the same classloader hierarchy,
and so the `AnnotationBeanConfigurerAspect` can hold a reference to only one of them.
In this case, we recommend defining the `@EnableSpringConfigured` bean in the shared
(parent) application context. This defines the services that you are likely to want to
inject into domain objects. A consequence is that you cannot configure domain objects
with references to beans defined in the child (servlet-specific) contexts by using the
@Configurable mechanism (which is probably not something you want to do anyway).

When deploying multiple web applications within the same container, ensure that each
web application loads the types in `spring-aspects.jar` by using its own classloader
(for example, by placing `spring-aspects.jar` in `'WEB-INF/lib'`). If `spring-aspects.jar`
is added only to the container-wide classpath (and hence loaded by the shared parent
classloader), all web applications share the same aspect instance (which is probably
not what you want).



[[aop-ajlib-other]]
=== Other Spring aspects for AspectJ

In addition to the `@Configurable` aspect, `spring-aspects.jar` contains an AspectJ
aspect that you can use to drive Spring's transaction management for types and methods
annotated with the `@Transactional` annotation. This is primarily intended for users who
want to use the Spring Framework's transaction support outside of the Spring container.

The aspect that interprets `@Transactional` annotations is the
`AnnotationTransactionAspect`. When you use this aspect, you must annotate the
implementation class (or methods within that class or both), not the interface (if
any) that the class implements. AspectJ follows Java's rule that annotations on
interfaces are not inherited.

A `@Transactional` annotation on a class specifies the default transaction semantics for
the execution of any public operation in the class.

A `@Transactional` annotation on a method within the class overrides the default
transaction semantics given by the class annotation (if present). Methods of any
visibility may be annotated, including private methods. Annotating non-public methods
directly is the only way to get transaction demarcation for the execution of such methods.

TIP: Since Spring Framework 4.2, `spring-aspects` provides a similar aspect that offers the
exact same features for the standard `javax.transaction.Transactional` annotation. Check
`JtaAnnotationTransactionAspect` for more details.

For AspectJ programmers who want to use the Spring configuration and transaction
management support but do not want to (or cannot) use annotations, `spring-aspects.jar`
also contains `abstract` aspects you can extend to provide your own pointcut
definitions. See the sources for the `AbstractBeanConfigurerAspect` and
`AbstractTransactionAspect` aspects for more information. As an example, the following
excerpt shows how you could write an aspect to configure all instances of objects
defined in the domain model by using prototype bean definitions that match the
fully qualified class names:

[source,java,indent=0,subs="verbatim,quotes"]
----
	public aspect DomainObjectConfiguration extends AbstractBeanConfigurerAspect {

		public DomainObjectConfiguration() {
			setBeanWiringInfoResolver(new ClassNameBeanWiringInfoResolver());
		}

		// the creation of a new bean (any object in the domain model)
		protected pointcut beanCreation(Object beanInstance) :
			initialization(new(..)) &&
			SystemArchitecture.inDomainModel() &&
			this(beanInstance);
	}
----



[[aop-aj-configure]]
=== Configuring AspectJ Aspects by Using Spring IoC

When you use AspectJ aspects with Spring applications, it is natural to both want and
expect to be able to configure such aspects with Spring. The AspectJ runtime itself is
responsible for aspect creation, and the means of configuring the AspectJ-created
aspects through Spring depends on the AspectJ instantiation model (the `per-xxx` clause)
used by the aspect.

The majority of AspectJ aspects are singleton aspects. Configuration of these
aspects is easy. You can create a bean definition that references the aspect type as
normal and include the `factory-method="aspectOf"` bean attribute. This ensures that
Spring obtains the aspect instance by asking AspectJ for it rather than trying to create
an instance itself. The following example shows how to use the `factory-method="aspectOf"` attribute:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="profiler" class="com.xyz.profiler.Profiler"
			factory-method="aspectOf"> <1>

		<property name="profilingStrategy" ref="jamonProfilingStrategy"/>
	</bean>
----
<1> Note the `factory-method="aspectOf"` attribute


Non-singleton aspects are harder to configure. However, it is possible to do so by
creating prototype bean definitions and using the `@Configurable` support from
`spring-aspects.jar` to configure the aspect instances once they have bean created by
the AspectJ runtime.

If you have some @AspectJ aspects that you want to weave with AspectJ (for example,
using load-time weaving for domain model types) and other @AspectJ aspects that you want
to use with Spring AOP, and these aspects are all configured in Spring, you
need to tell the Spring AOP @AspectJ auto-proxying support which exact subset of the
@AspectJ aspects defined in the configuration should be used for auto-proxying. You can
do this by using one or more `<include/>` elements inside the `<aop:aspectj-autoproxy/>`
declaration. Each `<include/>` element specifies a name pattern, and only beans with
names matched by at least one of the patterns are used for Spring AOP auto-proxy
configuration. The following example shows how to use `<include/>` elements:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:aspectj-autoproxy>
		<aop:include name="thisBean"/>
		<aop:include name="thatBean"/>
	</aop:aspectj-autoproxy>
----

NOTE: Do not be misled by the name of the `<aop:aspectj-autoproxy/>` element. Using it
results in the creation of Spring AOP proxies. The @AspectJ style of aspect
declaration is being used here, but the AspectJ runtime is not involved.



[[aop-aj-ltw]]
=== Load-time Weaving with AspectJ in the Spring Framework

Load-time weaving (LTW) refers to the process of weaving AspectJ aspects into an
application's class files as they are being loaded into the Java virtual machine (JVM).
The focus of this section is on configuring and using LTW in the specific context of the
Spring Framework. This section is not a general introduction to LTW. For full details on
the specifics of LTW and configuring LTW with only AspectJ (with Spring not being
involved at all), see the
https://www.eclipse.org/aspectj/doc/released/devguide/ltw.html[LTW section of the AspectJ
Development Environment Guide].

The value that the Spring Framework brings to AspectJ LTW is in enabling much
finer-grained control over the weaving process. 'Vanilla' AspectJ LTW is effected by using
a Java (5+) agent, which is switched on by specifying a VM argument when starting up a
JVM. It is, thus, a JVM-wide setting, which may be fine in some situations but is often a
little too coarse. Spring-enabled LTW lets you switch on LTW on a
per-`ClassLoader` basis, which is more fine-grained and which can make more
sense in a 'single-JVM-multiple-application' environment (such as is found in a typical
application server environment).

Further, <<aop-aj-ltw-environments, in certain environments>>, this support enables
load-time weaving without making any modifications to the application server's launch
script that is needed to add `-javaagent:path/to/aspectjweaver.jar` or (as we describe
later in this section) `-javaagent:path/to/spring-instrument.jar`. Developers configure
the application context to enable load-time weaving instead of relying on administrators
who typically are in charge of the deployment configuration, such as the launch script.

Now that the sales pitch is over, let us first walk through a quick example of AspectJ
LTW that uses Spring, followed by detailed specifics about elements introduced in the
example. For a complete example, see the
https://github.com/spring-projects/spring-petclinic[Petclinic sample application].


[[aop-aj-ltw-first-example]]
==== A First Example

Assume that you are an application developer who has been tasked with diagnosing
the cause of some performance problems in a system. Rather than break out a
profiling tool, we are going to switch on a simple profiling aspect that lets us
quickly get some performance metrics. We can then apply a finer-grained profiling
tool to that specific area immediately afterwards.

NOTE: The example presented here uses XML configuration. You can also configure and
use @AspectJ with <<beans-java, Java configuration>>. Specifically, you can use the
`@EnableLoadTimeWeaving` annotation as an alternative to `<context:load-time-weaver/>`
(see <<aop-aj-ltw-spring, below>> for details).

The following example shows the profiling aspect, which is not fancy.
It is a time-based profiler that uses the @AspectJ-style of aspect declaration:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package foo;

	import org.aspectj.lang.ProceedingJoinPoint;
	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.Around;
	import org.aspectj.lang.annotation.Pointcut;
	import org.springframework.util.StopWatch;
	import org.springframework.core.annotation.Order;

	@Aspect
	public class ProfilingAspect {

		@Around("methodsToBeProfiled()")
		public Object profile(ProceedingJoinPoint pjp) throws Throwable {
			StopWatch sw = new StopWatch(getClass().getSimpleName());
			try {
				sw.start(pjp.getSignature().getName());
				return pjp.proceed();
			} finally {
				sw.stop();
				System.out.println(sw.prettyPrint());
			}
		}

		@Pointcut("execution(public * foo..*.*(..))")
		public void methodsToBeProfiled(){}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package foo

	import org.aspectj.lang.ProceedingJoinPoint
	import org.aspectj.lang.annotation.Aspect
	import org.aspectj.lang.annotation.Around
	import org.aspectj.lang.annotation.Pointcut
	import org.springframework.util.StopWatch
	import org.springframework.core.annotation.Order

	@Aspect
	class ProfilingAspect {

		@Around("methodsToBeProfiled()")
		fun profile(pjp: ProceedingJoinPoint): Any {
			val sw = StopWatch(javaClass.simpleName)
			try {
				sw.start(pjp.getSignature().getName())
				return pjp.proceed()
			} finally {
				sw.stop()
				println(sw.prettyPrint())
			}
		}

		@Pointcut("execution(public * foo..*.*(..))")
		fun methodsToBeProfiled() {
		}
	}
----

We also need to create an `META-INF/aop.xml` file, to inform the AspectJ weaver that
we want to weave our `ProfilingAspect` into our classes. This file convention, namely
the presence of a file (or files) on the Java classpath called `META-INF/aop.xml` is
standard AspectJ. The following example shows the `aop.xml` file:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<!DOCTYPE aspectj PUBLIC "-//AspectJ//DTD//EN" "https://www.eclipse.org/aspectj/dtd/aspectj.dtd">
	<aspectj>

		<weaver>
			<!-- only weave classes in our application-specific packages -->
			<include within="foo.*"/>
		</weaver>

		<aspects>
			<!-- weave in just this aspect -->
			<aspect name="foo.ProfilingAspect"/>
		</aspects>

	</aspectj>
----

Now we can move on to the Spring-specific portion of the configuration. We need
to configure a `LoadTimeWeaver` (explained later). This load-time weaver is the
essential component responsible for weaving the aspect configuration in one or
more `META-INF/aop.xml` files into the classes in your application. The good
thing is that it does not require a lot of configuration (there are some more
options that you can specify, but these are detailed later), as can be seen in
the following example:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">

		<!-- a service object; we will be profiling its methods -->
		<bean id="entitlementCalculationService"
				class="foo.StubEntitlementCalculationService"/>

		<!-- this switches on the load-time weaving -->
		<context:load-time-weaver/>
	</beans>
----

Now that all the required artifacts (the aspect, the `META-INF/aop.xml`
file, and the Spring configuration) are in place, we can create the following
driver class with a `main(..)` method to demonstrate the LTW in action:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package foo;

	import org.springframework.context.support.ClassPathXmlApplicationContext;

	public final class Main {

		public static void main(String[] args) {
			ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml", Main.class);

			EntitlementCalculationService entitlementCalculationService =
					(EntitlementCalculationService) ctx.getBean("entitlementCalculationService");

			// the profiling aspect is 'woven' around this method execution
			entitlementCalculationService.calculateEntitlement();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package foo

	import org.springframework.context.support.ClassPathXmlApplicationContext

	fun main() {
		val ctx = ClassPathXmlApplicationContext("beans.xml")

		val entitlementCalculationService = ctx.getBean("entitlementCalculationService") as EntitlementCalculationService

		// the profiling aspect is 'woven' around this method execution
		entitlementCalculationService.calculateEntitlement()
	}
----

We have one last thing to do. The introduction to this section did say that one could
switch on LTW selectively on a per-`ClassLoader` basis with Spring, and this is true.
However, for this example, we use a Java agent (supplied with Spring) to switch on LTW.
We use the following command to run the `Main` class shown earlier:

[literal,subs="verbatim,quotes"]
----
java -javaagent:C:/projects/foo/lib/global/spring-instrument.jar foo.Main
----

The `-javaagent` is a flag for specifying and enabling
https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html[agents
to instrument programs that run on the JVM]. The Spring Framework ships with such an
agent, the `InstrumentationSavingAgent`, which is packaged in the
`spring-instrument.jar` that was supplied as the value of the `-javaagent` argument in
the preceding example.

The output from the execution of the `Main` program looks something like the next example.
(I have introduced a `Thread.sleep(..)` statement into the `calculateEntitlement()`
implementation so that the profiler actually captures something other than 0
milliseconds (the `01234` milliseconds is not an overhead introduced by the AOP).
The following listing shows the output we got when we ran our profiler:

[literal,subs="verbatim,quotes"]
----
Calculating entitlement

StopWatch 'ProfilingAspect': running time (millis) = 1234
------ ----- ----------------------------
ms     %     Task name
------ ----- ----------------------------
01234  100%  calculateEntitlement
----

Since this LTW is effected by using full-blown AspectJ, we are not limited only to advising
Spring beans. The following slight variation on the `Main` program yields the same
result:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package foo;

	import org.springframework.context.support.ClassPathXmlApplicationContext;

	public final class Main {

		public static void main(String[] args) {
			new ClassPathXmlApplicationContext("beans.xml", Main.class);

			EntitlementCalculationService entitlementCalculationService =
					new StubEntitlementCalculationService();

			// the profiling aspect will be 'woven' around this method execution
			entitlementCalculationService.calculateEntitlement();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package foo

	import org.springframework.context.support.ClassPathXmlApplicationContext

	fun main(args: Array<String>) {
		ClassPathXmlApplicationContext("beans.xml")

		val entitlementCalculationService = StubEntitlementCalculationService()

		// the profiling aspect will be 'woven' around this method execution
		entitlementCalculationService.calculateEntitlement()
	}
----

Notice how, in the preceding program, we bootstrap the Spring container and
then create a new instance of the `StubEntitlementCalculationService` totally outside
the context of Spring. The profiling advice still gets woven in.

Admittedly, the example is simplistic. However, the basics of the LTW support in Spring
have all been introduced in the earlier example, and the rest of this section explains
the "`why`" behind each bit of configuration and usage in detail.

NOTE: The `ProfilingAspect` used in this example may be basic, but it is quite useful. It is a
nice example of a development-time aspect that developers can use during development
and then easily exclude from builds of the application being deployed
into UAT or production.


[[aop-aj-ltw-the-aspects]]
==== Aspects

The aspects that you use in LTW have to be AspectJ aspects. You can write them in
either the AspectJ language itself, or you can write your aspects in the @AspectJ-style.
Your aspects are then both valid AspectJ and Spring AOP aspects.
Furthermore, the compiled aspect classes need to be available on the classpath.


[[aop-aj-ltw-aop_dot_xml]]
==== 'META-INF/aop.xml'

The AspectJ LTW infrastructure is configured by using one or more `META-INF/aop.xml`
files that are on the Java classpath (either directly or, more typically, in jar files).

The structure and contents of this file is detailed in the LTW part of the
https://www.eclipse.org/aspectj/doc/released/devguide/ltw-configuration.html[AspectJ reference
documentation]. Because the `aop.xml` file is 100% AspectJ, we do not describe it further here.


[[aop-aj-ltw-libraries]]
==== Required libraries (JARS)

At minimum, you need the following libraries to use the Spring Framework's support
for AspectJ LTW:

* `spring-aop.jar`
* `aspectjweaver.jar`

If you use the <<aop-aj-ltw-environment-generic, Spring-provided agent to enable
instrumentation>>, you also need:

* `spring-instrument.jar`


[[aop-aj-ltw-spring]]
==== Spring Configuration

The key component in Spring's LTW support is the `LoadTimeWeaver` interface (in the
`org.springframework.instrument.classloading` package), and the numerous implementations
of it that ship with the Spring distribution. A `LoadTimeWeaver` is responsible for
adding one or more `java.lang.instrument.ClassFileTransformers` to a `ClassLoader` at
runtime, which opens the door to all manner of interesting applications, one of which
happens to be the LTW of aspects.

TIP: If you are unfamiliar with the idea of runtime class file transformation, see the
javadoc API documentation for the `java.lang.instrument` package before continuing.
While that documentation is not comprehensive, at least you can see the key interfaces
and classes (for reference as you read through this section).

Configuring a `LoadTimeWeaver` for a particular `ApplicationContext` can be as easy as
adding one line. (Note that you almost certainly need to use an
`ApplicationContext` as your Spring container -- typically, a `BeanFactory` is not
enough because the LTW support uses `BeanFactoryPostProcessors`.)

To enable the Spring Framework's LTW support, you need to configure a `LoadTimeWeaver`,
which typically is done by using the `@EnableLoadTimeWeaving` annotation, as follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableLoadTimeWeaving
	public class AppConfig {
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableLoadTimeWeaving
	class AppConfig {
	}
----

Alternatively, if you prefer XML-based configuration, use the
`<context:load-time-weaver/>` element. Note that the element is defined in the
`context` namespace. The following example shows how to use `<context:load-time-weaver/>`:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">

		<context:load-time-weaver/>

	</beans>
----

The preceding configuration automatically defines and registers a number of LTW-specific
infrastructure beans, such as a `LoadTimeWeaver` and an `AspectJWeavingEnabler`, for you.
The default `LoadTimeWeaver` is the `DefaultContextLoadTimeWeaver` class, which attempts
to decorate an automatically detected `LoadTimeWeaver`. The exact type of `LoadTimeWeaver`
that is "`automatically detected`" is dependent upon your runtime environment.
The following table summarizes various `LoadTimeWeaver` implementations:

[[aop-aj-ltw-spring-env-impls]]
.DefaultContextLoadTimeWeaver LoadTimeWeavers
|===
| Runtime Environment| `LoadTimeWeaver` implementation

| Running in https://tomcat.apache.org/[Apache Tomcat]
| `TomcatLoadTimeWeaver`

| Running in https://eclipse-ee4j.github.io/glassfish/[GlassFish] (limited to EAR deployments)
| `GlassFishLoadTimeWeaver`

| Running in Red Hat's https://www.jboss.org/jbossas/[JBoss AS] or https://www.wildfly.org/[WildFly]
| `JBossLoadTimeWeaver`

| Running in IBM's https://www-01.ibm.com/software/webservers/appserv/was/[WebSphere]
| `WebSphereLoadTimeWeaver`

| Running in Oracle's
  https://www.oracle.com/technetwork/middleware/weblogic/overview/index-085209.html[WebLogic]
| `WebLogicLoadTimeWeaver`

| JVM started with Spring `InstrumentationSavingAgent`
  (`java -javaagent:path/to/spring-instrument.jar`)
| `InstrumentationLoadTimeWeaver`

| Fallback, expecting the underlying ClassLoader to follow common conventions
  (namely `addTransformer` and optionally a `getThrowawayClassLoader` method)
| `ReflectiveLoadTimeWeaver`
|===

Note that the table lists only the `LoadTimeWeavers` that are autodetected when you
use the `DefaultContextLoadTimeWeaver`. You can specify exactly which `LoadTimeWeaver`
implementation to use.

To specify a specific `LoadTimeWeaver` with Java configuration, implement the
`LoadTimeWeavingConfigurer` interface and override the `getLoadTimeWeaver()` method.
The following example specifies a `ReflectiveLoadTimeWeaver`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableLoadTimeWeaving
	public class AppConfig implements LoadTimeWeavingConfigurer {

		@Override
		public LoadTimeWeaver getLoadTimeWeaver() {
			return new ReflectiveLoadTimeWeaver();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableLoadTimeWeaving
	class AppConfig : LoadTimeWeavingConfigurer {

		override fun getLoadTimeWeaver(): LoadTimeWeaver {
			return ReflectiveLoadTimeWeaver()
		}
	}
----

If you use XML-based configuration, you can specify the fully qualified classname
as the value of the `weaver-class` attribute on the `<context:load-time-weaver/>`
element. Again, the following example specifies a `ReflectiveLoadTimeWeaver`:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">

		<context:load-time-weaver
				weaver-class="org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver"/>

	</beans>
----

The `LoadTimeWeaver` that is defined and registered by the configuration can be later
retrieved from the Spring container by using the well known name, `loadTimeWeaver`.
Remember that the `LoadTimeWeaver` exists only as a mechanism for Spring's LTW
infrastructure to add one or more `ClassFileTransformers`. The actual
`ClassFileTransformer` that does the LTW is the `ClassPreProcessorAgentAdapter` (from
the `org.aspectj.weaver.loadtime` package) class. See the class-level javadoc of the
`ClassPreProcessorAgentAdapter` class for further details, because the specifics of how
the weaving is actually effected is beyond the scope of this document.

There is one final attribute of the configuration left to discuss: the `aspectjWeaving`
attribute (or `aspectj-weaving` if you use XML). This attribute controls whether LTW
is enabled or not. It accepts one of three possible values, with the default value being
`autodetect` if the attribute is not present. The following table summarizes the three
possible values:

[[aop-aj-ltw-ltw-tag-attrs]]
.AspectJ weaving attribute values
|===
| Annotation Value| XML Value| Explanation

| `ENABLED`
| `on`
| AspectJ weaving is on, and aspects are woven at load-time as appropriate.

| `DISABLED`
| `off`
| LTW is off. No aspect is woven at load-time.

| `AUTODETECT`
| `autodetect`
| If the Spring LTW infrastructure can find at least one `META-INF/aop.xml` file,
  then AspectJ weaving is on. Otherwise, it is off. This is the default value.
|===


[[aop-aj-ltw-environments]]
==== Environment-specific Configuration

This last section contains any additional settings and configuration that you need
when you use Spring's LTW support in environments such as application servers and web
containers.

[[aop-aj-ltw-environments-tomcat-jboss-etc]]
===== Tomcat, JBoss, WebSphere, WebLogic

Tomcat, JBoss/WildFly, IBM WebSphere Application Server and Oracle WebLogic Server all
provide a general app `ClassLoader` that is capable of local instrumentation. Spring's
native LTW may leverage those ClassLoader implementations to provide AspectJ weaving.
You can simply enable load-time weaving, as <<aop-using-aspectj, described earlier>>.
Specifically, you do not need to modify the JVM launch script to add
`-javaagent:path/to/spring-instrument.jar`.

Note that on JBoss, you may need to disable the app server scanning to prevent it from
loading the classes before the application actually starts. A quick workaround is to add
to your artifact a file named `WEB-INF/jboss-scanning.xml` with the following content:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<scanning xmlns="urn:jboss:scanning:1.0"/>
----

[[aop-aj-ltw-environments-generic]]
===== Generic Java Applications

When class instrumentation is required in environments that are not supported by
specific `LoadTimeWeaver` implementations, a JVM agent is the general solution.
For such cases, Spring provides `InstrumentationLoadTimeWeaver` which requires a
Spring-specific (but very general) JVM agent, `spring-instrument.jar`, autodetected
by common `@EnableLoadTimeWeaving` and `<context:load-time-weaver/>` setups.

To use it, you must start the virtual machine with the Spring agent by supplying
the following JVM options:

[literal]
[subs="verbatim,quotes"]
----
-javaagent:/path/to/spring-instrument.jar
----

Note that this requires modification of the JVM launch script, which may prevent you
from using this in application server environments (depending on your server and your
operation policies). That said, for one-app-per-JVM deployments such as standalone
Spring Boot applications, you typically control the entire JVM setup in any case.




[[aop-resources]]
== Further Resources

More information on AspectJ can be found on the https://www.eclipse.org/aspectj[AspectJ website].

_Eclipse AspectJ_ by Adrian Colyer et. al. (Addison-Wesley, 2005) provides a
comprehensive introduction and reference for the AspectJ language.

_AspectJ in Action_, Second Edition by Ramnivas Laddad (Manning, 2009) comes highly
recommended. The focus of the book is on AspectJ, but a lot of general AOP themes are
explored (in some depth).
