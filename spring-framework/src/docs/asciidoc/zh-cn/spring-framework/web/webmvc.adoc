[[mvc]]
= Spring Web MVC
:doc-spring-security: {doc-root}/spring-security/site/docs/current/reference

Spring Web MVC是构建在Servlet API上的原始Web框架，从一开始就包含在Spring Framework中。 正式名称  "`Spring Web MVC,`" 来自其源模块(https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc[`spring-webmvc`])的名称，但它通常被称为 "`Spring MVC`".。

与Spring Web MVC并行，Spring Framework 5.0引入了一个响应式栈Web框架，其名称 "`Spring WebFlux,`" 也基于其源模块(https://github.com/spring-projects/spring-framework/tree/master/spring-webflux[`spring-webflux`])。 本节介绍Spring Web MVC。 <<web-reactive.adoc#spring-web-reactive, 下一节>>将介绍Spring WebFlux。.

有关基本信息以及与Servlet容器和Java EE版本范围的兼容性，请参阅Spring Framework https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-Versions[Wiki]。


[[mvc-servlet]]
== DispatcherServlet
[.small]#<<web-reactive.adoc#webflux-dispatcher-handler, WebFlux>>#

Spring MVC和许多其他Web框架一样，围绕前端控制器模式设计，其中核心  `DispatcherServlet` 为请求处理提供共享算法，而实际工作由可配置委托组件执行。 该模型非常灵活，支持多种工作流程。

`DispatcherServlet` 与任何 `Servlet` 一样，需要使用Java配置或 `web.xml` 根据 `Servlet` 规范进行声明和映射。 反过来，`DispatcherServlet` 使用Spring配置来发现请求映射，视图解析，异常处理 <<mvc-servlet-special-bean-types, 等等>>所需的委托组件。

下面的Java配置示例注册并初始化 `DispatcherServlet`，它由Servlet容器自动检测（请参阅<<mvc-container-config>>）：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MyWebApplicationInitializer implements WebApplicationInitializer {

		@Override
		public void onStartup(ServletContext servletCxt) {

			// Load Spring web application configuration
			AnnotationConfigWebApplicationContext ac = new AnnotationConfigWebApplicationContext();
			ac.register(AppConfig.class);
			ac.refresh();

			// Create and register the DispatcherServlet
			DispatcherServlet servlet = new DispatcherServlet(ac);
			ServletRegistration.Dynamic registration = servletCxt.addServlet("app", servlet);
			registration.setLoadOnStartup(1);
			registration.addMapping("/app/*");
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MyWebApplicationInitializer : WebApplicationInitializer {

		override fun onStartup(servletCxt: ServletContext) {

			// Load Spring web application configuration
			val ac = AnnotationConfigWebApplicationContext()
			ac.register(AppConfig::class.java)
			ac.refresh()

			// Create and register the DispatcherServlet
			val servlet = DispatcherServlet(ac)
			val registration = servletCxt.addServlet("app", servlet)
			registration.setLoadOnStartup(1)
			registration.addMapping("/app/*")
		}
	}
----

NOTE: 	除了直接使用ServletContext API之外，您还可以扩展 `AbstractAnnotationConfigDispatcherServletInitializer` 并覆盖特定方法（请参阅 <<mvc-servlet-context-hierarchy,上下文层次结构>>下的示例）。

以下 `web.xml` 配置示例注册并初始化 `DispatcherServlet`:

[source,xml,indent=0,subs="verbatim,quotes"]
----
<web-app>

	<listener>
		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	</listener>

	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>/WEB-INF/app-context.xml</param-value>
	</context-param>

	<servlet>
		<servlet-name>app</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value></param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>

	<servlet-mapping>
		<servlet-name>app</servlet-name>
		<url-pattern>/app/*</url-pattern>
	</servlet-mapping>

</web-app>
----

NOTE: Spring Boot遵循不同的初始化顺序。 Spring Boot使用Spring配置来引导自身和嵌入式 `Servlet` 容器，而不是挂钩到 `Servlet` 容器的生命周期。 在Spring配置中检测 `Filter` 和 `Servlet` 声明，并在Servlet容器中注册。 有关更多详细信息，请参阅https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-embedded-container[Spring Boot 文档] 。

[[mvc-servlet-context-hierarchy]]
=== 上下文层次结构

`DispatcherServlet` 需要一个 `WebApplicationContext`（`ApplicationContext` 的扩展）来配置自己。 `WebApplicationContext` 有一个指向 `ServletContext` 的链接以及与之关联的 `Servlet`。
它还绑定到 `ServletContext`，当需要访问它时，应用程序可以使用 `RequestContextUtils` 上的静态方法来查找 `WebApplicationContext`。

对于许多应用程序，拥有一个简单的 `WebApplicationContext` 已经足够了。它也有一个上下文层次结构，其中根 `WebApplicationContext` 在多个 `DispatcherServlet`（或其他 `Servlet`）实例之间共享， 每个实例都有自己的子 `WebApplicationContext` 配置。
有关上下文层次结构功能的更多信息，请参阅 <<core.adoc#context-introduction,`ApplicationContext` 的其他功能>>。

根 `WebApplicationContext` 通常包含bean基础结构，例如需要跨多个 `Servlet` 实例共享的数据存储库和业务服务。 这些bean被有效继承，可以在特定于 `Servlet` 的子 `WebApplicationContext` 中重写（即重新声明），它通常包含给定 `Servlet` 本地的bean。 下图显示了这种关系：

image::images/mvc-context-hierarchy.png[]

以下示例配置 `WebApplicationContext` 层次结构:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

		@Override
		protected Class<?>[] getRootConfigClasses() {
			return new Class<?>[] { RootConfig.class };
		}

		@Override
		protected Class<?>[] getServletConfigClasses() {
			return new Class<?>[] { App1Config.class };
		}

		@Override
		protected String[] getServletMappings() {
			return new String[] { "/app1/*" };
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MyWebAppInitializer : AbstractAnnotationConfigDispatcherServletInitializer() {

		override fun getRootConfigClasses(): Array<Class<*>> {
			return arrayOf(RootConfig::class.java)
		}

		override fun getServletConfigClasses(): Array<Class<*>> {
			return arrayOf(App1Config::class.java)
		}

		override fun getServletMappings(): Array<String> {
			return arrayOf("/app1/*")
		}
	}
----

TIP: 如果不需要应用程序上下文层次结构，则应用程序可以通过 `getRootConfigClasses()` 返回所有配置，并从 `getServletConfigClasses()` 返回 `null`。

以下示例显示了 `web.xml` 配置（和上面效果一样）:

[source,xml,indent=0,subs="verbatim,quotes"]
----
<web-app>

	<listener>
		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	</listener>

	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>/WEB-INF/root-context.xml</param-value>
	</context-param>

	<servlet>
		<servlet-name>app1</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>/WEB-INF/app1-context.xml</param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>

	<servlet-mapping>
		<servlet-name>app1</servlet-name>
		<url-pattern>/app1/*</url-pattern>
	</servlet-mapping>

</web-app>
----

TIP: 	如果不需要应用程序上下文层次结构，则应用程序可以仅配置 "`root`" 上下文，并将 `contextConfigLocation` Servlet参数保留为空。


[[mvc-servlet-special-bean-types]]
=== 特殊的Bean类型
[.small]#<<web-reactive.adoc#webflux-special-bean-types, WebFlux>>#

`DispatcherServlet` 委托特殊bean处理请求并渲染视图。 "`special beans`" 是指实现WebFlux框架的Spring管理的 `Object` 实例。 这些通常带有内置联系，但您可以自定义其属性并扩展或替换它们。


下表列出了 `DispatcherHandler` 检测到的特殊bean:

[[mvc-webappctx-special-beans-tbl]]
[cols="1,2", options="header"]
|===
| Bean 类型| 说明

| `HandlerMapping`
| 将请求映射到处理程序以及用于预处理和后处理的<<mvc-handlermapping-interceptor, 拦截器>>列表。 其映射规则基于某些标准，其细节因 `HandlerMapping` 实现而异。
    两个主要的 `HandlerMapping` 实现是 `RequestMappingHandlerMapping`（它支持 `@RequestMapping` 带注解的方法） 和 `SimpleUrlHandlerMapping` （它维护对处理程序的URI路径模式的显式注册）。

| `HandlerAdapter`
| 无论实际调用处理程序如何，都可以帮助 `DispatcherServlet` 调用映射到请求的处理程序。 例如，调用带有注解的控制器，需要从注解中解析一些信息。 `HandlerAdapter` 的主要目的是保护 `DispatcherServlet` 不受此类细节的影响。

| <<mvc-exceptionhandlers, `HandlerExceptionResolver`>>
| 解决异常的策略，他可以将捕获到的异常映射到处理程序，HTML错误视图或其他目标。 请参阅<<mvc-exceptionhandlers,`HandlerExceptionResolver`>>。

| <<mvc-viewresolver, `ViewResolver`>>
| 将从处理程序返回的逻辑基于 `String` 的视图名称解析为用于呈现给响应的实际 `View`。 请参阅 <<mvc-viewresolver>> 和 <<mvc-view>>。

| <<mvc-localeresolver, `LocaleResolver`>>, <<mvc-timezone, LocaleContextResolver>>
| 解析客户端正在使用的 · 以及可能的时区，以便能够提供国际化视图。 请参阅 <<mvc-localeresolver>>。

| <<mvc-themeresolver, `ThemeResolver`>>
| 解决Web应用程序可以使用的主题 - 例如，提供个性化布局。 见<<mvc-themeresolver>>。

| <<mvc-multipart, `MultipartResolver`>>
| 解析multi-part的请求（例如：浏览器表单文件上载）。请参阅<<mvc-multipart>>。

| <<mvc-flash-attributes, `FlashMapManager`>>
| 存储和检索 `"input"` 和 `"output"` `FlashMap`，可用于将属性从一个请求传递到另一个请求，通常是通过重定向。 请参阅<<mvc-flash-attributes>>。
|===


[[mvc-servlet-config]]
=== Web MVC 配置
[.small]#<<web-reactive.adoc#webflux-framework-config, WebFlux>>#

对于每种类型的 <<mvc-servlet-special-bean-types,特殊bean>>， `DispatcherServlet` 首先会检查 `WebApplicationContext`。如果没有匹配的bean类型，则会退回检查 https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/resources/org/springframework/web/servlet/DispatcherServlet.properties[`DispatcherServlet.properties`]。

在大多数情况下，<<mvc-config>>是最佳起点。 它以Java或XML声明所需的bean，并提供更高级别的配置回调API来自定义它。

NOTE: Spring Boot依赖于MVC Java配置来配置Spring MVC并提供许多额外的便捷选项。

[[mvc-container-config]]
=== Servlet 配置

在Servlet 3.0+环境中，您可以选择以编程方式配置Servlet容器作为替代方法，也可以与 `web.xml` 文件结合使用。 以下示例注册 `DispatcherServlet`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.springframework.web.WebApplicationInitializer;

	public class MyWebApplicationInitializer implements WebApplicationInitializer {

		@Override
		public void onStartup(ServletContext container) {
			XmlWebApplicationContext appContext = new XmlWebApplicationContext();
			appContext.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");

			ServletRegistration.Dynamic registration = container.addServlet("dispatcher", new DispatcherServlet(appContext));
			registration.setLoadOnStartup(1);
			registration.addMapping("/");
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.web.WebApplicationInitializer

	class MyWebApplicationInitializer : WebApplicationInitializer {

		override fun onStartup(container: ServletContext) {
			val appContext = XmlWebApplicationContext()
			appContext.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml")

			val registration = container.addServlet("dispatcher", DispatcherServlet(appContext))
			registration.setLoadOnStartup(1)
			registration.addMapping("/")
		}
	}
----

`WebApplicationInitializer` 是Spring MVC提供的一个接口，实现此接口的任何Servlet 3容器都可被检测到并自动初始化。
`AbstractDispatcherServletInitializer` 抽象类实现了 `WebApplicationInitializer` 接口，通过重写方法来指定 `servlet` 映射和 `DispatcherServlet` 配置的地址， 从而更方便的注册 `DispatcherServlet`。

对于使用基于Java的Spring配置的应用程序，建议使用此方法，如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

		@Override
		protected Class<?>[] getRootConfigClasses() {
			return null;
		}

		@Override
		protected Class<?>[] getServletConfigClasses() {
			return new Class<?>[] { MyWebConfig.class };
		}

		@Override
		protected String[] getServletMappings() {
			return new String[] { "/" };
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MyWebAppInitializer : AbstractAnnotationConfigDispatcherServletInitializer() {

		override fun getRootConfigClasses(): Array<Class<*>>? {
			return null
		}

		override fun getServletConfigClasses(): Array<Class<*>>? {
			return arrayOf(MyWebConfig::class.java)
		}

		override fun getServletMappings(): Array<String> {
			return arrayOf("/")
		}
	}
----

如果使用基于XML的Spring配置，则应直接从 `AbstractDispatcherServletInitializer` 扩展，如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MyWebAppInitializer extends AbstractDispatcherServletInitializer {

		@Override
		protected WebApplicationContext createRootApplicationContext() {
			return null;
		}

		@Override
		protected WebApplicationContext createServletApplicationContext() {
			XmlWebApplicationContext cxt = new XmlWebApplicationContext();
			cxt.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");
			return cxt;
		}

		@Override
		protected String[] getServletMappings() {
			return new String[] { "/" };
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MyWebAppInitializer : AbstractDispatcherServletInitializer() {

		override fun createRootApplicationContext(): WebApplicationContext? {
			return null
		}

		override fun createServletApplicationContext(): WebApplicationContext {
			return XmlWebApplicationContext().apply {
				setConfigLocation("/WEB-INF/spring/dispatcher-config.xml")
			}
		}

		override fun getServletMappings(): Array<String> {
			return arrayOf("/")
		}
	}
----

`AbstractDispatcherServletInitializer` 还提供了一种便捷的方法来添加 `Filter` 实例并将它们自动映射到 `DispatcherServlet`，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MyWebAppInitializer extends AbstractDispatcherServletInitializer {

		// ...

		@Override
		protected Filter[] getServletFilters() {
			return new Filter[] {
				new HiddenHttpMethodFilter(), new CharacterEncodingFilter() };
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MyWebAppInitializer : AbstractDispatcherServletInitializer() {

		// ...

		override fun getServletFilters(): Array<Filter> {
			return arrayOf(HiddenHttpMethodFilter(), CharacterEncodingFilter())
		}
	}
----

每个过滤器都根据其具体类型添加默认名称，并自动映射到 `DispatcherServlet`。

`AbstractDispatcherServletInitializer` 的 protected方法 `isAsyncSupported` 提供了一个单独的地址来启用 `DispatcherServlet` 上的异步支持以及映射到它的所有过滤器。 默认情况下，此标志设置为 `true`。

最后，如果您需要进一步自定义 `DispatcherServlet` 本身，则可以覆盖 `createDispatcherServlet` 方法。



[[mvc-servlet-sequence]]
=== Processing
[.small]#<<web-reactive.adoc#webflux-dispatcher-handler-sequence, WebFlux>>#

`DispatcherServlet` 按如下方式处理请求：

* 首先，搜索应用的上下文对象 `WebApplicationContext`，并把它作为一个属性（attribute)绑定到该请求上。以便让控制器和其他组件能使用它。 属性的键名默认为 `DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE`。
* 将locale resolver绑定到请求上，并允许其他组件解析处理请求时使用的语言环境（渲染视图，准备数据等）。 如果您不需要区域解析，则不需要locale resolver。
* 将theme resolver 绑定到请求，以允许视图等组件确定要使用的themes。 如果您不使用themes，则可以忽略它。
* 如果指定multipart 文件处理器，则会检查请求的文件是不是multiparts的， 如果是，请求将包装在 `MultipartHttpServletRequest` 中， 以便其他组件进一步处理。 有关Multipart Resolver的更多信息，请参见 <<mvc-multipart,Multipart Resolver>>。
* 为该请求查找一个合适的处理器。 如果找到处理程序，则与该处理器关联的整条执行链（前处理器、后处理器、控制器等）都会被执行，以完成相应模型的准备或视图的渲染。 或者，对于带注解的控制器，可以显示响应（在 HandlerAdapter中）而不是返回视图。
* 如果处理器返回模型，则渲染视图。 如果没有返回模型（可能是由于前处理器或后处理器拦截请求，可能是出于安全原因），则不会渲染任何视图，因为该请求可能已经完成。

在 `WebApplicationContext` 中声明的 `HandlerExceptionResolver` 用于解决请求处理过程中引发的异常。这些异常解析程序允许使用自定义的逻辑来解决，有关详细信息，请参阅<<mvc-exceptionhandlers,Exceptions>>  。

Spring的 `DispatcherServlet` 也允许处理器返回Servlet API规范中定义的最后修改时间戳（`last-modification-date`）值。确定请求最后修改时间的方式是直截了当的： `DispatcherServlet` 会先查找合适的处理映射来找到请求对应的处理器，然后检测它是否实现了 `LastModified` 接口。
如果是的话，则调用接口的 `long getLastModified(request)` 方法，并将返回的值传回给客户端。

您可以自定义通过 `DispatcherServlet` 的配置。可以在 `web.xml` 文件中，声明元素Servlet的上添加Servlet的初始化参数（`init-param` 元素）。 下表列出了支持的参数：

[[mvc-disp-servlet-init-params-tbl]]
.DispatcherServlet 初始化参数
|===
| 参数| 说明

| `contextClass`
| 实现 `ConfigurableWebApplicationContext` 的类，由此类通过本地配置来初始化 Servlet实例。 默认情况下，使用 `XmlWebApplicationContext`。

| `contextConfigLocation`
|
一个指定了上下文配置文件路径的字符串，并传递给上下文实例（由 `contextClass` 指定） 。该字符串可能包含多个字符串（使用逗号作为分隔符）以支持多个上下文。 对于具有两次定义的bean的多个上下文位置，最新位置优先（即最后加载的为准）。

| `namespace`
| `WebApplicationContext` 的命名空间。 默认为 `[servlet-name]-servlet`。

| `throwExceptionIfNoHandlerFound`
| 当没有找到请求的处理程序时是否抛出 `NoHandlerFoundException`。 然后可以使用 `HandlerExceptionResolver` 捕获异常（例如，使用 `@ExceptionHandler` 控制器方法）并像处理其他任何方法一样处理异常。

  默认情况下，此参数设置为 `false`，在这种情况下，`DispatcherServlet` 将响应状态设置为 `404（NOT_FOUND）`，而不会引发异常。

  请注意，如果配置了 默认servlet处理 ，则始终将未解析的请求转发到<<mvc-default-servlet-handler,默认servlet>>，并且永远不会引发404。
|===



[[mvc-handlermapping-interceptor]]
=== 拦截器

所有 `HandlerMapping` 实现都支持处理拦截器，这些拦截器在需要为特定类型的请求应用一些功能时可能很有用非常有用。
例如，检查用户身份等，`org.springframework.web.servlet` 包中的 `HandlerInterceptor` 实现了三种方法，提供足够的灵活性来执行各种预处理和后处理：

* `preHandle(..)`: 在执行实际处理程序之前
* `postHandle(..)`: 在执行实际处理程序之后
* `afterCompletion(..)`: 完成请求后

`preHandle(..)` 方法返回一个布尔值。 您可以使用此方法来中断或继续执行链的处理。 当此方法返回 `true` 时，处理程序执行链继续。
当它返回 `false` 时，`DispatcherServlet` 假定拦截器本身已处理请求（例如，呈现适当的视图）并且不继续执行执行链中的其他拦截器和实际处理程序。

有关如何配置 <<mvc-config-interceptors,Interceptors>>  的示例，请参阅MVC配置一节中的拦截器。 您还可以使用各个 `HandlerMapping` 实现上的setter方法直接注册它们。

请注意，在 `HandlerAdapter` 和 `postHandle` 之前，响应被写入并提交。 `postHandle` 对于 `@ResponseBody` 和 `ResponseEntity` 方法不太有用， 这意味着对响应进行任何更改都为时已晚.
例如添加额外的header。 对于此类方案，您可以实现 `ResponseBodyAdvice` 并将其声明为 <<mvc-ann-controller-advice,Controller Advice>> bean或直接在 `RequestMappingHandlerAdapter` 上进行配置。

[[mvc-exceptionhandlers]]
=== 异常
[.small]#<<web-reactive.adoc#webflux-dispatcher-exceptions, WebFlux>>#

如果在请求映射期间发生异常或从请求处理程序（例如 `@Controller`）抛出异常， 则 `DispatcherServlet` 委托给 `HandlerExceptionResolver` bean来处理并解决异常，这通常是错误响应。

下表列出了可用的 `HandlerExceptionResolver` 实现：

[cols="1,2", options="header"]
.HandlerExceptionResolver 实现
|===
| `HandlerExceptionResolver` | 描述

| `SimpleMappingExceptionResolver`
| 异常类名称和错误视图名称之间的映射。 用于在浏览器应用程序中呈现错误页面。

| {api-spring-framework}/web/servlet/mvc/support/DefaultHandlerExceptionResolver.html[`DefaultHandlerExceptionResolver`]
| 解决Spring MVC引发的异常并将它们映射到HTTP状态代码。 另请参阅备用 `ResponseEntityExceptionHandler` 和 <<mvc-ann-rest-exceptions,REST API exceptions>>异常。

| `ResponseStatusExceptionResolver`
| 使用 `@ResponseStatus` 注解解析异常，并根据注解中的值将它们映射到HTTP状态代码。

| `ExceptionHandlerExceptionResolver`
| 通过在 `@Controller` 或 `@ControllerAdvice` 类中调用 `@ExceptionHandler` 方法来解决异常。 请参阅 <<mvc-ann-exceptionhandler, @ExceptionHandler methods>>方法。
|===


[[mvc-excetionhandlers-handling]]
==== 解析链

您可以通过在Spring配置中声明多个 `HandlerExceptionResolver` bean并根据需要设置其顺序属性来形成异常解析链。 `order` 属性越高，异常解析器定位的越晚。

`HandlerExceptionResolver` 的约定指定它可以返回:

* 一个指向错误视图的 `ModelAndView`。
* 如果在解析程序中处理异常，则为空的 `ModelAndView`。
* 如果异常仍未解析，则为 `null`，以供后续解析器尝试，如果异常保留在最后，则允许冒泡到 `Servlet` 容器。.

<<mvc-config,MVC Config>>自动声明内置的解析器，用于默认的Spring MVC异常，`@ResponseStatus` 带注解的异常，以及对 `@ExceptionHandler` 方法的支持。 您可以自定义该列表或替换它。

[[mvc-ann-customer-servlet-container-error-page]]
==== 容器错误页面

如果任何 `HandlerExceptionResolver` 仍未解析异常，并且因此将其传播给servlet容器或者如果响应状态设置为错误状态（即4xx，5xx） ，则Servlet容器可以呈现HTML中的默认错误页面。
要自定义容器的默认错误页面，可以在 `web.xml`.中声明错误页面映射。 以下示例显示了如何执行此操作：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<error-page>
		<location>/error</location>
	</error-page>
----

根据前面的示例，当异常冒泡或响应具有错误状态时，Servlet容器会在容器内对配置的URL进行ERROR调度（例如，`/error`）。
然后由 `DispatcherServlet` 处理，可能将其映射到 `@Controller`，可以实现该控件以返回带有模型的错误视图名称或呈现JSON响应，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RestController
	public class ErrorController {

		@RequestMapping(path = "/error")
		public Map<String, Object> handle(HttpServletRequest request) {
			Map<String, Object> map = new HashMap<String, Object>();
			map.put("status", request.getAttribute("javax.servlet.error.status_code"));
			map.put("reason", request.getAttribute("javax.servlet.error.message"));
			return map;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RestController
	class ErrorController {

		@RequestMapping(path = ["/error"])
		fun handle(request: HttpServletRequest): Map<String, Any> {
			val map = HashMap<String, Any>()
			map["status"] = request.getAttribute("javax.servlet.error.status_code")
			map["reason"] = request.getAttribute("javax.servlet.error.message")
			return map
		}
	}
----

TIP: 	Servlet API没有提供在Java中创建错误页面映射的方法。 但是，您可以同时使用 `WebApplicationInitializer` 和简写的 `web.xml`。

[[mvc-viewresolver]]
=== View Resolution
[.small]#<<web-reactive.adoc#webflux-viewresolution, WebFlux>>#

Spring MVC定义了 `ViewResolver` 和 `View` 接口，使您可以在浏览器中呈现模型，而无需将您与特定的视图技术联系起来。 `ViewResolver` 提供视图名称和实际视图之间的映射。
`View` 接口负责准备请求，并将请求的渲染交给某种具体的视图技术实现。

下表提供了有关 `ViewResolver` 层次结构的更多详细信息：

[[mvc-view-resolvers-tbl]]
.ViewResolver 实现
|===
| ViewResolver| 描述

| `AbstractCachingViewResolver`
| `AbstractCachingViewResolver` 的子类缓存它们解析的视图实例。 缓存可提高某些视图技术的性能。 您可以通过将 `cache` 属性设置为 `false`.来关闭缓存。 此外，如果必须在运行时刷新某个视图（例如，修改 `FreeMarker` 模板时），则可以使用 `removeFromCache(String viewName, Locale loc)` 方法。

| `XmlViewResolver`
| 实现 `ViewResolver`，它必须和Spring的XML bean工厂有相同的DTD以。 默认配置文件是 `/WEB-INF/views.xml`。

| `ResourceBundleViewResolver`
|  `ViewResolver` 的实现，它使用由bundle根路径指定的 `ResourceBundle` 中的bean定义作为配置。 对于它应该解析的每个视图，它使用属性 `[viewname].(class)` 的值作为视图类， 并使用属性 `[viewname].url` 的值作为视图URL。 您可以在  <<mvc-view,视图技术>> 一章中找到示例。

| `UrlBasedViewResolver`
| `ViewResolver` 接口的简单实现，它不需要其他任何显式的映射说明，而直接使用URL来解析到逻辑视图名。 如果您的逻辑名称与真正的视图资源的名称匹配，则不需要任何映射。

| `InternalResourceViewResolver`
| `UrlBasedViewResolver` 的便捷子类，支持 `InternalResourceView`（实际上是Servlet和JSP）和子类，如 `JstlView` 和 `TilesView`。 您可以使用 `setViewClass(..)` 为此解析程序生成的所有视图指定视图类。 有关详细信息，请参阅{api-spring-framework}/web/reactive/result/view/UrlBasedViewResolver.html[`UrlBasedViewResolver`] javadoc。

| `FreeMarkerViewResolver`
| `UrlBasedViewResolver` 的便捷子类，支持 `FreeMarkerView` 其自定义子类。

| `ContentNegotiatingViewResolver`
| 实现 `ViewResolver` 接口，该接口根据请求文件名或 `Accept` 头解析视图。 请参阅  <<mvc-multiple-representations,Content Negotiation>>。
|===


[[mvc-viewresolver-handling]]
==== 处理
[.small]#<<web-reactive.adoc#webflux-viewresolution-handling, WebFlux>>#

您可以在视图解析器链中声明多个视图解析器，并在必要时通过设置 `order` 属性来指定排序。 请记住，order属性越高，视图解析器在链中的位置越晚。 .

`ViewResolver` 可以返回 `null` 以指示无法找到该视图。 但是，对于JSP和 `InternalResourceViewResolver`, 确定JSP是否存在的唯一方法是通过 `RequestDispatcher` 执行调度。 因此，您必须始终将 `InternalResourceViewResolver` 配置为视图解析器的整体顺序中的最后一个。

配置视图解析就像将 `ViewResolver` bean添加到Spring配置一样简单。<<mvc-config,MVC Config>>为<<mvc-config-view-resolvers,View 解析器>>提供专用配置API，并添加无逻辑视图控制器（<<mvc-config-view-controller, View Controllers>> ），这些控制器对于没有控制器逻辑的HTML模板渲染非常有用。

[[mvc-redirecting-redirect-prefix]]
==== 重定向
[.small]#<<web-reactive.adoc#webflux-redirecting-redirect-prefix, WebFlux>>#

您可以在视图中使用 `redirect:` 前缀来执行重定向。`UrlBasedViewResolver`（及其子类）将此识别为需要重定向的指令。 视图名称的其余部分是重定向URL。

控制器本身可以根据逻辑视图名称进行操作。 逻辑视图名称（例如 `redirect:/myapp/some/resource`）相对于当前Servlet上下文重定向，而名称如 `redirect:http://myhost.com/some/arbitrary/path`  重定向到绝对URL。

请注意，如果使用 `@ResponseStatus` 注解控制器方法，则注解值优先于 `RedirectView` 设置的响应状态。

[[mvc-redirecting-forward-prefix]]
==== 转发

你也可以在视图名称中使用 `forward:` 前缀，来作为 `UrlBasedViewResolver` 和其子类最终解析的视图名称。 这将创建一个 `InternalResourceView`，它执行 `RequestDispatcher.forward()`。
因此，此前缀对于 `InternalResourceViewResolver` 和 `InternalResourceView`（对于JSP）没有用，但如果您使用其他视图技术时仍希望强制Servlet/JSP引擎处理资源的转发，则它可能会有所帮助。 请注意，您也可以链接多个视图解析器。


[[mvc-multiple-representations]]
==== Content Negotiation
[.small]#<<web-reactive.adoc#webflux-multiple-representations, WebFlux>>#

{api-spring-framework}/web/servlet/view/ContentNegotiatingViewResolver.html[`ContentNegotiatingViewResolver`] 本身不解析视图，而是委托给其他视图解析器，并选择类似于客户端请求的表示的视图。 可以从 `Accept` 头或查询参数（例如， `"/path?format=pdf"`）确定表示。

`ContentNegotiatingViewResolver` 通过将请求的媒体类型与其每个 `ViewResolvers` 关联的 `View` 支持的媒体类型（也称为 `Content-Type`）进行比较，选择适当的 `View` 来处理请求。列表中具有兼容 `Content-Type` 的第一个 `View` 将表示返回给客户端。
如果 `ViewResolver` 链无法提供兼容视图，则会查询通过 `DefaultViews` 属性指定的视图列表。 后一个选项适用于单个视图，它可以呈现当前资源的适当表示，而不管逻辑视图名称如何。 `Accept` 头可以包含通配符（例如 `text/{asterisk}`），在这种情况下，`Content-Type` 为 `text/xml` 的 `View` 是兼容匹配。

有关配置详细信息，请参阅 <<mvc-config,MVC Config>> 下的<<mvc-config-view-resolvers,View 解析器>> 。

[[mvc-localeresolver]]
=== 国际化

正如Spring Web MVC框架所做的那样，Spring架构的大多数部分都支持国际化。 `DispatcherServlet` 允许您使用客户端的语言环境自动解析消息。 这是通过 `LocaleResolver` 对象完成的。

当请求进入时，`DispatcherServlet` 会查找当前语言环境解析器，如果找到，则会尝试使用它来设置语言环境。 您可以通过使用 `RequestContext.getLocale()` 方法，来获取由区域解析器解析到的结果。

除了自动解析语言环境之外，您还可以在处理程序时添加拦截器（有关拦截器的更多信息，请参阅<<mvc-handlermapping-interceptor,Interception>> ），以便于在特定情况下更改语言环境。例如（通过请求中的参数来改变语言环境）

区域解析器和拦截器在 `org.springframework.web.servlet.i18n` 包中定义，并以正常方式在应用程序上下文中进行配置。 Spring中包含以下选择的语言环境解析器。

* <<mvc-timezone>>
* <<mvc-localeresolver-acceptheader>>
* <<mvc-localeresolver-cookie>>
* <<mvc-localeresolver-session>>
* <<mvc-localeresolver-interceptor>>


[[mvc-timezone]]
==== Time Zone

除了获取客户端的区域设置外，了解其时区通常也很有用。 `LocaleContextResolver` 接口提供了 `LocaleResolver` 的扩展，它允许解析器提供更丰富的 `LocaleContext`，其中可能包含时区信息。

当此解析器可用时，可以使用 `RequestContext.getTimeZone()` 方法获取用户的 `TimeZone`。 时区信息由Spring的 `ConversionService` 注册的任何 Date/Time `Converter` 和 `Formatter` 对象自动使用。


[[mvc-localeresolver-acceptheader]]
==== Header 解析器

此区域解析器检查客户端（例如，Web浏览器）发送的请求头中的 `accept-language`。 通常，此字段包含客户端操作系统的区域设置。 请注意，此解析器不支持时区信息。


[[mvc-localeresolver-cookie]]
==== Cookie 解析器

此区域解析器检查客户端上可能存在的 `Cookie`，以查看是否指定了 `Locale` 或 `TimeZone`。 如果是，则使用指定的详细信息。 通过使用此区域解析器的属性，您可以指定cookie的名称以及失效时间。 以下示例定义 `CookieLocaleResolver`：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="localeResolver" class="org.springframework.web.servlet.i18n.CookieLocaleResolver">

		<property name="cookieName" value="clientlanguage"/>

		<!-- in seconds. If set to -1, the cookie is not persisted (deleted when browser shuts down) -->
		<property name="cookieMaxAge" value="100000"/>

	</bean>
----

下表描述了 `CookieLocaleResolver` 的属性：

[[mvc-cookie-locale-resolver-props-tbl]]
.CookieLocaleResolver 属性
[cols="1,1,4"]
|===
| 属性 | 默认值 | 描述

| `cookieName`
| classname + LOCALE
| cookie的名字

| `cookieMaxAge`
| Servlet container default
| Cookie在客户端上持续存在的最长时间。 如果指定 `-1`，则不会保留cookie。 它仅在客户端关闭浏览器之前可用。

| `cookiePath`
| /
| 限制cookie对您网站某个部分的可见性。 当指定了 `cookiePath` 时，cookie仅对该路径及其下方的路径可见。
|===


[[mvc-localeresolver-session]]
==== Session 解析器

您可以使用 `SessionLocaleResolver` 从与用户请求关联的 `Session` 中获取 `Locale` 和 `TimeZone`。 与 `CookieLocaleResolver` 相比，此策略将本地选择的区域设置存储在Servlet容器的 `HttpSession` 中。 因此，这些设置对于每个会话都是临时的，这些设置在会话结束时会丢失。

请注意，与外部会话管理机制没有直接关系，例如Spring Session项目。 此 `SessionLocaleResolver` 根据当前的 `HttpServletRequest` 评估和修改相应的 `HttpSession` 属性。


[[mvc-localeresolver-interceptor]]
==== Locale 拦截器

您可以通过将 `LocaleChangeInterceptor` 添加到其中一个 `HandlerMapping` 定义来启用语言环境的更改。 它会检测请求中的参数并相应地更改语言环境，在程序的应用程序上下文中调用 `LocaleResolver` 上的 `setLocale` 方法。
下一个示例显示，当调用包含名为 `siteLanguage` 的参数的所有`{asterisk}.view` 资源时更改了区域设置。 例如，对URL的请求 `http://www.sf.net/home.view?siteLanguage=nl` 将网站语言更改为荷兰语。 以下示例显示如何拦截区域设置:

[source,xml,indent=0,subs="verbatim"]
----
	<bean id="localeChangeInterceptor"
			class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor">
		<property name="paramName" value="siteLanguage"/>
	</bean>

	<bean id="localeResolver"
			class="org.springframework.web.servlet.i18n.CookieLocaleResolver"/>

	<bean id="urlMapping"
			class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
		<property name="interceptors">
			<list>
				<ref bean="localeChangeInterceptor"/>
			</list>
		</property>
		<property name="mappings">
			<value>/**/*.view=someController</value>
		</property>
	</bean>
----



[[mvc-themeresolver]]
=== 主题

您可以使用Spring Web MVC框架自带的主题来设置应用程序的整体外观，从而增强用户体验。 主题是静态资源的集合，通常是样式表和图像，它们会影响应用程序的视觉样式。


[[mvc-themeresolver-defining]]
==== 定义一个主题

要在Web应用程序中使用主题，必须设置 `org.springframework.ui.context.ThemeSource` 接口的实现。 `WebApplicationContext` 接口扩展了 `ThemeSource`， 但将其职责委托给专用实现。
默认情况下，委托是 `org.springframework.ui.context.support.ResourceBundleThemeSource` 的实现。它从类路径的根目录加载属性文件。
要使用自定义 `ThemeSource` 实现或配置 `ResourceBundleThemeSource` 的名称前缀，可以在应用程序上下文中使用保留名称 `themeSource` 注册bean。 Web应用程序上下文自动检测具有该名称的bean并使用它。

使用 `ResourceBundleThemeSource` 时，主题在简单属性文件中定义。 属性文件列出构成主题的资源，如以下示例所示：

[literal,subs="verbatim,quotes"]
----
styleSheet=/themes/cool/style.css
background=/themes/cool/img/coolBg.jpg
----

属性的键是从视图代码引用主题元素的名称。 对于JSP，通常使用 `spring:theme` 自定义标签执行此操作，该标记与 `spring:message` 标签非常相似。 以下JSP片段使用上一示例中定义的主题来自定义外观：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<%@ taglib prefix="spring" uri="http://www.springframework.org/tags"%>
	<html>
		<head>
			<link rel="stylesheet" href="<spring:theme code='styleSheet'/>" type="text/css"/>
		</head>
		<body style="background=<spring:theme code='background'/>">
			...
		</body>
	</html>
----

默认情况下，`ResourceBundleThemeSource` 使用空的名称前缀。 因此，从类路径的根加载属性文件。 因此，您可以将 `cool.properties` 主题定义放在类路径根目录的目录中（例如，在 `/WEB-INF/classes` 中）。
`ResourceBundleThemeSource` 使用标准的Java资源包加载机制，从而使主题也具有国际化。 例如，我们可以有一个 `/WEB-INF/classes/cool_nl.properties`，它引用一个带有荷兰文本的特殊背景图像。

[[mvc-themeresolver-resolving]]
==== 解析主题

定义主题后，如<<mvc-themeresolver-defining, 上一节所述>>，您可以决定使用哪个主题。 `DispatcherServlet` 查找名为 `themeResolver` 的bean，以找出要使用的 `ThemeResolver` 实现。
主题解析器的工作方式与 `LocaleResolver` 的工作方式大致相同。 它检测用于特定请求的主题，还可以更改请求的主题。 下表描述了Spring提供的主题解析器：

[[mvc-theme-resolver-impls-tbl]]
.ThemeResolver 实现
[cols="1,4"]
|===
| Class | 描述

| `FixedThemeResolver`
| 选择使用 `defaultThemeName`

| `SessionThemeResolver`
| 主题在用户的HTTP会话中维护。 它只需要为每个会话设置一次，但不会在会话之间保留。

| `CookieThemeResolver`
| 所选主题存储在客户端的cookie中。
|===

Spring还提供了一个 `ThemeChangeInterceptor`，它允许通过简单的请求参数对每个请求进行主题更改。


[[mvc-multipart]]
=== Multipart 解析器
[.small]#<<web-reactive.adoc#webflux-multipart, WebFlux>>#

`org.springframework.web.multipart` 包中的 `MultipartResolver` 是一种用于解析包括文件上传在内的多部分请求的策略。 他包含了一个 https://jakarta.apache.org/commons/fileupload[Commons FileUpload] 的实现，另一个基于Servlet 3.0多部分请求解析。

要启用多部分处理，Spring的配置文件中，在 `DispatcherServlet` 配置名称为 `multipartResolver` 的 `MultipartResolver` bean。 `DispatcherServlet` 会自动检测并将其应用于请求中。
当收到内容类型为 `multipart/form-data` 的POST请求时，解析器会解析内容并将当前的 `HttpServletRequest` 包装为 `MultipartHttpServletRequest`，以提供对已解析部分的访问，并将其作为请求参数公开。

[[mvc-multipart-resolver-commons]]
==== Apache Commons `FileUpload`

要使用Apache Commons `FileUpload`，您可以配置名为 `multipartResolver` 的 `CommonsMultipartResolver` 类型的bean。 您还需要添加 `commons-fileupload` 依赖。

[[mvc-multipart-resolver-standard]]
==== Servlet 3.0

需要通过Servlet容器配置启用Servlet 3.0多部分解析:

* 在Java中，在注册Servlet时设置 `MultipartConfigElement`。
* 在 `web.xml` 中，将 `"<multipart-config>"` 部分添加到servlet声明中。

以下示例显示如何在注册Servlet时设置 `MultipartConfigElement`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class AppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

		// ...

		@Override
		protected void customizeRegistration(ServletRegistration.Dynamic registration) {

			// Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold
			registration.setMultipartConfig(new MultipartConfigElement("/tmp"));
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class AppInitializer : AbstractAnnotationConfigDispatcherServletInitializer() {

		// ...

		override fun customizeRegistration(registration: ServletRegistration.Dynamic) {

			// Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold
			registration.setMultipartConfig(MultipartConfigElement("/tmp"))
		}

	}
----

一旦您配置好Servlet 3.0，您就可以添加名为 `multipartResolver` 的 `StandardServletMultipartResolver` 类型的bean。

[[mvc-logging]]
=== 日志
[.small]#<<web-reactive.adoc#webflux-logging, WebFlux>>#

Spring MVC中的DEBUG级别日志记录旨在实现紧凑，简约和人性化。 它侧重于那些一次又一次使用的高价值信息，其他的只有在调试特定问题时才有用。

TRACE级日志记录通常遵循与DEBUG相同的原则（例如，不应该是fire hose），但可以用于调试任何问题。 此外，一些日志消息可能在TRACE与DEBUG中显示不同的详细程度。

良好的日志记录来自使用日志的经验。 如果您发现任何不符合既定目标的事件，请告知我们。

[[mvc-logging-sensitive-data]]
==== 敏感数据
[.small]#<<web-reactive.adoc#webflux-logging-sensitive-data, WebFlux>>#

DEBUG和TRACE日志记录可能会记录敏感信息。 这就是默认情况下屏蔽请求参数和请求头的原因，并且必须通过 `DispatcherServlet` 上的 `enableLoggingRequestDetails` 属性显式启用它们的完整日志记录。

以下示例说明如何使用Java配置执行此操作：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
public class MyInitializer
		extends AbstractAnnotationConfigDispatcherServletInitializer {

	@Override
	protected Class<?>[] getRootConfigClasses() {
		return ... ;
	}

	@Override
	protected Class<?>[] getServletConfigClasses() {
		return ... ;
	}

	@Override
	protected String[] getServletMappings() {
		return ... ;
	}

	@Override
	protected void customizeRegistration(ServletRegistration.Dynamic registration) {
		registration.setInitParameter("enableLoggingRequestDetails", "true");
	}

}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MyInitializer : AbstractAnnotationConfigDispatcherServletInitializer() {

		override fun getRootConfigClasses(): Array<Class<*>>? {
			return ...
		}

		override fun getServletConfigClasses(): Array<Class<*>>? {
			return ...
		}

		override fun getServletMappings(): Array<String> {
			return ...
		}

		override fun customizeRegistration(registration: ServletRegistration.Dynamic) {
			registration.setInitParameter("enableLoggingRequestDetails", "true")
		}
	}
----




[[filters]]
== 过滤器
[.small]#<<web-reactive.adoc#webflux-filters, WebFlux>>#

`spring-web` 模块提供了一些有用的过滤器:

* <<filters-http-put,Form Data（表单数据）>>
* <<filters-forwarded-headers,Forwarded Headers（转发请求头）>>
* <<filters-shallow-etag,Shallow ETag()>>
* <<filters-cors,CORS>>



[[filters-http-put]]
=== 表单数据

浏览器只能通过HTTP GET或HTTP POST提交表单数据，但非浏览器客户端也可以使用HTTP PUT，PATCH和DELETE提交表单数据。 Servlet API要求 `ServletRequest.getParameter{asterisk}()` 方法仅支持HTTP POST的表单字段访问。.

`spring-web` 模块提供 `FormContentFilter` 过滤器来拦截HTTP PUT，PATCH和DELETE请求，请求类型为 `application/x-www-form-urlencoded`， `FormContentFilter` 从请求中读取表单数据， 并包装 `ServletRequest`，然后可以通过 `ServletRequest.getParameter{asterisk}()` 系列方法提供表单数据。

[[filters-forwarded-headers]]
=== 转发请求头
[.small]#<<web-reactive.adoc#webflux-forwarded-headers, WebFlux>>#

当通过代理主机或者端口或者其他方案请求时（例如，负载均衡），这是，从客户端角度看，创建正确的主机，端口或者其他方案成为一项挑战，

https://tools.ietf.org/html/rfc7239[RFC 7239] 定义了代理可以用来提供有关原始请求信息的转发HTTP头。 还有其他非标准头文件，包括 `X-Forwarded-Host`, `X-Forwarded-Port`, `X-Forwarded-Proto`, `X-Forwarded-Ssl`, 和 `X-Forwarded-Prefix`。

`ForwardedHeaderFilter` 是一个Servlet过滤器，它根据 `Forwarded` 头部信息修改请求的主机，端口和方案，然后删除请求头。过滤器依赖于包装请求，并且 ，必须先于其他过滤器（例如 `RequestContextFilter`）进行排序， 应该与修改后的请求而不是原始请求一起使用。

当转发请求头时需要注意的安全事项，因为应用程序无法知道请求头是代理按我们想的那样添加还是由客户端恶意添加，这就是为什么应该将信任边界的代理配置为删除来自外部的不受信任的转发请求头。 您还可以使用 `removeOnly=true` 配置 `ForwardedHeaderFilter`，在这种情况下，它会删除但不使用标头。

为了支持<<mvc-ann-async,异步请求>>并且可以处理错误的情况， 过滤器应使用 `DispatcherType.ASYNC` 和 `DispatcherType.ERROR` 映射。
如果使用Spring Framework的 `AbstractAnnotationConfigDispatcherServletInitializer`（请参阅<<mvc-container-config,Servlet 配置>>）所有过滤器都将自动注册 为 dispatch 类型。 但是，如果通过 `web.xml` 或在Spring Boot中 `FilterRegistrationBean` ,除了 `DispatcherType.REQUEST` 之外，还必须包含 `DispatcherType.ASYNC` 和 `DispatcherType.ERROR`。

[[filters-shallow-etag]]
=== Shallow ETag

`ShallowEtagHeaderFilter` 过滤器通过缓存写入响应的内容并从中计算MD5哈希来创建 "`shallow`" ETag。 客户端下次发送时， 它会执行相同操作，但它也会将计算值与 `If-None-Match` 请求头进行比较，如果两者相等，则返回304（NOT_MODIFIED）。

此策略可以节省网络带宽，但不能节省CPU，因为必须为每个请求计算完整响应。 前面描述的控制器级别的其他策略可以避免计算。 请参阅 <<mvc-caching,HTTP 缓存>>。

此过滤器具有 `writeWeakETag` 参数，该参数将过滤器配置为写入弱ETag，类似于以下内容：`W/"02a2d595e6ed9a0b24f027f2b63b134d6"`（如https://tools.ietf.org/html/rfc7232#section-2.3[RFC 7232 Section 2.3]）。

为了支持<< mvc-ann-async，异步请求>>，此过滤器必须与 `DispatcherType.ASYNC` 映射，以便过滤器可以延迟并成功生成ETag到最后一个异步调度的末尾。 如果使用Spring Framework的 `AbstractAnnotationConfigDispatcherServletInitializer`（请参阅<<mvc-container-config,Servlet 配置>>），则会为所有调度类型自动注册所有过滤器。 但是，如果通过 `web.xml` 或在Spring Boot中通过 `FilterRegistrationBean` 注册过滤器，请确保包括
`DispatcherType.ASYNC`

[[filters-cors]]
=== CORS
[.small]#<<web-reactive.adoc#webflux-filters-cors, WebFlux>>#

Spring MVC通过控制器上的注解为CORS配置提供细粒度的支持。 但是，当与Spring Security一起使用时，我们建议依赖于必须在Spring Security的过滤器链之前配置的内置 `CorsFilter`。

有关更多详细信息，请参阅  <<mvc-cors,CORS>> 和 <<mvc-cors-filter,CORS Filter>> 过滤器部分。

[[mvc-controller]]
== 注解控制器
[.small]#<<web-reactive.adoc#webflux-controller, WebFlux>>#

Spring MVC提供了基于注解的编程模型，其中 `@Controller` 和 `@RestController` 组件使用注解来表示请求映射、请求输入、异常处理等。被注解的控制器拥有灵活的方法签名，并且无需扩展基类或实现特定的接口。以下示例显示了由注解定义的控制器：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class HelloController {

		@GetMapping("/hello")
		public String handle(Model model) {
			model.addAttribute("message", "Hello World!");
			return "index";
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.ui.set

	@Controller
	class HelloController {

		@GetMapping("/hello")
		fun handle(model: Model): String {
			model["message"] = "Hello World!"
			return "index"
		}
	}
----

在前面的示例中，该方法接受 `Model` 并将视图名称作为 `String` 返回，但是存在许多其他选项，本章稍后将对其进行说明。

TIP: 有关 https://spring.io/guides[spring.io]的指南和教程，请使用本节中介绍的基于注解的编程模型。



[[mvc-ann-controller]]
=== Declaration
[.small]#<<web-reactive.adoc#webflux-ann-controller, WebFlux>>#

您可以在Servlet的 `WebApplicationContext` 中使用标准的Spring bean定义来定义控制器bean。`@Controller` 模板允许自动检测， 与Spring支持检测类路径中的 `@Component` 类一样，并会自动注册bean定义。它还充当注解类的模板，表示它充当的是Web组件的角色。

要启用 `@Controller` bean的自动检测，您可以将组件扫描添加到Java配置中，如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@ComponentScan("org.example.web")
	public class WebConfig {

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@ComponentScan("org.example.web")
	class WebConfig {

		// ...
	}
----

以下示例显示了与前面示例等效的XML配置:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:p="http://www.springframework.org/schema/p"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">

		<context:component-scan base-package="org.example.web"/>

		<!-- ... -->

	</beans>
----

`@RestController` 是一个<<core.adoc#beans-meta-annotations, 组合注解>>，它本身由 `@Controller` 和 `@ResponseBody` 元注解组成。 其每个方法都继承类型级别（type-level）的 `@ResponseBody` 注解，因此，直接写入响应主体与视图渲染和使用HTML模板。

[[mvc-ann-requestmapping-proxying]]
==== AOP 代理

在某些情况下，您需要在运行时使用AOP代理装饰控制器。 例如，如果您想在控制器上直接使用 `@Transactional` 注解。 在这种情况下，对于控制器而言，我们建议使用基于类的代理。 这通常也是控制器的默认选择。 但是，如果控制器没有实现Spring Context 回调的接口 （例如 `InitializingBean`, `*Aware` 等）， 则可能需要显式配置基于类的代理。
例如，使用 `<tx:annotation-driven/>`，您可以更改为 `<tx:annotation-driven proxy-target-class="true"/>`。使用 `@EnableTransactionManagement` ，你可以更改为 `@EnableTransactionManagement(proxyTargetClass = true)`

[[mvc-ann-requestmapping]]
=== Request Mapping
[.small]#<<web-reactive.adoc#webflux-ann-requestmapping, WebFlux>>#

`@RequestMapping` 注解用于将请求映射到控制器方法。它具有各种属性，可以通过URL、HTTP方法、请求参数、请求头参数（headers）和媒体类型进行匹配。 可以在类级别使用它来表示共享映射，或在方法级别上用于缩小到特定的端点映射范围。

还有 `@RequestMapping` 的HTTP方法特定的缩写变量:

* `@GetMapping`
* `@PostMapping`
* `@PutMapping`
* `@DeleteMapping`
* `@PatchMapping`

这些简洁的注解是<<mvc-ann-requestmapping-composed,自定义注解>>，因为，大多数的控制器方法应该映射到HTTP方法而不是使用 `@RequestMapping`。默认情况下， `@RequestMapping` 和所有HTTP方法匹配。在类上定义的仍然需要 `@RequestMapping` 来表示共享映射。

以下示例具有类型和方法级别映射:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RestController
	@RequestMapping("/persons")
	class PersonController {

		@GetMapping("/{id}")
		public Person getPerson(@PathVariable Long id) {
			// ...
		}

		@PostMapping
		@ResponseStatus(HttpStatus.CREATED)
		public void add(@RequestBody Person person) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RestController
	@RequestMapping("/persons")
	class PersonController {

		@GetMapping("/{id}")
		fun getPerson(@PathVariable id: Long): Person {
			// ...
		}

		@PostMapping
		@ResponseStatus(HttpStatus.CREATED)
		fun add(@RequestBody person: Person) {
			// ...
		}
	}
----



[[mvc-ann-requestmapping-uri-templates]]
==== URI 模式匹配
[.small]#<<web-reactive.adoc#webflux-ann-requestmapping-uri-templates, WebFlux>>#

您可以使用以下全局模式和通配符来映射请求：

* `?` 匹配一个字符
* `*` 匹配路径段一个或多个字符
* `**` 匹配0个或多个路径段

您还可以使用 `@PathVariable` 声明URI变量并访问它们的值，如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/owners/{ownerId}/pets/{petId}")
	public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/owners/{ownerId}/pets/{petId}")
	fun findPet(@PathVariable ownerId: Long, @PathVariable petId: Long): Pet {
		// ...
	}
----


您可以在类和方法级别声明URI变量，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	@RequestMapping("/owners/{ownerId}")
	public class OwnerController {

		@GetMapping("/pets/{petId}")
		public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	@RequestMapping("/owners/{ownerId}")
	class OwnerController {

		@GetMapping("/pets/{petId}")
		fun findPet(@PathVariable ownerId: Long, @PathVariable petId: Long): Pet {
			// ...
		}
	}
----

URI变量会自动转换为适当的类型，或者引发 `TypeMismatchException`。 默认情况下支持简单类型（`int`, `long`, `Date` 等），您也可以注册对任何其他数据类型的支持。 请参见<<mvc-ann-typeconversion,类型转换>> 和 <<mvc-ann-initbinder,DataBinder>>。

你可以显示命名URI 变量(例如, `@PathVariable("customId")` ),但是如果名称是相同的，并且代码是使用调试信息编译的，或者在Java 8中使用 `-parameters` 编译器标记。 则可以保留该详细信息。

语法 `{varName:regex}` 声明一个具有正则表达式的URI变量，其语法为 `{varName:regex}`。例如，给定URL `"/spring-web-3.0.5 .jar"`，以下方法提取名称，版本和文件扩展名:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}")
	public void handle(@PathVariable String version, @PathVariable String ext) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}")
	fun handle(@PathVariable version: String, @PathVariable ext: String) {
		// ...
	}
----

URI路径模式还可以嵌入 `${…​}`，在启动时通过 `PropertyPlaceHolderConfigurer` 解析本地、系统、环境和其他属性源时解析的占位符。例如，这种模式可以使用基于某些外部配置对基URL进行参数化

NOTE: Spring MVC使用 `PathMatcher` 联系和 `AntPathMatcher` 实现位于 `spring-core` URI路径匹配。


[[mvc-ann-requestmapping-pattern-comparison]]
==== 模式比较
[.small]#<<web-reactive.adoc#webflux-ann-requestmapping-pattern-comparison, WebFlux>>#

当多个模式与URL匹配时，必须对它们进行比较以找到最佳匹配。 这是通过使用 `AntPathMatcher.getPatternComparator(String path)` 来完成的，它会查找更具体的模式。

如果URI变量的数量较少且单个通配符计为1且双通配符计为2，那么模式就不那么具体了。如果模式得到的分数相等，那么会选择较长的模式匹配。如果分数和长度都相同，则会选择拥有比通配符更多的URI变量的模式。

默认映射模式(`/{asterisk}{asterisk}`)从评分中排除，并始终排在最后。 此外，前缀模式（例如 `/public/{asterisk}{asterisk}`）被认为比没有双通配符的其他模式更不具体。

有关详细信息，请参阅 {api-spring-framework}/util/AntPathMatcher.html[`AntPathMatcher`] 中的 {api-spring-framework}/util/AntPathMatcher.AntPatternComparator.html[`AntPatternComparator`]。 您可以自定义 {api-spring-framework}/util/PathMatcher.html[`PathMatcher`]  的实现. 请参阅 配置中的  <<mvc-config-path-matching,Path Matching>>


[[mvc-ann-requestmapping-suffix-pattern-match]]
==== 后缀匹配

默认情况下,默认情况下，Spring MVC执行 `.{asterisk}` 后缀模式匹配，以便映射到 `/person` 的控制器也隐式映射到 `/person.*`。这里使用文件扩展名来解释用于响应的请求内容类型（即，而不是 `Accept` 请求头） - 例如，`/person.pdf`，`/person.xml` 等。

当浏览器用于发送难以持续交互的 `Accept` 头时，必须以这种方式使用文件扩展名。目前，这不再是必需的，判断 `Accept` 头应该是首选。

随着时间的推移，文件扩展名的使用已经证明有多种方式存在问题。 当使用URI变量，路径参数和URI编码进行覆盖时，它可能会导致歧义。 有关基于URL的授权和安全性的推理（有关更多详细信息，请参阅下一节）也变得更加困难。

要完全禁用文件扩展名，必须同时设置以下两项:

* `useSuffixPatternMatching(false)`,  <<mvc-config-path-matching, PathMatchConfigurer>>
* `favorPathExtension(false)`,  <<mvc-config-content-negotiation, ContentNegotiationConfigurer>>

基于URL的内容协商仍然有用（例如，在浏览器中键入URL时）。 为此，我们建议使用基于查询参数的策略来避免文件扩展名带来的大多数问题。 或者，如果必须使用文件扩展名，请考虑通过 `ContentNegotiationConfigurer` 的 `mediaTypes` 属性将它们限制为显式注册的扩展名列表。

[[mvc-ann-requestmapping-rfd]]
==== 后缀匹配和RFD

反射文件下载（Reflected file download）攻击与XSS类似，因为它依赖请求输入，例如查询参数、URI变量，并且在响应中被反射。但是，RFD攻击不是将JavaScript插入HTML，而是依赖浏览器切换来执行下载，进而在之后的双击时将响应作为可执行脚本处理。

在Spring MVC中，`@ResponseBody` 和 `ResponseEntity` 方法存在风险，因为它们可以呈现不同的内容类型，客户端可以通过URL路径扩展来请求。 禁用后缀模式匹配并使用路径扩展进行内容协商可降低风险，但不足以防止RFD攻击。

为了防止RFD攻击，在呈现响应主体之前，需要在Spring MVC添加 `Content-Disposition:inline;filename=f.txt` 头用于提供固定和安全的下载文件。只有在URL路径包含的文件扩展名中既不包含白名单，也没有为内容协商显式注册以时，才需要这样做。 但是，在浏览器直接键入URL时，可能会产生副作用。

默认情况下，有许多常见的路径扩展白名单。具有自定义 `HttpMessageConverter` 实现的应用程序可以显式注册内容协商的文件扩展名，以避免为这些扩展添加 `Content-Disposition` 头。 请参阅<<mvc-config-content-negotiation>>

有关RFD的其他建议，请参阅 https://pivotal.io/security/cve-2015-5211[CVE-2015-5211]


[[mvc-ann-requestmapping-consumes]]
==== 消费者媒体类型
[.small]#<<web-reactive.adoc#webflux-ann-requestmapping-consumes, WebFlux>>#

您可以根据请求的 `Content-Type` 缩小请求映射范围，如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping(path = "/pets", consumes = "application/json") // <1>
	public void addPet(@RequestBody Pet pet) {
		// ...
	}
----
<1> 使用 `consumes` 属性来缩小内容类型的映射。


[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/pets", consumes = ["application/json"]) // <1>
	fun addPet(@RequestBody pet: Pet) {
		// ...
	}
----
<1> 使用 `consumes` 属性来缩小内容类型的映射。

`consumes` 属性还支持否定表达式 - 例如，`!text/plain` 表示除 `text/plain` 之外的任何内容类型。

您可以在类级别声明共享 `consumes` 属性。 但是，与大多数其他请求映射属性不同，在类级别使用时，方法级别会 `consumes` 属性覆盖而不是扩展类级别声明。

TIP: `MediaType` 为常用媒体类型提供常量，例如 `APPLICATION_JSON_VALUE` 和 `APPLICATION_XML_VALUE`。


[[mvc-ann-requestmapping-produces]]
==== 生产者媒体类型
[.small]#<<web-reactive.adoc#webflux-ann-requestmapping-produces, WebFlux>>#

您可以根据 `Accept` 请求头和控制器方法生成的内容类型列表来缩小请求映射，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping(path = "/pets/{petId}", produces = "application/json") // <1>
	@ResponseBody
	public Pet getPet(@PathVariable String petId) {
		// ...
	}
----
<1>  使用 `produces` 属性来缩小内容类型的映射。


[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/pets/{petId}", produces = ["application/json"]) // <1>
	@ResponseBody
	fun getPet(@PathVariable petId: String): Pet {
		// ...
	}
----
<1>  使用 `produces` 属性来缩小内容类型的映射。

媒体类型可以指定字符集。 支持否定表达式 - 例如， `!text/plain` 表示 "text/plain" 以外的任何内容类型。

您可以在类级别声明共享的 `produces` 属性。 但是，与大多数其他请求映射属性不同，在类级别使用时，方法级别会生成属性覆盖，而不是扩展类级别声明。

TIP: `MediaType` 为常用媒体类型提供常量，例如 `APPLICATION_JSON_UTF8_VALUE` 和 `APPLICATION_XML_VALUE`。


[[mvc-ann-requestmapping-params-and-headers]]
==== 参数, 请求头
[.small]#<<web-reactive.adoc#webflux-ann-requestmapping-params-and-headers, WebFlux>>#

您可以根据请求参数条件缩小请求映射。 您可以测试是否存在请求参数（`myParam`），缺少一个（`!myParam`）或特定值（`myParam=myValue`）。 以下示例显示如何测试特定值：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping(path = "/pets/{petId}", params = "myParam=myValue") // <1>
	public void findPet(@PathVariable String petId) {
		// ...
	}
----
<1> 测试 `myParam` 是否等于 `myValue`。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/pets/{petId}", params = ["myParam=myValue"]) // <1>
	fun findPet(@PathVariable petId: String) {
		// ...
	}
----
<1> 测试 `myParam` 是否等于 `myValue`。

您还可以将其与请求头条件一起使用，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping(path = "/pets", headers = "myHeader=myValue") // <1>
	public void findPet(@PathVariable String petId) {
		// ...
	}
----
<1> 测试 `myParam` 是否等于 `myValue`。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/pets", headers = ["myHeader=myValue"]) // <1>
	fun findPet(@PathVariable petId: String) {
		// ...
	}
----

TIP: 您可以将 `Content-Type` 和 `Accept` 与 `headers` 条件匹配，但最好使用<<mvc-ann-requestmapping-consumes, consumes>>和 <<mvc-ann-requestmapping-produces, produces>>替代。


[[mvc-ann-requestmapping-head-options]]
==== HTTP HEAD, OPTIONS
[.small]#<<web-reactive.adoc#webflux-ann-requestmapping-head-options, WebFlux>>#

`@GetMapping` (和 `@RequestMapping(method=HttpMethod.GET)`)一样，为了请求映射的目的，透明地支持HTTP HEAD以进行请求映射。控制器方法无需更改。 在 `javax.servlet.http.HttpServlet` 中应用的响应包确保有 `Content-Length` 头并且设置为写入的字节数，但实际上不会写入响应。

`@GetMapping` (和 `@RequestMapping(method=HttpMethod.GET)`)一样，为了请求映射的目的，被隐式映射到并支持HTTP HEAD，处理HTTP HEAD请求就像它是HTTP GET一样，但不是写入正文，而是计算字节数并设置 `Content-Length` 头。

默认情况下，HTTP OPTIONS通过设置 `Allow` 响应头来为所有具有匹配URL模式的 `@RequestMapping` 方法中列出的HTTP方法列表来处理HTTP选项。

对于没有HTTP方法声明的 `@RequestMapping`，`Allow` 请求头可以设置为 `GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS`。 控制器方法应始终声明支持的HTTP方法（例如，通过使用特定于HTTP方法的变体：`@GetMapping`, `@PostMapping` 等）。

您可以将 `@RequestMapping` 方法显式映射到HTTP HEAD和HTTP OPTIONS，但在常见情况下这不是必需的。


[[mvc-ann-requestmapping-composed]]
==== 自定义注解
[.small]#<<web-reactive.adoc#mvc-ann-requestmapping-head-options, WebFlux>>#

Spring MVC支持使用 <<core.adoc#beans-meta-annotations, 组合注解>>进行请求映射。 这些注解本身是使用 `@RequestMapping` 进行元注解的，并且用于重新声明具有更窄，更具体目的的 `@RequestMapping` 属性的子集（或全部）。

`@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping`, 和 `@PatchMapping` 就是组合注解最好的示例， 提供它们是因为.
可以说，大多数控制器方法应该映射到特定的HTTP方法，而不是使用 `@RequestMapping`，默认情况下，它与所有HTTP方法匹配。 如果您需要组合注解的示例，请查看如何声明这些注解。

Spring MVC还支持使用自定义请求匹配逻辑的自定义请求映射属性。这是一个更高级的选项，需要继承 `RequestMappingHandlerMapping` 并覆盖 `getCustomMethodCondition` 方法， 您可以在其中检查自定义属性并返回自己的 `RequestCondition`。

[[mvc-ann-requestmapping-registration]]
==== 显式注册
[.small]#<<web-reactive.adoc#webflux-ann-requestmapping-registration, WebFlux>>#

您可以以编程方式注册处理程序方法，您可以将其用于动态注册或高级情况，例如不同URL下的同一处理程序的不同实例。 以下示例注册处理程序方法：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class MyConfig {

		@Autowired
		public void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler) // <1>
				throws NoSuchMethodException {

			RequestMappingInfo info = RequestMappingInfo
					.paths("/user/{id}").methods(RequestMethod.GET).build(); // <2>

			Method method = UserHandler.class.getMethod("getUser", Long.class); // <3>

			mapping.registerMapping(info, handler, method); // <4>
		}
	}
----
<1> 为控制器注入目标处理程序和处理程序映射
<2> 准备映射元数据的请求
<3> 获取处理程序方法
<4> 添加注册

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class MyConfig {

		@Autowired
		fun setHandlerMapping(mapping: RequestMappingHandlerMapping, handler: UserHandler) { // <1>
			val info = RequestMappingInfo.paths("/user/{id}").methods(RequestMethod.GET).build() // <2>
			val method = UserHandler::class.java.getMethod("getUser", Long::class.java) // <3>
			mapping.registerMapping(info, handler, method) // <4>
		}
	}
----
<1> 为控制器注入目标处理程序和处理程序映射
<2> 准备映射元数据的请求
<3> 获取处理程序方法
<4> 添加注册



[[mvc-ann-methods]]
=== 程序处理方法
[.small]#<<web-reactive.adoc#webflux-ann-methods, WebFlux>>#

`@RequestMapping` 处理程序方法具有灵活的签名,可以从一系列受支持的控制器方法参数和返回值中进行选择.


[[mvc-ann-arguments]]
==== Method Arguments
[.small]#<<web-reactive.adoc#webflux-ann-arguments, WebFlux>>#

下表显示了受支持的控制器方法参数，任何参数都不支持响应式(Reactive)类型。

JDK 8  `java.util.Optional` 作为方法参数来支持的，它与具有必需属性的注解(例如 `@RequestParam`, `@RequestHeader` 等相结合)。 并且等同于 `required=false`。

[cols="1,2", options="header"]
|===
| 控制器方法参数 | 	描述

| `WebRequest`, `NativeWebRequest`
| 无需直接使用Servlet API即可访问请求参数以及request和session属性。

| `javax.servlet.ServletRequest`, `javax.servlet.ServletResponse`
| 选择任何特定的请求或响应类型 - 例如，`ServletRequest`, `HttpServletRequest` 或Spring的 `MultipartRequest`, `MultipartHttpServletRequest`。

| `javax.servlet.http.HttpSession`
| 强制进行会话。 因此，此类参数永远不可能为 `null`. 请注意，会话访问不是线程安全的。 如果允许多个请求同时访问会话，请考虑将 `RequestMappingHandlerAdapter` 实例的 `synchronizeOnSession` 标志设置为 `true`。

| `javax.servlet.http.PushBuilder`
| Spring4.0 push生成器API用于编程HTTP/2资源推送， 请注意，根据Servlet规范，如果客户端不支持该HTTP/2功能，则注入的 `PushBuilder` 实例可以为 `null`。

| `java.security.Principal`
| 当前经过身份验证的用户 - 如果已知，可能是特定的 `Principal` 实现类。

| `HttpMethod`
| 请求的HTTP方法.

| `java.util.Locale`
| 当前请求区域设置，由最可用的 `LocaleResolver`（实际上是已配置的 `LocaleResolver` 或 `LocaleContextResolver`）确定。

| `java.util.TimeZone` + `java.time.ZoneId`
| 与当前请求关联的时区，由 `LocaleContextResolver` 确定

| `java.io.InputStream`, `java.io.Reader`
| 用于访问Servlet API公开的原始请求主体。

| `java.io.OutputStream`, `java.io.Writer`
| 用于访问Servlet API公开的原始响应主体。

| `@PathVariable`
| 用于访问URI模板变量。 请参阅<<mvc-ann-requestmapping-uri-templates,URI模式>>.

| `@MatrixVariable`
| 用于访问URI路径段中的名称 - 值对。 请参见<<mvc-ann-matrix-variables,矩阵变量>>.

| `@RequestParam`
| 用于访问Servlet请求参数，包括多部分文件。 参数值将转换为声明的方法参数类型。 请参阅 <<mvc-ann-requestparam,@RequestParam>> 以及 <<mvc-multipart-forms,Multipart>>。 请注意，对于简单的参数值，使用 `@RequestParam` 是可选的。 请参阅本表末尾的“任何其他参数”。


| `@RequestHeader`
| 用于访问请求头。 头的值将转换为声明的方法参数类型。 请参阅<<mvc-ann-requestheader,@RequestHeader>>.

| `@CookieValue`
| 用于访问cookie。 Cookie值将转换为声明的方法参数类型。 请参阅<<mvc-ann-cookievalue,@CookieValue>>.

| `@RequestBody`
| 用于访问HTTP请求正文。 通过使用 `HttpMessageConverter` 实现将正文内容转换为声明的方法参数类型。 请参阅 <<mvc-ann-requestbody, @RequestBody>>。

| `HttpEntity<B>`
| 用于访问请求标头和正文。 使用HttpMessageConverter转换正文。 见<<mvc-ann-httpentity,HttpEntity>>.

| `@RequestPart`
| 要访问 `multipart/form-data` 请求中的部件，请使用 `HttpMessageConverter` 转换部件的主体。 见<<mvc-multipart-forms,Multipart>>。

| `java.util.Map`, `org.springframework.ui.Model`, `org.springframework.ui.ModelMap`
| 用于访问HTML控制器中使用的模型，并将其作为视图呈现的一部分暴露给模板。

| `RedirectAttributes`
| 指定在重定向（即，要附加到查询字符串）时使用的属性，以及临时存储的flash属性，直到重定向后的请求为止。 请参阅<<mvc-redirecting-passing-data,重定向属性>> 和<<mvc-flash-attributes,Flash属性>>。

| `@ModelAttribute`
| 用于访问模型中的现有属性（如果不存在则实例化），并应用数据绑定和验证。 请参阅<<mvc-ann-modelattrib-method-args,@ModelAttribute>>以及  <<mvc-ann-modelattrib-methods,Model>>和<<mvc-ann-initbinder,DataBinder>>。

    请注意，使用 `@ModelAttribute` 是可选的（例如，设置其属性）。 请参阅本表末尾的“任何其他参数”。

| `Errors`, `BindingResult`
| 用于访问来自命令对象的验证和数据绑定的错误（即 `@ModelAttribute` 参数）或来自验证 `@RequestBody` 或 `@RequestPart` 参数的错误。 您必须在经过验证的方法参数后立即声明 `Errors` 或 `BindingResult` 参数。

| `SessionStatus` + class-level `@SessionAttributes`
| 用于标记表单处理完成，从而触发通过类级别 `@SessionAttributes` 注解声明的会话属性的清除。 有关更多详细信息，请参阅  <<mvc-ann-sessionattributes,@SessionAttributes>>。

| `UriComponentsBuilder`
| 用于准备相对于当前请求的主机，端口，方案，上下文路径和servlet映射的文字部分的URL。 请参阅<<mvc-uri-building,URI Links>>.

| `@SessionAttribute`
| 用于访问任何会话属性，与由于类级别 `@SessionAttributes` 声明的结束形成对比。 有关更多详细信息，请参阅<<mvc-ann-sessionattribute, @SessionAttribute>>.

| `@RequestAttribute`
| 用于访问请求属性。 有关更多详细信息，请参阅<<mvc-ann-requestattrib,@RequestAttribute>>.

| Any other argument
| 如果方法参数与此表中的任何值不匹配，并且它是一个简单类型（由 {api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty] 确定， 则它被解析为 `@RequestParam`。否则，它将被解析为 `@ModelAttribute`。
|===


[[mvc-ann-return-types]]
==== 返回值
[.small]#<<web-reactive.adoc#webflux-ann-return-types, WebFlux>>#

下表描述了支持的控制器方法返回值。 所有返回值都支持响应式类型。

[cols="1,2", options="header"]
|===
| Controller method return value | Description

| `@ResponseBody`
|  返回值通过 `HttpMessageConverter` 实现转换并写入响应。 请参阅<<mvc-ann-responsebody,@ResponseBody>>.

| `HttpEntity<B>`, `ResponseEntity<B>`
| 指定完整响应（包括HTTP头和主体）的返回值将通过 `HttpMessageConverter` 实现转换并写入响应。 请参阅 <<mvc-ann-responseentity,ResponseEntity>>。

| `HttpHeaders`
| 用于返回带头部信息且没有正文的响应。

| `String`
| 要使用 `ViewResolver` 实现解析的视图名称，并与隐式模型一起使用 - 通过命令对象和 `@ModelAttribute` 方法确定。 处理程序方法还可以通过声明 `Model` 参数以编程方式丰富模型（请参阅<<mvc-ann-requestmapping-registration,显式注册>> ）。

| `View`
| 用于与隐式模型一起呈现的 `View` 实例 - 通过命令对象和 `@ModelAttribute` 方法确定。 处理程序方法还可以通过声明 `Model` 参数以编程方式丰富模型（请参阅<<mvc-ann-requestmapping-registration,显式注册>>）。

| `java.util.Map`, `org.springframework.ui.Model`
| 要添加到隐式模型的属性，通过 `RequestToViewNameTranslator` 隐式确定视图名称。

| `@ModelAttribute`
| 要添加到模型的属性，通过 `RequestToViewNameTranslator` 隐式确定视图名称。

  请注意，`@ModelAttribute` 是可选的。 请参阅本表末尾的“任何其他返回值”。

| `ModelAndView` object
| 要使用的视图和模型属性，以及（可选）响应状态。

| `void`
| 如果具有 `void` 返回类型（或返回值为 `null` ）的方法，如果它还具有 `ServletResponse`，`OutputStream` 参数或 `@ResponseStatus` 注解， 则认为已完全处理该响应。 如果控制器已进行正 `ETag` 或 `lastModified` 时间戳检查，则也是如此（有关详细信息，请参阅<<mvc-caching-etag-lastmodified,Controllers>> ）。
    如果以上都不是真的，则 `void` 返回类型也可以指示REST控制器的“无响应主体”或HTML控制器的默认视图名称选择。

| `DeferredResult<V>`
| 从任何线程异步生成任何前面的返回值 - 例如，由于某些事件或回调。 请参阅<<mvc-ann-async,异步请求>>和 <<mvc-ann-async-deferredresult,DeferredResult>>.

| `Callable<V>`
| 在Spring MVC管理的线程中异步生成上述任何返回值。 请参阅 和 <<mvc-ann-async-callable,Callable>>.

| `ListenableFuture<V>`,
  `java.util.concurrent.CompletionStage<V>`,
  `java.util.concurrent.CompletableFuture<V>`
| 作为替代 `DeferredResult` 的便捷操作（例如，当底层服务返回其中一个时）。

| `ResponseBodyEmitter`, `SseEmitter`
| 使用 `HttpMessageConverter` 实现以异步方式发送对象流以写入响应。 还支持 `ResponseEntity` 的主体。 请参阅<<mvc-ann-async,异步请求>>和<<mvc-ann-async-http-streaming, HTTP Streaming>>.

| `StreamingResponseBody`
| 异步写入响应 `OutputStream`。 还支持 `ResponseEntity` 的主体。 请参阅<<mvc-ann-async,异步请求>>和<<mvc-ann-async-http-streaming, HTTP Streaming>>.

| Reactive types -- Reactor, RxJava, or others through `ReactiveAdapterRegistry`
| 使用 `multi-value` 流（例如，`Flux`, `Observable`）替代 `DeferredResult` 收集到 `List` 中。

 对于流式场景(例如, `text/event-stream`, `application/json+stream`), `SseEmitter` 和 `ResponseBodyEmitter` 使用的是在Spring MVC 管理的线程上执行 `ServletOutputStream` 阻塞I/O，这是 针对每一个 `Write` 的

请参阅<<mvc-ann-async,异步请求>> 和 <<mvc-ann-async-reactive-types,Reactive Types>>.

| Any other return value
| 任何与此表中任何早期值不匹配且返回值为 `String` 或 `void` 的返回值都被视为视图名称（通过 `RequestToViewNameTranslator` 应用默认视图名称选择）， 前提是它不是简单类型，由 {api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty] 确定，简单类型的值仍未解决。
|===


[[mvc-ann-typeconversion]]
==== 类型转换
[.small]#<<web-reactive.adoc#webflux-ann-typeconversion, WebFlux>>#

如果参数声明为 `String` 以外的其他参数，则表示某些带注解的控制器方法参数（例如 `@RequestParam`, `@RequestHeader`, `@PathVariable`, `@MatrixVariable`, 和 `@CookieValue`）可能需要进行类型转换。

对于此类情况，将根据配置的转换器自动应用类型转换。 默认情况下，支持简单类型（`int`, `long`, `Date` 和其他）。 您可以通过 `WebDataBinder`（请参阅<<mvc-ann-initbinder,DataBinder>>）或使用 `FormattingConversionService` 注册 `Formatters` 来自定义类型转换。 请参见 <<core.adoc#format, Spring Field Formatting>>。


[[mvc-ann-matrix-variables]]
==== Matrix Variables
[.small]#<<web-reactive.adoc#webflux-ann-matrix-variables, WebFlux>>#

https://tools.ietf.org/html/rfc3986#section-3.3[RFC 3986] 讨论了路径段中的携带键值对。 在Spring MVC中，我们将那些基于Tim Berners-Lee的 https://www.w3.org/DesignIssues/MatrixURIs.html["`old post`"] 称为 "`matrix variables（矩阵变量）`" ，但它们也可以称为URI路径参数。

矩阵变量可以在任意路径段落中出现，每对矩阵变量之间使用分号隔开，多个值可以用逗号隔开（例如，`/cars;color=red,green;year=2012`）， 也可以通过重复的变量名称指定多个值（例如，`color=red;color=green;color=blue`）。

如果URL有可能会包含矩阵变量，那么在请求路径的映射配置上就需要使用URI模板来体现。这样才能确保请求可以被正确地映射，而不管矩阵变量在URI中是否出现、出现的次序是怎样的等。以下示例使用矩阵变量：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// GET /pets/42;q=11;r=22

	@GetMapping("/pets/{petId}")
	public void findPet(@PathVariable String petId, @MatrixVariable int q) {

		// petId == 42
		// q == 11
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// GET /pets/42;q=11;r=22

	@GetMapping("/pets/{petId}")
	fun findPet(@PathVariable petId: String, @MatrixVariable q: Int) {

		// petId == 42
		// q == 11
	}
----

由于任意路径段落中都可以含有矩阵变量，在某些场景下，开发者需要用更精确的信息来指定矩阵变量的位置。以下示例说明如何执行此操作：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// GET /owners/42;q=11/pets/21;q=22

	@GetMapping("/owners/{ownerId}/pets/{petId}")
	public void findPet(
			@MatrixVariable(name="q", pathVar="ownerId") int q1,
			@MatrixVariable(name="q", pathVar="petId") int q2) {

		// q1 == 11
		// q2 == 22
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// GET /owners/42;q=11/pets/21;q=22

	@GetMapping("/owners/{ownerId}/pets/{petId}")
	fun findPet(
			@MatrixVariable(name = "q", pathVar = "ownerId") q1: Int,
			@MatrixVariable(name = "q", pathVar = "petId") q2: Int) {

		// q1 == 11
		// q2 == 22
	}
----

矩阵变量可以定义为可选，并指定默认值，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// GET /pets/42

	@GetMapping("/pets/{petId}")
	public void findPet(@MatrixVariable(required=false, defaultValue="1") int q) {

		// q == 1
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// GET /pets/42

	@GetMapping("/pets/{petId}")
	fun findPet(@MatrixVariable(required = false, defaultValue = "1") q: Int) {

		// q == 1
	}
----

要获取所有矩阵变量，可以使用 `MultiValueMap`，如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// GET /owners/42;q=11;r=12/pets/21;q=22;s=23

	@GetMapping("/owners/{ownerId}/pets/{petId}")
	public void findPet(
			@MatrixVariable MultiValueMap<String, String> matrixVars,
			@MatrixVariable(pathVar="petId") MultiValueMap<String, String> petMatrixVars) {

		// matrixVars: ["q" : [11,22], "r" : 12, "s" : 23]
		// petMatrixVars: ["q" : 22, "s" : 23]
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// GET /owners/42;q=11;r=12/pets/21;q=22;s=23

	@GetMapping("/owners/{ownerId}/pets/{petId}")
	fun findPet(
			@MatrixVariable matrixVars: MultiValueMap<String, String>,
			@MatrixVariable(pathVar="petId") petMatrixVars: MultiValueMap<String, String>) {

		// matrixVars: ["q" : [11,22], "r" : 12, "s" : 23]
		// petMatrixVars: ["q" : 22, "s" : 23]
	}
----

请注意，您需要启用矩阵变量的使用。 在MVC Java配置中，您需要通过<<mvc-config-path-matching,PathMatchConfigurer>>将 `removeSemicolonContent`=false 设置为 `UrlPathHelper`。 在MVC XML命名空间中，您可以设置 `<mvc:annotation-driven enable-matrix-variables="true"/>`。


[[mvc-ann-requestparam]]
==== `@RequestParam`
[.small]#<<web-reactive.adoc#webflux-ann-requestparam, WebFlux>>#

您可以使用 `@RequestParam` 注解将Servlet请求参数（即查询参数或表单数据）绑定到控制器中的方法参数。

以下示例显示了如何执行此操作：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	@RequestMapping("/pets")
	public class EditPetForm {

		// ...

		@GetMapping
		public String setupForm(@RequestParam("petId") int petId, Model model) { <1>
			Pet pet = this.clinic.loadPet(petId);
			model.addAttribute("pet", pet);
			return "petForm";
		}

		// ...

	}
----
<1> 使用 `@RequestParam` 绑定 `petId`。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.ui.set

	@Controller
	@RequestMapping("/pets")
	class EditPetForm {

		// ...

		@GetMapping
		fun setupForm(@RequestParam("petId") petId: Int, model: Model): String { // <1>
			val pet = this.clinic.loadPet(petId);
			model["pet"] = pet
			return "petForm"
		}

		// ...

	}
----
<1> 使用 `@RequestParam` 绑定 `petId`。

若参数使用了该注解，则该参数默认是必须提供的.但您可以通过将 `@RequestParam` 注解的 `required` 属性设置为 `false` 或通过使用 `java.util.Optional` 包装器声明参数来指定方法参数是可选的。

如果目标方法参数类型不是 `String`，则会自动应用类型转换。 请参阅<<mvc-ann-typeconversion,类型转换>>。

将参数类型声明为数组或列表允许为同一参数名称解析多个参数值。

当 `@RequestParam` 注解声明为 `Map<String, String>` 或 `MultiValueMap<String, String>` 时， 如果注解中未指定参数名称，则会使用每个给定参数名称的请求参数值填充映射。

请注意，使用 `@RequestParam` 是可选的（例如，设置其属性）。 默认情况下， 任何属于简单值类型的参数（由 {api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty] 确定）并且未被任何其他参数解析器解析，都被视为使用 `@RequestParam` 进行注解。


[[mvc-ann-requestheader]]
==== `@RequestHeader`
[.small]#<<web-reactive.adoc#webflux-ann-requestheader, WebFlux>>#

您可以使用 `@RequestHeader` 注解将请求标头绑定到控制器中的方法参数。

考虑以下请求，请求头为:

[literal]
[subs="verbatim,quotes"]
----
Host                    localhost:8080
Accept                  text/html,application/xhtml+xml,application/xml;q=0.9
Accept-Language         fr,en-gb;q=0.7,en;q=0.3
Accept-Encoding         gzip,deflate
Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive              300
----

以下示例获取 `Accept-Encoding` 和 `Keep-Alive` 头的值：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/demo")
	public void handle(
			@RequestHeader("Accept-Encoding") String encoding, // <1>
			@RequestHeader("Keep-Alive") long keepAlive) { // <2>
		//...
	}
----
<1> 获取 `Accept-Encoding` 头部信息
<2> 获取 `Keep-Alive` 头部信息.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/demo")
	fun handle(
			@RequestHeader("Accept-Encoding") encoding: String, // <1>
			@RequestHeader("Keep-Alive") keepAlive: Long) { // <2>
		//...
	}
----
<1> 获取 `Accept-Encoding` 头部信息
<2> 获取 `Keep-Alive` 头部信息.

如果目标方法参数类型不是String，则会自动应用类型转换。 请参阅<<mvc-ann-typeconversion,类型转换>>。

在 `Map<String, String>，MultiValueMap<String, String>` 或 `HttpHeaders` 参数上使用 `@RequestHeader` 注解时，将使用所有请求头值填充映射。

TIP: 内置支持可用于将逗号分隔的字符串转换为字符串或字符串集或类型转换系统已知的其他类型。 例如，使用 `@RequestHeader("Accept")` 注解的方法参数可以是 `String` 类型，也可以是 `String[]` 或 `List<String>`。


[[mvc-ann-cookievalue]]
==== `@CookieValue`
[.small]#<<web-reactive.adoc#webflux-ann-cookievalue, WebFlux>>#

您可以使用 `@CookieValue` 注解将HTTP cookie 的值绑定到控制器中的方法参数。

考虑使用以下cookie的请求:

[literal,subs="verbatim,quotes"]
----
JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84
----

以下示例显示了如何获取cookie值：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/demo")
	public void handle(@CookieValue("JSESSIONID") String cookie) { <1>
		//...
	}
----
<1> 获取 `JSESSIONID` cookie的值


[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/demo")
	fun handle(@CookieValue("JSESSIONID") cookie: String) { // <1>
		//...
	}
----
<1> 获取 `JSESSIONID` cookie的值

如果目标方法参数类型不是String，则会自动应用类型转换。 请参阅<<mvc-ann-typeconversion,类型转换>>。

[[mvc-ann-modelattrib-method-args]]
==== `@ModelAttribute`
[.small]#<<web-reactive.adoc#webflux-ann-modelattrib-method-args, WebFlux>>#

您可以在方法参数上使用 `@ModelAttribute` 注解来从模型访问属性，或者如果不存在则将其实例化。 model属性还覆盖了名称与字段名称匹配的HTTP Servlet请求参数的值。 这称为数据绑定，它使您不必处理解析和转换单个查询参数和表单字段。 以下示例显示了如何执行此操作：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	public String processSubmit(@ModelAttribute Pet pet) { } <1>
----
<1> 绑定一个 `Pet` 的实例。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
fun processSubmit(@ModelAttribute pet: Pet): String { } // <1>
----
<1> 绑定一个 `Pet` 的实例。

上面的 `Pet` 实例解析如下：:

* 它可能来自已经添加的<<mvc-ann-modelattrib-methods,Model>>.
* 它可能因为<<mvc-ann-sessionattributes,@SessionAttributes>>注解的使用已经存在在model中.
* 它可能是由URI模板变量和转换中取得的（下面会详细讲解）.
* 它可能是调用了自身的默认构造器被实例化出来的.
* 他可能从调用具有与Servlet请求参数匹配的参数的 `"primary constructor"`。 参数名称通过JavaBeans `@ConstructorProperties` 或字节码中的运行时保留参数名称确定。

虽然通常使用<<mvc-ann-modelattrib-methods,Model>>来使用属性填充模型，但另一种替代方法是依赖于 `Converter<String, T>` 和URI路径变量。 在以下示例中，model 属性名称 `account` 匹配URI路径变量 `account`，并通过将String字符串传递到已注册的 `Converter<String, Account>` 转换器来加载 `Account` ：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PutMapping("/accounts/{account}")
	public String save(@ModelAttribute("account") Account account) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PutMapping("/accounts/{account}")
	fun save(@ModelAttribute("account") account: Account): String {
		// ...
	}
----

下一步就是数据的绑定，`WebDataBinder` 类能将请求参数，包括字符串的查询参数和表单字段等，通过名称匹配到model的属性上。
成功匹配的字段在需要的时候会进行一次类型转换（从String类型到目标字段的类型），然后被填充到model对应的属性中， 有关数据绑定（和验证）的更多信息，请参阅<<core.adoc#validation, Validation>>。 有关自定义数据绑定的更多信息，请参阅<<mvc-ann-initbinder,DataBinder>>。

数据绑定可能导致错误。 默认情况下，会引发 `BindException` 。 但是，要在控制器方法中检查此类错误，可以在 `@ModelAttribute` 旁边添加一个 `BindingResult` 参数，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	public String processSubmit(@ModelAttribute("pet") Pet pet, BindingResult result) { // <1>
		if (result.hasErrors()) {
			return "petForm";
		}
		// ...
	}
----
<1> 在 `@ModelAttribute` 旁边添加 `BindingResult`。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	fun processSubmit(@ModelAttribute("pet") pet: Pet, result: BindingResult): String { // <1>
		if (result.hasErrors()) {
			return "petForm"
		}
		// ...
	}
----
<1> 在 `@ModelAttribute` 旁边添加 `BindingResult`。

在某些情况下，您可能希望在没有数据绑定的情况下访问 `model` 属性。对于这种情况，您可以将model注入控制器并直接访问它，或者设置 `@ModelAttribute(binding=false)`，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ModelAttribute
	public AccountForm setUpForm() {
		return new AccountForm();
	}

	@ModelAttribute
	public Account findAccount(@PathVariable String accountId) {
		return accountRepository.findOne(accountId);
	}

	@PostMapping("update")
	public String update(@Valid AccountForm form, BindingResult result,
			@ModelAttribute(binding=false) Account account) { // <1>
		// ...
	}
----
<1> 设置 `@ModelAttribute(binding=false)`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ModelAttribute
	fun setUpForm(): AccountForm {
		return AccountForm()
	}

	@ModelAttribute
	fun findAccount(@PathVariable accountId: String): Account {
		return accountRepository.findOne(accountId)
	}

	@PostMapping("update")
	fun update(@Valid form: AccountForm, result: BindingResult,
			   @ModelAttribute(binding = false) account: Account): String { // <1>
		// ...
	}
----
<1> 设置 `@ModelAttribute(binding=false)`.

通过添加 `javax.validation.Valid` 注解或Spring的 `@Validated` 注解（<<core.adoc#validation-beanvalidation, Bean Validation>>和<<core.adoc#validation, Spring validation>>），您可以在数据绑定后自动应用验证。 以下示例显示了如何执行此操作：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
		@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
		public String processSubmit(@Valid @ModelAttribute("pet") Pet pet, BindingResult result) { // <1>
			if (result.hasErrors()) {
				return "petForm";
			}
			// ...
		}
----
<1> 验证 `Pet` 实例.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	fun processSubmit(@Valid @ModelAttribute("pet") pet: Pet, result: BindingResult): String { // <1>
		if (result.hasErrors()) {
			return "petForm"
		}
		// ...
	}
----

请注意，使用 `@ModelAttribute` 是可选的（例如，设置其属性）。 默认情况下，任何非简单值类型的参数（由{api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty]确定）并且未被任何其他参数解析器解析，都被视为使用 `@ModelAttribute` 进行注解。

[[mvc-ann-sessionattributes]]
==== `@SessionAttributes`
[.small]#<<web-reactive.adoc#webflux-ann-sessionattributes, WebFlux>>#

`@SessionAttributes` 用于在请求之间的HTTP Servlet会话中存储model属性。 它是一个类型级别的注解，用于声明特定控制器使用的会话属性。 这通常列出model属性的名称或model属性的类型，这些属性应该透明地存储在会话中以供后续访问请求使用。

以下示例使用 `@SessionAttributes` 注解:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	@SessionAttributes("pet") // <1>
	public class EditPetForm {
		// ...
	}
----
<1> 使用 `@SessionAttributes` 注解.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	@SessionAttributes("pet") // <1>
	public class EditPetForm {
		// ...
	}
----
<1> 使用 `@SessionAttributes` 注解.

在第一个请求中，当名称为 `pet` 的model属性添加到模型中时，他会自动保存到HTTP Servlet会话中，并保持不变，直到另一个控制器方法使用 `SessionStatus` 方法参数来清除存储，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	@SessionAttributes("pet") // <1>
	public class EditPetForm {

		// ...

		@PostMapping("/pets/{id}")
		public String handle(Pet pet, BindingResult errors, SessionStatus status) {
			if (errors.hasErrors) {
				// ...
			}
				status.setComplete(); // <2>
				// ...
			}
		}
	}
----
<1> 在Servlet会话中存储 `Pet` 值。
<2> 在Servlet会话中清除 `Pet` 值。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
@Controller
@SessionAttributes("pet") // <1>
class EditPetForm {

	// ...

	@PostMapping("/pets/{id}")
	fun handle(pet: Pet, errors: BindingResult, status: SessionStatus): String {
		if (errors.hasErrors()) {
			// ...
		}
		status.setComplete() // <2>
		// ...
	}
}
----
<1> 在Servlet会话中存储 `Pet` 值。
<2> 在Servlet会话中清除 `Pet` 值。


[[mvc-ann-sessionattribute]]
==== `@SessionAttribute`
[.small]#<<web-reactive.adoc#webflux-ann-sessionattribute, WebFlux>>#

如果需要访问已存在的被全局session属性，例如在控制器之外（如通过过滤器）的（可有可无），请在方法参数上使用 `@SessionAttribute` 注解：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RequestMapping("/")
	public String handle(@SessionAttribute User user) { <1>
		// ...
	}
----
<1> 使用 `@SessionAttribute` 注解.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RequestMapping("/")
	fun handle(@SessionAttribute user: User): String { // <1>
		// ...
	}
----

对于需要添加或删除会话属性的用例，请考虑将 `org.springframework.web.context.request.WebRequest` 或 `javax.servlet.http.HttpSession` 注入控制器方法。

作为控制器工作流的一部分，在会话中临时存储模型属性的方法可以使用 `@SessionAttributes`，详情请参阅<<mvc-ann-sessionattributes,@SessionAttributes>>。

[[mvc-ann-requestattrib]]
==== `@RequestAttribute`
[.small]#<<web-reactive.adoc#webflux-ann-requestattrib, WebFlux>>#

与 `@SessionAttribute` 类似，`@RequestAttribute` 注解可用于访问由过滤器（`Filter`）或拦截器（`HandlerInterceptor`）创建的已存在的请求属性:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/")
	public String handle(@RequestAttribute Client client) { // <1>
		// ...
	}
----
<1> 使用 `@RequestAttribute` 注解.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/")
	fun handle(@RequestAttribute client: Client): String { // <1>
		// ...
	}
----
<1> 使用 `@RequestAttribute` 注解.


[[mvc-redirecting-passing-data]]
==== 重定向属性

默认情况下，所有模型属性都被视为在重定向URL中公开为URI模板变量。 在其余属性中，原始类型或集合或基本类型数组的属性将自动附加为查询参数。

如果专门为重定向准备了模型实例，期望的结果则是将原始类型属性作为查询参数。 但是，在带注解的控制器中，为了渲染目的，模型可以包含其他属性（例如，下拉字段值）。
为了避免在URL中出现此类属性的可能性，`@RequestMapping` 方法可以声明 `RedirectAttributes` 类型的参数， 并使用它来指定可供 `RedirectView` 使用的确切属性。 如果方法重定向，则使用 `RedirectAttributes` 的内容。 否则，使用模型的内容。

`RequestMappingHandlerAdapter` 提供了一个名为 `ignoreDefaultModelOnRedirect` 的标志，您可以使用该标志指示如果控制器方法重定向，则永远不应使用默认模型的内容。
相反，控制器方法应声明 `RedirectAttributes` 类型的属性，如果不这样做，则不应将任何属性传递给 `RedirectView`。 MVC命名空间和MVC Java配置都将此标志设置为 `false`，以保持向后兼容性。 但是，对于新应用程序，我们建议将其设置为 `true`。

请注意，扩展重定向URL时，当前请求中的URI模板变量会自动可用，您需要通过 `Model` 或 `RedirectAttributes` 显式添加它们。 以下示例显示如何定义重定向：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/files/{path}")
	public String upload(...) {
		// ...
		return "redirect:files/{path}";
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/files/{path}")
	fun upload(...): String {
		// ...
		return "redirect:files/{path}"
	}
----

将数据传递到重定向目标的另一种方法是使用<<mvc-flash-attributes,flash属性>>。 与其他重定向属性不同，Flash属性保存在HTTP会话中（因此，不会出现在URL中）。 有关更多信息，请参阅 Flash 属性。


[[mvc-flash-attributes]]
==== Flash 属性

Flash属性（flash attributes）提供了一个请求为另一个请求存储有用属性的方法。这在重定向的时候最常使用，比如常见的POST/REDIRECT/GET模式。 Flash属性会在重定向前被暂时地保存起来（通常是保存在session中），重定向后会重新被下一个请求取用并立即从原保存地移除。

为支持flash属性，Spring MVC提供了两个抽象。 `FlashMap` 被用来存储flash属性，而用 `FlashMapManager` 来存储、取回、管理 `FlashMap` 的实例。

对flash属性的支持默认是启用 "`on`" 的，并不需要显式声明，不过没用到它时它绝不会主动地去创建HTTP会话（session）。对于每个请求，框架都会"`input`" 一个 `FlashMap`，里面存储了从上个请求（如果有）保存下来的属性；
同时，每个请求也会 "`output`" `FlashMap`，里面保存了要给下个请求使用的属性。 两个FlashMap实例在Spring MVC应用中的任何地点都可以通过 `RequestContextUtils` 工具类的静态方法取得。

控制器通常不需要直接接触FlashMap。一般是通过 `@RequestMapping` 方法去接受 `RedirectAttributes` 类型的参数，然后直接地往其中添加flash属性。
通过 `RedirectAttributes` 对象添加进去的flash属性会自动被填充到请求的 "`output`" `FlashMap` 对象中去。类似地，重定向后 "`input`" 的 `FlashMap` 属性也会自动被添加到服务重定向URL的控制器参数 `Model` 中去

.匹配请求所使用的flash属性
****
flash属性的概念在其他许多的Web框架中也存在，并且实践证明有时可能会导致并发上的问题。这是因为从定义上讲，flash属性保存的时间是到下个请求接收到之前。 问题在于，`"next"` 请求不一定刚好就是需要重定向到的那个请求，它有可能是其他的异步请求（比如polling请求或者资源请求等）。这会导致flash属性在到达真正的目标请求前就被移除了。

为了减少这个问题发生的可能性，重定向视图 `RedirectView` 会自动为一个 `FlashMap` 实例记录其目标重定向URL的路径和查询参数。然后，默认的 `FlashMapManager` 会在为请求查找其该 "input" 的 `FlashMap` 时，匹配这些信息。

这并不能完全解决重定向的并发问题，但极大程度地减少了这种可能性，因为它可以从重定向URL已有的信息中来做匹配。因此，一般只有在重定向的场景下，才推荐使用flash属性。
****


[[mvc-multipart-forms]]
==== Multipart
[.small]#<<web-reactive.adoc#webflux-multipart-forms, WebFlux>>#

<<mvc-multipart,启用>> `MultipartResolver` 后，将解析具有 `multipart/form-data` 的POST请求的内容，并将其作为常规请求参数进行访问。 以下示例访问一个常规表单字段和一个上载文件：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class FileUploadController {

		@PostMapping("/form")
		public String handleFormUpload(@RequestParam("name") String name,
				@RequestParam("file") MultipartFile file) {

			if (!file.isEmpty()) {
				byte[] bytes = file.getBytes();
				// store the bytes somewhere
				return "redirect:uploadSuccess";
			}
			return "redirect:uploadFailure";
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	class FileUploadController {

		@PostMapping("/form")
		fun handleFormUpload(@RequestParam("name") name: String,
							@RequestParam("file") file: MultipartFile): String {

			if (!file.isEmpty) {
				val bytes = file.bytes
				// store the bytes somewhere
				return "redirect:uploadSuccess"
			}
			return "redirect:uploadFailure"
		}
	}
----

将参数类型声明为 `List<MultipartFile>` 允许为同一参数名称解析多个文件。

当 `@RequestParam` 注解声明为 `Map<String, MultipartFile>` 或 `MultiValueMap<String, MultipartFile>` 时，如果注解中未指定参数名称，则会使用每个给定参数名称的多部分文件填充map。

NOTE: 使用Servlet 3.0多部分解析，您也可以将 `javax.servlet.http.Part` 而不是Spring的 `MultipartFile` 声明为方法参数或集合值类型。

您还可以将多部分内容用作绑定到<<mvc-ann-modelattrib-method-args, 命令对象>>的数据的一部分。 例如，前面示例中的表单字段和文件可以是表单对象上的字段，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	class MyForm {

		private String name;

		private MultipartFile file;

		// ...
	}

	@Controller
	public class FileUploadController {

		@PostMapping("/form")
		public String handleFormUpload(MyForm form, BindingResult errors) {
			if (!form.getFile().isEmpty()) {
				byte[] bytes = form.getFile().getBytes();
				// store the bytes somewhere
				return "redirect:uploadSuccess";
			}
			return "redirect:uploadFailure";
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MyForm(val name: String, val file: MultipartFile, ...)

	@Controller
	class FileUploadController {

		@PostMapping("/form")
		fun handleFormUpload(form: MyForm, errors: BindingResult): String {
			if (!form.file.isEmpty) {
				val bytes = form.file.bytes
				// store the bytes somewhere
				return "redirect:uploadSuccess"
			}
			return "redirect:uploadFailure"
		}
	}
----


还可以在RESTful服务方案中从非浏览器客户端提交多部分请求。 以下示例显示了带有JSON的文件：

[literal,subs="verbatim,quotes"]
----
POST /someUrl
Content-Type: multipart/mixed

--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name="meta-data"
Content-Type: application/json; charset=UTF-8
Content-Transfer-Encoding: 8bit

{
	"name": "value"
}
--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name="file-data"; filename="file.properties"
Content-Type: text/xml
Content-Transfer-Encoding: 8bit
... File Data ...
----

对于名称为 "meta-data" 的部分，可以通过控制器方法上的 `@RequestParam` `String` metadata参数来获得。
但对于那部分请求体中为JSON格式数据的请求， 可能更想通过接受一个对应的强类型对象，就像 `@RequestBody` 通过 <<integration.adoc#rest-message-conversion, HttpMessageConverter>> 将一般请求的请求体转换成一个对象一样。使用 `@RequestPart` 注解访问多部分：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/")
	public String handle(@RequestPart("meta-data") MetaData metadata,
			@RequestPart("file-data") MultipartFile file) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/")
	fun handle(@RequestPart("meta-data") metadata: MetaData,
			@RequestPart("file-data") file: MultipartFile): String {
		// ...
	}
----

您可以将 `@RequestPart` 与 `javax.validation.Valid` 结合使用，或使用Spring的 `@Validated` 注解，这两种注解都会导致应用标准Bean验证。
默认情况下，验证错误会导致 `MethodArgumentNotValidException`， 并将其转换为400（BAD_REQUEST）响应。 或者，您可以通过 `Errors` 或 `BindingResult` 参数在控制器内本地处理验证错误，如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/")
	public String handle(@Valid @RequestPart("meta-data") MetaData metadata,
			BindingResult result) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/")
	fun handle(@Valid @RequestPart("meta-data") metadata: MetaData,
			result: BindingResult): String {
		// ...
	}
----



[[mvc-ann-requestbody]]
==== `@RequestBody`
[.small]#<<web-reactive.adoc#webflux-ann-requestbody, WebFlux>>#

您可以使用 `@RequestBody` 注解通过 <<integration.adoc#rest-message-conversion, `HttpMessageConverter`>> 将请求主体读取并反序列化为 `Object`。 以下示例使用 `@RequestBody` 参数:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/accounts")
	public void handle(@RequestBody Account account) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/accounts")
	fun handle(@RequestBody account: Account) {
		// ...
	}
----

您可以使用<<mvc-config,MVC Config >>的<<mvc-config-message-converters,Message Converters>>选项来配置或自定义消息转换。

您可以将 `@RequestBody` 与 `javax.validation.Valid` 或Spring的 `@Validated` 注解结合使用，这两种注解都会导致应用标准Bean验证。
默认情况下，验证错误会导致 `MethodArgumentNotValidException`，并将其转换为400（BAD_REQUEST）响应。 或者，您可以通过 `Errors` 或 `BindingResult` 参数在控制器内本地处理验证错误，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/accounts")
	public void handle(@Valid @RequestBody Account account, BindingResult result) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/accounts")
	fun handle(@Valid @RequestBody account: Account, result: BindingResult) {
		// ...
	}
----


[[mvc-ann-httpentity]]
==== HttpEntity
[.small]#<<web-reactive.adoc#webflux-ann-httpentity, WebFlux>>#

`HttpEntity` 与使用 <<mvc-ann-requestbody, `@RequestBody`>> 或多或少有些类似，但它基于一个公开请求头和正文的容器对象。 以下清单显示了一个示例:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/accounts")
	public void handle(HttpEntity<Account> entity) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/accounts")
	fun handle(entity: HttpEntity<Account>) {
		// ...
	}
----



[[mvc-ann-responsebody]]
==== `@ResponseBody`
[.small]#<<web-reactive.adoc#webflux-ann-responsebody, WebFlux>>#

您可以在方法上使用 `@ResponseBody` 注解，以通过<<integration.adoc#rest-message-conversion, HttpMessageConverter>>将返回序列化到响应主体。 以下清单显示了一个示例:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/accounts/{id}")
	@ResponseBody
	public Account handle() {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/accounts/{id}")
	@ResponseBody
	fun handle(): Account {
		// ...
	}
----

类级别也支持 `@ResponseBody` ，在这种情况下，它由所有控制器方法继承。 例如 `@RestController` 的效果，它只不过是一个用 `@Controller` 和 `@ResponseBody` 标记的元注解。

您可以将 `@ResponseBody` 与reactive类型一起使用。 有关更多详细信息，请参阅<<mvc-ann-async,异步请求>>和<<mvc-ann-async-reactive-types,Reactive 类型>>。

您可以使用 <<mvc-config,MVC Config>>的 <<mvc-config-message-converters,Message Converters>> 选项来配置或自定义消息转换。

您可以将 `@ResponseBody` 方法与JSON序列化视图结合使用。 有关详细信息，请参阅<<mvc-ann-jackson,Jackson JSON>> 。


[[mvc-ann-responseentity]]
==== ResponseEntity
[.small]#<<web-reactive.adoc#webflux-ann-responseentity, WebFlux>>#

`ResponseEntity` 与<<mvc-ann-responsebody,@ResponseBody>>类似，但具有状态和响应头。 例如:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/something")
	public ResponseEntity<String> handle() {
		String body = ... ;
		String etag = ... ;
		return ResponseEntity.ok().eTag(etag).build(body);
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/something")
	fun handle(): ResponseEntity<String> {
		val body = ...
		val etag = ...
		return ResponseEntity.ok().eTag(etag).build(body)
	}
----

Spring MVC支持使用单值<<mvc-ann-async-reactive-types, reactive type>>异步生成 `ResponseEntity`，and/or 主体的单值和多值reactive类型。


[[mvc-ann-jackson]]
==== Jackson JSON

Spring为Jackson JSON库提供支持。

[[mvc-ann-jsonview]]
===== JSON 序列化视图
[.small]#<<web-reactive.adoc#webflux-ann-jsonview, WebFlux>>#

Spring MVC为https://www.baeldung.com/jackson-json-view-annotation[Jackson的序列化视图]提供内置支持，允许仅渲染Object中所有字段的子集。 为了与 `@ResponseBody` 控制器方法或者返回 `ResponseEntity` 的控制器方法一起使用，可以简单地将 `@JsonView` 注解放在参数上，指定需要使用的视图类或接口即可。如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RestController
	public class UserController {

		@GetMapping("/user")
		@JsonView(User.WithoutPasswordView.class)
		public User getUser() {
			return new User("eric", "7!jd#h23");
		}
	}

	public class User {

		public interface WithoutPasswordView {};
		public interface WithPasswordView extends WithoutPasswordView {};

		private String username;
		private String password;

		public User() {
		}

		public User(String username, String password) {
			this.username = username;
			this.password = password;
		}

		@JsonView(WithoutPasswordView.class)
		public String getUsername() {
			return this.username;
		}

		@JsonView(WithPasswordView.class)
		public String getPassword() {
			return this.password;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RestController
	class UserController {

		@GetMapping("/user")
		@JsonView(User.WithoutPasswordView::class)
		fun getUser() = User("eric", "7!jd#h23")
	}

	class User(
			@JsonView(WithoutPasswordView::class) val username: String,
			@JsonView(WithPasswordView::class) val password: String) {

		interface WithoutPasswordView
		interface WithPasswordView : WithoutPasswordView
	}
----

NOTE: `@JsonView` 允许一组视图类，但每个控制器方法只能指定一个。 如果需要激活多个视图，可以使用复合接口。

对于依赖视图的控制器，只需将序列化视图类添加到model中即可。如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class UserController extends AbstractController {

		@GetMapping("/user")
		public String getUser(Model model) {
			model.addAttribute("user", new User("eric", "7!jd#h23"));
			model.addAttribute(JsonView.class.getName(), User.WithoutPasswordView.class);
			return "userView";
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.ui.set

	@Controller
	class UserController : AbstractController() {

		@GetMapping("/user")
		fun getUser(model: Model): String {
			model["user"] = User("eric", "7!jd#h23")
			model[JsonView::class.qualifiedName] = User.WithoutPasswordView::class.java
			return "userView"
		}
	}
----



[[mvc-ann-modelattrib-methods]]
=== Model
[.small]#<<web-reactive.adoc#webflux-ann-modelattrib-methods, WebFlux>>#

您可以使用 `@ModelAttribute` 注解：

* 在 `@RequestMapping` 方法中的<<mvc-ann-modelattrib-method-args,方法参数>>，用于从 `model` 创建或访问Object并通过 `WebDataBinder` 将其绑定到请求。
* 作为 `@Controller` 或 `@ControllerAdvice` 类中的方法级注解，有助于在任何 `@RequestMapping` 方法调用之前初始化模型。
* 在 `@RequestMapping` 方法上标记其返回值是一个模型属性。

本节讨论 `@ModelAttribute` 注解可被应用在方法或方法参数上 - 前面列表中的第二项。控制器可以包含任意数量的 `@ModelAttribute` 方法。
在同一控制器中的 `@RequestMapping` 方法之前调用所有这些方法。 `@ModelAttribute` 方法也可以通过 `@ControllerAdvice` 在控制器之间共享。 有关更多详细信息，请参阅<<mvc-ann-controller-advice,Controller Advice>>  部分。

`@ModelAttribute` 方法具有灵活的方法签名。 除了与 `@ModelAttribute` 本身或请求体相关的任何内容外，它们支持许多与 `@RequestMapping` 方法相同的参数。

以下示例显示了 `@ModelAttribute` 方法：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ModelAttribute
	public void populateModel(@RequestParam String number, Model model) {
		model.addAttribute(accountRepository.findAccount(number));
		// add more ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ModelAttribute
	fun populateModel(@RequestParam number: String, model: Model) {
		model.addAttribute(accountRepository.findAccount(number))
		// add more ...
	}
----

以下示例仅添加一个属性:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ModelAttribute
	public Account addAccount(@RequestParam String number) {
		return accountRepository.findAccount(number);
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ModelAttribute
	fun addAccount(@RequestParam number: String): Account {
		return accountRepository.findAccount(number)
	}
----


NOTE: 如果未明确指定名称，框架将根据属性的类型给予一个默认名称，如 {api-spring-framework}/core/Conventions.html[`Conventions`] 的javadoc中所述。 你可以通过设置 `@ModelAttribute` 注解的值来改变默认值。当向 `Model` 中直接添加属性时，请使用合适的重载方法 `addAttribute`。

`@ModelAttribute` 注解也可以被用在 `@RequestMapping` 方法上，这种情况下，`@RequestMapping` 方法的返回值将会被解释为model的一个属性，而非一个视图名。 此时视图名将以视图命名约定来方式来决议，与返回值为void的方法所采用的处理方法类似。`@ModelAttribute` 还可以自定义模型属性名称，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/accounts/{id}")
	@ModelAttribute("myAccount")
	public Account handle() {
		// ...
		return account;
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/accounts/{id}")
	@ModelAttribute("myAccount")
	fun handle(): Account {
		// ...
		return account
	}
----



[[mvc-ann-initbinder]]
=== `DataBinder`
[.small]#<<web-reactive.adoc#webflux-ann-initbinder, WebFlux>>#

`@Controller` 或 `@ControllerAdvice` 类可以使用 `@InitBinder` 方法初始化 `WebDataBinder` 的实例，而这些方法又可以：


* 将请求参数（即表单或查询数据）绑定到模型对象。
* 将基于字符串的请求值（例如请求参数，路径变量，请求头，cookie等）转换为目标类型的控制器方法参数。
* 在呈现HTML表单时将模型对象值格式化为 `String` 值。

`@InitBinder` 方法可以注册特定于控制器的 `java.bean.PropertyEditor` 或Spring `Converter` 和 `Formatter` 组件。 此外，您可以使用<<mvc-config-conversion,MVC config>> 在全局共享的 `FormattingConversionService` 中注册 `Converter` 和 `Formatter` 类型。

`@InitBinder` 方法支持许多与 `@RequestMapping` 方法相同的参数，但 `@ModelAttribute`（命令对象）参数除外。 通常，它们使用 `WebDataBinder` 参数（用于注册）和 `void` 返回值进行声明。 以下清单显示了一个示例:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class FormController {

		@InitBinder // <1>
		public void initBinder(WebDataBinder binder) {
			SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
			dateFormat.setLenient(false);
			binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));
		}

		// ...
	}
----
<1> 定义一个 `@InitBinder` 方法.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	class FormController {

		@InitBinder // <1>
		fun initBinder(binder: WebDataBinder) {
			val dateFormat = SimpleDateFormat("yyyy-MM-dd")
			dateFormat.isLenient = false
			binder.registerCustomEditor(Date::class.java, CustomDateEditor(dateFormat, false))
		}

		// ...
	}
----
<1> 定义一个 `@InitBinder` 方法.

或者，当使用基于 `Formatter` 的设置时，您可以通过共享的 `FormattingConversionService` 重复使用相同的方法并注册特定于控制器的 `Formatter` 实现，如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class FormController {

		@InitBinder // <1>
		protected void initBinder(WebDataBinder binder) {
			binder.addCustomFormatter(new DateFormatter("yyyy-MM-dd"));
		}

		// ...
	}
----
<1> 使用自定义 formatter 定义一个 Defining an `@InitBinder` 方法.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	class FormController {

		@InitBinder // <1>
		protected fun initBinder(binder: WebDataBinder) {
			binder.addCustomFormatter(DateFormatter("yyyy-MM-dd"))
		}

		// ...
	}
----
<1> 使用自定义 formatter 定义一个 Defining an `@InitBinder` 方法.

[[mvc-ann-exceptionhandler]]
=== 异常
[.small]#<<web-reactive.adoc#webflux-ann-controller-exceptions, WebFlux>>#

`@Controller` 和 <<mvc-ann-controller-advice, @ControllerAdvice>> 可以使用 `@ExceptionHandler` 方法来处理来自控制器方法的异常，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class SimpleController {

		// ...

		@ExceptionHandler
		public ResponseEntity<String> handle(IOException ex) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	class SimpleController {

		// ...

		@ExceptionHandler
		fun handle(ex: IOException): ResponseEntity<String> {
			// ...
		}
	}
----

该异常可能与顶级异常（即抛出直接 `IOException`）或顶级包装器中的异常（例如，包含在 `IllegalStateException` 内的 `IOException`）相匹配。

对于匹配的异常类型，最好将目标异常声明为方法参数，如前面的示例所示。当多个异常方法匹配时，根(root)异常匹配通常优先于原因(cause )异常匹配。 更具体地说，`ExceptionDepthComparator` 用于根据抛出的异常类型的深度对异常进行排序。

注解声明可以缩小要匹配的异常类型，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ExceptionHandler({FileSystemException.class, RemoteException.class})
	public ResponseEntity<String> handle(IOException ex) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ExceptionHandler(FileSystemException::class, RemoteException::class)
	fun handle(ex: IOException): ResponseEntity<String> {
		// ...
	}
----

您甚至可以使用特定异常类型列表中的非常通用的参数签名，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ExceptionHandler({FileSystemException.class, RemoteException.class})
	public ResponseEntity<String> handle(Exception ex) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ExceptionHandler(FileSystemException::class, RemoteException::class)
	fun handle(ex: Exception): ResponseEntity<String> {
		// ...
	}
----

[NOTE]
====
root 和 cause 异常匹配之间的区别可能是令人惊讶的。

在前面显示的 `IOException` 变体中，通常使用实际的 `FileSystemException` 或 `RemoteException` 实例作为参数调用该方法，因为它们都是从 `IOException` 扩展的。 但是，如果任何此类异常在包装器内传播，而该异常本身就是 `IOException`，则传入的异常实例就是包装器异常。

在 `handle(Exception)` 变体中，行为更简单。 这总是在包装场景中使用包装器异常调用，在这种情况下可以通过 `ex.getCause()` 找到实际匹配的异常。 传入的异常仅在实际的 `FileSystemException` 或 `RemoteException` 实例被抛出为顶级异常时才会发生。
====

我们通常建议您在参数签名中尽可能具体，减少root和cause异常类型之间不匹配的可能性。 考虑将多匹配方法分解为单独的 `@ExceptionHandler` 方法，每个方法通过其签名匹配单个特定异常类型。

在具有多个 `@ControllerAdvice` 组成中，我们建议在 `@ControllerAdvice` 上声明根异常映射，并使用相应的顺序进行优先级排序。
虽然根异常匹配优先于某个原因，但这是在给定控制器或 `@ControllerAdvice` 类的方法中定义的。 这意味着优先级较高的 `@ControllerAdvice` bean上的原因匹配优先于较低优先级的 `@ControllerAdvice` bean上的任何匹配（例如，root）。

最后但同样重要的是， 可以通过 `@ExceptionHandler` 方法的实现，讲异常以原始的形式重新抛出，并提供给特定的异常实例。 这在您仅对根级别匹配或在特定上下文中无法静态确定的匹配中感兴趣的情况下非常有用。 重新抛出的异常通过后续的解析链传播，就好像给定的 `@ExceptionHandler` 方法首先不匹配一样。

Spring MVC中对 `@ExceptionHandler` 方法的支持是基于 `DispatcherServlet` 级别的<<mvc-exceptionhandlers, HandlerExceptionResolver>>机制构建的。


[[mvc-ann-exceptionhandler-args]]
==== 方法参数

`@ExceptionHandler`方法支持以下参数：

[cols="1,2", options="header"]
|===
| 方法参数 | 描述

| Exception type
| 用于访问引发的异常。

| `HandlerMethod`
| 访问控制器方法引发的异常

| `WebRequest`, `NativeWebRequest`
| 无需直接使用Servlet API即可访问请求参数以及请求和会话属性。

| `javax.servlet.ServletRequest`, `javax.servlet.ServletResponse`
| 选择任何特定的请求或响应类型（例如，`ServletRequest` 或 `HttpServletRequest` 或 Spring的 `MultipartRequest` or `MultipartHttpServletRequest`).

| `javax.servlet.http.HttpSession`
| 强制进行会话。 因此，这样的结果永远不会是 `null` 的。请注意，会话访问不是线程安全的。 如果允许多个请求同时访问会话，请考虑将 `RequestMappingHandlerAdapter` 实例的 `synchronizeOnSession` 标志设置为 `true`。

| `java.security.Principal`
| 当前经过身份验证的用户 - 如果已知，可能是特定的 `Principal` 实现类。

| `HttpMethod`
| 请求的HTTP方法。

| `java.util.Locale`
| 当前请求区域设置，由最可用的 `LocaleResolver`（实际上是已配置的 `LocaleResolver` 或 `LocaleContextResolver`）确定。

| `java.util.TimeZone`, `java.time.ZoneId`
| 与当前请求关联的时区，由 `LocaleContextResolver` 确定。

| `java.io.OutputStream`, `java.io.Writer`
| 用于访问Servlet API公开的原始响应主体。

| `java.util.Map`, `org.springframework.ui.Model`, `org.springframework.ui.ModelMap`
| 用于访问模型以获取错误响应。 总是为空.

| `RedirectAttributes`
| 指定在重定向的情况下使用的属性 - （将附加到查询字符串）和临时存储的flash属性，直到重定向后的请求为止。 请参阅  <<mvc-redirecting-passing-data,Redirect 属性>>和 <<mvc-flash-attributes, Flash 属性>>。

| `@SessionAttribute`
| 用于访问任何会话属性，与由于类级别 `@SessionAttributes` 声明的结束形成对比。 有关更多详细信息，请参阅<<mvc-ann-sessionattribute,@SessionAttribute>>。

| `@RequestAttribute`
| 用于访问请求属性。 有关更多详细信息，请参阅<<mvc-ann-requestattrib,@RequestAttribute>>。

|===


[[mvc-ann-exceptionhandler-return-values]]
==== 返回值

`@ExceptionHandler` 方法支持以下返回值:

[cols="1,2", options="header"]
|===
| Return value | Description

| `@ResponseBody`
| 返回值通过 `HttpMessageConverter` 实现转换并写入响应。 请参阅<<mvc-ann-responsebody,@ResponseBody>>

| `HttpEntity<B>`, `ResponseEntity<B>`
| 指定完整响应（包括HTTP头和主体）的返回值将通过 `HttpMessageConverter` 实现转换并写入响应。 请参阅<<mvc-ann-responseentity,ResponseEntity>>。

| `String`
| 要使用 `ViewResolver实现解析的视图名称`，并与隐式模型一起使用 - 通过命令对象和 @ModelAttribute方法确定。 处理程序方法还可以通过声明 `Model` 参数以编程方式丰富模型（请参阅 <<mvc-ann-requestmapping-registration,显式注册>>）。

| `View`
| 用于与隐式模型一起呈现的View实例 - 通过命令对象和 `@ModelAttribute` 方法确定。 处理程序方法还可以通过声明 `Model` 参数以编程方式丰富模型（请参阅 <<mvc-ann-requestmapping-registration,显式注册>>）。

| `java.util.Map`, `org.springframework.ui.Model`
| 要添加到隐式模型的属性，通过 `RequestToViewNameTranslator` 隐式确定视图名称。

| `@ModelAttribute`
| 要添加到模型的属性，通过隐式确定视图名称。

 请注意，@ModelAttribute是可选的。 请参阅本表末尾的“任何其他返回值”。

| `ModelAndView` object
| 要使用的视图和模型属性，以及（可选）响应状态。

| `void`
| 如果具有 `void` 返回类型（或返回值为 `null` ）的方法，如果它还具有 `ServletResponse`，`OutputStream` 参数或 `@ResponseStatus` 注解， 则认为已完全处理该响应。 如果控制器已进行正 `ETag` 或 `lastModified` 时间戳检查，则也是如此（有关详细信息，请参阅<<mvc-caching-etag-lastmodified,Controllers>>）。

  如果以上都不是真的，则void返回类型也可以指示REST控制器的“无响应主体”或HTML控制器的默认视图名称选择。

| Any other return value
| 任何与此表中任何早期值不匹配且返回值为 `String` 或 `void` 的返回值都被视为视图名称（通过 `RequestToViewNameTranslator` 应用默认视图名称选择）， 前提是它不是简单类型，由 {api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty] 确定，简单类型的值仍未解决。
|===


[[mvc-ann-rest-exceptions]]
==== REST API 异常
[.small]#<<web-reactive.adoc#webflux-ann-rest-exceptions, WebFlux>>#

REST服务的一个常见要求是在响应正文中包含错误详细信息。 Spring Framework不会自动执行此操作，因为响应正文中的错误详细信息的表示是特定于应用程序的。 但是，`@RestController` 可以使用带有 `ResponseEntity` 返回值的 `@ExceptionHandler` 方法来设置响应的状态和正文。 这些方法也可以在 `@ControllerAdvice` 类中声明，以全局应用它们。

在响应主体中实现具有错误详细信息的全局异常处理的应用程序应考虑扩展{api-spring-framework}/web/servlet/mvc/method/annotation/ResponseEntityExceptionHandler.html[`ResponseEntityExceptionHandler`]， 它提供对Spring MVC引发的异常的处理，并提供钩子来定制响应主体。要使用它，请创建 `ResponseEntityExceptionHandler` 的子类，使用 `@ControllerAdvice` 注解它，覆盖必要的方法，并将其声明为Spring bean。

[[mvc-ann-controller-advice]]
=== Controller Advice
[.small]#<<web-reactive.adoc#webflux-ann-controller-advice, WebFlux>>#

通常，在 `@Controller` 类上声明 `@ExceptionHandler`, `@InitBinder`, 和 `@ModelAttribute` 注解。 如果您希望此类方法更全局地应用（跨控制器），则可以在标有 `@ControllerAdvice` 或 `@RestControllerAdvice` 的类中声明它们。

`@ControllerAdvice` `@Component` 注解，这意味着可以通过组件扫描将这些类注册为Spring bean。 `@RestControllerAdvice` 也是一个用 `@ControllerAdvice` 和 `@ResponseBody` 标记的元注解，这实际上意味着 `@ExceptionHandler` 方法通过消息转换（与视图分辨率或模板渲染相对）呈现给响应主体。

在启动时， `@RequestMapping` 和 `@ExceptionHandler` 方法的基础结构类检测 `@ControllerAdvice` 类型的Spring bean，然后在运行时应用它们的方法。
全局 `@ExceptionHandler` 方法（来自 `@ControllerAdvice`）在本地方法之后（来自 `@Controller`）应用。 相比之下，全局 `@ModelAttribute` 和 `@InitBinder` 方法在本地方法之前应用。

默认情况下，`@ControllerAdvice` 方法适用于每个请求（即所有控制器），但您可以通过使用注解上的属性将其缩小到控制器的子集，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// Target all Controllers annotated with @RestController
	@ControllerAdvice(annotations = RestController.class)
	public class ExampleAdvice1 {}

	// Target all Controllers within specific packages
	@ControllerAdvice("org.example.controllers")
	public class ExampleAdvice2 {}

	// Target all Controllers assignable to specific classes
	@ControllerAdvice(assignableTypes = {ControllerInterface.class, AbstractController.class})
	public class ExampleAdvice3 {}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// Target all Controllers annotated with @RestController
	@ControllerAdvice(annotations = [RestController::class])
	class ExampleAdvice1

	// Target all Controllers within specific packages
	@ControllerAdvice("org.example.controllers")
	class ExampleAdvice2

	// Target all Controllers assignable to specific classes
	@ControllerAdvice(assignableTypes = [ControllerInterface::class, AbstractController::class])
	class ExampleAdvice3
----

前面示例中的选择器在运行时进行评估，如果广泛使用，可能会对性能产生负面影响。 有关更多详细信息，请参阅{api-spring-framework}/web/bind/annotation/ControllerAdvice.html[`@ControllerAdvice`] javadoc 。

include::webmvc-functional.adoc[leveloffset=+1]

[[mvc-uri-building]]
== URI Links
[.small]#<<web-reactive.adoc#webflux-uri-building, WebFlux>>#

This section describes various options available in the Spring Framework to work with URI's.

include::web-uris.adoc[leveloffset=+2]



[[mvc-servleturicomponentsbuilder]]
=== Relative Servlet Requests

You can use `ServletUriComponentsBuilder` to create URIs relative to the current request,
as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	HttpServletRequest request = ...

	// Re-uses host, scheme, port, path and query string...

	ServletUriComponentsBuilder ucb = ServletUriComponentsBuilder.fromRequest(request)
			.replaceQueryParam("accountId", "{id}").build()
			.expand("123")
			.encode();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val request: HttpServletRequest = ...

	// Re-uses host, scheme, port, path and query string...

	val ucb = ServletUriComponentsBuilder.fromRequest(request)
			.replaceQueryParam("accountId", "{id}").build()
			.expand("123")
			.encode()
----

You can create URIs relative to the context path, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// Re-uses host, port and context path...

	ServletUriComponentsBuilder ucb = ServletUriComponentsBuilder.fromContextPath(request)
			.path("/accounts").build()
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// Re-uses host, port and context path...

	val ucb = ServletUriComponentsBuilder.fromContextPath(request)
			.path("/accounts").build()
----

You can create URIs relative to a Servlet (for example, `/main/{asterisk}`),
as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// Re-uses host, port, context path, and Servlet prefix...

	ServletUriComponentsBuilder ucb = ServletUriComponentsBuilder.fromServletMapping(request)
			.path("/accounts").build()
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// Re-uses host, port, context path, and Servlet prefix...

	val ucb = ServletUriComponentsBuilder.fromServletMapping(request)
			.path("/accounts").build()
----

NOTE: As of 5.1, `ServletUriComponentsBuilder` ignores information from the `Forwarded` and
`X-Forwarded-*` headers, which specify the client-originated address. Consider using the
<<filters-forwarded-headers, `ForwardedHeaderFilter`>> to extract and use or to discard
such headers.



[[mvc-links-to-controllers]]
=== Links to Controllers

Spring MVC provides a mechanism to prepare links to controller methods. For example,
the following MVC controller allows for link creation:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	@RequestMapping("/hotels/{hotel}")
	public class BookingController {

		@GetMapping("/bookings/{booking}")
		public ModelAndView getBooking(@PathVariable Long booking) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	@RequestMapping("/hotels/{hotel}")
	class BookingController {

		@GetMapping("/bookings/{booking}")
		fun getBooking(@PathVariable booking: Long): ModelAndView {
			// ...
		}
	}
----

You can prepare a link by referring to the method by name, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	UriComponents uriComponents = MvcUriComponentsBuilder
		.fromMethodName(BookingController.class, "getBooking", 21).buildAndExpand(42);

	URI uri = uriComponents.encode().toUri();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val uriComponents = MvcUriComponentsBuilder
		.fromMethodName(BookingController::class.java, "getBooking", 21).buildAndExpand(42)

	val uri = uriComponents.encode().toUri()
----

In the preceding example, we provide actual method argument values (in this case, the long value: `21`)
to be used as a path variable and inserted into the URL. Furthermore, we provide the
value, `42`, to fill in any remaining URI variables, such as the `hotel` variable inherited
from the type-level request mapping. If the method had more arguments, we could supply null for
arguments not needed for the URL. In general, only `@PathVariable` and `@RequestParam` arguments
are relevant for constructing the URL.

There are additional ways to use `MvcUriComponentsBuilder`. For example, you can use a technique
akin to mock testing through proxies to avoid referring to the controller method by name, as the following example shows
(the example assumes static import of `MvcUriComponentsBuilder.on`):

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	UriComponents uriComponents = MvcUriComponentsBuilder
		.fromMethodCall(on(BookingController.class).getBooking(21)).buildAndExpand(42);

	URI uri = uriComponents.encode().toUri();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val uriComponents = MvcUriComponentsBuilder
		.fromMethodCall(on(BookingController::class.java).getBooking(21)).buildAndExpand(42)

	val uri = uriComponents.encode().toUri()
----

NOTE: Controller method signatures are limited in their design when they are supposed to be usable for
link creation with `fromMethodCall`. Aside from needing a proper parameter signature,
there is a technical limitation on the return type (namely, generating a runtime proxy
for link builder invocations), so the return type must not be `final`. In particular,
the common `String` return type for view names does not work here. You should use `ModelAndView`
or even plain `Object` (with a `String` return value) instead.

The earlier examples use static methods in `MvcUriComponentsBuilder`. Internally, they rely
on `ServletUriComponentsBuilder` to prepare a base URL from the scheme, host, port,
context path, and servlet path of the current request. This works well in most cases.
However, sometimes, it can be insufficient. For example, you may be outside the context of
a request (such as a batch process that prepares links) or perhaps you need to insert a path
prefix (such as a locale prefix that was removed from the request path and needs to be
re-inserted into links).

For such cases, you can use the static `fromXxx` overloaded methods that accept a
`UriComponentsBuilder` to use a base URL. Alternatively, you can create an instance of `MvcUriComponentsBuilder`
with a base URL and then use the instance-based `withXxx` methods. For example, the
following listing uses `withMethodCall`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	UriComponentsBuilder base = ServletUriComponentsBuilder.fromCurrentContextPath().path("/en");
	MvcUriComponentsBuilder builder = MvcUriComponentsBuilder.relativeTo(base);
	builder.withMethodCall(on(BookingController.class).getBooking(21)).buildAndExpand(42);

	URI uri = uriComponents.encode().toUri();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val base = ServletUriComponentsBuilder.fromCurrentContextPath().path("/en")
	val builder = MvcUriComponentsBuilder.relativeTo(base)
	builder.withMethodCall(on(BookingController::class.java).getBooking(21)).buildAndExpand(42)

	val uri = uriComponents.encode().toUri()
----

NOTE: As of 5.1, `MvcUriComponentsBuilder` ignores information from the `Forwarded` and
`X-Forwarded-*` headers, which specify the client-originated address. Consider using the
<<filters-forwarded-headers, ForwardedHeaderFilter>> to extract and use or to discard
such headers.



[[mvc-links-to-controllers-from-views]]
=== Links in Views

In views such as Thymeleaf, FreeMarker, or JSP, you can build links to annotated controllers
by referring to the implicitly or explicitly assigned name for each request mapping.

Consider the following example:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RequestMapping("/people/{id}/addresses")
	public class PersonAddressController {

		@RequestMapping("/{country}")
		public HttpEntity<PersonAddress> getAddress(@PathVariable String country) { ... }
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RequestMapping("/people/{id}/addresses")
	class PersonAddressController {

		@RequestMapping("/{country}")
		fun getAddress(@PathVariable country: String): HttpEntity<PersonAddress> { ... }
	}
----

Given the preceding controller, you can prepare a link from a JSP, as follows:

[source,jsp,indent=0,subs="verbatim,quotes"]
----
<%@ taglib uri="http://www.springframework.org/tags" prefix="s" %>
...
<a href="${s:mvcUrl('PAC#getAddress').arg(0,'US').buildAndExpand('123')}">Get Address</a>
----

The preceding example relies on the `mvcUrl` function declared in the Spring tag library
(that is, META-INF/spring.tld), but it is easy to define your own function or prepare a
similar one for other templating technologies.

Here is how this works. On startup, every `@RequestMapping` is assigned a default name
through `HandlerMethodMappingNamingStrategy`, whose default implementation uses the
capital letters of the class and the method name (for example, the `getThing` method in
`ThingController` becomes "TC#getThing"). If there is a name clash, you can use
`@RequestMapping(name="..")` to assign an explicit name or implement your own
`HandlerMethodMappingNamingStrategy`.




[[mvc-ann-async]]
== Asynchronous Requests
[.small]#<<mvc-ann-async-vs-webflux, Compared to WebFlux>>#

Spring MVC has an extensive integration with Servlet 3.0 asynchronous request
<<mvc-ann-async-processing,processing>>:

* <<mvc-ann-async-deferredresult, `DeferredResult`>> and <<mvc-ann-async-callable, `Callable`>>
return values in controller methods and provide basic support for a single asynchronous
return value.
* Controllers can <<mvc-ann-async-http-streaming,stream>> multiple values, including
<<mvc-ann-async-sse, SSE>> and <<mvc-ann-async-output-stream, raw data>>.
* Controllers can use reactive clients and return
<<mvc-ann-async-reactive-types, reactive types>> for response handling.



[[mvc-ann-async-deferredresult]]
=== `DeferredResult`
[.small]#<<mvc-ann-async-vs-webflux, Compared to WebFlux>>#

Once the asynchronous request processing feature is <<mvc-ann-async-configuration, enabled>>
in the Servlet container, controller methods can wrap any supported controller method
return value with `DeferredResult`, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/quotes")
	@ResponseBody
	public DeferredResult<String> quotes() {
		DeferredResult<String> deferredResult = new DeferredResult<String>();
		// Save the deferredResult somewhere..
		return deferredResult;
	}

	// From some other thread...
	deferredResult.setResult(result);
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/quotes")
	@ResponseBody
	fun quotes(): DeferredResult<String> {
		val deferredResult = DeferredResult<String>()
		// Save the deferredResult somewhere..
		return deferredResult
	}

	// From some other thread...
	deferredResult.setResult(result)
----

The controller can produce the return value asynchronously, from a different thread -- for
example, in response to an external event (JMS message), a scheduled task, or other event.



[[mvc-ann-async-callable]]
=== `Callable`
[.small]#<<mvc-ann-async-vs-webflux, Compared to WebFlux>>#

A controller can wrap any supported return value with `java.util.concurrent.Callable`,
as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping
	public Callable<String> processUpload(final MultipartFile file) {

		return new Callable<String>() {
			public String call() throws Exception {
				// ...
				return "someView";
			}
		};
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping
	fun processUpload(file: MultipartFile) = Callable<String> {
		// ...
		"someView"
	}
----

The return value can then be obtained by running the given task through the
<<mvc-ann-async-configuration-spring-mvc, configured>> `TaskExecutor`.



[[mvc-ann-async-processing]]
=== Processing
[.small]#<<mvc-ann-async-vs-webflux, Compared to WebFlux>>#

Here is a very concise overview of Servlet asynchronous request processing:

* A `ServletRequest` can be put in asynchronous mode by calling `request.startAsync()`.
  The main effect of doing so is that the Servlet (as well as any filters) can exit, but
  the response remains open to let processing complete later.
* The call to `request.startAsync()` returns `AsyncContext`, which you can use for
  further control over asynchronous processing. For example, it provides the `dispatch` method,
  which is similar to a forward from the Servlet API, except that it lets an
  application resume request processing on a Servlet container thread.
* The `ServletRequest` provides access to the current `DispatcherType`, which you can
  use to distinguish between processing the initial request, an asynchronous
  dispatch, a forward, and other dispatcher types.

`DeferredResult` processing works as follows:

* The controller returns a `DeferredResult` and saves it in some in-memory
  queue or list where it can be accessed.
* Spring MVC calls `request.startAsync()`.
* Meanwhile, the `DispatcherServlet` and all configured filters exit the request
  processing thread, but the response remains open.
* The application sets the `DeferredResult` from some thread, and Spring MVC
  dispatches the request back to the Servlet container.
* The `DispatcherServlet` is invoked again, and processing resumes with the
  asynchronously produced return value.

`Callable` processing works as follows:

* The controller returns a `Callable`.
* Spring MVC calls `request.startAsync()` and submits the `Callable` to
  a `TaskExecutor` for processing in a separate thread.
* Meanwhile, the `DispatcherServlet` and all filters exit the Servlet container thread,
  but the response remains open.
* Eventually the `Callable` produces a result, and Spring MVC dispatches the request back
  to the Servlet container to complete processing.
* The `DispatcherServlet` is invoked again, and processing resumes with the
  asynchronously produced return value from the `Callable`.

For further background and context, you can also read
https://spring.io/blog/2012/05/07/spring-mvc-3-2-preview-introducing-servlet-3-async-support[the
blog posts] that introduced asynchronous request processing support in Spring MVC 3.2.


[[mvc-ann-async-exceptions]]
==== Exception Handling

When you use a `DeferredResult`, you can choose whether to call `setResult` or
`setErrorResult` with an exception. In both cases, Spring MVC dispatches the request back
to the Servlet container to complete processing. It is then treated either as if the
controller method returned the given value or as if it produced the given exception.
The exception then goes through the regular exception handling mechanism (for example, invoking
`@ExceptionHandler` methods).

When you use `Callable`, similar processing logic occurs, the main difference being that
the result is returned from the `Callable` or an exception is raised by it.


[[mvc-ann-async-interception]]
==== Interception

`HandlerInterceptor` instances can be of type `AsyncHandlerInterceptor`, to receive the
`afterConcurrentHandlingStarted` callback on the initial request that starts asynchronous
processing (instead of `postHandle` and `afterCompletion`).

`HandlerInterceptor` implementations can also register a `CallableProcessingInterceptor`
or a `DeferredResultProcessingInterceptor`, to integrate more deeply with the
lifecycle of an asynchronous request (for example, to handle a timeout event). See
{api-spring-framework}/web/servlet/AsyncHandlerInterceptor.html[`AsyncHandlerInterceptor`]
for more details.

`DeferredResult` provides `onTimeout(Runnable)` and `onCompletion(Runnable)` callbacks.
See the {api-spring-framework}/web/context/request/async/DeferredResult.html[javadoc of `DeferredResult`]
for more details. `Callable` can be substituted for `WebAsyncTask` that exposes additional
methods for timeout and completion callbacks.


[[mvc-ann-async-vs-webflux]]
==== Compared to WebFlux

The Servlet API was originally built for making a single pass through the Filter-Servlet
chain. Asynchronous request processing, added in Servlet 3.0, lets applications exit
the Filter-Servlet chain but leave the response open for further processing. The Spring MVC
asynchronous support is built around that mechanism. When a controller returns a `DeferredResult`,
the Filter-Servlet chain is exited, and the Servlet container thread is released. Later, when
the `DeferredResult` is set, an `ASYNC` dispatch (to the same URL) is made, during which the
controller is mapped again but, rather than invoking it, the `DeferredResult` value is used
(as if the controller returned it) to resume processing.

By contrast, Spring WebFlux is neither built on the Servlet API, nor does it need such an
asynchronous request processing feature, because it is asynchronous by design. Asynchronous
handling is built into all framework contracts and is intrinsically supported through all
stages of request processing.

From a programming model perspective, both Spring MVC and Spring WebFlux support
asynchronous and <<mvc-ann-async-reactive-types>> as return values in controller methods.
Spring MVC even supports streaming, including reactive back pressure. However, individual
writes to the response remain blocking (and are performed on a separate thread), unlike WebFlux,
which relies on non-blocking I/O and does not need an extra thread for each write.

Another fundamental difference is that Spring MVC does not support asynchronous or reactive
types in controller method arguments (for example, `@RequestBody`, `@RequestPart`, and others),
nor does it have any explicit support for asynchronous and reactive types as model attributes.
Spring WebFlux does support all that.



[[mvc-ann-async-http-streaming]]
=== HTTP Streaming
[.small]#<<web-reactive.adoc#webflux-codecs-streaming, WebFlux>>#

You can use `DeferredResult` and `Callable` for a single asynchronous return value.
What if you want to produce multiple asynchronous values and have those written to the
response? This section describes how to do so.


[[mvc-ann-async-objects]]
==== Objects

You can use the `ResponseBodyEmitter` return value to produce a stream of objects, where
each object is serialized with an
<<integration.adoc#rest-message-conversion, `HttpMessageConverter`>> and written to the
response, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/events")
	public ResponseBodyEmitter handle() {
		ResponseBodyEmitter emitter = new ResponseBodyEmitter();
		// Save the emitter somewhere..
		return emitter;
	}

	// In some other thread
	emitter.send("Hello once");

	// and again later on
	emitter.send("Hello again");

	// and done at some point
	emitter.complete();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/events")
	fun handle() = ResponseBodyEmitter().apply {
		// Save the emitter somewhere..
	}

	// In some other thread
	emitter.send("Hello once")

	// and again later on
	emitter.send("Hello again")

	// and done at some point
	emitter.complete()
----

You can also use `ResponseBodyEmitter` as the body in a `ResponseEntity`, letting you
customize the status and headers of the response.

When an `emitter` throws an `IOException` (for example, if the remote client went away), applications
are not responsible for cleaning up the connection and should not invoke `emitter.complete`
or `emitter.completeWithError`. Instead, the servlet container automatically initiates an
`AsyncListener` error notification, in which Spring MVC makes a `completeWithError` call.
This call, in turn, performs one final `ASYNC` dispatch to the application, during which Spring MVC
invokes the configured exception resolvers and completes the request.


[[mvc-ann-async-sse]]
==== SSE

`SseEmitter` (a subclass of `ResponseBodyEmitter`) provides support for
https://www.w3.org/TR/eventsource/[Server-Sent Events], where events sent from the server
are formatted according to the W3C SSE specification. To produce an SSE
stream from a controller, return `SseEmitter`, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping(path="/events", produces=MediaType.TEXT_EVENT_STREAM_VALUE)
	public SseEmitter handle() {
		SseEmitter emitter = new SseEmitter();
		// Save the emitter somewhere..
		return emitter;
	}

	// In some other thread
	emitter.send("Hello once");

	// and again later on
	emitter.send("Hello again");

	// and done at some point
	emitter.complete();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/events", produces = [MediaType.TEXT_EVENT_STREAM_VALUE])
	fun handle() = SseEmitter().apply {
		// Save the emitter somewhere..
	}

	// In some other thread
	emitter.send("Hello once")

	// and again later on
	emitter.send("Hello again")

	// and done at some point
	emitter.complete()
----

While SSE is the main option for streaming into browsers, note that Internet Explorer
does not support Server-Sent Events. Consider using Spring's
<<web.adoc#websocket, WebSocket messaging>> with
<<web.adoc#websocket-fallback, SockJS fallback>> transports (including SSE) that target
a wide range of browsers.

See also <<mvc-ann-async-objects, previous section>> for notes on exception handling.


[[mvc-ann-async-output-stream]]
==== Raw Data

Sometimes, it is useful to bypass message conversion and stream directly to the response
`OutputStream` (for example, for a file download). You can use the `StreamingResponseBody`
return value type to do so, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/download")
	public StreamingResponseBody handle() {
		return new StreamingResponseBody() {
			@Override
			public void writeTo(OutputStream outputStream) throws IOException {
				// write...
			}
		};
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/download")
	fun handle() = StreamingResponseBody {
		// write...
	}
----

You can use `StreamingResponseBody` as the body in a `ResponseEntity` to
customize the status and headers of the response.



[[mvc-ann-async-reactive-types]]
=== Reactive Types
[.small]#<<web-reactive.adoc#webflux-codecs-streaming, WebFlux>>#

Spring MVC supports use of reactive client libraries in a controller (also read
<<web-reactive.adoc#webflux-reactive-libraries, Reactive Libraries>> in the WebFlux section).
This includes the `WebClient` from `spring-webflux` and others, such as Spring Data
reactive data repositories. In such scenarios, it is convenient to be able to return
reactive types from the controller method.

Reactive return values are handled as follows:

* A single-value promise is adapted to, similar to using `DeferredResult`. Examples
include `Mono` (Reactor) or `Single` (RxJava).
* A multi-value stream with a streaming media type (such as `application/stream+json`
or `text/event-stream`) is adapted to, similar to using `ResponseBodyEmitter` or
`SseEmitter`. Examples include `Flux` (Reactor) or `Observable` (RxJava).
Applications can also return `Flux<ServerSentEvent>` or `Observable<ServerSentEvent>`.
* A multi-value stream with any other media type (such as `application/json`) is adapted
to, similar to using `DeferredResult<List<?>>`.

TIP: Spring MVC supports Reactor and RxJava through the
{api-spring-framework}/core/ReactiveAdapterRegistry.html[`ReactiveAdapterRegistry`] from
`spring-core`, which lets it adapt from multiple reactive libraries.

For streaming to the response, reactive back pressure is supported, but writes to the
response are still blocking and are executed on a separate thread through the
<<mvc-ann-async-configuration-spring-mvc, configured>> `TaskExecutor`, to avoid
blocking the upstream source (such as a `Flux` returned from `WebClient`).
By default, `SimpleAsyncTaskExecutor` is used for the blocking writes, but that is not
suitable under load. If you plan to stream with a reactive type, you should use the
<<mvc-ann-async-configuration-spring-mvc, MVC configuration>> to configure a task executor.



[[mvc-ann-async-disconnects]]
=== Disconnects
[.small]#<<web-reactive.adoc#webflux-codecs-streaming, WebFlux>>#

The Servlet API does not provide any notification when a remote client goes away.
Therefore, while streaming to the response, whether through <<mvc-ann-async-sse, SseEmitter>>
or <<mvc-ann-async-reactive-types, reactive types>>, it is important to send data periodically,
since the write fails if the client has disconnected. The send could take the form of an
empty (comment-only) SSE event or any other data that the other side would have to interpret
as a heartbeat and ignore.

Alternatively, consider using web messaging solutions (such as
<<websocket-stomp, STOMP over WebSocket>> or WebSocket with <<websocket-fallback, SockJS>>)
that have a built-in heartbeat mechanism.



[[mvc-ann-async-configuration]]
=== Configuration
[.small]#<<mvc-ann-async-vs-webflux, Compared to WebFlux>>#

The asynchronous request processing feature must be enabled at the Servlet container level.
The MVC configuration also exposes several options for asynchronous requests.


[[mvc-ann-async-configuration-servlet3]]
==== Servlet Container

Filter and Servlet declarations have an `asyncSupported` flag that needs to be set to `true`
to enable asynchronous request processing. In addition, Filter mappings should be
declared to handle the `ASYNC` `javax.servlet.DispatchType`.

In Java configuration, when you use `AbstractAnnotationConfigDispatcherServletInitializer`
to initialize the Servlet container, this is done automatically.

In `web.xml` configuration, you can add `<async-supported>true</async-supported>` to the
`DispatcherServlet` and to `Filter` declarations and add
`<dispatcher>ASYNC</dispatcher>` to filter mappings.


[[mvc-ann-async-configuration-spring-mvc]]
==== Spring MVC

The MVC configuration exposes the following options related to asynchronous request processing:

* Java configuration: Use the `configureAsyncSupport` callback on `WebMvcConfigurer`.
* XML namespace: Use the `<async-support>` element under `<mvc:annotation-driven>`.

You can configure the following:

* Default timeout value for async requests, which if not set, depends
on the underlying Servlet container.
* `AsyncTaskExecutor` to use for blocking writes when streaming with
<<mvc-ann-async-reactive-types>> and for executing `Callable` instances returned from
controller methods. We highly recommended configuring this property if you
stream with reactive types or have controller methods that return `Callable`, since
by default, it is a `SimpleAsyncTaskExecutor`.
* `DeferredResultProcessingInterceptor` implementations and `CallableProcessingInterceptor` implementations.

Note that you can also set the default timeout value on a `DeferredResult`,
a `ResponseBodyEmitter`, and an `SseEmitter`. For a `Callable`, you can use
`WebAsyncTask` to provide a timeout value.

include::webmvc-cors.adoc[leveloffset=+1]




[[mvc-web-security]]
== Web Security
[.small]#<<web-reactive.adoc#webflux-web-security, WebFlux>>#

The https://projects.spring.io/spring-security/[Spring Security] project provides support
for protecting web applications from malicious exploits. See the Spring Security
reference documentation, including:

* {doc-spring-security}/html5/#mvc[Spring MVC Security]
* {doc-spring-security}/html5/#test-mockmvc[Spring MVC Test Support]
* {doc-spring-security}/html5/#csrf[CSRF protection]
* {doc-spring-security}/html5/#headers[Security Response Headers]

https://hdiv.org/[HDIV] is another web security framework that integrates with Spring MVC.




[[mvc-caching]]
== HTTP Caching
[.small]#<<web-reactive.adoc#webflux-caching, WebFlux>>#

HTTP caching can significantly improve the performance of a web application. HTTP caching
revolves around the `Cache-Control` response header and, subsequently, conditional request
headers (such as `Last-Modified` and `ETag`). `Cache-Control` advises private (for example, browser)
and public (for example, proxy) caches on how to cache and re-use responses. An `ETag` header is used
to make a conditional request that may result in a 304 (NOT_MODIFIED) without a body,
if the content has not changed. `ETag` can be seen as a more sophisticated successor to
the `Last-Modified` header.

This section describes the HTTP caching-related options that are available in Spring Web MVC.



[[mvc-caching-cachecontrol]]
=== `CacheControl`
[.small]#<<web-reactive.adoc#webflux-caching-cachecontrol, WebFlux>>#

{api-spring-framework}/http/CacheControl.html[`CacheControl`] provides support for
configuring settings related to the `Cache-Control` header and is accepted as an argument
in a number of places:

* {api-spring-framework}/web/servlet/mvc/WebContentInterceptor.html[`WebContentInterceptor`]
* {api-spring-framework}/web/servlet/support/WebContentGenerator.html[`WebContentGenerator`]
* <<mvc-caching-etag-lastmodified>>
* <<mvc-caching-static-resources>>

While https://tools.ietf.org/html/rfc7234#section-5.2.2[RFC 7234] describes all possible
directives for the `Cache-Control` response header, the `CacheControl` type takes a
use case-oriented approach that focuses on the common scenarios:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// Cache for an hour - "Cache-Control: max-age=3600"
	CacheControl ccCacheOneHour = CacheControl.maxAge(1, TimeUnit.HOURS);

	// Prevent caching - "Cache-Control: no-store"
	CacheControl ccNoStore = CacheControl.noStore();

	// Cache for ten days in public and private caches,
	// public caches should not transform the response
	// "Cache-Control: max-age=864000, public, no-transform"
	CacheControl ccCustom = CacheControl.maxAge(10, TimeUnit.DAYS).noTransform().cachePublic();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// Cache for an hour - "Cache-Control: max-age=3600"
	val ccCacheOneHour = CacheControl.maxAge(1, TimeUnit.HOURS)

	// Prevent caching - "Cache-Control: no-store"
	val ccNoStore = CacheControl.noStore()

	// Cache for ten days in public and private caches,
	// public caches should not transform the response
	// "Cache-Control: max-age=864000, public, no-transform"
	val ccCustom = CacheControl.maxAge(10, TimeUnit.DAYS).noTransform().cachePublic()
----

`WebContentGenerator` also accept a simpler `cachePeriod` property (defined in seconds) that
works as follows:

* A `-1` value does not generate a `Cache-Control` response header.
* A `0` value prevents caching by using the `'Cache-Control: no-store'` directive.
* An `n > 0` value caches the given response for `n` seconds by using the
`'Cache-Control: max-age=n'` directive.



[[mvc-caching-etag-lastmodified]]
=== Controllers
[.small]#<<web-reactive.adoc#webflux-caching-etag-lastmodified, WebFlux>>#

Controllers can add explicit support for HTTP caching. We recommended doing so, since the
`lastModified` or `ETag` value for a resource needs to be calculated before it can be compared
against conditional request headers. A controller can add an `ETag` header and `Cache-Control`
settings to a `ResponseEntity`, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/book/{id}")
	public ResponseEntity<Book> showBook(@PathVariable Long id) {

		Book book = findBook(id);
		String version = book.getVersion();

		return ResponseEntity
				.ok()
				.cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))
				.eTag(version) // lastModified is also available
				.body(book);
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/book/{id}")
	fun showBook(@PathVariable id: Long): ResponseEntity<Book> {

		val book = findBook(id);
		val version = book.getVersion()

		return ResponseEntity
				.ok()
				.cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))
				.eTag(version) // lastModified is also available
				.body(book)
	}
----

The preceding example sends an 304 (NOT_MODIFIED) response with an empty body if the comparison
to the conditional request headers indicates that the content has not changed. Otherwise, the
`ETag` and `Cache-Control` headers are added to the response.

You can also make the check against conditional request headers in the controller,
as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RequestMapping
	public String myHandleMethod(WebRequest webRequest, Model model) {

		long eTag = ... // <1>

		if (request.checkNotModified(eTag)) {
			return null; // <2>
		}

		model.addAttribute(...); // <3>
		return "myViewName";
	}
----
<1> Application-specific calculation.
<2> The response has been set to 304 (NOT_MODIFIED) -- no further processing.
<3> Continue with the request processing.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RequestMapping
	fun myHandleMethod(webRequest: WebRequest, model: Model): String? {

		val eTag: Long = ... // <1>

		if (request.checkNotModified(eTag)) {
			return null // <2>
		}

		model[...] = ... // <3>
		return "myViewName"
	}
----
<1> Application-specific calculation.
<2> The response has been set to 304 (NOT_MODIFIED) -- no further processing.
<3> Continue with the request processing.


There are three variants for checking conditional requests against `eTag` values, `lastModified`
values, or both. For conditional `GET` and `HEAD` requests, you can set the response to
304 (NOT_MODIFIED). For conditional `POST`, `PUT`, and `DELETE`, you can instead set the response
to 412 (PRECONDITION_FAILED), to prevent concurrent modification.



[[mvc-caching-static-resources]]
=== Static Resources
[.small]#<<web-reactive.adoc#webflux-caching-static-resources, WebFlux>>#

You should serve static resources with a `Cache-Control` and conditional response headers
for optimal performance. See the section on configuring <<mvc-config-static-resources>>.



[[mvc-httpcaching-shallowetag]]
=== `ETag` Filter

You can use the `ShallowEtagHeaderFilter` to add "`shallow`" `eTag` values that are computed from the
response content and, thus, save bandwidth but not CPU time. See <<filters-shallow-etag>>.

include::webmvc-view.adoc[leveloffset=+1]




[[mvc-config]]
== MVC Config
[.small]#<<web-reactive.adoc#webflux-config, WebFlux>>#

The MVC Java configuration and the MVC XML namespace provide default configuration
suitable for most applications and a configuration API to customize it.

For more advanced customizations, which are not available in the configuration API,
see <<mvc-config-advanced-java>> and <<mvc-config-advanced-xml>>.

You do not need to understand the underlying beans created by the MVC Java configuration
and the MVC namespace. If you want to learn more, see <<mvc-servlet-special-bean-types>>
and <<mvc-servlet-config>>.



[[mvc-config-enable]]
=== Enable MVC Configuration
[.small]#<<web-reactive.adoc#webflux-config-enable, WebFlux>>#

In Java configuration, you can use the `@EnableWebMvc` annotation to enable MVC
configuration, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig {
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig
----

In XML configuration, you can use the `<mvc:annotation-driven>` element to enable MVC
configuration, as the following example shows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:mvc="http://www.springframework.org/schema/mvc"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/mvc
			https://www.springframework.org/schema/mvc/spring-mvc.xsd">

		<mvc:annotation-driven/>

	</beans>
----

The preceding example registers a number of Spring MVC
<<mvc-servlet-special-bean-types, infrastructure beans>> and adapts to dependencies
available on the classpath (for example, payload converters for JSON, XML, and others).



[[mvc-config-customize]]
=== MVC Config API
[.small]#<<web-reactive.adoc#webflux-config-customize, WebFlux>>#

In Java configuration, you can implement the `WebMvcConfigurer` interface, as the
following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		// Implement configuration methods...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {
		// Implement configuration methods...
	}
----


In XML, you can check attributes and sub-elements of `<mvc:annotation-driven/>`. You can
view the https://schema.spring.io/mvc/spring-mvc.xsd[Spring MVC XML schema] or use
the code completion feature of your IDE to discover what attributes and
sub-elements are available.



[[mvc-config-conversion]]
=== Type Conversion
[.small]#<<web-reactive.adoc#webflux-config-conversion, WebFlux>>#

By default formatters, for `Number` and `Date` types are installed, including support for
the `@NumberFormat` and `@DateTimeFormat` annotations. Full support for the Joda-Time
formatting library is also installed if Joda-Time is present on the classpath.

In Java configuration, you can register custom formatters and converters, as the
following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void addFormatters(FormatterRegistry registry) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun addFormatters(registry: FormatterRegistry) {
			// ...
		}
	}
----

The following example shows how to achieve the same configuration in XML:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:mvc="http://www.springframework.org/schema/mvc"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/mvc
			https://www.springframework.org/schema/mvc/spring-mvc.xsd">

		<mvc:annotation-driven conversion-service="conversionService"/>

		<bean id="conversionService"
				class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
			<property name="converters">
				<set>
					<bean class="org.example.MyConverter"/>
				</set>
			</property>
			<property name="formatters">
				<set>
					<bean class="org.example.MyFormatter"/>
					<bean class="org.example.MyAnnotationFormatterFactory"/>
				</set>
			</property>
			<property name="formatterRegistrars">
				<set>
					<bean class="org.example.MyFormatterRegistrar"/>
				</set>
			</property>
		</bean>

	</beans>
----

NOTE: See <<core.adoc#format-FormatterRegistrar-SPI, the `FormatterRegistrar` SPI>>
and the `FormattingConversionServiceFactoryBean` for more information on when to use
FormatterRegistrar implementations.



[[mvc-config-validation]]
=== Validation
[.small]#<<web-reactive.adoc#webflux-config-validation, WebFlux>>#

By default, if <<core.adoc#validation-beanvalidation-overview, Bean Validation>> is present
on the classpath (for example, Hibernate Validator), the `LocalValidatorFactoryBean` is
registered as a global <<core.adoc#validator, Validator>> for use with `@Valid` and
`Validated` on controller method arguments.

In Java configuration, you can customize the global `Validator` instance, as the
following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public Validator getValidator() {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun getValidator(): Validator {
			// ...
		}
	}
----

The following example shows how to achieve the same configuration in XML:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:mvc="http://www.springframework.org/schema/mvc"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/mvc
			https://www.springframework.org/schema/mvc/spring-mvc.xsd">

		<mvc:annotation-driven validator="globalValidator"/>

	</beans>
----

Note that you can also register `Validator` implementations locally, as the following
example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class MyController {

		@InitBinder
		protected void initBinder(WebDataBinder binder) {
			binder.addValidators(new FooValidator());
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	class MyController {

		@InitBinder
		protected fun initBinder(binder: WebDataBinder) {
			binder.addValidators(FooValidator())
		}
	}
----

TIP: If you need to have a `LocalValidatorFactoryBean` injected somewhere, create a bean and
mark it with `@Primary` in order to avoid conflict with the one declared in the MVC configuration.



[[mvc-config-interceptors]]
=== Interceptors

In Java configuration, you can register interceptors to apply to incoming requests, as
the following example shows:

[source,java,indent=0,subs="verbatim",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void addInterceptors(InterceptorRegistry registry) {
			registry.addInterceptor(new LocaleChangeInterceptor());
			registry.addInterceptor(new ThemeChangeInterceptor()).addPathPatterns("/**").excludePathPatterns("/admin/**");
			registry.addInterceptor(new SecurityInterceptor()).addPathPatterns("/secure/*");
		}
	}
----
[source,kotlin,indent=0,subs="verbatim",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun addInterceptors(registry: InterceptorRegistry) {
			registry.addInterceptor(LocaleChangeInterceptor())
			registry.addInterceptor(ThemeChangeInterceptor()).addPathPatterns("/**").excludePathPatterns("/admin/**")
			registry.addInterceptor(SecurityInterceptor()).addPathPatterns("/secure/*")
		}
	}
----

The following example shows how to achieve the same configuration in XML:

[source,xml,indent=0,subs="verbatim"]
----
	<mvc:interceptors>
		<bean class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor"/>
		<mvc:interceptor>
			<mvc:mapping path="/**"/>
			<mvc:exclude-mapping path="/admin/**"/>
			<bean class="org.springframework.web.servlet.theme.ThemeChangeInterceptor"/>
		</mvc:interceptor>
		<mvc:interceptor>
			<mvc:mapping path="/secure/*"/>
			<bean class="org.example.SecurityInterceptor"/>
		</mvc:interceptor>
	</mvc:interceptors>
----



[[mvc-config-content-negotiation]]
=== Content Types
[.small]#<<web-reactive.adoc#webflux-config-content-negotiation, WebFlux>>#

You can configure how Spring MVC determines the requested media types from the request
(for example, `Accept` header, URL path extension, query parameter, and others).

By default, the URL path extension is checked first -- with `json`, `xml`, `rss`, and `atom`
registered as known extensions (depending on classpath dependencies). The `Accept` header
is checked second.

Consider changing those defaults to `Accept` header only, and, if you must use URL-based
content type resolution, consider using the query parameter strategy over path extensions. See
<<mvc-ann-requestmapping-suffix-pattern-match>> and <<mvc-ann-requestmapping-rfd>> for
more details.

In Java configuration, you can customize requested content type resolution, as the
following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
			configurer.mediaType("json", MediaType.APPLICATION_JSON);
			configurer.mediaType("xml", MediaType.APPLICATION_XML);
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun configureContentNegotiation(configurer: ContentNegotiationConfigurer) {
			configurer.mediaType("json", MediaType.APPLICATION_JSON)
			configurer.mediaType("xml", MediaType.APPLICATION_XML)
		}
	}
----


The following example shows how to achieve the same configuration in XML:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<mvc:annotation-driven content-negotiation-manager="contentNegotiationManager"/>

	<bean id="contentNegotiationManager" class="org.springframework.web.accept.ContentNegotiationManagerFactoryBean">
		<property name="mediaTypes">
			<value>
				json=application/json
				xml=application/xml
			</value>
		</property>
	</bean>
----



[[mvc-config-message-converters]]
=== Message Converters
[.small]#<<web-reactive.adoc#webflux-config-message-codecs, WebFlux>>#

You can customize `HttpMessageConverter` in Java configuration by overriding
{api-spring-framework}/web/servlet/config/annotation/WebMvcConfigurer.html#configureMessageConverters-java.util.List-[`configureMessageConverters()`]
(to replace the default converters created by Spring MVC) or by overriding
{api-spring-framework}/web/servlet/config/annotation/WebMvcConfigurer.html#extendMessageConverters-java.util.List-[`extendMessageConverters()`]
(to customize the default converters or add additional converters to the default ones).

The following example adds XML and Jackson JSON converters with a customized
`ObjectMapper` instead of the default ones:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfiguration implements WebMvcConfigurer {

		@Override
		public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
			Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder()
					.indentOutput(true)
					.dateFormat(new SimpleDateFormat("yyyy-MM-dd"))
					.modulesToInstall(new ParameterNamesModule());
			converters.add(new MappingJackson2HttpMessageConverter(builder.build()));
			converters.add(new MappingJackson2XmlHttpMessageConverter(builder.createXmlMapper(true).build()));
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfiguration : WebMvcConfigurer {

		override fun configureMessageConverters(converters: MutableList<HttpMessageConverter<*>>) {
			val builder = Jackson2ObjectMapperBuilder()
					.indentOutput(true)
					.dateFormat(SimpleDateFormat("yyyy-MM-dd"))
					.modulesToInstall(ParameterNamesModule())
			converters.add(MappingJackson2HttpMessageConverter(builder.build()))
			converters.add(MappingJackson2XmlHttpMessageConverter(builder.createXmlMapper(true).build()))
----

In the preceding example,
{api-spring-framework}/http/converter/json/Jackson2ObjectMapperBuilder.html[`Jackson2ObjectMapperBuilder`]
is used to create a common configuration for both `MappingJackson2HttpMessageConverter` and
`MappingJackson2XmlHttpMessageConverter` with indentation enabled, a customized date format,
and the registration of
https://github.com/FasterXML/jackson-module-parameter-names[`jackson-module-parameter-names`],
Which adds support for accessing parameter names (a feature added in Java 8).

This builder customizes Jackson's default properties as follows:

* https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/DeserializationFeature.html#FAIL_ON_UNKNOWN_PROPERTIES[`DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES`] is disabled.
* https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/MapperFeature.html#DEFAULT_VIEW_INCLUSION[`MapperFeature.DEFAULT_VIEW_INCLUSION`] is disabled.

It also automatically registers the following well-known modules if they are detected on the classpath:

* https://github.com/FasterXML/jackson-datatype-joda[jackson-datatype-joda]: Support for Joda-Time types.
* https://github.com/FasterXML/jackson-datatype-jsr310[jackson-datatype-jsr310]: Support for Java 8 Date and Time API types.
* https://github.com/FasterXML/jackson-datatype-jdk8[jackson-datatype-jdk8]: Support for other Java 8 types, such as `Optional`.
* https://github.com/FasterXML/jackson-module-kotlin[`jackson-module-kotlin`]: Support for Kotlin classes and data classes.

NOTE: Enabling indentation with Jackson XML support requires
https://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.codehaus.woodstox%22%20AND%20a%3A%22woodstox-core-asl%22[`woodstox-core-asl`]
dependency in addition to https://search.maven.org/#search%7Cga%7C1%7Ca%3A%22jackson-dataformat-xml%22[`jackson-dataformat-xml`] one.

Other interesting Jackson modules are available:

* https://github.com/zalando/jackson-datatype-money[jackson-datatype-money]: Support for `javax.money` types (unofficial module).
* https://github.com/FasterXML/jackson-datatype-hibernate[jackson-datatype-hibernate]: Support for Hibernate-specific types and properties (including lazy-loading aspects).

The following example shows how to achieve the same configuration in XML:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<mvc:annotation-driven>
		<mvc:message-converters>
			<bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter">
				<property name="objectMapper" ref="objectMapper"/>
			</bean>
			<bean class="org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter">
				<property name="objectMapper" ref="xmlMapper"/>
			</bean>
		</mvc:message-converters>
	</mvc:annotation-driven>

	<bean id="objectMapper" class="org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"
		  p:indentOutput="true"
		  p:simpleDateFormat="yyyy-MM-dd"
		  p:modulesToInstall="com.fasterxml.jackson.module.paramnames.ParameterNamesModule"/>

	<bean id="xmlMapper" parent="objectMapper" p:createXmlMapper="true"/>
----



[[mvc-config-view-controller]]
=== View Controllers

This is a shortcut for defining a `ParameterizableViewController` that immediately
forwards to a view when invoked. You can use it in static cases when there is no Java controller
logic to execute before the view generates the response.

The following example of Java configuration forwards a request for `/` to a view called `home`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void addViewControllers(ViewControllerRegistry registry) {
			registry.addViewController("/").setViewName("home");
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun addViewControllers(registry: ViewControllerRegistry) {
			registry.addViewController("/").setViewName("home")
		}
	}
----

The following example achieves the same thing as the preceding example, but with XML, by
using the `<mvc:view-controller>` element:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<mvc:view-controller path="/" view-name="home"/>
----



[[mvc-config-view-resolvers]]
=== View 解析器
[.small]#<<web-reactive.adoc#webflux-config-view-resolvers, WebFlux>>#

The MVC configuration simplifies the registration of view resolvers.

The following Java configuration example configures content negotiation view
resolution by using JSP and Jackson as a default `View` for JSON rendering:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void configureViewResolvers(ViewResolverRegistry registry) {
			registry.enableContentNegotiation(new MappingJackson2JsonView());
			registry.jsp();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun configureViewResolvers(registry: ViewResolverRegistry) {
			registry.enableContentNegotiation(MappingJackson2JsonView())
			registry.jsp()
		}
	}
----


The following example shows how to achieve the same configuration in XML:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<mvc:view-resolvers>
		<mvc:content-negotiation>
			<mvc:default-views>
				<bean class="org.springframework.web.servlet.view.json.MappingJackson2JsonView"/>
			</mvc:default-views>
		</mvc:content-negotiation>
		<mvc:jsp/>
	</mvc:view-resolvers>
----

Note, however, that FreeMarker, Tiles, Groovy Markup, and script templates also require
configuration of the underlying view technology.

The MVC namespace provides dedicated elements. The following example works with FreeMarker:

[source,xml,indent=0,subs="verbatim,quotes"]
----

	<mvc:view-resolvers>
		<mvc:content-negotiation>
			<mvc:default-views>
				<bean class="org.springframework.web.servlet.view.json.MappingJackson2JsonView"/>
			</mvc:default-views>
		</mvc:content-negotiation>
		<mvc:freemarker cache="false"/>
	</mvc:view-resolvers>

	<mvc:freemarker-configurer>
		<mvc:template-loader-path location="/freemarker"/>
	</mvc:freemarker-configurer>

----

In Java configuration, you can add the respective `Configurer` bean,
as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void configureViewResolvers(ViewResolverRegistry registry) {
			registry.enableContentNegotiation(new MappingJackson2JsonView());
			registry.freeMarker().cache(false);
		}

		@Bean
		public FreeMarkerConfigurer freeMarkerConfigurer() {
			FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
			configurer.setTemplateLoaderPath("/freemarker");
			return configurer;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun configureViewResolvers(registry: ViewResolverRegistry) {
			registry.enableContentNegotiation(MappingJackson2JsonView())
			registry.freeMarker().cache(false)
		}

		@Bean
		fun freeMarkerConfigurer() = FreeMarkerConfigurer().apply {
			setTemplateLoaderPath("/freemarker")
		}
	}
----



[[mvc-config-static-resources]]
=== Static Resources
[.small]#<<web-reactive.adoc#webflux-config-static-resources, WebFlux>>#

This option provides a convenient way to serve static resources from a list of
{api-spring-framework}/core/io/Resource.html[`Resource`]-based locations.

In the next example, given a request that starts with `/resources`, the relative path is
used to find and serve static resources relative to `/public` under the web application
root or on the classpath under `/static`. The resources are served with a one-year future
expiration to ensure maximum use of the browser cache and a reduction in HTTP requests
made by the browser. The `Last-Modified` header is also evaluated and, if present, a `304`
status code is returned.

The following listing shows how to do so with Java configuration:

[source,java,indent=0,subs="verbatim",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void addResourceHandlers(ResourceHandlerRegistry registry) {
			registry.addResourceHandler("/resources/**")
				.addResourceLocations("/public", "classpath:/static/")
				.setCachePeriod(31556926);
		}
	}
----
[source,kotlin,indent=0,subs="verbatim",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun addResourceHandlers(registry: ResourceHandlerRegistry) {
			registry.addResourceHandler("/resources/**")
					.addResourceLocations("/public", "classpath:/static/")
					.setCachePeriod(31556926)
		}
	}
----

The following example shows how to achieve the same configuration in XML:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<mvc:resources mapping="/resources/**"
		location="/public, classpath:/static/"
		cache-period="31556926" />
----

See also
<<mvc-caching-static-resources, HTTP caching support for static resources>>.

The resource handler also supports a chain of
{api-spring-framework}/web/servlet/resource/ResourceResolver.html[`ResourceResolver`] implementations and
{api-spring-framework}/web/servlet/resource/ResourceTransformer.html[`ResourceTransformer`] implementations,
which you can use to create a toolchain for working with optimized resources.

You can use the `VersionResourceResolver` for versioned resource URLs based on an MD5 hash
computed from the content, a fixed application version, or other. A
`ContentVersionStrategy` (MD5 hash) is a good choice -- with some notable exceptions, such as
JavaScript resources used with a module loader.

The following example shows how to use `VersionResourceResolver` in Java configuration:

[source,java,indent=0,subs="verbatim",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void addResourceHandlers(ResourceHandlerRegistry registry) {
			registry.addResourceHandler("/resources/**")
					.addResourceLocations("/public/")
					.resourceChain(true)
					.addResolver(new VersionResourceResolver().addContentVersionStrategy("/**"));
		}
	}
----
[source,kotlin,indent=0,subs="verbatim",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun addResourceHandlers(registry: ResourceHandlerRegistry) {
			registry.addResourceHandler("/resources/**")
					.addResourceLocations("/public/")
					.resourceChain(true)
					.addResolver(VersionResourceResolver().addContentVersionStrategy("/**"))
		}
	}
----

The following example shows how to achieve the same configuration in XML:

[source,xml,indent=0,subs="verbatim"]
----
<mvc:resources mapping="/resources/**" location="/public/">
	<mvc:resource-chain resource-cache="true">
		<mvc:resolvers>
			<mvc:version-resolver>
				<mvc:content-version-strategy patterns="/**"/>
			</mvc:version-resolver>
		</mvc:resolvers>
	</mvc:resource-chain>
</mvc:resources>
----

You can then use `ResourceUrlProvider` to rewrite URLs and apply the full chain of resolvers and
transformers -- for example, to insert versions. The MVC configuration provides a `ResourceUrlProvider`
bean so that it can be injected into others. You can also make the rewrite transparent with the
`ResourceUrlEncodingFilter` for Thymeleaf, JSPs, FreeMarker, and others with URL tags that
rely on `HttpServletResponse#encodeURL`.

Note that, when using both `EncodedResourceResolver` (for example, for serving gzipped or
brotli-encoded resources) and `VersionResourceResolver`, you must register them in this order.
That ensures content-based versions are always computed reliably, based on the unencoded file.

https://www.webjars.org/documentation[WebJars] are also supported through the
`WebJarsResourceResolver` which is automatically registered when the
`org.webjars:webjars-locator-core` library is present on the classpath. The resolver can
re-write URLs to include the version of the jar and can also match against incoming URLs
without versions -- for example, from `/jquery/jquery.min.js` to
`/jquery/1.2.0/jquery.min.js`.



[[mvc-default-servlet-handler]]
=== Default Servlet

Spring MVC allows for mapping the `DispatcherServlet` to `/` (thus overriding the mapping
of the container's default Servlet), while still allowing static resource requests to be
handled by the container's default Servlet. It configures a
`DefaultServletHttpRequestHandler` with a URL mapping of `/**` and the lowest priority
relative to other URL mappings.

This handler forwards all requests to the default Servlet. Therefore, it must
remain last in the order of all other URL `HandlerMappings`. That is the
case if you use `<mvc:annotation-driven>`. Alternatively, if you set up your
own customized `HandlerMapping` instance, be sure to set its `order` property to a value
lower than that of the `DefaultServletHttpRequestHandler`, which is `Integer.MAX_VALUE`.

The following example shows how to enable the feature by using the default setup:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
			configurer.enable();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun configureDefaultServletHandling(configurer: DefaultServletHandlerConfigurer) {
			configurer.enable()
		}
	}
----

The following example shows how to achieve the same configuration in XML:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<mvc:default-servlet-handler/>
----

The caveat to overriding the `/` Servlet mapping is that the `RequestDispatcher` for the
default Servlet must be retrieved by name rather than by path. The
`DefaultServletHttpRequestHandler` tries to auto-detect the default Servlet for
the container at startup time, using a list of known names for most of the major Servlet
containers (including Tomcat, Jetty, GlassFish, JBoss, Resin, WebLogic, and WebSphere).
If the default Servlet has been custom-configured with a different name, or if a
different Servlet container is being used where the default Servlet name is unknown,
then you must explicitly provide the default Servlet's name, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
			configurer.enable("myCustomDefaultServlet");
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun configureDefaultServletHandling(configurer: DefaultServletHandlerConfigurer) {
			configurer.enable("myCustomDefaultServlet")
		}
	}
----


The following example shows how to achieve the same configuration in XML:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<mvc:default-servlet-handler default-servlet-name="myCustomDefaultServlet"/>
----



[[mvc-config-path-matching]]
=== Path Matching
[.small]#<<web-reactive.adoc#webflux-config-path-matching, WebFlux>>#

You can customize options related to path matching and treatment of the URL.
For details on the individual options, see the
{api-spring-framework}/web/servlet/config/annotation/PathMatchConfigurer.html[`PathMatchConfigurer`] javadoc.

The following example shows how to customize path matching in Java configuration:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void configurePathMatch(PathMatchConfigurer configurer) {
			configurer
				.setUseSuffixPatternMatch(true)
				.setUseTrailingSlashMatch(false)
				.setUseRegisteredSuffixPatternMatch(true)
				.setPathMatcher(antPathMatcher())
				.setUrlPathHelper(urlPathHelper())
				.addPathPrefix("/api",
						HandlerTypePredicate.forAnnotation(RestController.class));
		}

		@Bean
		public UrlPathHelper urlPathHelper() {
			//...
		}

		@Bean
		public PathMatcher antPathMatcher() {
			//...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun configurePathMatch(configurer: PathMatchConfigurer) {
			configurer
				.setUseSuffixPatternMatch(true)
				.setUseTrailingSlashMatch(false)
				.setUseRegisteredSuffixPatternMatch(true)
				.setPathMatcher(antPathMatcher())
				.setUrlPathHelper(urlPathHelper())
				.addPathPrefix("/api",
						HandlerTypePredicate.forAnnotation(RestController::class.java))
		}

		@Bean
		fun urlPathHelper(): UrlPathHelper {
			//...
		}

		@Bean
		fun antPathMatcher(): PathMatcher {
			//...
		}
	}
----

The following example shows how to achieve the same configuration in XML:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<mvc:annotation-driven>
		<mvc:path-matching
			suffix-pattern="true"
			trailing-slash="false"
			registered-suffixes-only="true"
			path-helper="pathHelper"
			path-matcher="pathMatcher"/>
	</mvc:annotation-driven>

	<bean id="pathHelper" class="org.example.app.MyPathHelper"/>
	<bean id="pathMatcher" class="org.example.app.MyPathMatcher"/>
----



[[mvc-config-advanced-java]]
=== Advanced Java Config
[.small]#<<web-reactive.adoc#webflux-config-advanced-java, WebFlux>>#

`@EnableWebMvc` imports `DelegatingWebMvcConfiguration`, which:

* Provides default Spring configuration for Spring MVC applications
* Detects and delegates to `WebMvcConfigurer` implementations to customize that configuration.

For advanced mode, you can remove `@EnableWebMvc` and extend directly from
`DelegatingWebMvcConfiguration` instead of implementing `WebMvcConfigurer`,
as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class WebConfig extends DelegatingWebMvcConfiguration {

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class WebConfig : DelegatingWebMvcConfiguration() {

		// ...
	}
----

You can keep existing methods in `WebConfig`, but you can now also override bean declarations
from the base class, and you can still have any number of other `WebMvcConfigurer` implementations on
the classpath.



[[mvc-config-advanced-xml]]
=== Advanced XML Config

The MVC namespace does not have an advanced mode. If you need to customize a property on
a bean that you cannot change otherwise, you can use the `BeanPostProcessor` lifecycle
hook of the Spring `ApplicationContext`, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Component
	public class MyPostProcessor implements BeanPostProcessor {

		public Object postProcessBeforeInitialization(Object bean, String name) throws BeansException {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Component
	class MyPostProcessor : BeanPostProcessor {
		
		override fun postProcessBeforeInitialization(bean: Any, name: String): Any {
			// ...
		}
	}
----


Note that you need to declare `MyPostProcessor` as a bean, either explicitly in XML or
by letting it be detected through a `<component-scan/>` declaration.




[[mvc-http2]]
== HTTP/2
[.small]#<<web-reactive.adoc#webflux-http2, WebFlux>>#

Servlet 4 containers are required to support HTTP/2, and Spring Framework 5 is compatible
with Servlet API 4. From a programming model perspective, there is nothing specific that
applications need to do. However, there are considerations related to server configuration.
For more details, see the
https://github.com/spring-projects/spring-framework/wiki/HTTP-2-support[HTTP/2 wiki page].

The Servlet API does expose one construct related to HTTP/2. You can use the
`javax.servlet.http.PushBuilder` proactively push resources to clients, and it
is supported as a <<mvc-ann-arguments, method argument>> to `@RequestMapping` methods.
