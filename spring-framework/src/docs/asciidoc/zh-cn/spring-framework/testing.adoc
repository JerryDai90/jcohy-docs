[[testing]]
= 测试
:doc-root: https://docs.spring.io
:api-spring-framework: {doc-root}/spring-framework/docs/{spring-version}/javadoc-api/org/springframework
:doc-spring-boot: {doc-root}/spring-boot/docs/current/reference
:toc: left
:toclevels: 4
:tabsize: 4
:docinfo1:

本章介绍了Spring对集成测试的支持以及单元测试的最佳实践。 Spring团队提倡测试驱动开发（TDD）。 Spring团队发现正确使用控制反转（IoC）确实使单元测试和集成测试更加容易（因为在类上存在setter方法和适当的构造函数，使得它们在测试中更容易连接在一起，而不必设置服务定位器注册表和类似结构）。




[[testing-introduction]]
== Spring 测试简介

测试是企业软件开发的组成部分。 本章重点介绍IoC原则为<<unit-testing, 单元测试>>带来的附加价值，以及Spring框架对<<integration-testing, 集成测试>>的支持所带来的好处。 （对企业中测试的彻底处理不在本参考手册的范围之内。）


[[unit-testing]]
== 单元测试

与传统的Java EE开发相比，依赖注入应该使您的代码对容器的依赖程度降低。 组成应用程序的POJO应该可以在JUnit或TestNG测试中进行测试，并且可以使用 `new` 运算符实例化对象，而无需使用Spring或任何其他容器。
您可以使用 <<mock-objects, Mock Objects(模拟对象)>>（结合其他有价值的测试技术）来单独测试代码。 如果您遵循Spring的体系结构建议，那么代码库的最终分层和组件化将使单元测试更加容易。 例如，您可以通过存根或模拟DAO或存储库接口来测试服务层对象，而无需在运行单元测试时访问持久性数据。

真正的单元测试通常运行非常快，因为没有可设置的运行时基础架构。 将真正的单元测试作为开发方法的一部分可以提高生产率。 您可能不需要测试章节的这一部分来帮助您为基于IoC的应用程序编写有效的单元测试。 但是，对于某些单元测试方案，Spring框架提供了模拟对象和测试支持类，本章对此进行了介绍。

[[mock-objects]]
=== 模拟对象

Spring包含许多专用于模拟的软件包：

* <<mock-objects-env,环境>>
* <<mock-objects-jndi,JNDI>>
* <<mock-objects-servlet,Servlet API>>
* <<mock-objects-web-reactive,Spring Web Reactive>>


[[mock-objects-env]]
==== 环境

`org.springframework.mock.env` 包包含 `Environment` 和 `PropertySource` 抽象的模拟实现（请参阅<<core.adoc#beans-definition-profiles, Bean定义配置文件>>和<<core.adoc#beans-property-source-abstraction, `PropertySource` 抽象>>）。
`MockEnvironment` 和 `MockPropertySource` 对于编写那些依赖于特定环境或属性的测试非常有用。


[[mock-objects-jndi]]
==== JNDI

`org.springframework.mock.jndi` 包包含JNDI SPI的部分实现，可用于为测试套件或独立应用程序设置简单的JNDI环境。 例如，如果JDBC `DataSource` 实例在测试代码中与在Java EE容器中绑定到相同的JNDI名称，则可以在测试场景中重用应用程序代码和配置，而无需进行修改。

WARNING: 从Spring Framework 5.2开始，正式弃用了 `org.springframework.mock.jndi` 包中对模拟JNDI支持，而希望使用第三方的完整解决方案，例如https://github.com/h-thurow/Simple-JNDI[Simple-JNDI]。

[[mock-objects-servlet]]
==== Servlet API

`org.springframework.mock.web` 包包含一组全面的Servlet API模拟对象，这些对象对于测试Web上下文，控制器和过滤器非常有用。 这些模拟对象是针对Spring的Web MVC框架使用的，通常比动态模拟对象（例如 http://easymock.org/[EasyMock]）或其他Servlet API模拟对象（例如 http://www.mockobjects.com[MockObjects]）更方便使用。

TIP: 从Spring Framework 5.0开始，`org.springframework.mock.web` 中的模拟对象基于Servlet 4.0 API。

Spring MVC测试框架建立在模拟Servlet API对象的基础上，为Spring MVC提供了集成测试框架。参见<<spring-mvc-test-framework,Spring MVC测试框架>>。


[[mock-objects-web-reactive]]
==== Spring Web Reactive

`org.springframework.mock.http.server.reactive` 包包含 `ServerHttpRequest` 和 `ServerHttpResponse` 的模拟实现，供WebFlux应用程序使用。 `org.springframework.mock.web.server` 包包含一个模拟 `ServerWebExchange`，它依赖于那些模拟请求和响应对象。

`MockServerHttpRequest` 和 `MockServerHttpResponse` 都从与特定于服务器的实现相同的抽象基类扩展，并与它们共享行为。 例如，模拟请求一旦创建便是不可变的，但是您可以使用 `ServerHttpRequest` 中的 `mutate()` 方法来创建修改后的实例。

为了使模拟响应正确实现写约定并返回写完成句柄（即 `Mono<Void>`），默认情况下，它使用带有Flux的 `cache()`。`then()` 来对数据进行缓冲并使其 可用于测试中的断言。 应用程序可以设置自定义写入功能（例如，测试无限流）。

<<webtestclient,`WebTestClient`>> 建立在模拟请求和响应的基础上，为不使用HTTP服务器的WebFlux应用程序测试提供支持。 客户端还可以用于正在运行的服务器的端到端测试。

[[unit-testing-support-classes]]
=== 单元测试支持的类

Spring包含许多可以帮助进行单元测试的类。 它们分为两类：

* <<unit-testing-utilities,通用测试工具>>
* <<unit-testing-spring-mvc,Spring MVC测试实用程序>>


[[unit-testing-utilities]]
==== 通用测试工具

`org.springframework.test.util` 包包含几个通用的实用程序，用于单元测试和集成测试。

`ReflectionTestUtils` 是基于反射的实用程序方法的集合。 您可以在测试场景中使用这些方法，在这些场景中，当测试应用程序代码时，需要更改常量的值，设置非公共字段，调用非公共setter方法或调用非公共配置或生命周期回调方法。 用例如下：

* ORM框架（例如JPA和Hibernate）宽容 `private` 或 `protected` 的字段访问，而不是域实体中属性的 `public` 设置方法。
* Spring支持注解（例如 `@Autowired`，`@Inject` 和 `@Resource`），这些注解为 `private` 或 `protected` 的字段，setter方法和配置方法提供依赖项注入。
* 将诸如 `@PostConstruct` 和 `@PreDestroy` 之类的注解用于生命周期回调方法

{api-spring-framework}/test/util/AopTestUtils.html[`AopTestUtils`] 是与AOP相关的实用程序方法的集合。 您可以使用这些方法来获取对隐藏在一个或多个Spring代理后面的基础目标对象的引用。
例如，如果您已通过使用诸如EasyMock或Mockito之类的库将bean配置为动态模拟，并且该模拟包装在Spring代理中，则可能需要直接访问基础模拟以在其上配置期望并执行验证 。 有关Spring的核心AOP实用程序，请参阅 {api-spring-framework}/aop/support/AopUtils.html[`AopUtils`]和 {api-spring-framework}/aop/framework/AopProxyUtils.html[`AopProxyUtils`]。

[[unit-testing-spring-mvc]]
==== Spring MVC测试实用程序

`org.springframework.test.web` 包包含 {api-spring-framework}/test/web/ModelAndViewAssert.html[`ModelAndViewAssert`]，您可以将其与JUnit，TestNG或任何其他测试框架结合使用，以进行处理Spring MVC `ModelAndView` 对象的单元测试。

.单元测试Spring MVC控制器
TIP: 要对作为POJO的Spring MVC `Controller` 类进行单元测试，请将 `ModelAndViewAssert` 与Spring的<<mock-objects-servlet, Servlet API mocks>>模拟中的 `MockHttpServletRequest`，`MockHttpSession` 等结合使用。
为了与Spring MVC的 `WebApplicationContext` 配置一起对Spring MVC和REST `Controller` 类进行全面的集成测试，请改用<<spring-mvc-test-framework, Spring MVC Test Framework>>。

[[integration-testing]]
== 测试集成

本节（本章其余部分）涵盖了Spring应用程序的集成测试。 它包括以下主题：

* <<integration-testing-overview,概述>>
* <<integration-testing-goals,集成测试的目标>>
* <<integration-testing-support-jdbc,JDBC测试支持>>
* <<integration-testing-annotations,注解>>
* <<testcontext-framework,Spring TestContext框架>>
* <<spring-mvc-test-framework,Spring MVC测试框架>>



[[integration-testing-overview]]
=== 概述

无需将应用程序部署到服务器或链接到其他企业基础结构，能够执行一些测试。这一点很重要。这样可以测试以下内容：

* Spring IoC容器上下文的正确装配。
* 使用JDBC或ORM工具进行数据访问。 这可以包括诸如SQL语句的正确性，Hibernate查询，JPA实体映射之类的东西。

Spring框架为 `spring-test` 模块中的集成测试提供了一流的支持。 实际的JAR文件的名称可能包括发行版，也可能采用长 `org.springframework.test` 格式，具体取决于您从何处获取（请参阅<<core.adoc#dependency-management, 依赖管理>>部分中的说明）。
该库包含 `org.springframework.test` 包，其中包含用于与Spring容器进行集成测试的有价值的类。 此测试不依赖于应用程序服务器或其他部署环境。 此类测试的运行速度比单元测试慢，但比依赖于部署到应用程序服务器的等效 Selenium 测试或远程测试快。

单元和集成测试支持以注解驱动的<<testcontext-framework, Spring TestContext Framework>>的形式提供。 TestContext框架与实际使用的测试框架无关，该框架允许在各种环境（包括JUnit，TestNG和其他环境）中对测试进行检测。


[[integration-testing-goals]]
=== 集成测试的目标

Spring的集成测试支持的主要目标如下：:

* 在测试之间管理 <<testing-ctx-management, Spring IoC容器缓存>>
* 提供<<testing-fixture-di, Fixtures（测试夹具）实例的依赖注入>>。
* 提供适合集成测试的<<testing-tx, 事务管理>>。
* 提供<<testing-support-classes, 特定于Spring的基类>>，以帮助开发人员编写集成测试。

接下来的几节描述了每个目标，并提供了有关实现和配置详细信息的链接。


[[testing-ctx-management]]
==== 上下文管理和缓存

Spring TestContext Framework提供了Spring `ApplicationContext` 实例和 `WebApplicationContext` 实例的一致加载以及这些上下文的缓存。 支持加载上下文的缓存很重要，因为启动时间可能会成为一个问题-不是因为Spring本身的开销，而是因为Spring容器实例化的对象需要时间才能实例化。
例如，具有50到100个Hibernate映射文件的项目可能需要10到20秒来加载映射文件，并且在每个测试夹具中运行每个测试之前要承担该费用，这会导致整体测试运行速度变慢，从而降低了开发人员的工作效率。

测试类通常声明XML或Groovy配置元数据的资源位置数组（通常是在类路径中）或用于配置应用程序的组件类的数组。 这些位置或类与 `web.xml` 或其他用于生产部署的配置文件中指定的位置或类相同或相似。

默认情况下，加载后，已配置的 `ApplicationContext` 将重新用于每个测试。 因此，每个测试套件仅产生一次安装成本，并且随后的测试执行要快得多。 在这种情况下，术语“测试套件”是指所有测试都在同一JVM中运行，例如，所有测试都从给定项目或模块的Ant，Maven或Gradle构建运行。
在不太可能的情况下，测试破坏了应用程序上下文并需要重新加载（例如，通过修改bean定义或应用程序对象的状态），可以将TestContext框架配置为重新加载配置并重建应用程序上下文，然后再执行下一个 测试。


请参见使用TestContext框架进行<<testcontext-ctx-management,上下文管理>>和<<testcontext-ctx-management-caching,上下文缓存>>。

[[testing-fixture-di]]
==== 测试夹具实例的依赖注入

当TestContext框架加载您的应用程序上下文时，可以选择使用依赖注入来配置测试类的实例。 这提供了一种方便的机制，可以通过在应用程序上下文中使用预配置的bean来设置测试装置。
此处的一个强大好处是您可以在各种测试场景中重用应用程序上下文（例如，用于配置Spring管理的对象图，事务代理，`DataSource` 实例等），从而避免了为单个测试复制复杂的测试夹具设置的需要 案件。

例如，考虑一个场景，其中我们有一个类（`HibernateTitleRepository`），该类为 `Title` 域实体实现数据访问逻辑。 我们要编写集成测试来测试以下方面：

* Spring配置：基本上，与 `HibernateTitleRepository` bean的配置有关的所有内容是否正确并存在？
* Hibernate映射文件配置：是否正确映射了所有内容，并且是否有正确的延迟加载设置？
* `HibernateTitleRepository` 的逻辑: 此类的配置实例是否按预期执行？

请参见使用<<testcontext-fixture-di, TestContext framework>>进行测试夹具的依赖注入。

[[testing-tx]]
==== 事务管理

访问真实数据库的测试中的一个常见问题是它们对持久性存储状态的影响。 即使使用开发数据库，​​对状态的更改也可能会影响以后的测试。 同样，许多操作（例如插入或修改持久数据）无法在事务之外执行（或验证）。

TestContext框架解决了这个问题。 默认情况下，框架为每个测试创建并回滚事务。 您可以编写可以假定存在事务的代码。 如果在测试中调用事务代理对象，则对象将根据其配置的事务语义正确运行。
此外，如果测试方法在测试管理的事务中运行时删除了选定表的内容，则该事务将默认回滚，并且数据库将返回到执行测试之前的状态。 通过使用在测试的应用程序上下文中定义的 `PlatformTransactionManager` bean，可以为测试提供事务支持。

如果您要提交事务（不常见，但在希望特定测试填充或修改数据库时偶尔有用），则可以使用<<integration-testing-annotations, `@Commit`>>注解告诉TestContext框架使事务提交而不是回滚。

请参阅使用 <<testcontext-tx, TestContext framework>>进行事务管理。

[[testing-support-classes]]
==== 集成测试支持类

Spring TestContext Framework提供了几个抽象支持类，这些类简化了集成测试的编写。 这些基础测试类为测试框架提供了定义明确的钩子，以及方便的实例变量和方法，可用于访问以下内容：

* `ApplicationContext`，用于执行显式的bean查找或测试整个上下文的状态。
* 一个 `JdbcTemplate`，用于执行SQL语句来查询数据库。 您可以在执行与数据库相关的应用程序代码之前和之后使用此类查询来确认数据库状态，并且Spring确保此类查询在与应用程序代码相同的事务范围内运行。 与ORM工具一起使用时，请确保避免<<testcontext-tx-false-positives, 误报>>。

另外，您可能希望使用针对您的项目的实例变量和方法创建自己的自定义，应用程序范围的超类。

请参阅<<testcontext-support-classes, TestContext framework>>的支持类。

[[integration-testing-support-jdbc]]
=== JDBC 测试支持

`org.springframework.test.jdbc` 包中包含 `JdbcTestUtils`，它是一个JDBC相关的工具方法集，旨在简化标准数据库测试方案。具体来说，`JdbcTestUtils` 提供以下静态实用程序方法。

The `org.springframework.test.jdbc` package contains `JdbcTestUtils`, which is a
collection of JDBC-related utility functions intended to simplify standard database
testing scenarios. Specifically, `JdbcTestUtils` provides the following static utility
methods.

* `countRowsInTable(..)`: 统计给定表的行数。
* `countRowsInTableWhere(..)`: 使用提供的 `where` 语句进行筛选统计给定表的行数。
* `deleteFromTables(..)`: 删除特定表的全部数据。
* `deleteFromTableWhere(..)`: 使用提供的 `where` 语句进行筛选并删除给定表的数据。
* `dropTables(..)`: 删除指定的表。

[TIP]
====
<<testcontext-support-classes-junit4, `AbstractTransactionalJUnit4SpringContextTests`>>
和 <<testcontext-support-classes-testng, `AbstractTransactionalTestNGSpringContextTests`>>
提供了委托给前面所述的 `JdbcTestUtils` 中的方法的简便方法。

`spring-jdbc` 模块提供了配置和启动嵌入式数据库的支持，可用于与数据库交互的集成测试中。

详见 <<data-access.adoc#jdbc-embedded-database-support, 嵌入式数据库支持>> and <<data-access.adoc#jdbc-embedded-database-dao-testing, 使用嵌入式数据库测试数据访问逻辑>> 。
====



[[integration-testing-annotations]]
=== 注解

本节介绍了在测试Spring应用程序时可以使用的注解。
它包括以下主题：

* <<integration-testing-annotations-spring,Spring测试注解>>
* <<integration-testing-annotations-standard,标准注解支持>>
* <<integration-testing-annotations-junit4,Spring JUnit 4 测试注解>>
* <<integration-testing-annotations-junit-jupiter,Spring JUnit Jupiter Testing Annotations>>
* <<integration-testing-annotations-meta,Meta-Annotation Support for Testing>>


[[integration-testing-annotations-spring]]
==== Spring Testing Annotations

Spring框架提供以下Spring特定的注解集合，你可以在单元和集成测试中协同TestContext框架使用它们。请参考相应的JAVA帮助文档作进一步了解，包括默认的属性，属性别名等等。

* <<spring-testing-annotation-bootstrapwith,`@BootstrapWith`>>
* <<spring-testing-annotation-contextconfiguration,`@ContextConfiguration`>>
* <<spring-testing-annotation-webappconfiguration, `@WebAppConfiguration`>>
* <<spring-testing-annotation-contexthierarchy, `@ContextHierarchy`>>
* <<spring-testing-annotation-activeprofiles, `@ActiveProfiles`>>
* <<spring-testing-annotation-testpropertysource,`@TestPropertySource`>>
* <<spring-testing-annotation-dirtiescontext, `@DirtiesContext`>>
* <<spring-testing-annotation-testexecutionlisteners, `@TestExecutionListeners`>>
* <<spring-testing-annotation-commit, `@Commit`>>
* <<spring-testing-annotation-rollback, `@Rollback`>>
* <<spring-testing-annotation-beforetransaction, `@BeforeTransaction`>>
* <<spring-testing-annotation-aftertransaction, `@AfterTransaction`>>
* <<spring-testing-annotation-sql, `@Sql`>>
* <<spring-testing-annotation-sqlconfig, `@SqlConfig`>>
* <<spring-testing-annotation-sqlmergemode, `@SqlMergeMode`>>
* <<spring-testing-annotation-sqlgroup, `@SqlGroup`>>

[[spring-testing-annotation-bootstrapwith]]
===== `@BootstrapWith`

`@BootstrapWith` 是一个用于配置Spring TestContext框架如何引导的类级别的注解。具体地说，`@BootstrapWith` 用于指定一个自定义的 `TestContextBootstrapper`。请查看<<testcontext-bootstrapping, 引导TestContext框架>>作进一步了解。

[[spring-testing-annotation-contextconfiguration]]
===== `@ContextConfiguration`

`@ContextConfiguration` 定义了类级别的元数据来决定如何为集成测试来加载和配置应用程序上下文。具体地说，`@ContextConfiguration` 声明了用于加载上下文的应用程序上下文资源路径和注解类。

资源路径通常是类路径中的XML配置文件或者Groovy脚本；而注解类通常是使用 `@Configuration` 注解的类。但是，资源路径也可以指向文件系统中的文件和脚本，而组件类可以是 `@Component` 类，`@Service` 类，等等。 有关更多详细信息，请参见<<testcontext-ctx-management-javaconfig-component-classes,组件类>> 。

下面的示例显示了引用XML文件的@ContextConfiguration注解:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ContextConfiguration("/test-config.xml") // <1>
	class XmlApplicationContextTests {
		// class body...
	}
----
<1> 引用XML文件。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ContextConfiguration("/test-config.xml") // <1>
	class XmlApplicationContextTests {
		// class body...
	}
----
<1> 引用XML文件。


以下示例显示了一个 `@ContextConfiguration` 注解，该注解引用了一个类：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ContextConfiguration(classes = TestConfig.class) // <1>
	class ConfigClassApplicationContextTests {
		// class body...
	}
----
<1> 指一类。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ContextConfiguration(classes = [TestConfig::class]) // <1>
	class ConfigClassApplicationContextTests {
		// class body...
	}
----
<1> 指一类。

作为声明资源位置或组件类的替代方法或补充，可以使用 `@ContextConfiguration` 声明 `ApplicationContextInitializer` 类。以下示例显示了这种情况：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ContextConfiguration(initializers = CustomContextIntializer.class) // <1>
	class ContextInitializerTests {
		// class body...
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ContextConfiguration(initializers = [CustomContextIntializer::class]) // <1>
	class ContextInitializerTests {
		// class body...
	}
----
<1> 声明一个初始化器类


`@ContextConfiguration` 偶尔也被用作声明 `ContextLoader` 策略。但注意，通常你不需要显示的配置加载器，因为默认的加载器已经支持资源路径或者注解类以及初始化器。

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ContextConfiguration(locations = "/test-context.xml", loader = CustomContextLoader.class) // <1>
	class CustomLoaderXmlApplicationContextTests {
		// class body...
	}
----
<1> 以下示例同时 location和 custom loader.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ContextConfiguration("/test-context.xml", loader = CustomContextLoader::class) // <1>
	class CustomLoaderXmlApplicationContextTests {
		// class body...
	}
----
<1> 以下示例同时 location和 custom loader.


NOTE: `@ContextConfiguration` 默认对继承父类定义的资源路径或者配置类以及上下文初始化器提供支持。

参阅<<testcontext-ctx-management,上下文管理>> 和 `@ContextConfiguration` 帮助文档作进一步了解。

[[spring-testing-annotation-webappconfiguration]]
===== `@WebAppConfiguration`

`@WebAppConfiguration` 是一个用于声明集成测试所加载的 `ApplicationContext` 须是 `WebApplicationContext` 的类级别的注解。测试类的 `@WebAppConfiguration` 注解只是为了保证用于测试的 `WebApplicationContext` 会被加载，
它使用 `"file:src/main/webapp"` 路径默认值作为web应用的根路径（即，资源基路径）。资源基路径用于幕后创建一个 `MockServletContext` 作为测试的 `WebApplicationContext` 的 `ServletContext`。

以下示例显示了如何使用 `@WebAppConfiguration` 注解：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ContextConfiguration
	@WebAppConfiguration // <1>
	class WebAppTests {
		// class body...
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ContextConfiguration
	@WebAppConfiguration // <1>
	class WebAppTests {
		// class body...
	}
----
<1>  `@WebAppConfiguration` 注解.

要覆盖默认值，可以使用隐式值属性指定其他基础资源路径。  `classpath:` 和 `file:` 资源前缀均受支持。 如果未提供资源前缀，则假定该路径是文件系统资源。 以下示例显示如何指定类路径资源：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ContextConfiguration
	@WebAppConfiguration("classpath:test-web-resources") // <1>
	class WebAppTests {
		// class body...
	}
----
<1> 指定类路径资源。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ContextConfiguration
	@WebAppConfiguration("classpath:test-web-resources") // <1>
	class WebAppTests {
		// class body...
	}
----
<1> 指定类路径资源。

注意 `@WebAppConfiguration` 必须和 `@ContextConfiguration` 一起使用，或者在同一个测试类，或者在测试类层次结构中。请参阅 {api-spring-framework}/test/context/web/WebAppConfiguration.html[`@WebAppConfiguration`] 帮助文档作进一步了解。

[[spring-testing-annotation-contexthierarchy]]
===== `@ContextHierarchy`

`@ContextHierarchy` 是一个类级别的注解，用于定义用于集成测试的 `ApplicationContext` 实例的层次结构。 `@ContextHierarchy` 应该用一个或多个 `@ContextConfiguration` 实例的列表声明，每个实例定义上下文层次结构中的一个级别。
以下示例演示了在单个测试类中使用 `@ContextHierarchy`（也可以在测试类层次结构中使用 `@ContextHierarchy`）：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ContextHierarchy({
		@ContextConfiguration("/parent-config.xml"),
		@ContextConfiguration("/child-config.xml")
	})
	class ContextHierarchyTests {
		// class body...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ContextHierarchy(
		ContextConfiguration("/parent-config.xml"),
		ContextConfiguration("/child-config.xml"))
	class ContextHierarchyTests {
		// class body...
	}
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@WebAppConfiguration
	@ContextHierarchy({
		@ContextConfiguration(classes = AppConfig.class),
		@ContextConfiguration(classes = WebConfig.class)
	})
	class WebIntegrationTests {
		// class body...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@WebAppConfiguration
	@ContextHierarchy(
			ContextConfiguration(classes = [AppConfig::class]),
			ContextConfiguration(classes = [WebConfig::class]))
	class WebIntegrationTests {
		// class body...
	}
----

如果需要合并或覆盖测试类层次结构中给定级别的上下文层次结构的配置，你就必须在类层次中的每一个相应的层次通过为 `@ContextConfiguration` 的 `name` 属性提供与该层次相同的值的方式来显示地指定这个层次。请参阅<<testcontext-ctx-management-ctx-hierarchies,上下文层次结构>> 和 {api-spring-framework}/test/context/ContextHierarchy.html[`@ContextHierarchy`] 帮助文档来获得更多的示例。

[[spring-testing-annotation-activeprofiles]]
===== `@ActiveProfiles`

`@ActiveProfiles` 是一个类级别的注解，用于声明在为集成测试加载 `ApplicationContext` 时应启用哪些bean定义配置文件。

以下示例表明 `dev` 配置文件应处于激活状态：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ContextConfiguration
	@ActiveProfiles("dev") // <1>
	class DeveloperTests {
		// class body...
	}
----
<1> Indicate that the `dev` profile should be active.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ContextConfiguration
	@ActiveProfiles("dev") // <1>
	class DeveloperTests {
		// class body...
	}
----
<1> Indicate that the `dev` profile should be active.


The following example indicates that both the `dev` and the `integration` profiles should
be active:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ContextConfiguration
	@ActiveProfiles({"dev", "integration"}) // <1>
	class DeveloperIntegrationTests {
		// class body...
	}
----
<1> Indicate that the `dev` and `integration` profiles should be active.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ContextConfiguration
	@ActiveProfiles(["dev", "integration"]) // <1>
	class DeveloperIntegrationTests {
		// class body...
	}
----
<1> Indicate that the `dev` and `integration` profiles should be active.


NOTE: `@ActiveProfiles` 默认为继承激活的在超类声明的 bean definition profiles提供支持。通过实现一个自定义的 <<testcontext-ctx-management-env-profiles-ActiveProfilesResolver, `ActiveProfilesResolver`>> 并通过 `@ActiveProfiles` 的 `resolver` 属性来注册它的编程的方式来解决激活bean definition profiles问题也是可行的。

参阅<<testcontext-ctx-management-env-profiles,使用环境配置文件进行上下文配置>>和 {api-spring-framework}/test/context/ActiveProfiles.html[`@ActiveProfiles`] 帮助文档作进一步了解。

[[spring-testing-annotation-testpropertysource]]
===== `@TestPropertySource`

`@TestPropertySource` 是一个用于为集成测试加载 `ApplicationContext` 时配置属性文件的位置和增加到 `Environment` 中的 `PropertySources` 集中的内联属性的类级别的注解。

测试属性源比那些从系统环境或者Java系统属性以及通过 `@PropertySource` 或者编程方式声明方式增加的属性源具有更高的优先级。而且，内联属性比从资源路径加载的属性具有更高的优先级。

下面的例子展示了如何从类路径中声明属性文件。

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ContextConfiguration
	@TestPropertySource("/test.properties") // <1>
	class MyIntegrationTests {
		// class body...
	}
----
<1> 从类路径根目录中的 `test.properties` 获取属性。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ContextConfiguration
	@TestPropertySource("/test.properties") // <1>
	class MyIntegrationTests {
		// class body...
	}
----
<1> 从类路径根目录中的 `test.properties` 获取属性。


下面的示例演示如何声明内联属性：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ContextConfiguration
	@TestPropertySource(properties = { "timezone = GMT", "port: 4242" }) // <1>
	class MyIntegrationTests {
		// class body...
	}
----
<1> 声明 `timezone` 和 `port` 属性.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ContextConfiguration
	@TestPropertySource(properties = ["timezone = GMT", "port: 4242"]) // <1>
	class MyIntegrationTests {
		// class body...
	}
----
<1> 声明 `timezone` 和 `port` 属性.

有关示例和更多详细信息，请参见<<testcontext-ctx-management-property-sources,具有测试属性源的上下文配置>> 。

[[spring-testing-annotation-dirtiescontext]]
===== `@DirtiesContext`

`@DirtiesContext` 指明测试执行期间该Spring应用程序上下文已经被弄脏（也就是说通过某种方式被更改或者破坏——比如，更改单例bean的状态）。当应用程序上下文被标为”脏”，它将从测试框架缓存中被移除并关闭。因此，Spring容器将为随后需要同样配置元数据的测试而被重建。

`@DirtiesContext` 可以在同一个类或者类层次结构中的类级别和方法级别中使用。在这个场景下，应用程序上下文将在任意此注解的方法之前或之后以及当前测试类之前或之后被标为“脏”，这取决于配置的 `methodMode` 和 `classMode`。

下面的例子解释了在多种配置场景下什么时候上下文会被标为“脏”。

* 当在一个类中声明并将类模式设为 `BEFORE_CLASS`，则在当前测试类之前。
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@DirtiesContext(classMode = BEFORE_CLASS) // <1>
	class FreshContextTests {
		// some tests that require a new Spring container
	}
----
<1> 在当前测试类之前弄脏上下文。
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@DirtiesContext(classMode = BEFORE_CLASS) // <1>
	class FreshContextTests {
		// some tests that require a new Spring container
	}
----
<1> 在当前测试类之前弄脏上下文。

* 当在一个类中声明并将类模式设为 `AFTER_CLASS`（也就是，默认的类模式），则在当前测试类之后。
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@DirtiesContext // <1>
	class ContextDirtyingTests {
		// some tests that result in the Spring container being dirtied
	}
----
<1> 当前测试类后弄脏的上下文。
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@DirtiesContext // <1>
	class ContextDirtyingTests {
		// some tests that result in the Spring container being dirtied
	}
----
<1> 当前测试类后弄脏的上下文。


* 当在一个类中声明并将类模式设为 `BEFORE_EACH_TEST_METHOD`，则在当前测试类的每个方法之前。
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@DirtiesContext(classMode = BEFORE_EACH_TEST_METHOD) // <1>
	class FreshContextTests {
		// some tests that require a new Spring container
	}
----
<1> Dirty the context before each test method.
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@DirtiesContext(classMode = BEFORE_EACH_TEST_METHOD) // <1>
	class FreshContextTests {
		// some tests that require a new Spring container
	}
----
<1> Dirty the context before each test method.


* 当在一个类中声明并将类模式设为 `AFTER_EACH_TEST_METHOD`，则在当前测试类的每个方法之后。
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@DirtiesContext(classMode = AFTER_EACH_TEST_METHOD) // <1>
	class ContextDirtyingTests {
		// some tests that result in the Spring container being dirtied
	}
----
<1> Dirty the context after each test method.
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@DirtiesContext(classMode = AFTER_EACH_TEST_METHOD) // <1>
	class ContextDirtyingTests {
		// some tests that result in the Spring container being dirtied
	}
----
<1> Dirty the context after each test method.


* 当在一个方法中声明并将方法模式设为 `BEFORE_METHOD`，则在当前方法之前。
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@DirtiesContext(methodMode = BEFORE_METHOD) // <1>
	@Test
	void testProcessWhichRequiresFreshAppCtx() {
		// some logic that requires a new Spring container
	}
----
<1> Dirty the context before the current test method.
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@DirtiesContext(methodMode = BEFORE_METHOD) // <1>
	@Test
	fun testProcessWhichRequiresFreshAppCtx() {
		// some logic that requires a new Spring container
	}
----
<1> Dirty the context before the current test method.

* 当在一个方法中声明并将方法模式设为 `AFTER_METHOD`(也就是说，默认的方法模式），则在当前方法之后。
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@DirtiesContext // <1>
	@Test
	void testProcessWhichDirtiesAppCtx() {
		// some logic that results in the Spring container being dirtied
	}
----
<1> Dirty the context after the current test method.
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@DirtiesContext // <1>
	@Test
	fun testProcessWhichDirtiesAppCtx() {
		// some logic that results in the Spring container being dirtied
	}
----
<1> Dirty the context after the current test method.

如果 `@DirtiesContext` 被用于上下文被配置为通过 `@ContextHierarchy` 定义的上下文层次中的一部分的测试中，则 `hierarchyMode` 标志可用于控制如何声明上下文缓存。默认将使用一个穷举算法用于清除包括不仅当前层次而且与当前测试拥有共同祖先的其它上下文层次的缓存。
所有在拥有共同祖先上下文的子层次的应用程序上下文都会从上下文中被移除并关闭。如果穷举算法对于特定的使用场景显得有点威力过猛，那么你可以指定一个更简单的当前层算法来代替，如下所。

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ContextHierarchy({
		@ContextConfiguration("/parent-config.xml"),
		@ContextConfiguration("/child-config.xml")
	})
	class BaseTests {
		// class body...
	}

	class ExtendedTests extends BaseTests {

		@Test
		@DirtiesContext(hierarchyMode = CURRENT_LEVEL) // <1>
		void test() {
			// some logic that results in the child context being dirtied
		}
	}
----
<1> 使用当前级别的算法。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ContextHierarchy(
		ContextConfiguration("/parent-config.xml"),
		ContextConfiguration("/child-config.xml"))
	open class BaseTests {
		// class body...
	}

	class ExtendedTests : BaseTests() {

		@Test
		@DirtiesContext(hierarchyMode = CURRENT_LEVEL) // <1>
		fun test() {
			// some logic that results in the child context being dirtied
		}
	}
----
<1> 使用当前级别的算法。

参阅 {api-spring-framework}/test/annotation/DirtiesContext.HierarchyMode.html[`DirtiesContext.HierarchyMode`]帮助文档以获得 `EXHAUSTIVE` (穷举) 和 `CURRENT_LEVEL` (当前层算法)更详细的了解。

[[spring-testing-annotation-testexecutionlisteners]]
===== `@TestExecutionListeners`

`@TestExecutionListeners` 定义了一个类级别的元数据，用于配置需要用 `TestContextManager` 进行注册的 `TestExecutionListener` 实现。通常，`@TestExecutionListeners` 与 `@ContextConfiguration` 一起使用。


[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ContextConfiguration
	@TestExecutionListeners({CustomTestExecutionListener.class, AnotherTestExecutionListener.class}) // <1>
	class CustomTestExecutionListenerTests {
		// class body...
	}
----
<1> Register two `TestExecutionListener` implementations.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ContextConfiguration
	@TestExecutionListeners(CustomTestExecutionListener::class, AnotherTestExecutionListener::class) // <1>
	class CustomTestExecutionListenerTests {
		// class body...
	}
----
<1> Register two `TestExecutionListener` implementations.

 `@TestExecutionListeners`默认支持继承监听器。参阅 {api-spring-framework}/test/context/TestExecutionListeners.html[javadoc] 获得示例和更详细的了解。

[[spring-testing-annotation-commit]]
===== `@Commit`

`@Commit` 指定事务性的测试方法在测试方法执行完成后对事务进行提交。`@Commit` 可以用作 `@Rollback(false)` 的直接替代，以更好的传达代码的意图。和 `@Rollback` 一样，`@Commit` 可以在类层次或者方法层级声明。

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Commit // <1>
	@Test
	void testProcessWithoutRollback() {
		// ...
	}
----
<1> 将测试结果提交到数据库。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Commit // <1>
	@Test
	fun testProcessWithoutRollback() {
		// ...
	}
----
<1> 将测试结果提交到数据库。


[[spring-testing-annotation-rollback]]
===== `@Rollback`

`@Rollback` 指明当测试方法执行完毕的时候是否对事务性方法中的事务进行回滚。如果为 `true`,则进行回滚；否则，则提交（请参阅 <<spring-testing-annotation-commit,`@Commit`>>）。在Spring TestContext 框架中，集成测试默认的 `Rollback` 语义为 `true`，即使你不显示的指定它。

当声明为类级注解时，`@Rollback` 定义测试类层次结构中所有测试方法的默认回滚语义。 当声明为方法级别的注解时，`@Rollback` 定义特定测试方法的回滚语义，从而可能覆盖类级别的 `@Rollback` 或 `@Commit` 语义。

以下示例使测试方法的结果不回滚（即，结果已提交到数据库）：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Rollback(false) // <1>
	@Test
	void testProcessWithoutRollback() {
		// ...
	}
----
<1> 不要回滚结果。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Rollback(false) // <1>
	@Test
	fun testProcessWithoutRollback() {
		// ...
	}
----
<1> 不要回滚结果。


[[spring-testing-annotation-beforetransaction]]
===== `@BeforeTransaction`

`@BeforeTransaction` 指明通过Spring的 `@Transactional` 注解配置为需要在事务中执行的测试方法在事务开始之前先执行注解的 `void` 方法。从Spring框架4.3版本起，`@BeforeTransaction` 方法不再需要为 `public` 并可能被声明为基于Java8的接口的默认方法。

以下示例显示了如何使用 `@BeforeTransaction` 注解：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@BeforeTransaction // <1>
	void beforeTransaction() {
		// logic to be executed before a transaction is started
	}
----
<1> 在事务之前运行此方法。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@BeforeTransaction // <1>
	fun beforeTransaction() {
		// logic to be executed before a transaction is started
	}
----
<1> 在事务之前运行此方法。


[[spring-testing-annotation-aftertransaction]]
===== `@AfterTransaction`

`@AfterTransaction` 表示，对于已配置为使用Spring的 `@Transactional` 注解在事务内运行的测试方法，带注解的 `void` 方法应在事务结束后运行。 `@AfterTransaction` 方法不再需要为 `public`，可以在基于Java 8的接口默认方法中声明。

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@AfterTransaction // <1>
	void afterTransaction() {
		// logic to be executed after a transaction has ended
	}
----
<1> 事务后运行此方法。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@AfterTransaction // <1>
	fun afterTransaction() {
		// logic to be executed after a transaction has ended
	}
----
<1> 事务后运行此方法。


[[spring-testing-annotation-sql]]
===== `@Sql`

`@Sql` 用于注解测试类或者测试方法，以让在集成测试过程中配置的SQL脚本能够在给定的的数据库中得到执行。

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Test
	@Sql({"/test-schema.sql", "/test-user-data.sql"}) // <1>
	void userTest() {
		// execute code that relies on the test schema and test data
	}
----
<1> 运行此测试的两个脚本。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Test
	@Sql("/test-schema.sql", "/test-user-data.sql") // <1>
	fun userTest() {
		// execute code that relies on the test schema and test data
	}
----
<1> 运行此测试的两个脚本。

请参阅<<testcontext-executing-sql-declaratively,通过@sql声明执行的SQL脚本>>作进一步了解。

[[spring-testing-annotation-sqlconfig]]
===== `@SqlConfig`

`@SqlConfig` 定义了用于决定如何解析和执行通过 `@Sql` 注解配置的SQL脚本。

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Test
	@Sql(
		scripts = "/test-user-data.sql",
		config = @SqlConfig(commentPrefix = "`", separator = "@@") // <1>
	)
	void userTest() {
		// execute code that relies on the test data
	}
----
<1> 在SQL脚本中设置注解前缀和分隔符。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Test
	@Sql("/test-user-data.sql", config = SqlConfig(commentPrefix = "`", separator = "@@")) // <1>
	fun userTest() {
		// execute code that relies on the test data
	}
----
<1> 在SQL脚本中设置注解前缀和分隔符。

[[spring-testing-annotation-sqlmergemode]]
===== `@SqlMergeMode`

`@SqlMergeMode` 用于注解测试类或测试方法，以配置是否将方法级 `@Sql` 声明与类级 `@Sql` 声明合并。 如果在测试类或测试方法上未声明 `@SqlMergeMode`，则默认情况下将使用 `OVERRIDE` 合并模式。 在 `OVERRIDE` 模式下，方法级别的 `@Sql` 声明将有效地覆盖类级别的 `@Sql` 声明。

请注意，方法级别的 `@SqlMergeMode` 声明将覆盖类级别的声明。

下面的示例演示如何在类级别使用 `@SqlMergeMode`。

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@SpringJUnitConfig(TestConfig.class)
	@Sql("/test-schema.sql")
	@SqlMergeMode(MERGE) // <1>
	class UserTests {

		@Test
		@Sql("/user-test-data-001.sql")
		void standardUserProfile() {
			// execute code that relies on test data set 001
		}
	}
----
<1> 将类中的所有测试方法的 `@Sql` 合并模式设置为 `MERGE`。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@SpringJUnitConfig(TestConfig::class)
	@Sql("/test-schema.sql")
	@SqlMergeMode(MERGE) // <1>
	class UserTests {

		@Test
		@Sql("/user-test-data-001.sql")
		fun standardUserProfile() {
			// execute code that relies on test data set 001
		}
	}
----
<1> 将类中的所有测试方法的 `@Sql` 合并模式设置为 `MERGE`。

下面的示例演示如何在方法级别使用 `@SqlMergeMode`。

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@SpringJUnitConfig(TestConfig.class)
	@Sql("/test-schema.sql")
	class UserTests {

		@Test
		@Sql("/user-test-data-001.sql")
		@SqlMergeMode(MERGE) // <1>
		void standardUserProfile() {
			// execute code that relies on test data set 001
		}
	}
----
<1> 将特定测试方法的 `@Sql` 合并模式设置为 `MERGE`。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@SpringJUnitConfig(TestConfig::class)
	@Sql("/test-schema.sql")
	class UserTests {

		@Test
		@Sql("/user-test-data-001.sql")
		@SqlMergeMode(MERGE) // <1>
		fun standardUserProfile() {
			// execute code that relies on test data set 001
		}
	}
----
<1> 将特定测试方法的 `@Sql` 合并模式设置为 `MERGE`。


[[spring-testing-annotation-sqlgroup]]
===== `@SqlGroup`

`@SqlGroup` 是一个用于聚合几个 `@Sql` 注解的容器注解。`@SqlGroup` 可以直接使用，通过声明几个嵌套的 `@Sql` 注解，也可以与Java8的可重复注解支持协同使用，即简单地在同一个类或方法上声明几个 `@Sql` 注解，隐式地产生这个容器注解。

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Test
	@SqlGroup({ // <1>
		@Sql(scripts = "/test-schema.sql", config = @SqlConfig(commentPrefix = "`")),
		@Sql("/test-user-data.sql")
	)}
	void userTest() {
		// execute code that uses the test schema and test data
	}
----
<1> 声明一组SQL脚本。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Test
	@SqlGroup( // <1>
		Sql("/test-schema.sql", config = SqlConfig(commentPrefix = "`")),
		Sql("/test-user-data.sql"))
	fun userTest() {
		// execute code that uses the test schema and test data
	}
----
<1> 声明一组SQL脚本。

[[integration-testing-annotations-standard]]
==== 标准注解支持

以下注解为Spring TestContext 框架所有的配置提供标准语义支持。注意这些注解不仅限于测试，可以用在Spring框架的任意地方。

* `@Autowired`
* `@Qualifier`
* `@Value`
* `@Resource` (javax.annotation) if JSR-250 is present
* `@ManagedBean` (javax.annotation) if JSR-250 is present
* `@Inject` (javax.inject) if JSR-330 is present
* `@Named` (javax.inject) if JSR-330 is present
* `@PersistenceContext` (javax.persistence) if JPA is present
* `@PersistenceUnit` (javax.persistence) if JPA is present
* `@Required`
* `@Transactional` (org.springframework.transaction.annotation)
  _with <<testcontext-tx-attribute-support, limited attribute support>>_

.JSR-250 生命周期注解
[NOTE]
====
在Spring TestContext 框架中，`@PostConstruct` 和 `@PreDestroy` 可以通过标准语义在配置于应用程序上下文的任意应用程序组件中使用; 但是, 这些生命周期注解在实际测试类中只有很有限的作用。

如果一个测试类的方法被注解为 `@PostConstruct`，这个方法将在test框架中的任何before方法（例如，使用JUnit Jupiter的 `@BeforeEach` 注解的方法）调用之前被执行, 这个规则将被应用于测试类的每个方法。另一方面，如果一个测试类的方法被注解为 `@PreDestroy`，这个方法将永远不会被执行。
因为建议在测试类中使用test 框架的测试生命周期回调来代替使用 `@PostConstruct` 和 `@PreDestroy`。
====


[[integration-testing-annotations-junit4]]
==== Spring JUnit 4 测试注解

以下注解仅在与<<testcontext-junit4-runner, SpringRunner>>，Spring的<<testcontext-junit4-rules, JUnit 4规则>>或Spring的<<testcontext-support-classes-junit4, JUnit 4支持类结合>>使用时才受支持：

* <<integration-testing-annotations-junit4-ifprofilevalue,@IfProfileValue>>
* <<integration-testing-annotations-junit4-profilevaluesourceconfiguration,@ProfileValueSourceConfiguration >>
* <<integration-testing-annotations-junit4-timed,@Timed>>
* <<integration-testing-annotations-junit4-repeat,@Repeat>>

[[integration-testing-annotations-junit4-ifprofilevalue]]
===== `@IfProfileValue`

`@IfProfileValue` 指明该测试只在特定的测试环境中被启用。如果 `ProfileValueSource` 配置的 `value` 属性与此注解配置的 `name` 属性一致，这该测试将被启用。否则，该测试将被禁用并忽略。

`@IfProfileValue` 可以用在类级别、方法级别或者两个同时。使用类级别的 `@IfProfileValue` 注解优先于当前类或其子类的任意方法的使用方法级别的注解。有 `@IfProfileValue` 注解意味着则测试被隐式开启。这与JUnit4的 `@Ignore` 注解是相类似的，除了使用 `@Ignore` 注解是用于禁用测试的之外。

以下示例显示了具有 `@IfProfileValue` 注解的测试：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@IfProfileValue(name="java.vendor", value="Oracle Corporation") // <1>
	@Test
	public void testProcessWhichRunsOnlyOnOracleJvm() {
		// some logic that should run only on Java VMs from Oracle Corporation
	}
----
<1> 仅当Java供应商是 "Oracle Corporation" 时才运行此测试。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@IfProfileValue(name="java.vendor", value="Oracle Corporation") // <1>
	@Test
	fun testProcessWhichRunsOnlyOnOracleJvm() {
		// some logic that should run only on Java VMs from Oracle Corporation
	}
----
<1> 仅当Java供应商是 "Oracle Corporation" 时才运行此测试。

另外，您可以使用 `values` 列表（带有 `OR` 语义）配置 `@IfProfileValue`，以在JUnit 4环境中实现对Test Group的类似于TestNG的支持。 考虑以下示例：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@IfProfileValue(name="test-groups", values={"unit-tests", "integration-tests"}) // <1>
	@Test
	public void testProcessWhichRunsForUnitOrIntegrationTestGroups() {
		// some logic that should run only for unit and integration test groups
	}
----
<1> 对单元测试和集成测试运行此测试。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@IfProfileValue(name="test-groups", values=["unit-tests", "integration-tests"]) // <1>
	@Test
	fun testProcessWhichRunsForUnitOrIntegrationTestGroups() {
		// some logic that should run only for unit and integration test groups
	}
----
<1> 对单元测试和集成测试运行此测试。


[[integration-testing-annotations-junit4-profilevaluesourceconfiguration]]
===== `@ProfileValueSourceConfiguration`

`@ProfileValueSourceConfiguration` 是类级别注解，用于当获取通过 `@IfProfileValue` 配置的 `profile` 值时指定使用什么样的 `ProfileValueSource` 类型。如果一个测试没有指定 `@ProfileValueSourceConfiguration`，那么默认使用 `SystemProfileValueSource`。

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ProfileValueSourceConfiguration(CustomProfileValueSource.class) // <1>
	public class CustomProfileValueSourceTests {
		// class body...
	}
----
<1> Use a custom profile value source.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ProfileValueSourceConfiguration(CustomProfileValueSource::class) // <1>
	class CustomProfileValueSourceTests {
		// class body...
	}
----
<1> Use a custom profile value source.


[[integration-testing-annotations-junit4-timed]]
===== `@Timed`

`@Timed` 用于指明被注解的测试必须在指定的时限（毫秒）内结束。如果测试超过指定时限，就当作测试失败。

时限包括测试方法本身所耗费的时间，包括任何重复（请查看 `@Repeat`）及任意初始化和销毁所用的时间。

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Timed(millis = 1000) // <1>
	public void testProcessWithOneSecondTimeout() {
		// some logic that should not take longer than 1 second to execute
	}
----
<1> Set the time period for the test to one second.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Timed(millis = 1000) // <1>
	fun testProcessWithOneSecondTimeout() {
		// some logic that should not take longer than 1 second to execute
	}
----
<1> Set the time period for the test to one second.

Spring的 `@Timed` 注解与JUnit 4的 `@Test(timeout=…​)` 支持相比具有不同的语义。确切地说，由于在JUnit 4中处理方法执行超时的方式（也就是，在独立纯程中执行该测试方法），如果一个测试方法执行时间太长，`@Test(timeout=…​)` 将直接判定该测试失败。
而Spring的 `@Timed` 则不直接判定失败而是等待测试完成。

[[integration-testing-annotations-junit4-repeat]]
===== `@Repeat`

`@Repeat` 指明该测试方法需被重复执行。注解指定该测试方法被重复的次数。重复的范围包括该测试方法自身也包括相应的初始化和销毁方法。

重复执行的范围包括测试方法本身的执行以及测试夹具的任何安装或拆除。以下示例显示了如何使用 `@Repeat` 注解：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Repeat(10) // <1>
	@Test
	public void testProcessRepeatedly() {
		// ...
	}
----
<1> 重复此测试十次。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Repeat(10) // <1>
	@Test
	fun testProcessRepeatedly() {
		// ...
	}
----
<1> 重复此测试十次。


[[integration-testing-annotations-junit-jupiter]]
==== Spring JUnit Jupiter Testing Annotations

以下注解仅在与<<testcontext-junit-jupiter-extension, `SpringExtension`>> 和JUnit Jupiter（即JUnit 5中的编程模型）结合使用时才受支持：

* <<integration-testing-annotations-junit-jupiter-springjunitconfig,@SpringJUnitConfig>>
* <<integration-testing-annotations-junit-jupiter-springjunitwebconfig,@SpringJUnitWebConfig>>
* <<integration-testing-annotations-testconstructor,@TestConstructor>>
* <<integration-testing-annotations-junit-jupiter-enabledif,@EnabledIf>>
* <<integration-testing-annotations-junit-jupiter-disabledif,@DisabledIf>>

[[integration-testing-annotations-junit-jupiter-springjunitconfig]]
===== `@SpringJUnitConfig`

`@SpringJUnitConfig` 是一个组合注解，它将JUnit Jupiter的 `@ExtendWith(SpringExtension.class)` 与Spring TestContext Framework的 `@ContextConfiguration` 组合在一起。 它可以在类级别用作 `@ContextConfiguration` 的直接替代。
关于配置选项，`@ContextConfiguration` 和 `@SpringJUnitConfig` 之间的唯一区别是可以使用 `@SpringJUnitConfig` 中的 `value` 属性声明组件类。

以下示例显示如何使用 `@SpringJUnitConfig` 注解指定配置类：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@SpringJUnitConfig(TestConfig.class) // <1>
	class ConfigurationClassJUnitJupiterSpringTests {
		// class body...
	}
----
<1> 指定配置类。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@SpringJUnitConfig(TestConfig::class) // <1>
	class ConfigurationClassJUnitJupiterSpringTests {
		// class body...
	}
----
<1> 指定配置类。


以下示例显示如何使用 `@SpringJUnitConfig` 注解指定配置文件的位置：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@SpringJUnitConfig(locations = "/test-config.xml") // <1>
	class XmlJUnitJupiterSpringTests {
		// class body...
	}
----
<1> 指定配置文件的位置。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@SpringJUnitConfig(locations = ["/test-config.xml"]) // <1>
	class XmlJUnitJupiterSpringTests {
		// class body...
	}
----
<1> 指定配置文件的位置。

有关更多详细信息，请参见<<testcontext-ctx-management,上下文管理>>以及 {api-spring-framework}/test/context/junit/jupiter/SpringJUnitConfig.html[`@SpringJUnitConfig`]和 `@ContextConfiguration` 的javadoc。

[[integration-testing-annotations-junit-jupiter-springjunitwebconfig]]
===== `@SpringJUnitWebConfig`

`@SpringJUnitWebConfig` 是一个组合的注解，它将来自JUnit Jupiter的 `@ExtendWith(SpringExtension.class)` 与来自Spring TestContext Framework的 `@ContextConfiguration` 和 `@WebAppConfiguration` 组合在一起。
您可以在类级别使用它来替代 `@ContextConfiguration` 和 `@WebAppConfiguration`。 关于配置选项，`@ContextConfiguration` 和 `@SpringJUnitWebConfig` 之间的唯一区别是，您可以使用 `@SpringJUnitWebConfig` 中的 `value` 属性来声明组件类。
此外，仅通过使用 `@SpringJUnitWebConfig` 中的 `resourcePath` 属性，可以覆盖 `@WebAppConfiguration` 中的 `value` 属性。

以下示例显示如何使用 `@SpringJUnitWebConfig` 注解指定配置类：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@SpringJUnitWebConfig(TestConfig.class) // <1>
	class ConfigurationClassJUnitJupiterSpringWebTests {
		// class body...
	}
----
<1> 指定配置类。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@SpringJUnitWebConfig(TestConfig::class) // <1>
	class ConfigurationClassJUnitJupiterSpringWebTests {
		// class body...
	}
----
<1> 指定配置类。

以下示例显示如何使用 `@SpringJUnitWebConfig` 注解指定配置文件的位置：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@SpringJUnitWebConfig(locations = "/test-config.xml") // <1>
	class XmlJUnitJupiterSpringWebTests {
		// class body...
	}
----
<1> 指定配置文件的位置。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@SpringJUnitWebConfig(locations = ["/test-config.xml"]) // <1>
	class XmlJUnitJupiterSpringWebTests {
		// class body...
	}
----
<1> 指定配置文件的位置。

有关更多详细信息，请参见<<testcontext-ctx-management,上下文管理>> 以及 {api-spring-framework}/test/context/junit/jupiter/web/SpringJUnitWebConfig.html[`@SpringJUnitWebConfig`]，{api-spring-framework}/test/context/ContextConfiguration.html[`@ContextConfiguration`]和 {api-spring-framework}/test/context/web/WebAppConfiguration.html[`@WebAppConfiguration`]的javadoc。

[[integration-testing-annotations-testconstructor]]
===== `@TestConstructor`

`@TestConstructor` 是类型级别的注解，用于配置如何从测试的 `ApplicationContext` 中的组件自动连接测试类构造函数的参数。

如果在测试类上不存在 `@TestConstructor` 或不存在 meta-test，则将使用默认的测试构造函数自动装配模式。 有关如何更改默认模式的详细信息，请参见下面的提示。 但是请注意，构造函数上的 `@Autowired` 本地声明优先于 `@TestConstructor` 和默认模式。

.更改默认的测试构造函数自动装配模式
[TIP]
=====
可以通过将JVM系统属性 `spring.test.constructor.autowire.mode` 设置为 `all` 来更改默认的测试构造函数自动装配模式。 或者，可以通过 `SpringProperties` 机制更改默认模式。

如果未设置 `spring.test.constructor.autowire.mode` 属性，则测试类构造函数将不会自动进行自动装配。
=====

NOTE: 从Spring Framework 5.2开始，仅将 `@TestConstructor` 与 `SpringExtension` 结合使用以与JUnit Jupiter一起使用。 请注意，`SpringExtension` 通常会自动为您注册-例如，在使用 `@SpringJUnitConfig` 和 `@SpringJUnitWebConfig` 之类的注解或 Spring Boot Test中与测试相关的各种注解时。

[[integration-testing-annotations-junit-jupiter-enabledif]]
===== `@EnabledIf`

`@EnabledIf` 用于表示已注解的JUnit Jupiter测试类或测试方法已启用，如果提供的表达式的值为 `true`，则应运行 `@EnabledIf` 。 具体来说，如果表达式的计算结果为 `Boolean.TRUE` 或等于 `true` 的字符串（忽略大小写），则启用测试。 在类级别应用时，默认情况下也会自动启用该类中的所有测试方法。

表达式可以是以下任意一种：

* <<core.adoc#expressions, Spring Expression Language>> (SpEL) 表达式:
  `@EnabledIf("#{systemProperties['os.name'].toLowerCase().contains('mac')}")`
* Spring  <<core.adoc#beans-environment, `Environment`>>中可用属性的占位符。例如: `@EnabledIf("${smoke.tests.enabled}")`
* 文本文字: `@EnabledIf("true")`

但是请注意，不是属性占位符的动态解析结果的文本文字的实际值为零，因为 `@EnabledIf("false")` 等效于 `@Disabled`，而 `@EnabledIf("true")` 在逻辑上是没有意义的 。

您可以使用 `@EnabledIf` 作为元注解来创建自定义的组合注解。 例如，您可以创建一个自定义 `@EnabledOnMac` 注解，如下所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Target({ElementType.TYPE, ElementType.METHOD})
	@Retention(RetentionPolicy.RUNTIME)
	@EnabledIf(
		expression = "#{systemProperties['os.name'].toLowerCase().contains('mac')}",
		reason = "Enabled on Mac OS"
	)
	public @interface EnabledOnMac {}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Target(AnnotationTarget.TYPE, AnnotationTarget.FUNCTION)
	@Retention(AnnotationRetention.RUNTIME)
	@EnabledIf(
			expression = "#{systemProperties['os.name'].toLowerCase().contains('mac')}",
			reason = "Enabled on Mac OS"
	)
	annotation class EnabledOnMac {}
----

[[integration-testing-annotations-junit-jupiter-disabledif]]
===== `@DisabledIf`

`@DisabledIf` 用于表示已注解的JUnit Jupiter测试类或测试方法已禁用，并且如果提供的表达式求值为 `true`，则不应执行该操作。 具体来说，如果表达式的计算结果为 `Boolean.TRUE` 或等于 `true` 的String（忽略大小写），则测试将被禁用。 当在类级别应用时，该类中的所有测试方法也会自动禁用。

表达式可以是以下任意一种：

* <<core.adoc#expressions, Spring Expression Language>> (SpEL)表达式:
  `@DisabledIf("#{systemProperties['os.name'].toLowerCase().contains('mac')}")`
* Spring  <<core.adoc#beans-environment, `Environment`>>中可用属性的占位符。例如:: `@DisabledIf("${smoke.tests.disabled}")`
* 文本文字: `@DisabledIf("true")`

但是请注意，不是属性占位符动态解析的结果的文本文字的实际值为零，因为 `@DisabledIf("true")` 等效于 `@Disabled`，而 `@DisabledIf("false")` 在逻辑上是没有意义的 。

您可以使用 `@DisabledIf` 作为元注解来创建自定义的组合注解。 例如，您可以创建一个自定义 `@DisabledOnMac` 注解，如下所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Target({ElementType.TYPE, ElementType.METHOD})
	@Retention(RetentionPolicy.RUNTIME)
	@DisabledIf(
		expression = "#{systemProperties['os.name'].toLowerCase().contains('mac')}",
		reason = "Disabled on Mac OS"
	)
	public @interface DisabledOnMac {}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Target(AnnotationTarget.TYPE, AnnotationTarget.FUNCTION)
	@Retention(AnnotationRetention.RUNTIME)
	@DisabledIf(
			expression = "#{systemProperties['os.name'].toLowerCase().contains('mac')}",
			reason = "Disabled on Mac OS"
	)
	annotation class DisabledOnMac {}
----

[[integration-testing-annotations-meta]]
==== Meta-Annotation Support for Testing

可以将大部分测试相关的注解当作<<core.adoc#beans-meta-annotations, meta-annotations>>使用，以创建自定义组合注解来减少测试集中的重复配置。

下面的每个都可以在<<testcontext-framework, TestContext 框架>>中被当作meta-annotations使用。

* `@BootstrapWith`
* `@ContextConfiguration`
* `@ContextHierarchy`
* `@ActiveProfiles`
* `@TestPropertySource`
* `@DirtiesContext`
* `@WebAppConfiguration`
* `@TestExecutionListeners`
* `@Transactional`
* `@BeforeTransaction`
* `@AfterTransaction`
* `@Commit`
* `@Rollback`
* `@Sql`
* `@SqlConfig`
* `@SqlMergeMode`
* `@SqlGroup`
* `@Repeat` _(only supported on JUnit 4)_
* `@Timed` _(only supported on JUnit 4)_
* `@IfProfileValue` _(only supported on JUnit 4)_
* `@ProfileValueSourceConfiguration` _(only supported on JUnit 4)_
* `@SpringJUnitConfig` _(only supported on JUnit Jupiter)_
* `@SpringJUnitWebConfig` _(only supported on JUnit Jupiter)_
* `@TestConstructor` _(only supported on JUnit Jupiter)_
* `@EnabledIf` _(only supported on JUnit Jupiter)_
* `@DisabledIf` _(only supported on JUnit Jupiter)_

考虑以下示例：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RunWith(SpringRunner.class)
	@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
	@ActiveProfiles("dev")
	@Transactional
	public class OrderRepositoryTests { }

	@RunWith(SpringRunner.class)
	@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
	@ActiveProfiles("dev")
	@Transactional
	public class UserRepositoryTests { }
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RunWith(SpringRunner::class)
	@ContextConfiguration("/app-config.xml", "/test-data-access-config.xml")
	@ActiveProfiles("dev")
	@Transactional
	class OrderRepositoryTests { }

	@RunWith(SpringRunner::class)
	@ContextConfiguration("/app-config.xml", "/test-data-access-config.xml")
	@ActiveProfiles("dev")
	@Transactional
	class UserRepositoryTests { }
----

如果发现我们在基于JUnit 4的测试套件中重复了前面的配置，则可以通过引入一个自定义的组合注解来减少重复，该注解集中了Spring的通用测试配置，如下所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
	@ActiveProfiles("dev")
	@Transactional
	public @interface TransactionalDevTestConfig { }
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Target(AnnotationTarget.TYPE)
	@Retention(AnnotationRetention.RUNTIME)
	@ContextConfiguration("/app-config.xml", "/test-data-access-config.xml")
	@ActiveProfiles("dev")
	@Transactional
	annotation class TransactionalDevTestConfig { }
----

然后，我们可以使用我们的自定义 `@TransactionalDevTestConfig` 注解来简化基于单个JUnit 4的测试类的配置，如下所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RunWith(SpringRunner.class)
	@TransactionalDevTestConfig
	public class OrderRepositoryTests { }

	@RunWith(SpringRunner.class)
	@TransactionalDevTestConfig
	public class UserRepositoryTests { }
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RunWith(SpringRunner::class)
	@TransactionalDevTestConfig
	class OrderRepositoryTests

	@RunWith(SpringRunner::class)
	@TransactionalDevTestConfig
	class UserRepositoryTests
----

如果我们编写使用JUnit Jupiter的测试，则可以进一步减少代码重复，因为JUnit 5中的注解也可以用作元注解。考虑以下示例：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ExtendWith(SpringExtension.class)
	@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
	@ActiveProfiles("dev")
	@Transactional
	class OrderRepositoryTests { }

	@ExtendWith(SpringExtension.class)
	@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
	@ActiveProfiles("dev")
	@Transactional
	class UserRepositoryTests { }
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ExtendWith(SpringExtension::class)
	@ContextConfiguration("/app-config.xml", "/test-data-access-config.xml")
	@ActiveProfiles("dev")
	@Transactional
	class OrderRepositoryTests { }

	@ExtendWith(SpringExtension::class)
	@ContextConfiguration("/app-config.xml", "/test-data-access-config.xml")
	@ActiveProfiles("dev")
	@Transactional
	class UserRepositoryTests { }
----

如果我们发现要在基于JUnit Jupiter的测试套件中重复上述配置，则可以通过引入一个自定义的组合注解来减少重复，该注解集中了Spring和JUnit Jupiter的通用测试配置，如下所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@ExtendWith(SpringExtension.class)
	@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
	@ActiveProfiles("dev")
	@Transactional
	public @interface TransactionalDevTestConfig { }
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Target(AnnotationTarget.TYPE)
	@Retention(AnnotationRetention.RUNTIME)
	@ExtendWith(SpringExtension::class)
	@ContextConfiguration("/app-config.xml", "/test-data-access-config.xml")
	@ActiveProfiles("dev")
	@Transactional
	annotation class TransactionalDevTestConfig { }
----

然后，我们可以使用我们的自定义 `@TransactionalDevTestConfig` 注解来简化基于单个JUnit Jupiter的测试类的配置，如下所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@TransactionalDevTestConfig
	class OrderRepositoryTests { }

	@TransactionalDevTestConfig
	class UserRepositoryTests { }
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@TransactionalDevTestConfig
	class OrderRepositoryTests { }

	@TransactionalDevTestConfig
	class UserRepositoryTests { }
----

由于JUnit Jupiter支持使用 `@Test`，`@RepeatedTest`，`ParameterizedTest` 和其他作为元注解，因此您还可以在测试方法级别创建自定义的组合注解。 例如，如果我们希望创建一个组合的注解，将JUnit Jupiter的 `@Test` 和 `@Tag` 注解与Spring的 `@Transactional` 注解相结合，则可以创建一个 `@TransactionalIntegrationTest` 注解，如下所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Target(ElementType.METHOD)
	@Retention(RetentionPolicy.RUNTIME)
	@Transactional
	@Tag("integration-test") // org.junit.jupiter.api.Tag
	@Test // org.junit.jupiter.api.Test
	public @interface TransactionalIntegrationTest { }
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Target(AnnotationTarget.TYPE)
	@Retention(AnnotationRetention.RUNTIME)
	@Transactional
	@Tag("integration-test") // org.junit.jupiter.api.Tag
	@Test // org.junit.jupiter.api.Test
	annotation class TransactionalIntegrationTest { }
----

然后，我们可以使用我们的自定义 `@TransactionalIntegrationTest` 注解来简化基于JUnit Jupiter的各个测试方法的配置，如下所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@TransactionalIntegrationTest
	void saveOrder() { }

	@TransactionalIntegrationTest
	void deleteOrder() { }
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@TransactionalIntegrationTest
	fun saveOrder() { }

	@TransactionalIntegrationTest
	fun deleteOrder() { }
----

有关更多详细信息，请参见 https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model[Spring Annotation编程模型]Wiki页面。

[[testcontext-framework]]
=== Spring TestContext 框架

Spring TestContext Framework（位于 `org.springframework.test.context`` 包中）提供了通用的，注解驱动的单元和集成测试支持，这些支持与所使用的测试框架无关。 TestContext框架还非常重视约定优于配置，您可以通过基于注解的配置覆盖合理的默认值。

除了通用测试基础结构之外，TestContext框架还为JUnit 4，JUnit Jupiter（AKA JUnit 5）和TestNG提供了显式支持。 对于JUnit 4和TestNG，Spring提供了抽象支持类。 此外，Spring为JUnit 4提供了自定义JUnit `Runner` 和自定义JUnit  `Rules` ，以及JUnit Jupiter的自定义扩展，
可让您编写所谓的POJO测试类。 不需要POJO测试类来扩展特定的类层次结构，例如抽象支持类。

以下部分概述了TestContext框架的内部。 如果您只对使用框架感兴趣，而对使用自己的自定义监听器或自定义加载程序进行扩展不感兴趣，请直接转到配置（<<testcontext-ctx-management, 上下文管理>>,
<<testcontext-fixture-di, 依赖注入>>, <<testcontext-tx,事务管理>>），<<testcontext-support-classes, 支持类>>和<<integration-testing-annotations, 注解支持>>部分。


[[testcontext-key-abstractions]]
==== Key 抽象

该框架的核心由 `TestContextManager` 类和 `TestContext`，`TestExecutionListener` 和 `SmartContextLoader` 接口组成。 为每个测试类创建一个 `TestContextManager`（例如，用于在JUnit Jupiter中的单个测试类中执行所有测试方法）。
反过来，`TestContextManager` 管理一个 `TestContext`，它保存当前测试的上下文。 随着测试的进行，`TestContextManager` 还更新了 `TestContext` 的状态，并委托给 `TestExecutionListener` 实现，该实现通过提供依赖项注入，管理事务等来检测实际的测试执行。
`SmartContextLoader``负责为给定的测试类加载 `ApplicationContext`。 有关更多信息和各种实现的示例，请参见 {api-spring-framework}/test/context/package-summary.html[javadoc]和Spring测试套件。

===== `TestContext`

`TestContext` 封装了在其中执行测试的上下文（与使用中的实际测试框架无关），并为其负责的测试实例提供了上下文管理和缓存支持。 如果需要，`TestContext` 还委托给 `SmartContextLoader` 来加载 `ApplicationContext`。

===== `TestContextManager`

`TestContextManager` 是Spring `TestContext` Framework的主要入口点，并负责管理单个 `TestContext` 并在定义良好的测试执行点向每个注册的 `TestExecutionListener` 发出事件信号：

* 在特定测试框架的任何 "`before class`""`before all`"  方法之前。 测试实例后处理。
* 测试实例后处理。
* 在特定测试框架的任何 "`before`" 或 "`before each`" 方法之前。
* 在执行测试方法之前但在测试设置之后。
* 在执行测试方法之后但立即将测试拆解。
* 在特定测试框架的任何 "`after`" 或  "`after each`"  方法之后。
* 在特定测试框架的任何 "`after class`" 或 "`after all`" 方法之后

===== `TestExecutionListener`

`TestExecutionListener` 定义用于对由注册监听器的 `TestContextManager` 发布的测试执行事件做出反应的API。请参阅 <<testcontext-tel-config,TestExecutionListener 配置>>。

===== Context Loaders

`ContextLoader` 是一个策略接口，用于为 Spring TestContext Framework 管理的集成测试加载 `ApplicationContext`。 您应该实现 `SmartContextLoader` 而不是此接口，以提供对组件类，活动bean定义配置文件，测试属性源，上下文层次结构和 `WebApplicationContext` 支持的支持。

`SmartContextLoader` 是 `ContextLoader` 接口的扩展，它取代了原始的最小 `ContextLoader` SPI。 具体来说，`SmartContextLoader` 可以选择处理资源位置，组件类或上下文初始化程序。 此外，`SmartContextLoader` 可以在其加载的上下文中设置活动的Bean定义配置文件并测试属性源。

Spring提供了以下实现：

* `DelegatingSmartContextLoader`: 这是两个默认加载器之一，它在内部委派给 `AnnotationConfigContextLoader`，`GenericXmlContextLoader` 或 `GenericGroovyXmlContextLoader`，具体取决于为测试类声明的配置或默认位置或默认配置类的存在。 仅当Groovy在类路径上时才启用Groovy支持。
* `WebDelegatingSmartContextLoader`: 这是两个默认加载器之一，它在内部委派给 `AnnotationConfigWebContextLoader`，`GenericXmlWebContextLoader` 或 `GenericGroovyXmlWebContextLoader`，具体取决于为测试类声明的配置或默认位置或默认配置类的存在。 仅当测试类上存在 `@WebAppConfiguration` 时，才使用Web `ContextLoader`。 仅当Groovy在类路径上时才启用Groovy支持。
* `AnnotationConfigContextLoader`: 从组件类加载标准 `ApplicationContext`。
* `AnnotationConfigWebContextLoader`: 从组件类加载 `WebApplicationContext`。
* `GenericGroovyXmlContextLoader`: 从Groovy脚本或XML配置文件的资源位置加载标准 `ApplicationContext`。
* `GenericGroovyXmlWebContextLoader`: 从Groovy脚本或XML配置文件的资源位置加载 `WebApplicationContext`。
* `GenericXmlContextLoader`: 从XML资源位置加载标准 `ApplicationContext`。
* `GenericXmlWebContextLoader`: 从XML资源位置加载 `WebApplicationContext`。
* `GenericPropertiesContextLoader`: 从Java属性文件加载标准 `ApplicationContext`。


[[testcontext-bootstrapping]]
==== 引导TestContext框架

Spring TestContext Framework内部的默认配置足以满足所有常见用例。 但是，有时开发团队或第三方框架希望更改默认的 `ContextLoader`，实现自定义的 `TestContext` 或 `ContextCache`，扩展默认的 `ContextCustomizerFactory` 和 `TestExecutionListener` 实现集，等等。
为了对 TestContext 框架的运行方式进行低级控制，Spring提供了自举策略。

`TestContextBootstrapper` 定义了用于引导TestContext框架的SPI。 `TestContextManager` 使用 `TestContextBootstrapper` 加载当前测试的 `TestExecutionListener` 实现，并构建它管理的 TestContext。 您可以直接使用 `@BootstrapWith` 或作为元注解，为测试类（或测试类层次结构）配置自定义引导策略。 如果没有使用 `@BootstrapWith` 显式配置引导程序，则根据 `@WebAppConfiguration` 的存在，使用 `DefaultTestContextBootstrapper` 或 `WebTestContextBootstrapper`。

由于 `TestContextBootstrapper` SPI将来可能会更改（以适应新要求），因此我们强烈建议实现者不要直接实现此接口，而应扩展 `AbstractTestContextBootstrapper` 或其具体子类之一。


[[testcontext-tel-config]]
==== `TestExecutionListener` 配置

Spring提供了以下 `TestExecutionListener` 实现，这些实现默认情况下按以下顺序注册：

* `ServletTestExecutionListener`: 为 `WebApplicationContext` 配置Servlet API模拟。
* `DirtiesContextBeforeModesTestExecutionListener`: 处理 `@DirtiesContext` 注解的 "before" 模式。
* `DependencyInjectionTestExecutionListener`: 为测试实例提供依赖项注入。
* `DirtiesContextTestExecutionListener`: 处理 "after" 模式的 `@DirtiesContext` 注解。
* `TransactionalTestExecutionListener`: 提供具有默认回滚语义的事务测试执行。
* `SqlScriptsTestExecutionListener`: 运行使用@Sql注解配置的SQL脚本。
* `EventPublishingTestExecutionListener`: 将测试执行事件发布到测试的 `ApplicationContext` 中（请参阅<<testcontext-test-execution-events,测试执行事件>>）。

[[testcontext-tel-config-registering-tels]]
===== 注册 `TestExecutionListener` 实现

您可以使用 `@TestExecutionListeners` 注解为测试类及其子类注册 `TestExecutionListener` 实现。有关详细信息和示例，请参见<<integration-testing-annotations, 注解支持>>和 {api-spring-framework}/test/context/TestExecutionListeners.html[`@TestExecutionListeners`] 的javadoc。

[[testcontext-tel-config-automatic-discovery]]
===== 自动发现默认的 `TestExecutionListener` 实现

通过使用 `@TestExecutionListeners` 注册 `TestExecutionListener` 实现适用于在有限的测试方案中使用的自定义监听器。 但是，如果需要在整个测试套件中使用自定义监听器，则可能会变得很麻烦。
通过支持通过 `SpringFactoriesLoader` 机制自动发现默认的 `TestExecutionListener` 实现，解决了此问题。

具体来说，`spring-test` 模块在其 `META-INF/spring.factories` 属性文件中的 `org.springframework.test.context.TestExecutionListener` 项下声明所有核心默认 `TestExecutionListener` 实现。
第三方框架和开发人员可以通过自己的 `META-INF/spring.factories` 属性文件以相同的方式将自己的 `TestExecutionListener` 实现贡献到默认监听器列表中。

[[testcontext-tel-config-ordering]]
===== 排序 `TestExecutionListener` 实现

当TestContext框架通过<<testcontext-tel-config-automatic-discovery, 上述>> `SpringFactoriesLoader` 机制发现默认的 `TestExecutionListener` 实现时，实例化的监听器将使用Spring的 `AnnotationAwareOrderComparator` 进行排序，该类将使用Spring的 `Ordered` 接口和 `@Order` 注解进行排序。
Spring提供的 `AbstractTestExecutionListener` 和所有默认的 `TestExecutionListener` 实现以适当的值实现 `Ordered`。 因此，第三方框架和开发人员应通过实施 `Ordered` 或声明 `@Order` 来确保以默认顺序注册其默认的 `TestExecutionListener` 实现。
请参阅javadoc以获取核心默认 `TestExecutionListener` 实现的 `getOrder()` 方法，以获取有关为每个核心监听器分配哪些值的详细信息。

[[testcontext-tel-config-merging]]
===== 合并 `TestExecutionListener` 实现

如果通过 `@TestExecutionListeners` 注册了自定义 `TestExecutionListener`，则不会注册默认监听器。 在大多数常见的测试方案中，这有效地迫使开发人员手动声明除任何自定义监听器之外的所有默认监听器。 下面的清单演示了这种配置样式：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ContextConfiguration
	@TestExecutionListeners({
		MyCustomTestExecutionListener.class,
		ServletTestExecutionListener.class,
		DirtiesContextBeforeModesTestExecutionListener.class,
		DependencyInjectionTestExecutionListener.class,
		DirtiesContextTestExecutionListener.class,
		TransactionalTestExecutionListener.class,
		SqlScriptsTestExecutionListener.class
	})
	class MyTest {
		// class body...
	}
----

[source,java,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ContextConfiguration
	@TestExecutionListeners(
		MyCustomTestExecutionListener::class,
		ServletTestExecutionListener::class,
		DirtiesContextBeforeModesTestExecutionListener::class,
		DependencyInjectionTestExecutionListener::class,
		DirtiesContextTestExecutionListener::class,
		TransactionalTestExecutionListener::class,
		SqlScriptsTestExecutionListener::class
	)
	class MyTest {
		// class body...
	}
----

这种方法的挑战在于，它要求开发人员确切地知道默认情况下注册了哪些监听器。 此外，默认的监听器集可以随版本的不同而变化-例如，Spring Framework 4.1中引入了 `SqlScriptsTestExecutionListener`，
而Spring Framework 4.2中引入了 `DirtiesContextBeforeModesTestExecutionListener`。 此外，诸如Spring Boot和Spring Security之类的第三方框架通过使用上述自动发现机制注册了自己的默认 `TestExecutionListener` 实现。

为避免必须了解并重新声明所有默认监听器，可以将 `@TestExecutionListeners` 的 `mergeMode` 属性设置为 `MergeMode.MERGE_WITH_DEFAULTS`。 MERGE_WITH_DEFAULTS指示应将本地声明的监听器与默认监听器合并。
合并算法可确保从列表中删除重复项，并确保根据 `AnnotationAwareOrderComparator` 的语义对合并的监听器集进行排序，如  <<testcontext-tel-config-ordering,排序 `TestExecutionListener` 实现>>中所述。 如果监听器实现 `Ordered` 或使用 `@Order` 进行注解，则它可以影响将其与默认值合并的位置。
否则，合并时，本地声明的监听器将追加到默认监听器列表中。

例如，如果上一个示例中的 `MyCustomTestExecutionListener` 类将其顺序值（例如 `500`）配置为小于 `ServletTestExecutionListener` 的顺序（恰好是 `1000`），则可以将 `MyCustomTestExecutionListener` 自动与默认列表合并。
在 `ServletTestExecutionListener` 前面，并且前面的示例可以替换为以下内容：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ContextConfiguration
	@TestExecutionListeners(
		listeners = MyCustomTestExecutionListener.class,
		mergeMode = MERGE_WITH_DEFAULTS
	)
	class MyTest {
		// class body...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ContextConfiguration
	@TestExecutionListeners(
			listeners = [MyCustomTestExecutionListener::class],
			mergeMode = MERGE_WITH_DEFAULTS
	)
	class MyTest {
		// class body...
	}
----

[[testcontext-test-execution-events]]
==== 测试执行事件

Spring Framework 5.2中引入的 `EventPublishingTestExecutionListener` 提供了一种实现自定义 `TestExecutionListener` 的替代方法。 测试的 `ApplicationContext` 中的组件可以侦听 `EventPublishingTestExecutionListener` 发布的以下事件，
每个事件都与 `TestExecutionListener` API中的方法相对应。

* `BeforeTestClassEvent`
* `PrepareTestInstanceEvent`
* `BeforeTestMethodEvent`
* `BeforeTestExecutionEvent`
* `AfterTestExecutionEvent`
* `AfterTestMethodEvent`
* `AfterTestClassEvent`

NOTE: 仅当 `ApplicationContext` 已加载时才发布这些事件。

这些事件可能由于各种原因而被消耗，例如重置模拟bean或跟踪测试执行。 使用测试执行事件而不是实现自定义 `TestExecutionListener` 的一个优点是，测试执行事件可以被测试 `ApplicationContext` 中注册的任何Spring bean所消耗，并且此类bean可以直接受益于依赖项注入和 `ApplicationContext` 的其他功能。 相反，`TestExecutionListener` 不是 `ApplicationContext` 中的bean。

为了监听测试执行事件，Spring bean可以选择实现 `org.springframework.context.ApplicationListener` 接口。 另外，可以使用 `@EventListener` 注解监听器方法，并将监听器方法配置为侦听上面列出的特定事件类型之一（请参阅<<core.adoc#context-functionality-events-annotation, 基于注解的事件监听器>>）。 由于这种方法的流行，Spring提供了以下专用的 `@EventListener` 注解，以简化测试执行事件监听器的注册。 这些注解驻留在 `org.springframework.test.context.event.annotation` 包中。

* `@BeforeTestClass`
* `@PrepareTestInstance`
* `@BeforeTestMethod`
* `@BeforeTestExecution`
* `@AfterTestExecution`
* `@AfterTestMethod`
* `@AfterTestClass`

[[testcontext-test-execution-events-exception-handling]]
===== 异常处理

默认情况下，如果测试执行事件监听器在使用事件时抛出异常，则该异常将传播到使用中的基础测试框架（例如JUnit或TestNG）。 例如，如果使用 `BeforeTestMethodEvent` 导致异常，则相应的测试方法将由于异常而失败。 相反，如果异步测试执行事件监听器引发异常，则该异常不会传播到基础测试框架。 有关异步异常处理的更多详细信息，请查阅 `@EventListener` 的类级javadoc。

[[testcontext-test-execution-events-async]]
===== 异步监听器

如果您希望特定的测试执行事件监听器异步处理事件，则可以使用Spring的常规 `@Async` 支持。有关更多详细信息，请查阅 `@EventListener` 的类级javadoc。

[[testcontext-ctx-management]]
==== 上下文管理

每个 `TestContext` 为其负责的测试实例提供上下文管理和缓存支持。 测试实例不会自动接收对配置的 `ApplicationContext` 的访问。 但是，如果测试类实现 `ApplicationContextAware` 接口，则将对 `ApplicationContext` 的引用提供给测试实例。 请注意，`AbstractJUnit4SpringContextTests` 和 `AbstractTestNGSpringContextTests` 实现了 `ApplicationContextAware`，因此可以自动提供对 `ApplicationContext` 的访问。

.@Autowired ApplicationContext
[TIP]
=====
作为实现 `ApplicationContextAware` 接口的替代方法，您可以通过字段或 `setter` 方法上的 `@Autowired` 注解为测试类注入应用程序上下文，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@SpringJUnitConfig
	class MyTest {

		@Autowired // <1>
		ApplicationContext applicationContext;

		// class body...
	}
----
<1> Injecting the `ApplicationContext`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@SpringJUnitConfig
	class MyTest {

		@Autowired // <1>
		lateinit var applicationContext: ApplicationContext

		// class body...
	}
----
<1> Injecting the `ApplicationContext`.


同样，如果将测试配置为加载 `WebApplicationContext`，则可以将Web应用程序上下文注入到测试中，如下所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@SpringJUnitWebConfig // <1>
	class MyWebAppTest {

		@Autowired // <2>
		WebApplicationContext wac;

		// class body...
	}
----
<1> Configuring the `WebApplicationContext`.
<2> Injecting the `WebApplicationContext`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@SpringJUnitWebConfig // <1>
	class MyWebAppTest {

		@Autowired // <2>
		lateinit var wac: WebApplicationContext
		// class body...
	}
----
<1> Configuring the `WebApplicationContext`.
<2> Injecting the `WebApplicationContext`.


使用 `@Autowired` 的依赖项注入由 `DependencyInjectionTestExecutionListener` 提供，它是默认配置的（请参阅<<testcontext-fixture-di,测试夹具的依赖项注入>>）。
=====

使用TestContext框架的测试类不需要扩展任何特定的类或实现特定的接口来配置其应用程序上下文。 而是通过在类级别声明 `@ContextConfiguration` 注解来实现配置。 如果您的测试类未明确声明应用程序上下文资源位置或组件类，则配置的 `ContextLoader` 决定如何从默认位置或默认配置类加载上下文。 除了上下文资源位置和组件类之外，还可以通过应用程序上下文初始化程序配置应用程序上下文。

以下各节说明如何使用Spring的 `@ContextConfiguration` 注解通过XML配置文件，Groovy脚本，组件类（通常为 `@Configuration` 类）或上下文初始化器来配置测试 `ApplicationContext`。 另外，您可以为高级用例实现和配置自己的自定义 `SmartContextLoader`。

* <<testcontext-ctx-management-xml,使用XML资源进行上下文配置>>
* <<testcontext-ctx-management-groovy,使用Groovy脚本进行上下文配置>>
* <<testcontext-ctx-management-javaconfig,使用组件类进行上下文配置>>
* <<testcontext-ctx-management-mixed-config,混合XML，Groovy脚本和组件类>>
* <<testcontext-ctx-management-initializers,使用上下文初始化器进行上下文配置>>
* <<testcontext-ctx-management-inheritance,上下文配置继承>>
* <<testcontext-ctx-management-env-profiles,使用环境配置文件进行上下文配置>>
* <<testcontext-ctx-management-property-sources,具有测试属性源的上下文配置>>
* <<testcontext-ctx-management-web,加载 `WebApplicationContext`>>
* <<testcontext-ctx-management-caching,上下文缓存>>
* <<testcontext-ctx-management-ctx-hierarchies,上下文层次结构>>

[[testcontext-ctx-management-xml]]
===== 使用XML资源进行上下文配置

若要使用XML配置文件为测试加载 `ApplicationContext`，请使用 `@ContextConfiguration` 注解测试类，并使用包含XML配置元数据的资源位置的数组配置 `locations` 属性。 普通或相对路径（例如 `context.xml`）被视为相对于定义测试类的程序包的类路径资源。
以斜杠开头的路径被视为绝对类路径位置（例如， `/org/example/config.xml`）。 照原样使用表示资源URL的路径（即，以 `classpath:`， `file:`，`http:` 等开头的路径）。

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ExtendWith(SpringExtension.class)
	// ApplicationContext will be loaded from "/app-config.xml" and
	// "/test-config.xml" in the root of the classpath
	@ContextConfiguration(locations={"/app-config.xml", "/test-config.xml"}) // <1>
	class MyTest {
		// class body...
	}
----
<1> 将 `locations` 属性设置为XML文件列表。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ExtendWith(SpringExtension::class)
	// ApplicationContext will be loaded from "/app-config.xml" and
	// "/test-config.xml" in the root of the classpath
	@ContextConfiguration("/app-config.xml", "/test-config.xml") // <1>
	class MyTest {
		// class body...
	}
----
<1> 将 `locations` 属性设置为XML文件列表。

`@ContextConfiguration` 通过标准Java值属性为 `locations` 属性支持别名。 因此，如果不需要在 `@ContextConfiguration` 中声明其他属性，则可以使用以下示例中演示的速记格式，省略 `locations` 属性名称的声明并声明资源位置：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ExtendWith(SpringExtension.class)
	@ContextConfiguration({"/app-config.xml", "/test-config.xml"}) <1>
	class MyTest {
		// class body...
	}
----
<1> 在不使用 `location` 属性的情况下指定XML文件。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ExtendWith(SpringExtension::class)
	@ContextConfiguration("/app-config.xml", "/test-config.xml") // <1>
	class MyTest {
		// class body...
	}
----
<1> 在不使用 `location` 属性的情况下指定XML文件。

如果您从 `@ContextConfiguration` 注解中省略了位置和值属性，则TestContext框架将尝试检测默认的XML资源位置。 具体来说，`GenericXmlContextLoader` 和 `GenericXmlWebContextLoader` 根据测试类的名称检测默认位置。
如果您的类名为 `com.example.MyTest`，则 `GenericXmlContextLoader` 将从 `"classpath:com/example/MyTest-context.xml"` 加载应用程序上下文。 以下示例显示了如何执行此操作：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ExtendWith(SpringExtension.class)
	// ApplicationContext will be loaded from
	// "classpath:com/example/MyTest-context.xml"
	@ContextConfiguration // <1>
	class MyTest {
		// class body...
	}
----
<1> 从默认位置加载配置。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ExtendWith(SpringExtension::class)
	// ApplicationContext will be loaded from
	// "classpath:com/example/MyTest-context.xml"
	@ContextConfiguration // <1>
	class MyTest {
		// class body...
	}
----
<1> 从默认位置加载配置。


[[testcontext-ctx-management-groovy]]
===== 使用Groovy脚本进行上下文配置

要通过使用使用<<core.adoc#groovy-bean-definition-dsl, Groovy Bean定义DSL>>的Groovy脚本为测试加载 `ApplicationContext`，可以使用 `@ContextConfiguration` 注解测试类，并使用包含Groovy脚本资源位置的数组配置 `location` 或 `value` 属性。 Groovy脚本的资源查找语义与针对<<testcontext-ctx-management-xml, XML配置文件>>描述的语义相同。

.启用Groovy脚本支持
TIP: 如果Groovy位于类路径上，则会自动启用对使用Groovy脚本在Spring TestContext Framework中加载 `ApplicationContext` 的支持。

下面的示例显示如何指定Groovy配置文件：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ExtendWith(SpringExtension.class)
	// ApplicationContext will be loaded from "/AppConfig.groovy" and
	// "/TestConfig.groovy" in the root of the classpath
	@ContextConfiguration({"/AppConfig.groovy", "/TestConfig.Groovy"}) <1>
	class MyTest {
		// class body...
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ExtendWith(SpringExtension::class)
	// ApplicationContext will be loaded from "/AppConfig.groovy" and
	// "/TestConfig.groovy" in the root of the classpath
	@ContextConfiguration("/AppConfig.groovy", "/TestConfig.Groovy") // <1>
	class MyTest {
		// class body...
	}
----
<1> 指定Groovy配置文件的位置。

如果您从 `@ContextConfiguration` 注解中省略了 `location` 和 `value` 属性，则TestContext框架将尝试检测默认的Groovy脚本。 具体来说，`GenericGroovyXmlContextLoader` 和 `GenericGroovyXmlWebContextLoader` 根据测试类的名称检测默认位置。
如果您的类名为 `com.example.MyTest`，则Groovy上下文加载器将从 `"classpath:com/example/MyTestContext.groovy"` 加载应用程序上下文。 以下示例显示如何使用默认值：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ExtendWith(SpringExtension.class)
	// ApplicationContext will be loaded from
	// "classpath:com/example/MyTestContext.groovy"
	@ContextConfiguration // <1>
	class MyTest {
		// class body...
	}
----
<1> 从默认位置加载配置。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ExtendWith(SpringExtension::class)
	// ApplicationContext will be loaded from
	// "classpath:com/example/MyTestContext.groovy"
	@ContextConfiguration // <1>
	class MyTest {
		// class body...
	}
----
<1> 从默认位置加载配置。


.同时声明XML配置和Groovy脚本
[TIP]
=====
您可以使用 `@ContextConfiguration` 的 `location` 或 `value` 属性同时声明XML配置文件和Groovy脚本。 如果到已配置资源位置的路径以.xml结尾，则使用 `XmlBeanDefinitionReader` 加载该路径。 否则，将使用 `GroovyBeanDefinitionReader` 加载它。

以下清单显示了如何在集成测试中将两者结合在一起：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ExtendWith(SpringExtension.class)
	// ApplicationContext will be loaded from
	// "/app-config.xml" and "/TestConfig.groovy"
	@ContextConfiguration({ "/app-config.xml", "/TestConfig.groovy" })
	class MyTest {
		// class body...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ExtendWith(SpringExtension::class)
	// ApplicationContext will be loaded from
	// "/app-config.xml" and "/TestConfig.groovy"
	@ContextConfiguration("/app-config.xml", "/TestConfig.groovy")
	class MyTest {
		// class body...
	}
----
=====

[[testcontext-ctx-management-javaconfig]]
===== 使用组件类进行上下文配置

若要使用组件类（请参见<<core.adoc#beans-java, 基于Java的容器配置>>）为测试加载 `ApplicationContext`，可以使用 `@ContextConfiguration` 注解测试类，并使用包含对组件类的引用的数组来配置 `classes` 属性。 以下示例显示了如何执行此操作：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ExtendWith(SpringExtension.class)
	// ApplicationContext will be loaded from AppConfig and TestConfig
	@ContextConfiguration(classes = {AppConfig.class, TestConfig.class}) // <1>
	class MyTest {
		// class body...
	}
----
<1> 指定组件类。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ExtendWith(SpringExtension::class)
	// ApplicationContext will be loaded from AppConfig and TestConfig
	@ContextConfiguration(classes = [AppConfig::class, TestConfig::class]) // <1>
	class MyTest {
		// class body...
	}
----
<1> 指定组件类。


[[testcontext-ctx-management-javaconfig-component-classes]]
.组件类
[TIP]
====
术语 "`组件类`" 可以指以下任何一种：

* 一个带有 `@Configuration` 注解的类。
* 一个组件(也就是说，一个用 `@Component`， `@Service`， `@Repository`，或者其他 stereotype  注解的类)。
* 一个JSR-330兼容的类，用 `javax.inject` 注解。
* 包含 `@bean` -方法的任何类。
* 打算注册为Spring组件的任何其他类（即 `ApplicationContext` 中的Spring bean），可能利用单个自动构造函数的自动自动装配而无需使用Spring注解。

有关组件类的配置和语义的更多信息，请参见 {api-spring-framework}/context/annotation/Configuration.html[`@Configuration`] 和 {api-spring-framework}/context/annotation/Bean.html[`@Bean`] 的javadoc，尤其要注意 `@Bean` Lite Mode的讨论。
====

如果从 `@ContextConfiguration` 注解中省略了 `classes` 属性，则TestContext框架将尝试检测默认配置类的存在。 具体来说，`AnnotationConfigContextLoader` 和 `AnnotationConfigWebContextLoader` 将检测测试类的所有静态嵌套类，这些静态嵌套类满足配置类实现的要求，
如 {api-spring-framework}/context/annotation/Configuration.html[`@Configuration`] javadoc中所指定。 请注意，配置类的名称是任意的。 此外，如果需要，测试类可以包含多个静态嵌套配置类。 在以下示例中，`OrderServiceTest` 类声明一个名为 `Config` 的静态嵌套配置类，该配置类将自动用于为测试类加载 `ApplicationContext`：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@SpringJUnitConfig <1>
	// ApplicationContext will be loaded from the
	// static nested Config class
	class OrderServiceTest {

		@Configuration
		static class Config {

			// this bean will be injected into the OrderServiceTest class
			@Bean
			OrderService orderService() {
				OrderService orderService = new OrderServiceImpl();
				// set properties, etc.
				return orderService;
			}
		}

		@Autowired
		OrderService orderService;

		@Test
		void testOrderService() {
			// test the orderService
		}

	}
----
<1> 从嵌套的 `Config` 类中加载配置信息。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@SpringJUnitConfig <1>
	// ApplicationContext will be loaded from the nested Config class
	class OrderServiceTest {

		@Autowired
		lateinit var orderService: OrderService

		@Configuration
		class Config {

			// this bean will be injected into the OrderServiceTest class
			@Bean
			fun orderService(): OrderService {
				// set properties, etc.
				return OrderServiceImpl()
			}
		}

		@Test
		fun testOrderService() {
			// test the orderService
		}
	}
----
<1> 从嵌套的 `Config` 类中加载配置信息。


[[testcontext-ctx-management-mixed-config]]
===== 混合XML，Groovy脚本和组件类

有时可能需要混合使用XML配置文件，Groovy脚本和组件类（通常为 `@Configuration` 类）来为测试配置 `ApplicationContext`。 例如，如果您在生产中使用XML配置，则可以决定要使用 `@Configuration` 类为测试配置特定的Spring托管组件，反之亦然。

此外，某些第三方框架（例如Spring Boot）提供了一流的支持，可以同时从不同类型的资源（例如XML配置文件，Groovy脚本和 `@Configuration` 类）中加载 `ApplicationContext`。 过去，Spring框架不支持此标准部署。
因此，Spring框架在 `spring-test` 模块中提供的大多数 `SmartContextLoader` 实现对于每个测试上下文仅支持一种资源类型。 但是，这并不意味着您不能同时使用两者。 通用规则的一个例外是 `GenericGroovyXmlContextLoader` 和 `GenericGroovyXmlWebContextLoader` 同时支持XML配置文件和Groovy脚本。
此外，第三方框架可以选择通过 `@ContextConfiguration` 支持位置和类的声明，并且，借助TestContext框架中的标准测试支持，您可以选择以下选项。

如果要使用资源位置（例如XML或Groovy）和 `@Configuration` 类来配置测试，则必须选择一个作为入口点，并且其中一个必须包含或导入另一个。 例如，在XML或Groovy脚本中，可以通过使用组件扫描或将它们定义为普通的Spring bean来包括 `@Configuration` 类，而在 `@Configuration` 类中，
可以使用 `@ImportResource` 导入XML配置文件或Groovy脚本。 请注意，此行为在语义上等同于您在生产环境中配置应用程序的方式：在生产配置中，您定义了一组XML或Groovy资源位置或一组 `@Configuration` 类，
从中加载了生产 `ApplicationContext`，但是您仍然拥有 包含或导入其他类型配置的自由。

[[testcontext-ctx-management-initializers]]
===== 使用上下文初始化器进行上下文配置

若要使用上下文初始化程序为测试配置 `ApplicationContext`，请使用 `@ContextConfiguration` 注解测试类，并使用包含对实现 `ApplicationContextInitializer` 的类的引用的数组配置初始化程序属性。
然后，使用声明的上下文初始值设定项来初始化为测试加载的 `ConfigurableApplicationContext`。
请注意，每个声明的初始化程序支持的具体 `ConfigurableApplicationContext` 类型必须与使用中的 `SmartContextLoader` 创建的 `ApplicationContext` 类型（通常是 `GenericApplicationContext`）兼容。
此外，初始化程序的调用顺序取决于它们是实现Spring的 `Ordered` 接口还是用Spring的 `@Order` 注解或标准的 `@Priority` 注解进行注解。 以下示例显示如何使用初始化程序：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ExtendWith(SpringExtension.class)
	// ApplicationContext will be loaded from TestConfig
	// and initialized by TestAppCtxInitializer
	@ContextConfiguration(
		classes = TestConfig.class,
		initializers = TestAppCtxInitializer.class) // <1>
	class MyTest {
		// class body...
	}
----
<1> 使用配置类和初始化程序指定配置。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ExtendWith(SpringExtension::class)
	// ApplicationContext will be loaded from TestConfig
	// and initialized by TestAppCtxInitializer
	@ContextConfiguration(
			classes = [TestConfig::class],
			initializers = [TestAppCtxInitializer::class]) // <1>
	class MyTest {
		// class body...
	}
----
<1> 使用配置类和初始化程序指定配置。

您还可以完全省略 `@ContextConfiguration` 中的XML配置文件，Groovy脚本或组件类的声明，而仅声明 `ApplicationContextInitializer` 类，然后这些类负责在上下文中注册Bean（例如，通过编程方式从XML文件加载Bean定义） 或配置类。 以下示例显示了如何执行此操作：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ExtendWith(SpringExtension.class)
	// ApplicationContext will be initialized by EntireAppInitializer
	// which presumably registers beans in the context
	@ContextConfiguration(initializers = EntireAppInitializer.class) <1>
	class MyTest {
		// class body...
	}
----
<1> 仅使用初始化程序来指定配置。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ExtendWith(SpringExtension::class)
	// ApplicationContext will be initialized by EntireAppInitializer
	// which presumably registers beans in the context
	@ContextConfiguration(initializers = [EntireAppInitializer::class]) // <1>
	class MyTest {
		// class body...
	}
----
<1> 仅使用初始化程序来指定配置。


[[testcontext-ctx-management-inheritance]]
===== 上下文配置继承

`@ContextConfiguration` 支持布尔值继承位置和 `InheritInitializers` 属性，这些属性指示是否应继承资源位置或组件类以及超类声明的上下文初始化器。 这两个标志的默认值为 `true`。 这意味着测试类将继承资源位置或组件类以及任何超类声明的上下文初始化器。
具体地说，将测试类的资源位置或组件类附加到由超类声明的资源位置或带注解的类的列表中。 同样，将给定测试类的初始化程序添加到由测试超类定义的初始化程序集。 因此，子类可以选择扩展资源位置，组件类或上下文初始化程序。

如果 `@ContextConfiguration` 中的 `InheritLocations` 或 `InheritInitializers` 属性设置为 `false`，则测试类的影子的资源位置或组件类以及上下文初始化器分别有效地替换超类定义的配置。

在下一个使用XML资源位置的示例中，从 `Base-config.xml` 和 `Extended-config.xml` 依次加载 `ExtendedTest` 的 `ApplicationContext`。 因此，`extended-config.xml` 中定义的Bean可以覆盖（即替换）`base-config.xml` 中定义的Bean。
以下示例显示了一个类如何扩展另一个类并使用其自己的配置文件和超类的配置文件：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ExtendWith(SpringExtension.class)
	// ApplicationContext will be loaded from "/base-config.xml"
	// in the root of the classpath
	@ContextConfiguration("/base-config.xml") <1>
	class BaseTest {
		// class body...
	}

	// ApplicationContext will be loaded from "/base-config.xml" and
	// "/extended-config.xml" in the root of the classpath
	@ContextConfiguration("/extended-config.xml") <2>
	class ExtendedTest extends BaseTest {
		// class body...
	}
----
<1> 在超类中定义的配置文件。
<2> 子类中定义的配置文件。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ExtendWith(SpringExtension::class)
	// ApplicationContext will be loaded from "/base-config.xml"
	// in the root of the classpath
	@ContextConfiguration("/base-config.xml") // <1>
	open class BaseTest {
		// class body...
	}

	// ApplicationContext will be loaded from "/base-config.xml" and
	// "/extended-config.xml" in the root of the classpath
	@ContextConfiguration("/extended-config.xml") // <2>
	class ExtendedTest : BaseTest() {
		// class body...
	}
----
<1> 在超类中定义的配置文件。
<2> 子类中定义的配置文件。

同样，在下一个使用组件类的示例中，从 `BaseConfig` 和 `ExtendedConfig` 类按该顺序加载 `ExtendedTest` 的 `ApplicationContext`。 因此，`在ExtendedConfig` 中定义的Bean可以覆盖（即替换）在 `BaseConfig` 中定义的那些。 以下示例显示了一个类如何扩展另一个类并使用其自己的配置类和超类的配置类：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// ApplicationContext will be loaded from BaseConfig
	@SpringJUnitConfig(BaseConfig.class) // <1>
	class BaseTest {
		// class body...
	}

	// ApplicationContext will be loaded from BaseConfig and ExtendedConfig
	@SpringJUnitConfig(ExtendedConfig.class) // <2>
	class ExtendedTest extends BaseTest {
		// class body...
	}
----
<1> 在超类中定义的配置文件。
<2> 子类中定义的配置文件。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// ApplicationContext will be loaded from BaseConfig
	@SpringJUnitConfig(BaseConfig::class) // <1>
	open class BaseTest {
		// class body...
	}

	// ApplicationContext will be loaded from BaseConfig and ExtendedConfig
	@SpringJUnitConfig(ExtendedConfig::class) // <2>
	class ExtendedTest : BaseTest() {
		// class body...
	}
----
<1> 在超类中定义的配置文件。
<2> 子类中定义的配置文件。

在使用上下文初始化程序的下一个示例中，通过使用 `BaseInitializer` 和 `ExtendedInitializer` 初始化 `ExtendedTest` 的 `ApplicationContext`。 但是请注意，初始化程序的调用顺序取决于它们是实现Spring的 `Ordered` 接口还是以Spring的 `@Order` 注解或标准的 `@Priority` 注解进行注解。 以下示例显示了一个类如何扩展另一个类并同时使用其自己的初始化程序和超类的初始化程序：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// ApplicationContext will be initialized by BaseInitializer
	@SpringJUnitConfig(initializers = BaseInitializer.class) // <1>
	class BaseTest {
		// class body...
	}

	// ApplicationContext will be initialized by BaseInitializer
	// and ExtendedInitializer
	@SpringJUnitConfig(initializers = ExtendedInitializer.class) // <2>
	class ExtendedTest extends BaseTest {
		// class body...
	}
----
<1> 在超类中定义的初始化程序。
<2> 子类中定义的初始化程序。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// ApplicationContext will be initialized by BaseInitializer
	@SpringJUnitConfig(initializers = [BaseInitializer::class]) // <1>
	open class BaseTest {
		// class body...
	}

	// ApplicationContext will be initialized by BaseInitializer
	// and ExtendedInitializer
	@SpringJUnitConfig(initializers = [ExtendedInitializer::class]) // <2>
	class ExtendedTest : BaseTest() {
		// class body...
	}
----
<1> 在超类中定义的初始化程序。
<2> 子类中定义的初始化程序。


[[testcontext-ctx-management-env-profiles]]
===== 使用环境配置文件进行上下文配置

Spring框架对环境和概要文件（AKA "bean定义概要文件"）的概念提供了一流的支持，并且可以将集成测试配置为针对各种测试场景激活特定的bean定义概要文件。 这是通过使用 `@ActiveProfiles` 注解测试类并提供在加载测试的 `ApplicationContext` 时应激活的配置文件列表来实现的。

NOTE: 您可以将 `@ActiveProfiles` 与 `SmartContextLoader` SPI的任何实现一起使用，但较早的 `ContextLoader` SPI的实现不支持 `@ActiveProfiles`。

考虑两个带有XML配置和 `@Configuration` 类的示例：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<!-- app-config.xml -->
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:jdbc="http://www.springframework.org/schema/jdbc"
		xmlns:jee="http://www.springframework.org/schema/jee"
		xsi:schemaLocation="...">

		<bean id="transferService"
				class="com.bank.service.internal.DefaultTransferService">
			<constructor-arg ref="accountRepository"/>
			<constructor-arg ref="feePolicy"/>
		</bean>

		<bean id="accountRepository"
				class="com.bank.repository.internal.JdbcAccountRepository">
			<constructor-arg ref="dataSource"/>
		</bean>

		<bean id="feePolicy"
			class="com.bank.service.internal.ZeroFeePolicy"/>

		<beans profile="dev">
			<jdbc:embedded-database id="dataSource">
				<jdbc:script
					location="classpath:com/bank/config/sql/schema.sql"/>
				<jdbc:script
					location="classpath:com/bank/config/sql/test-data.sql"/>
			</jdbc:embedded-database>
		</beans>

		<beans profile="production">
			<jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/datasource"/>
		</beans>

		<beans profile="default">
			<jdbc:embedded-database id="dataSource">
				<jdbc:script
					location="classpath:com/bank/config/sql/schema.sql"/>
			</jdbc:embedded-database>
		</beans>

	</beans>
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ExtendWith(SpringExtension.class)
	// ApplicationContext will be loaded from "classpath:/app-config.xml"
	@ContextConfiguration("/app-config.xml")
	@ActiveProfiles("dev")
	class TransferServiceTest {

		@Autowired
		TransferService transferService;

		@Test
		void testTransferService() {
			// test the transferService
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ExtendWith(SpringExtension::class)
	// ApplicationContext will be loaded from "classpath:/app-config.xml"
	@ContextConfiguration("/app-config.xml")
	@ActiveProfiles("dev")
	class TransferServiceTest {

		@Autowired
		lateinit var transferService: TransferService

		@Test
		fun testTransferService() {
			// test the transferService
		}
	}
----

运行 `TransferServiceTest` 时，会从类路径根目录中的 `app-config.xml` 配置文件中加载其 `ApplicationContext`。 如果检查 `app-config.xml`，可以看到 `accountRepository` bean对 `dataSource` bean有依赖性。 但是，`dataSource` 没有定义为顶级bean。
相反，`dataSource` 定义了三次：在生产配置文件中，在开发配置文件中以及在默认配置文件中。

通过使用 `@ActiveProfiles("dev")` 注解 `TransferServiceTest`，我们指示Spring TestContext Framework加载具有设置为 `{"dev"}` 的活动配置文件的 `ApplicationContext`。 结果，创建了一个嵌入式数据库，并用测试数据填充了该数据库，
并用对开发 `DataSource` 的引用连接了 `accountRepository` bean。 这可能是我们在集成测试中想要的。

有时将bean分配给默认概要文件很有用。 仅当没有专门激活其他配置文件时，才包含默认配置文件中的Bean。 您可以使用它来定义要在应用程序默认状态下使用的 "`fallback`"  bean。
例如，您可以显式提供开发和生产配置文件的数据源，但是当两者都不处于活动状态时，将内存中数据源定义为默认数据源。

以下代码清单演示了如何使用 `@Configuration` 类而不是XML实现相同的配置和集成测试：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@Profile("dev")
	public class StandaloneDataConfig {

		@Bean
		public DataSource dataSource() {
			return new EmbeddedDatabaseBuilder()
				.setType(EmbeddedDatabaseType.HSQL)
				.addScript("classpath:com/bank/config/sql/schema.sql")
				.addScript("classpath:com/bank/config/sql/test-data.sql")
				.build();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@Profile("dev")
	class StandaloneDataConfig {

		@Bean
		fun dataSource(): DataSource {
			return EmbeddedDatabaseBuilder()
					.setType(EmbeddedDatabaseType.HSQL)
					.addScript("classpath:com/bank/config/sql/schema.sql")
					.addScript("classpath:com/bank/config/sql/test-data.sql")
					.build()
		}
	}
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@Profile("production")
	public class JndiDataConfig {

		@Bean(destroyMethod="")
		public DataSource dataSource() throws Exception {
			Context ctx = new InitialContext();
			return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@Profile("production")
	class JndiDataConfig {

		@Bean(destroyMethod = "")
		fun dataSource(): DataSource {
			val ctx = InitialContext()
			return ctx.lookup("java:comp/env/jdbc/datasource") as DataSource
		}
	}
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@Profile("default")
	public class DefaultDataConfig {

		@Bean
		public DataSource dataSource() {
			return new EmbeddedDatabaseBuilder()
				.setType(EmbeddedDatabaseType.HSQL)
				.addScript("classpath:com/bank/config/sql/schema.sql")
				.build();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@Profile("default")
	class DefaultDataConfig {

		@Bean
		fun dataSource(): DataSource {
			return EmbeddedDatabaseBuilder()
					.setType(EmbeddedDatabaseType.HSQL)
					.addScript("classpath:com/bank/config/sql/schema.sql")
					.build()
		}
	}
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class TransferServiceConfig {

		@Autowired DataSource dataSource;

		@Bean
		public TransferService transferService() {
			return new DefaultTransferService(accountRepository(), feePolicy());
		}

		@Bean
		public AccountRepository accountRepository() {
			return new JdbcAccountRepository(dataSource);
		}

		@Bean
		public FeePolicy feePolicy() {
			return new ZeroFeePolicy();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class TransferServiceConfig {

		@Autowired
		lateinit var dataSource: DataSource

		@Bean
		fun transferService(): TransferService {
			return DefaultTransferService(accountRepository(), feePolicy())
		}

		@Bean
		fun accountRepository(): AccountRepository {
			return JdbcAccountRepository(dataSource)
		}

		@Bean
		fun feePolicy(): FeePolicy {
			return ZeroFeePolicy()
		}
	}
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@SpringJUnitConfig({
			TransferServiceConfig.class,
			StandaloneDataConfig.class,
			JndiDataConfig.class,
			DefaultDataConfig.class})
	@ActiveProfiles("dev")
	class TransferServiceTest {

		@Autowired
		TransferService transferService;

		@Test
		void testTransferService() {
			// test the transferService
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@SpringJUnitConfig(
			TransferServiceConfig::class,
			StandaloneDataConfig::class,
			JndiDataConfig::class,
			DefaultDataConfig::class)
	@ActiveProfiles("dev")
	class TransferServiceTest {

		@Autowired
		lateinit var transferService: TransferService

		@Test
		fun testTransferService() {
			// test the transferService
		}
	}
----

在此变体中，我们将XML配置分为四个独立的 `@Configuration` 类：

* `TransferServiceConfig`: 使用 `@Autowired` 通过依赖项注入获取 `dataSource`。
* `StandaloneDataConfig`: 为适合开发人员测试的嵌入式数据库定义 `dataSource`。
* `JndiDataConfig`: 定义在生产环境中从JNDI检索的 `dataSource`。
* `DefaultDataConfig`: 如果没有配置文件处于活动状态，则为默认的嵌入式数据库定义一个 `dataSource`。

与基于XML的配置示例一样，我们仍然使用 `@ActiveProfiles("dev")` 注解 `TransferServiceTest`，但是这次我们使用 `@ContextConfiguration` 注解指定所有四个配置类。 测试类的主体本身保持完全不变。

通常，在给定项目中的多个测试类之间使用一组概要文件。 因此，为避免 `@ActiveProfiles` 注解的重复声明，您可以在基类上声明一次 `@ActiveProfiles`，子类会自动从基类继承 `@ActiveProfiles` 配置。 在以下示例中，`@ActiveProfiles` 的声明（以及其他注解）已移至抽象超类 `AbstractIntegrationTest`：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@SpringJUnitConfig({
			TransferServiceConfig.class,
			StandaloneDataConfig.class,
			JndiDataConfig.class,
			DefaultDataConfig.class})
	@ActiveProfiles("dev")
	abstract class AbstractIntegrationTest {
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@SpringJUnitConfig(
			TransferServiceConfig::class,
			StandaloneDataConfig::class,
			JndiDataConfig::class,
			DefaultDataConfig::class)
	@ActiveProfiles("dev")
	abstract class AbstractIntegrationTest {
	}
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// "dev" profile inherited from superclass
	class TransferServiceTest extends AbstractIntegrationTest {

		@Autowired
		TransferService transferService;

		@Test
		void testTransferService() {
			// test the transferService
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// "dev" profile inherited from superclass
	class TransferServiceTest : AbstractIntegrationTest() {

		@Autowired
		lateinit var transferService: TransferService

		@Test
		fun testTransferService() {
			// test the transferService
		}
	}
----

`@ActiveProfiles` 还支持可用于禁用活动配置文件的继承的 `InheritedProfiles` 属性，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// "dev" profile overridden with "production"
	@ActiveProfiles(profiles = "production", inheritProfiles = false)
	class ProductionTransferServiceTest extends AbstractIntegrationTest {
		// test body
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// "dev" profile overridden with "production"
	@ActiveProfiles("production", inheritProfiles = false)
	class ProductionTransferServiceTest : AbstractIntegrationTest() {
		// test body
	}
----

[[testcontext-ctx-management-env-profiles-ActiveProfilesResolver]]
此外，有时有必要以编程方式而不是以声明方式来解析测试的活动配置文件，例如，基于：

* 当前的操作系统。
* 是否在持续集成构建服务器上执行测试。
* 存在某些环境变量。
* 自定义类级别注解的存在。
* 其他问题。

要以编程方式解析活动bean定义概要文件，可以实现自定义 `ActiveProfilesResolver` 并使用 `@ActiveProfiles` 的 `resolver` 属性对其进行注册。 有关更多信息，请参见相应的 {api-spring-framework}/test/context/ActiveProfilesResolver.html[javadoc]。 下面的示例演示如何实现和注册自定义 `OperatingSystemActiveProfilesResolver`：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// "dev" profile overridden programmatically via a custom resolver
	@ActiveProfiles(
			resolver = OperatingSystemActiveProfilesResolver.class,
			inheritProfiles = false)
	class TransferServiceTest extends AbstractIntegrationTest {
		// test body
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// "dev" profile overridden programmatically via a custom resolver
	@ActiveProfiles(
			resolver = OperatingSystemActiveProfilesResolver::class,
			inheritProfiles = false)
	class TransferServiceTest : AbstractIntegrationTest() {
		// test body
	}
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class OperatingSystemActiveProfilesResolver implements ActiveProfilesResolver {

		@Override
		public String[] resolve(Class<?> testClass) {
			String profile = ...;
			// determine the value of profile based on the operating system
			return new String[] {profile};
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class OperatingSystemActiveProfilesResolver : ActiveProfilesResolver {

		override fun resolve(testClass: Class<*>): Array<String> {
			val profile: String = ...
			// determine the value of profile based on the operating system
			return arrayOf(profile)
		}
	}
----

[[testcontext-ctx-management-property-sources]]
===== 具有测试属性源的上下文配置

Spring框架对具有属性源层次结构的环境的概念提供了一流的支持，您可以使用特定于测试的属性源配置集成测试。 与 `@Configuration` 类上使用的 `@PropertySource` 注解相反，可以在测试类上声明 `@TestPropertySource` 注解，以声明测试属性文件或内联属性的资源位置。
将这些测试属性源添加到环境中针对为注解集成测试加载的 `ApplicationContext` 的 `PropertySources` 集中。

[NOTE]
====
您可以将 `@TestPropertySource` 与 `SmartContextLoader` SPI的任何实现一起使用，但是较早的 `ContextLoader` SPI的实现不支持 `@TestPropertySource`。

`SmartContextLoader` 的实现可通过 `MergedContextConfiguration` 中的 `getPropertySourceLocations()` 和 `getPropertySourceProperties()` 方法访问合并的测试属性源值。
====

====== 声明测试属性源

您可以使用 `@TestPropertySource` 的 `location` 或 `value` 属性来配置测试属性文件。

支持传统属性和基于XML的属性文件格式，例如 `"classpath:/com/example/test.properties"` 或 `"file:///path/to/file.xml"`。

每个路径都被解释为Spring资源。 纯路径（例如，`"test.properties"`）被视为相对于定义测试类的程序包的类路径资源。 以斜杠开头的路径被视为绝对类路径资源（例如： `"/org/example/test.xml"`）。 通过使用指定的资源协议加载引用URL的路径（例如，以  `classpath:`, `file:`, or `http:` 开头的路径）。 不允许使用资源位置通配符（例如 `**/*.properties`）：每个位置都必须精确评估为一个 `.properties` 或 `.xml` 资源。

以下示例使用测试属性文件：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ContextConfiguration
	@TestPropertySource("/test.properties") // <1>
	class MyIntegrationTests {
		// class body...
	}
----
<1> 指定具有绝对路径的属性文件。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ContextConfiguration
	@TestPropertySource("/test.properties") // <1>
	class MyIntegrationTests {
		// class body...
	}
----
<1> 指定具有绝对路径的属性文件。

您可以使用 `@TestPropertySource` 的 `properties` 属性以键-值对的形式配置内联属性，如下例所示。 所有键值对都作为优先级最高的单个测试 `PropertySource` 添加到封闭环境中。

键值对支持的语法与为Java属性文件中的条目定义的语法相同：

* `key=value`
* `key:value`
* `key value`

The following example sets two inlined properties:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ContextConfiguration
	@TestPropertySource(properties = {"timezone = GMT", "port: 4242"}) // <1>
	class MyIntegrationTests {
		// class body...
	}
----
<1> 通过使用键值语法的两种变体来设置两个属性。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ContextConfiguration
	@TestPropertySource(properties = ["timezone = GMT", "port: 4242"]) // <1>
	class MyIntegrationTests {
		// class body...
	}
----
<1> 通过使用键值语法的两种变体来设置两个属性。

[NOTE]
====
从Spring Framework 5.2开始，`@TestPropertySource` 可以用作可重复注解。 这意味着您可以在单个测试类上具有 `@TestPropertySource` 的多个声明，其后的 `@TestPropertySource` 注解中的位置和属性将覆盖先前的 `@TestPropertySource` 注解中的位置和属性。

另外，您可以在一个测试类上声明多个组成的注解，每个注解都使用 `@TestPropertySource` 进行元注解，所有这些 `@TestPropertySource` 声明都将有助于您的测试属性源。

直接存在的 `@TestPropertySource` 注解始终优先于元存在的 `@TestPropertySource` 注解。 换句话说，直接存在的 `@TestPropertySource` 注解中的位置和属性将覆盖 `@TestPropertySource` 注解中用作元注解的位置和属性。
====


====== 默认属性文件检测

如果 `@TestPropertySource` 声明为空注解（即，没有位置或属性属性的显式值），则尝试检测相对于声明该注解的类的默认属性文件。 例如，如果带注解的测试类是 `com.example.MyTest`，则相应的默认属性文件是 `classpath:com/example/MyTest.properties`。 如果无法检测到默认值，则抛出 `IllegalStateException`。

====== 优先顺序

测试属性源的优先级高于从操作系统环境，Java系统属性或应用程序通过使用 `@PropertySource` 声明性地或以编程方式添加的属性源中加载的属性。 因此，测试属性源可用于选择性覆盖系统和应用程序属性源中定义的属性。 此外，内联属性比从资源位置加载的属性具有更高的优先级。

在下一个示例中， `timezone` 和  `port` 属性以及在 `"/test.properties"` 中定义的任何属性都将覆盖在系统和应用程序属性源中定义的具有相同名称的所有属性。 此外，如果 `"/test.properties"` 文件定义了 `timezone` 和  `port`  属性，则这些条目将被使用 `properties` 属性声明的内联属性所覆盖。 以下示例显示如何在文件和内联中指定属性：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ContextConfiguration
	@TestPropertySource(
		locations = "/test.properties",
		properties = {"timezone = GMT", "port: 4242"}
	)
	class MyIntegrationTests {
		// class body...
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ContextConfiguration
	@TestPropertySource("/test.properties",
			properties = ["timezone = GMT", "port: 4242"]
	)
	class MyIntegrationTests {
		// class body...
	}
----

====== 继承和覆盖测试属性源

`@TestPropertySource` 支持 `booleanInheritLocations` 和 `InheritProperties` 属性，这些属性指示是否应继承属性文件和超类声明的内联属性的资源位置。 这两个标志的默认值为 `true`。 这意味着测试类将继承任何超类声明的位置和内联属性。
具体来说，将测试类的位置和内联属性附加到超类声明的位置和内联属性中。 因此，子类可以选择扩展位置和内联属性。 请注意，稍后出现的属性会阴影（即，覆盖）之前出现的相同名称的属性。 此外，上述优先规则也适用于继承的测试属性源。

如果 `@TestPropertySource` 中的 `InheritLocations` 或 `InheritProperties` 属性设置为 `false`，则分别为测试类阴影设置位置或内联属性，并有效替换超类定义的配置。

在下一个示例中，仅通过将 `base.properties` 文件用作测试属性源来加载 `BaseTest` 的 `ApplicationContext`。 相反，通过使用 `base.properties` 和 `extended.properties` 文件作为测试属性源位置来加载 `ExtendedContext` 的 `ApplicationContext`。 下面的示例显示如何通过使用属性文件在子类及其父类中定义属性：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@TestPropertySource("base.properties")
	@ContextConfiguration
	class BaseTest {
		// ...
	}

	@TestPropertySource("extended.properties")
	@ContextConfiguration
	class ExtendedTest extends BaseTest {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@TestPropertySource("base.properties")
	@ContextConfiguration
	open class BaseTest {
		// ...
	}

	@TestPropertySource("extended.properties")
	@ContextConfiguration
	class ExtendedTest : BaseTest() {
		// ...
	}
----

在下一个示例中，仅使用内联的 `key1` 属性加载 `BaseTest` 的 `ApplicationContext`。 相反，通过使用内联的 `key1` 和 `key2` 属性来加载 `ExtendedTest` 的 `ApplicationContext`。 下面的示例演示如何通过使用内联属性在子类及其父类中定义属性：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@TestPropertySource(properties = "key1 = value1")
	@ContextConfiguration
	class BaseTest {
		// ...
	}

	@TestPropertySource(properties = "key2 = value2")
	@ContextConfiguration
	class ExtendedTest extends BaseTest {
		// ...
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@TestPropertySource(properties = ["key1 = value1"])
	@ContextConfiguration
	open class BaseTest {
		// ...
	}

	@TestPropertySource(properties = ["key2 = value2"])
	@ContextConfiguration
	class ExtendedTest : BaseTest() {
		// ...
	}
----

[[testcontext-ctx-management-web]]
===== 加载 `WebApplicationContext`

若要指示 `TestContext` 框架加载 `WebApplicationContext` 而不是标准 `ApplicationContext`，可以使用 `@WebAppConfiguration` 注解各自的测试类。

测试类上 `@WebAppConfiguration` 的存在指示 TestContext框架（TCF）应该为集成测试加载 `WebApplicationContext`（WAC）。 TCF在后台确保创建了 `MockServletContext` 并将其提供给测试的WAC。 默认情况下，您的 `MockServletContext` 的基本资源路径设置为 `src/main/webapp`。
这被解释为相对于JVM根目录的路径（通常是项目的路径）。 如果您熟悉Maven项目中Web应用程序的目录结构，则知道 `src/main/webapp` 是WAR根目录的默认位置。 如果需要覆盖此默认值，
则可以提供@WebAppConfiguration注解的备用路径（例如，@ WebAppConfiguration（“ src / test / webapp”））。 如果您希望从类路径而不是文件系统中引用基本资源路径，则可以使用Spring的 `classpath:` 前缀。

请注意，Spring对 `WebApplicationContext` 实现的测试支持与其对标准 `ApplicationContext` 实现的支持相当。 使用 `WebApplicationContext` 进行测试时，可以使用 `@ContextConfiguration` 声明XML配置文件，Groovy脚本或 `@Configuration` 类。
您还可以自由使用任何其他测试注解，例如 `@ActiveProfiles`，`@TestExecutionListeners`，`@Sql`，`@Rollback` 等。

本节中的其余示例显示了用于加载 `WebApplicationContext` 的各种配置选项。 以下示例显示了 TestContext 框架对配置约定的支持：

.Conventions
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ExtendWith(SpringExtension.class)

	// defaults to "file:src/main/webapp"
	@WebAppConfiguration

	// detects "WacTests-context.xml" in the same package
	// or static nested @Configuration classes
	@ContextConfiguration
	class WacTests {
		//...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ExtendWith(SpringExtension::class)

	// defaults to "file:src/main/webapp"
	@WebAppConfiguration

	// detects "WacTests-context.xml" in the same package
	// or static nested @Configuration classes
	@ContextConfiguration
	class WacTests {
		//...
	}
----

如果使用 `@WebAppConfiguration` 注解测试类而未指定资源基本路径，则资源路径实际上默认为 `file:src/main/webapp`。 同样，如果在声明 `@ContextConfiguration` 时未指定资源位置，组件类或上下文初始化器，则Spring会尝试使用约定（即 `WacTests-context.xml` 与 `WacTests` 类或静态包放在同一包中）来检测配置的存在。 嵌套的 `@Configuration` 类）。

以下示例显示如何使用 `@WebAppConfiguration` 显式声明资源基础路径和使用 `@ContextConfiguration` 显式声明XML资源位置：

.Default resource semantics
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ExtendWith(SpringExtension.class)

	// file system resource
	@WebAppConfiguration("webapp")

	// classpath resource
	@ContextConfiguration("/spring/test-servlet-config.xml")
	class WacTests {
		//...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ExtendWith(SpringExtension::class)

	// file system resource
	@WebAppConfiguration("webapp")

	// classpath resource
	@ContextConfiguration("/spring/test-servlet-config.xml")
	class WacTests {
		//...
	}
----

这里要注意的重要一点是具有这两个注解的路径的语义不同。 默认情况下，`@WebAppConfiguration` 资源路径基于文件系统，而 `@ContextConfiguration` 资源位置基于类路径。

下面的示例显示，我们可以通过指定Spring资源前缀来覆盖两个注解的默认资源语义：

.Explicit resource semantics
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ExtendWith(SpringExtension.class)

	// classpath resource
	@WebAppConfiguration("classpath:test-web-resources")

	// file system resource
	@ContextConfiguration("file:src/main/webapp/WEB-INF/servlet-config.xml")
	class WacTests {
		//...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ExtendWith(SpringExtension::class)

	// classpath resource
	@WebAppConfiguration("classpath:test-web-resources")

	// file system resource
	@ContextConfiguration("file:src/main/webapp/WEB-INF/servlet-config.xml")
	class WacTests {
		//...
	}
----

将本示例中的注解与上一个示例进行对比。

.[[testcontext-ctx-management-web-mocks]]Working with Web Mocks
--
为了提供全面的Web测试支持，TestContext框架具有默认启用的 `ServletTestExecutionListener`。 在针对 `WebApplicationContext` 进行测试时，此  <<testcontext-key-abstractions, `TestExecutionListener`>> 会在每个测试方法之前使用Spring Web的 `RequestContextHolder` 来设置默认的线程本地状态，并根据通过 `@WebAppConfiguration` 配置的基本资源路径创建 `MockHttpServletRequest`，`MockHttpServletResponse` 和 `ServletWebRequest`。 `ServletTestExecutionListener` 还确保可以将 `MockHttpServletResponse` 和 `ServletWebRequest` 注入到测试实例中，并且一旦测试完成，它将清除线程本地状态。

一旦为测试加载了 `WebApplicationContext`，您可能会发现您需要与Web模拟进行交互，例如，在调用Web组件后设置测试夹具或执行断言。 以下示例显示可以将哪些模拟自动连接到您的测试实例。 请注意，`WebApplicationContext` 和 `MockServletContext` 都缓存在测试套件中，而其他模拟则由 `ServletTestExecutionListener` 针对每个测试方法进行管理。

.Injecting mocks
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@SpringJUnitWebConfig
	class WacTests {

		@Autowired
		WebApplicationContext wac; // cached

		@Autowired
		MockServletContext servletContext; // cached

		@Autowired
		MockHttpSession session;

		@Autowired
		MockHttpServletRequest request;

		@Autowired
		MockHttpServletResponse response;

		@Autowired
		ServletWebRequest webRequest;

		//...
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@SpringJUnitWebConfig
	class WacTests {

		@Autowired
		lateinit var wac: WebApplicationContext // cached

		@Autowired
		lateinit var servletContext: MockServletContext // cached

		@Autowired
		lateinit var session: MockHttpSession

		@Autowired
		lateinit var request: MockHttpServletRequest

		@Autowired
		lateinit var response: MockHttpServletResponse

		@Autowired
		lateinit var webRequest: ServletWebRequest

		//...
	}
----
--

[[testcontext-ctx-management-caching]]
===== 上下文缓存

一旦TestContext框架为测试加载了 `ApplicationContext`（或 `WebApplicationContext`），该上下文将被缓存并重新用于在同一测试套件中声明相同唯一上下文配置的所有后续测试。 要了解缓存的工作原理，重要的是要了解“唯一”和“测试套件”的含义。

可以通过用于加载它的配置参数的组合来唯一标识 `ApplicationContext`。 因此，配置参数的唯一组合用于生成一个密钥，在该密钥下缓存上下文。 TestContext框架使用以下配置参数来构建上下文缓存键：

* `locations` (from `@ContextConfiguration`)
* `classes` (from `@ContextConfiguration`)
* `contextInitializerClasses` (from `@ContextConfiguration`)
* `contextCustomizers` (from `ContextCustomizerFactory`)
* `contextLoader` (from `@ContextConfiguration`)
* `parent` (from `@ContextHierarchy`)
* `activeProfiles` (from `@ActiveProfiles`)
* `propertySourceLocations` (from `@TestPropertySource`)
* `propertySourceProperties` (from `@TestPropertySource`)
* `resourceBasePath` (from `@WebAppConfiguration`)

例如，如果 `TestClassA` 为 `@ContextConfiguration` 的 `location`（或 `value`）属性指定 `{"app-config.xml", "test-config.xml"}`，则TestContext框架将加载相应的 `ApplicationContext` 并将其存储在静态上下文缓存中 仅基于那些位置的密钥下。
因此，如果 `TestClassB` 还为其位置（通过继承显式或隐式）定义了 `{"app-config.xml", "test-config.xml"}` ，但未定义 `@WebAppConfiguration`，不同的 `ContextLoader`，不同的活动配置文件，不同的 上下文初始化程序，不同的测试属性源或不同的父上下文，则两个测试类将共享相同的 `ApplicationContext`。 这意味着加载应用程序上下文的设置成本仅发生一次（每个测试套件），并且随后的测试执行要快得多。

.Test suites and forked processes
[NOTE]
====
Spring TestContext框架将应用程序上下文存储在静态缓存中。 这意味着上下文实际上是存储在 `static`  变量中的。 换句话说，如果测试是在单独的进程中执行的，则在每次测试执行之间都会清除静态缓存，从而有效地禁用了缓存机制。

为了从缓存机制中受益，所有测试必须在同一进程或测试套件中运行。 这可以通过在IDE中以组的形式执行所有测试来实现。 同样，在使用诸如Ant，Maven或Gradle之类的构建框架执行测试时，确保该构建框架不会在测试之间进行派生很重要。 例如，如果将Maven Surefire插件的 https://maven.apache.org/plugins/maven-surefire-plugin/test-mojo.html#forkMode[`forkMode`]设置为 `always` 或 `pertest`，则TestContext框架将无法在测试类之间缓存应用程序上下文，因此，构建过程的运行速度将大大降低。
====

上下文缓存的大小以默认的最大大小32为界。只要达到最大大小，就会使用最近最少使用（LRU）驱逐策略来驱逐和关闭陈旧的上下文。 您可以通过设置名为 `spring.test.context.cache.maxSize` 的JVM系统属性，从命令行或构建脚本中配置最大大小。 或者，您可以使用 `SpringProperties` API以编程方式设置相同的属性。

由于在给定的测试套件中加载大量应用程序上下文会导致套件花费不必要的长时间执行，因此准确地知道已加载和缓存了多少个上下文通常是有益的。 要查看基础上下文缓存的统计信息，可以将 `org.springframework.test.context.cache` 日志记录类别的日志级别设置为 `DEBUG`。

万一测试破坏了应用程序上下文并需要重新加载（例如，通过修改Bean定义或应用程序对象的状态），则可以使用 `@DirtiesContext` 注解测试类或测试方法（请参阅的讨论 <<spring-testing-annotation-dirtiescontext,`@DirtiesContext`>> 中的DirtiesContext`）。 这指示Spring在运行下一个需要相同应用程序上下文的测试之前，从缓存中删除上下文并重建应用程序上下文。 请注意，`@DirtiesContext` 注解的支持由 `DirtiesContextBeforeModesTestExecutionListene` r和 `DirtiesContextTestExecutionListener` 默认启用。

[[testcontext-ctx-management-ctx-hierarchies]]
===== 上下文层次结构

在编写依赖于已加载的Spring `ApplicationContext` 的集成测试时，通常足以针对单个上下文进行测试。 但是，有时需要对 `ApplicationContext` 实例的层次结构进行测试是有益的甚至是必要的。 例如，如果您正在开发Spring MVC Web应用程序，
则通常具有由Spring的 `ContextLoaderListener` 加载的根 `WebApplicationContext` 和由Spring的 `DispatcherServlet` 加载的子 `WebApplicationContext`。 这导致父子上下文层次结构，其中共享组件和基础结构配置在根上下文中声明，并在特定于Web的组件的子上下文中使用。 在Spring Batch应用程序中可以找到另一个用例，在该应用程序中，您经常有一个父上下文为共享批处理基础结构提供配置，而子上下文为特定批处理作业的配置提供配置。

您可以通过在单个测试类上或在测试类层次结构中使用 `@ContextHierarchy` 注解声明上下文配置来编写使用上下文层次结构的集成测试。 如果在测试类层次结构中的多个类上声明了上下文层次结构，则还可以合并或覆盖上下文层次结构中特定命名级别的上下文配置。 合并层次结构中给定级别的配置时，配置资源类型（即XML配置文件或组件类）必须一致。 否则，在使用不同资源类型配置的上下文层次结构中具有不同级别是完全可以接受的。

本节中其余的基于JUnit Jupiter的示例显示了需要使用上下文层次结构的集成测试的常见配置方案。

.具有上下文层次结构的单个测试类
--
`ControllerIntegrationTests` 通过声明一个上下文层次结构来表示Spring MVC Web应用程序的典型集成测试场景，该上下文层次结构包含两个级别，一个层次用于根 `WebApplicationContext`（通过使用 `TestAppConfig`  `@Configuration` 类加载），一个层次用于调度程序Servlet `WebApplicationContext`（通过使用 `WebConfig` `@Configuration` 类 加载）。 自动连接到测试实例的  `WebApplicationContext` 是用于子上下文（即，层次结构中的最低上下文）的 `WebApplicationContext`。 以下清单显示了此配置方案：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ExtendWith(SpringExtension.class)
	@WebAppConfiguration
	@ContextHierarchy({
		@ContextConfiguration(classes = TestAppConfig.class),
		@ContextConfiguration(classes = WebConfig.class)
	})
	class ControllerIntegrationTests {

		@Autowired
		WebApplicationContext wac;

		// ...
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ExtendWith(SpringExtension::class)
	@WebAppConfiguration
	@ContextHierarchy(
		ContextConfiguration(classes = [TestAppConfig::class]),
		ContextConfiguration(classes = [WebConfig::class]))
	class ControllerIntegrationTests {

		@Autowired
		lateinit var wac: WebApplicationContext

		// ...
	}
----
--


.具有隐式父上下文的类层次结构
--
本示例中的测试类在测试类层次结构中定义了上下文层次结构。 `AbstractWebTests` 在Spring驱动的Web应用程序中声明根 `WebApplicationContext` 的配置。 但是请注意，`AbstractWebTests` 不会声明 `@ContextHierarchy`。
因此，`AbstractWebTests` 的子类可以选择参与上下文层次结构或遵循 `@ContextConfiguration` 的标准语义。 `SoapWebServiceTests` 和 `RestWebServiceTests` 都扩展了 `AbstractWebTests` 并使用 `@ContextHierarchy` 定义了上下文层次结构。
结果是，加载了三个应用程序上下文（每个 `@ContextConfiguration` 声明一个），并且基于 `AbstractWebTests` 中的配置加载的应用程序上下文被设置为为具体子类加载的每个上下文的父上下文。 以下清单显示 了此配置方案：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ExtendWith(SpringExtension.class)
	@WebAppConfiguration
	@ContextConfiguration("file:src/main/webapp/WEB-INF/applicationContext.xml")
	public abstract class AbstractWebTests {}

	@ContextHierarchy(@ContextConfiguration("/spring/soap-ws-config.xml"))
	public class SoapWebServiceTests extends AbstractWebTests {}

	@ContextHierarchy(@ContextConfiguration("/spring/rest-ws-config.xml"))
	public class RestWebServiceTests extends AbstractWebTests {}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ExtendWith(SpringExtension::class)
	@WebAppConfiguration
	@ContextConfiguration("file:src/main/webapp/WEB-INF/applicationContext.xml")
	abstract class AbstractWebTests

	@ContextHierarchy(ContextConfiguration("/spring/soap-ws-config.xml"))
	class SoapWebServiceTests : AbstractWebTests()

	@ContextHierarchy(ContextConfiguration("/spring/rest-ws-config.xml"))
	class RestWebServiceTests : AbstractWebTests()

----
--

.具有合并上下文层次结构配置的类层次结构
--
此示例中的类显示了使用命名层次结构级别的目的，以便合并上下文层次结构中特定级别的配置。 `BaseTests` 在层次结构中定义了两个级别，`parent` 级别和 `child` 级别。 `ExtendedTests` 扩展 `BaseTests` 并指示Spring TestContext Framework合并子层次结构级别的上下文配置，
方法是确保在 `@ContextConfiguration` 的 `name` 属性中声明的名称均为 `child` 元素。 结果是加载了三个应用程序上下文：一个用于 `/app-config.xml`，一个用于 `/user-config.xml`，一个用于 `{"/user-config.xml", "/order-config.xml"}`。
与前面的示例一样，将从 `/app-config.xml`  加载的应用程序上下文设置为从  `/user-config.xml` 和  `{"/user-config.xml", "/order-config.xml"}`。 以下清单显示了此配置方案：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ExtendWith(SpringExtension.class)
	@ContextHierarchy({
		@ContextConfiguration(name = "parent", locations = "/app-config.xml"),
		@ContextConfiguration(name = "child", locations = "/user-config.xml")
	})
	class BaseTests {}

	@ContextHierarchy(
		@ContextConfiguration(name = "child", locations = "/order-config.xml")
	)
	class ExtendedTests extends BaseTests {}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ExtendWith(SpringExtension::class)
	@ContextHierarchy(
		ContextConfiguration(name = "parent", locations = ["/app-config.xml"]),
		ContextConfiguration(name = "child", locations = ["/user-config.xml"]))
	open class BaseTests {}

	@ContextHierarchy(
		ContextConfiguration(name = "child", locations = ["/order-config.xml"])
	)
	class ExtendedTests : BaseTests() {}
----
--

.具有覆盖的上下文层次结构配置的类层次结构
--
与前面的示例相反，此示例演示了如何通过将 `@ContextConfiguration` 中的 `InheritLocations` 标志设置为 `false` 来覆盖上下文层次结构中给定命名级别的配置。
因此，`ExtendedTests` 的应用程序上下文仅从 `/test-user-config.xml` 加载，并且其父级设置为从 `/app-config.xml` 加载的上下文。 以下清单显示了此配置方案：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ExtendWith(SpringExtension.class)
	@ContextHierarchy({
		@ContextConfiguration(name = "parent", locations = "/app-config.xml"),
		@ContextConfiguration(name = "child", locations = "/user-config.xml")
	})
	class BaseTests {}

	@ContextHierarchy(
		@ContextConfiguration(
			name = "child",
			locations = "/test-user-config.xml",
			inheritLocations = false
	))
	class ExtendedTests extends BaseTests {}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ExtendWith(SpringExtension::class)
	@ContextHierarchy(
		ContextConfiguration(name = "parent", locations = ["/app-config.xml"]),
		ContextConfiguration(name = "child", locations = ["/user-config.xml"]))
	open class BaseTests {}

	@ContextHierarchy(
			ContextConfiguration(
					name = "child",
					locations = ["/test-user-config.xml"],
					inheritLocations = false
			))
	class ExtendedTests : BaseTests() {}
----

.污染上下文层次结构中的上下文

NOTE: 如果在上下文被配置为上下文层次结构一部分的测试中使用 `@DirtiesContext`，则可以使用 `hierarchyMode` 标志控制清除上下文缓存的方式。 有关更多详细信息，请参见 <<spring-testing-annotation-dirtiescontext, Spring Testing Annotations>>中的 `@DirtiesContext` 和 {api-spring-framework}/test/annotation/DirtiesContext.html[`@DirtiesContext`]  javadoc的讨论。
--

[[testcontext-fixture-di]]
==== Dependency Injection of Test Fixtures

When you use the `DependencyInjectionTestExecutionListener` (which is configured by
default), the dependencies of your test instances are injected from beans in the
application context that you configured with `@ContextConfiguration` or related
annotations. You may use setter injection, field injection, or both, depending on
which annotations you choose and whether you place them on setter methods or fields.
If you are using JUnit Jupiter you may also optionally use constructor injection
(see <<testcontext-junit-jupiter-di>>). For consistency with Spring's annotation-based
injection support, you may also use Spring's `@Autowired` annotation or the `@Inject`
annotation from JSR-330 for field and setter injection.

TIP: For testing frameworks other than JUnit Jupiter, the TestContext framework does not
participate in instantiation of the test class. Thus, the use of `@Autowired` or
`@Inject` for constructors has no effect for test classes.

NOTE: Although field injection is discouraged in production code, field injection is
actually quite natural in test code. The rationale for the difference is that you will
never instantiate your test class directly. Consequently, there is no need to be able to
invoke a `public` constructor or setter method on your test class.

Because `@Autowired` is used to perform <<core.adoc#beans-factory-autowire, autowiring by
type>>, if you have multiple bean definitions of the same type, you cannot rely on this
approach for those particular beans. In that case, you can use `@Autowired` in
conjunction with `@Qualifier`. You can also choose to use `@Inject` in conjunction with
`@Named`. Alternatively, if your test class has access to its `ApplicationContext`, you
can perform an explicit lookup by using (for example) a call to
`applicationContext.getBean("titleRepository", TitleRepository.class)`.

If you do not want dependency injection applied to your test instances, do not annotate
fields or setter methods with `@Autowired` or `@Inject`. Alternatively, you can disable
dependency injection altogether by explicitly configuring your class with
`@TestExecutionListeners` and omitting `DependencyInjectionTestExecutionListener.class`
from the list of listeners.

Consider the scenario of testing a `HibernateTitleRepository` class, as outlined in the
<<integration-testing-goals, Goals>> section. The next two code listings demonstrate the
use of `@Autowired` on fields and setter methods. The application context configuration
is presented after all sample code listings.

[NOTE]
====
The dependency injection behavior in the following code listings is not specific to JUnit
Jupiter. The same DI techniques can be used in conjunction with any supported testing
framework.

The following examples make calls to static assertion methods, such as `assertNotNull()`,
but without prepending the call with `Assertions`. In such cases, assume that the method
was properly imported through an `import static` declaration that is not shown in the
example.
====

The first code listing shows a JUnit Jupiter based implementation of the test class that
uses `@Autowired` for field injection:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ExtendWith(SpringExtension.class)
	// specifies the Spring configuration to load for this test fixture
	@ContextConfiguration("repository-config.xml")
	class HibernateTitleRepositoryTests {

		// this instance will be dependency injected by type
		@Autowired
		HibernateTitleRepository titleRepository;

		@Test
		void findById() {
			Title title = titleRepository.findById(new Long(10));
			assertNotNull(title);
		}
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ExtendWith(SpringExtension::class)
	// specifies the Spring configuration to load for this test fixture
	@ContextConfiguration("repository-config.xml")
	class HibernateTitleRepositoryTests {

		// this instance will be dependency injected by type
		@Autowired
		lateinit var titleRepository: HibernateTitleRepository

		@Test
		fun findById() {
			val title = titleRepository.findById(10)
			assertNotNull(title)
		}
	}
----

Alternatively, you can configure the class to use `@Autowired` for setter injection, as
follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ExtendWith(SpringExtension.class)
	// specifies the Spring configuration to load for this test fixture
	@ContextConfiguration("repository-config.xml")
	class HibernateTitleRepositoryTests {

		// this instance will be dependency injected by type
		HibernateTitleRepository titleRepository;

		@Autowired
		void setTitleRepository(HibernateTitleRepository titleRepository) {
			this.titleRepository = titleRepository;
		}

		@Test
		void findById() {
			Title title = titleRepository.findById(new Long(10));
			assertNotNull(title);
		}
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ExtendWith(SpringExtension::class)
	// specifies the Spring configuration to load for this test fixture
	@ContextConfiguration("repository-config.xml")
	class HibernateTitleRepositoryTests {

		// this instance will be dependency injected by type
		lateinit var titleRepository: HibernateTitleRepository

		@Autowired
		fun setTitleRepository(titleRepository: HibernateTitleRepository) {
			this.titleRepository = titleRepository
		}

		@Test
		fun findById() {
			val title = titleRepository.findById(10)
			assertNotNull(title)
		}
	}
----

The preceding code listings use the same XML context file referenced by the
`@ContextConfiguration` annotation (that is, `repository-config.xml`). The following
shows this configuration:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<!-- this bean will be injected into the HibernateTitleRepositoryTests class -->
		<bean id="titleRepository" class="com.foo.repository.hibernate.HibernateTitleRepository">
			<property name="sessionFactory" ref="sessionFactory"/>
		</bean>

		<bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
			<!-- configuration elided for brevity -->
		</bean>

	</beans>
----

[NOTE]
=====
If you are extending from a Spring-provided test base class that happens to use
`@Autowired` on one of its setter methods, you might have multiple beans of the affected
type defined in your application context (for example, multiple `DataSource` beans). In
such a case, you can override the setter method and use the `@Qualifier` annotation to
indicate a specific target bean, as follows (but make sure to delegate to the overridden
method in the superclass as well):

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// ...

		@Autowired
		@Override
		public void setDataSource(@Qualifier("myDataSource") DataSource dataSource) {
			super.setDataSource(dataSource);
		}

	// ...
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// ...

		@Autowired
		override fun setDataSource(@Qualifier("myDataSource") dataSource: DataSource) {
			super.setDataSource(dataSource)
		}

	// ...
----

The specified qualifier value indicates the specific `DataSource` bean to inject,
narrowing the set of type matches to a specific bean. Its value is matched against
`<qualifier>` declarations within the corresponding `<bean>` definitions. The bean name
is used as a fallback qualifier value, so you can effectively also point to a specific
bean by name there (as shown earlier, assuming that `myDataSource` is the bean `id`).
=====


[[testcontext-web-scoped-beans]]
==== Testing Request- and Session-scoped Beans

Spring has supported <<core#beans-factory-scopes-other, Request- and session-scoped
beans>> since the early years, and you can test your request-scoped and session-scoped
beans by following these steps:

* Ensure that a `WebApplicationContext` is loaded for your test by annotating your test
  class with `@WebAppConfiguration`.
* Inject the mock request or session into your test instance and prepare your test
  fixture as appropriate.
* Invoke your web component that you retrieved from the configured
  `WebApplicationContext` (with dependency injection).
* Perform assertions against the mocks.

The next code snippet shows the XML configuration for a login use case. Note that the
`userService` bean has a dependency on a request-scoped `loginAction` bean. Also, the
`LoginAction` is instantiated by using <<core.adoc#expressions, SpEL expressions>> that
retrieve the username and password from the current HTTP request. In our test, we want to
configure these request parameters through the mock managed by the TestContext framework.
The following listing shows the configuration for this use case:

.Request-scoped bean configuration
[source,xml,indent=0]
----
	<beans>

		<bean id="userService" class="com.example.SimpleUserService"
				c:loginAction-ref="loginAction"/>

		<bean id="loginAction" class="com.example.LoginAction"
				c:username="#{request.getParameter('user')}"
				c:password="#{request.getParameter('pswd')}"
				scope="request">
			<aop:scoped-proxy/>
		</bean>

	</beans>
----

In `RequestScopedBeanTests`, we inject both the `UserService` (that is, the subject under
test) and the `MockHttpServletRequest` into our test instance. Within our
`requestScope()` test method, we set up our test fixture by setting request parameters in
the provided `MockHttpServletRequest`. When the `loginUser()` method is invoked on our
`userService`, we are assured that the user service has access to the request-scoped
`loginAction` for the current `MockHttpServletRequest` (that is, the one in which we just
set parameters). We can then perform assertions against the results based on the known
inputs for the username and password. The following listing shows how to do so:

.Request-scoped bean test
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@SpringJUnitWebConfig
	class RequestScopedBeanTests {

		@Autowired UserService userService;
		@Autowired MockHttpServletRequest request;

		@Test
		void requestScope() {
			request.setParameter("user", "enigma");
			request.setParameter("pswd", "$pr!ng");

			LoginResults results = userService.loginUser();
			// assert results
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@SpringJUnitWebConfig
	class RequestScopedBeanTests {

		@Autowired lateinit var userService: UserService
		@Autowired lateinit var request: MockHttpServletRequest

		@Test
		fun requestScope() {
			request.setParameter("user", "enigma")
			request.setParameter("pswd", "\$pr!ng")

			val results = userService.loginUser()
			// assert results
		}
	}
----

The following code snippet is similar to the one we saw earlier for a request-scoped
bean. However, this time, the `userService` bean has a dependency on a session-scoped
`userPreferences` bean. Note that the `UserPreferences` bean is instantiated by using a
SpEL expression that retrieves the theme from the current HTTP session. In our test, we
need to configure a theme in the mock session managed by the TestContext framework. The
following example shows how to do so:

.Session-scoped bean configuration
[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<beans>

		<bean id="userService" class="com.example.SimpleUserService"
				c:userPreferences-ref="userPreferences" />

		<bean id="userPreferences" class="com.example.UserPreferences"
				c:theme="#{session.getAttribute('theme')}"
				scope="session">
			<aop:scoped-proxy/>
		</bean>

	</beans>
----

In `SessionScopedBeanTests`, we inject the `UserService` and the `MockHttpSession` into
our test instance. Within our `sessionScope()` test method, we set up our test fixture by
setting the expected `theme` attribute in the provided `MockHttpSession`. When the
`processUserPreferences()` method is invoked on our `userService`, we are assured that
the user service has access to the session-scoped `userPreferences` for the current
`MockHttpSession`, and we can perform assertions against the results based on the
configured theme. The following example shows how to do so:

.Session-scoped bean test
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@SpringJUnitWebConfig
	class SessionScopedBeanTests {

		@Autowired UserService userService;
		@Autowired MockHttpSession session;

		@Test
		void sessionScope() throws Exception {
			session.setAttribute("theme", "blue");

			Results results = userService.processUserPreferences();
			// assert results
		}
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@SpringJUnitWebConfig
	class SessionScopedBeanTests {

		@Autowired lateinit var userService: UserService
		@Autowired lateinit var session: MockHttpSession

		@Test
		fun sessionScope() {
			session.setAttribute("theme", "blue")

			val results = userService.processUserPreferences()
			// assert results
		}
	}
----

[[testcontext-tx]]
==== Transaction Management

In the TestContext framework, transactions are managed by the
`TransactionalTestExecutionListener`, which is configured by default, even if you do not
explicitly declare `@TestExecutionListeners` on your test class. To enable support for
transactions, however, you must configure a `PlatformTransactionManager` bean in the
`ApplicationContext` that is loaded with `@ContextConfiguration` semantics (further
details are provided later). In addition, you must declare Spring's `@Transactional`
annotation either at the class or the method level for your tests.

[[testcontext-tx-test-managed-transactions]]
===== Test-managed Transactions

Test-managed transactions are transactions that are managed declaratively by using the
`TransactionalTestExecutionListener` or programmatically by using `TestTransaction`
(described later). You should not confuse such transactions with Spring-managed
transactions (those managed directly by Spring within the `ApplicationContext` loaded for
tests) or application-managed transactions (those managed programmatically within
application code that is invoked by tests). Spring-managed and application-managed
transactions typically participate in test-managed transactions. However, you should use
caution if Spring-managed or application-managed transactions are configured with any
propagation type other than `REQUIRED` or `SUPPORTS` (see the discussion on
<<data-access.adoc#tx-propagation, transaction propagation>> for details).

.Preemptive timeouts and test-managed transactions
[WARNING]
====
Caution must be taken when using any form of preemptive timeouts from a testing framework
in conjunction with Spring's test-managed transactions.

Specifically, Spring’s testing support binds transaction state to the current thread (via
a `java.lang.ThreadLocal` variable) _before_ the current test method is invoked. If a
testing framework invokes the current test method in a new thread in order to support a
preemptive timeout, any actions performed within the current test method will _not_ be
invoked within the test-managed transaction. Consequently, the result of any such actions
will not be rolled back with the test-managed transaction. On the contrary, such actions
will be committed to the persistent store -- for example, a relational database -- even
though the test-managed transaction is properly rolled back by Spring.

Situations in which this can occur include but are not limited to the following.

* JUnit 4's `@Test(timeout = ...)` support and `TimeOut` rule
* JUnit Jupiter's `assertTimeoutPreemptively(...)` methods in the
  `org.junit.jupiter.api.Assertions` class
* TestNG's `@Test(timeOut = ...)` support
====

[[testcontext-tx-enabling-transactions]]
===== Enabling and Disabling Transactions

Annotating a test method with `@Transactional` causes the test to be run within a
transaction that is, by default, automatically rolled back after completion of the test.
If a test class is annotated with `@Transactional`, each test method within that class
hierarchy runs within a transaction. Test methods that are not annotated with
`@Transactional` (at the class or method level) are not run within a transaction. Note
that `@Transactional` is not supported on test lifecycle methods — for example, methods
annotated with JUnit Jupiter's `@BeforeAll`, `@BeforeEach`, etc. Furthermore, tests that
are annotated with `@Transactional` but have the `propagation` attribute set to
`NOT_SUPPORTED` are not run within a transaction.

[[testcontext-tx-attribute-support]]
.`@Transactional` attribute support
|===
|Attribute |Supported for test-managed transactions

|`value` and `transactionManager` |yes

|`propagation` |only `Propagation.NOT_SUPPORTED` is supported

|`isolation` |no

|`timeout` |no

|`readOnly` |no

|`rollbackFor` and `rollbackForClassName` |no: use `TestTransaction.flagForRollback()` instead

|`noRollbackFor` and `noRollbackForClassName` |no: use `TestTransaction.flagForCommit()` instead
|===

[TIP]
====
Method-level lifecycle methods — for example, methods annotated with JUnit Jupiter's
`@BeforeEach` or `@AfterEach` — are run within a test-managed transaction. On the other
hand, suite-level and class-level lifecycle methods — for example, methods annotated with
JUnit Jupiter's `@BeforeAll` or `@AfterAll` and methods annotated with TestNG's
`@BeforeSuite`, `@AfterSuite`, `@BeforeClass`, or `@AfterClass` — are _not_ run within a
test-managed transaction.

If you need to execute code in a suite-level or class-level lifecycle method within a
transaction, you may wish to inject a corresponding `PlatformTransactionManager` into
your test class and then use that with a `TransactionTemplate` for programmatic
transaction management.
====

Note that <<testcontext-support-classes-junit4,
`AbstractTransactionalJUnit4SpringContextTests`>> and
<<testcontext-support-classes-testng, `AbstractTransactionalTestNGSpringContextTests`>>
are preconfigured for transactional support at the class level.

The following example demonstrates a common scenario for writing an integration test for
a Hibernate-based `UserRepository`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@SpringJUnitConfig(TestConfig.class)
	@Transactional
	class HibernateUserRepositoryTests {

		@Autowired
		HibernateUserRepository repository;

		@Autowired
		SessionFactory sessionFactory;

		JdbcTemplate jdbcTemplate;

		@Autowired
		void setDataSource(DataSource dataSource) {
			this.jdbcTemplate = new JdbcTemplate(dataSource);
		}

		@Test
		void createUser() {
			// track initial state in test database:
			final int count = countRowsInTable("user");

			User user = new User(...);
			repository.save(user);

			// Manual flush is required to avoid false positive in test
			sessionFactory.getCurrentSession().flush();
			assertNumUsers(count + 1);
		}

		private int countRowsInTable(String tableName) {
			return JdbcTestUtils.countRowsInTable(this.jdbcTemplate, tableName);
		}

		private void assertNumUsers(int expected) {
			assertEquals("Number of rows in the [user] table.", expected, countRowsInTable("user"));
		}
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@SpringJUnitConfig(TestConfig::class)
	@Transactional
	class HibernateUserRepositoryTests {

		@Autowired
		lateinit var repository: HibernateUserRepository

		@Autowired
		lateinit var sessionFactory: SessionFactory

		lateinit var jdbcTemplate: JdbcTemplate

		@Autowired
		fun setDataSource(dataSource: DataSource) {
			this.jdbcTemplate = JdbcTemplate(dataSource)
		}

		@Test
		fun createUser() {
			// track initial state in test database:
			val count = countRowsInTable("user")

			val user = User()
			repository.save(user)

			// Manual flush is required to avoid false positive in test
			sessionFactory.getCurrentSession().flush()
			assertNumUsers(count + 1)
		}

		private fun countRowsInTable(tableName: String): Int {
			return JdbcTestUtils.countRowsInTable(jdbcTemplate, tableName)
		}

		private fun assertNumUsers(expected: Int) {
			assertEquals("Number of rows in the [user] table.", expected, countRowsInTable("user"))
		}
	}
----

As explained in <<testcontext-tx-rollback-and-commit-behavior>>, there is no need to
clean up the database after the `createUser()` method runs, since any changes made to the
database are automatically rolled back by the `TransactionalTestExecutionListener`.

[[testcontext-tx-rollback-and-commit-behavior]]
===== Transaction Rollback and Commit Behavior

By default, test transactions will be automatically rolled back after completion of the
test; however, transactional commit and rollback behavior can be configured declaratively
via the `@Commit` and `@Rollback` annotations. See the corresponding entries in the
<<integration-testing-annotations, annotation support>> section for further details.

[[testcontext-tx-programmatic-tx-mgt]]
===== Programmatic Transaction Management

You can interact with test-managed transactions programmatically by using the static
methods in `TestTransaction`. For example, you can use `TestTransaction` within test
methods, before methods, and after methods to start or end the current test-managed
transaction or to configure the current test-managed transaction for rollback or commit.
Support for `TestTransaction` is automatically available whenever the
`TransactionalTestExecutionListener` is enabled.

The following example demonstrates some of the features of `TestTransaction`. See the
javadoc for {api-spring-framework}/test/context/transaction/TestTransaction.html[`TestTransaction`]
for further details.

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ContextConfiguration(classes = TestConfig.class)
	public class ProgrammaticTransactionManagementTests extends
			AbstractTransactionalJUnit4SpringContextTests {

		@Test
		public void transactionalTest() {
			// assert initial state in test database:
			assertNumUsers(2);

			deleteFromTables("user");

			// changes to the database will be committed!
			TestTransaction.flagForCommit();
			TestTransaction.end();
			assertFalse(TestTransaction.isActive());
			assertNumUsers(0);

			TestTransaction.start();
			// perform other actions against the database that will
			// be automatically rolled back after the test completes...
		}

		protected void assertNumUsers(int expected) {
			assertEquals("Number of rows in the [user] table.", expected, countRowsInTable("user"));
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ContextConfiguration(classes = [TestConfig::class])
	class ProgrammaticTransactionManagementTests : AbstractTransactionalJUnit4SpringContextTests() {

		@Test
		fun transactionalTest() {
			// assert initial state in test database:
			assertNumUsers(2)

			deleteFromTables("user")

			// changes to the database will be committed!
			TestTransaction.flagForCommit()
			TestTransaction.end()
			assertFalse(TestTransaction.isActive())
			assertNumUsers(0)

			TestTransaction.start()
			// perform other actions against the database that will
			// be automatically rolled back after the test completes...
		}

		protected fun assertNumUsers(expected: Int) {
			assertEquals("Number of rows in the [user] table.", expected, countRowsInTable("user"))
		}
	}
----

[[testcontext-tx-before-and-after-tx]]
===== Running Code Outside of a Transaction

Occasionally, you may need to execute certain code before or after a transactional test
method but outside the transactional context -- for example, to verify the initial
database state prior to running your test or to verify expected transactional commit
behavior after your test runs (if the test was configured to commit the transaction).
`TransactionalTestExecutionListener` supports the `@BeforeTransaction` and
`@AfterTransaction` annotations for exactly such scenarios. You can annotate any `void`
method in a test class or any `void` default method in a test interface with one of these
annotations, and the `TransactionalTestExecutionListener` ensures that your before
transaction method or after transaction method runs at the appropriate time.

TIP: Any before methods (such as methods annotated with JUnit Jupiter's `@BeforeEach`)
and any after methods (such as methods annotated with JUnit Jupiter's `@AfterEach`) are
run within a transaction. In addition, methods annotated with `@BeforeTransaction` or
`@AfterTransaction` are not run for test methods that are not configured to run within a
transaction.

[[testcontext-tx-mgr-config]]
===== Configuring a Transaction Manager

`TransactionalTestExecutionListener` expects a `PlatformTransactionManager` bean to be
defined in the Spring `ApplicationContext` for the test. If there are multiple instances
of `PlatformTransactionManager` within the test's `ApplicationContext`, you can declare a
qualifier by using `@Transactional("myTxMgr")` or `@Transactional(transactionManager =
"myTxMgr")`, or `TransactionManagementConfigurer` can be implemented by an
`@Configuration` class. Consult the
{api-spring-framework}/test/context/transaction/TestContextTransactionUtils.html#retrieveTransactionManager-org.springframework.test.context.TestContext-java.lang.String-[javadoc
for `TestContextTransactionUtils.retrieveTransactionManager()`] for details on the
algorithm used to look up a transaction manager in the test's `ApplicationContext`.

[[testcontext-tx-annotation-demo]]
===== Demonstration of All Transaction-related Annotations

The following JUnit Jupiter based example displays a fictitious integration testing
scenario that highlights all transaction-related annotations. The example is not intended
to demonstrate best practices but rather to demonstrate how these annotations can be
used. See the <<integration-testing-annotations, annotation support>> section for further
information and configuration examples. <<testcontext-executing-sql-declaratively-tx,
Transaction management for `@Sql`>> contains an additional example that uses `@Sql` for
declarative SQL script execution with default transaction rollback semantics. The
following example shows the relevant annotations:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@SpringJUnitConfig
	@Transactional(transactionManager = "txMgr")
	@Commit
	class FictitiousTransactionalTest {

		@BeforeTransaction
		void verifyInitialDatabaseState() {
			// logic to verify the initial state before a transaction is started
		}

		@BeforeEach
		void setUpTestDataWithinTransaction() {
			// set up test data within the transaction
		}

		@Test
		// overrides the class-level @Commit setting
		@Rollback
		void modifyDatabaseWithinTransaction() {
			// logic which uses the test data and modifies database state
		}

		@AfterEach
		void tearDownWithinTransaction() {
			// execute "tear down" logic within the transaction
		}

		@AfterTransaction
		void verifyFinalDatabaseState() {
			// logic to verify the final state after transaction has rolled back
		}

	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@SpringJUnitConfig
	@Transactional(transactionManager = "txMgr")
	@Commit
	class FictitiousTransactionalTest {

		@BeforeTransaction
		fun verifyInitialDatabaseState() {
			// logic to verify the initial state before a transaction is started
		}

		@BeforeEach
		fun setUpTestDataWithinTransaction() {
			// set up test data within the transaction
		}

		@Test
		// overrides the class-level @Commit setting
		@Rollback
		fun modifyDatabaseWithinTransaction() {
			// logic which uses the test data and modifies database state
		}

		@AfterEach
		fun tearDownWithinTransaction() {
			// execute "tear down" logic within the transaction
		}

		@AfterTransaction
		fun verifyFinalDatabaseState() {
			// logic to verify the final state after transaction has rolled back
		}

	}
----

[[testcontext-tx-false-positives]]
.Avoid false positives when testing ORM code

[NOTE]
=====
When you test application code that manipulates the state of a Hibernate session or JPA
persistence context, make sure to flush the underlying unit of work within test methods
that run that code. Failing to flush the underlying unit of work can produce false
positives: Your test passes, but the same code throws an exception in a live, production
environment. Note that this applies to any ORM framework that maintains an in-memory unit
of work. In the following Hibernate-based example test case, one method demonstrates a
false positive, and the other method correctly exposes the results of flushing the
session:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// ...

	@Autowired
	SessionFactory sessionFactory;

	@Transactional
	@Test // no expected exception!
	public void falsePositive() {
		updateEntityInHibernateSession();
		// False positive: an exception will be thrown once the Hibernate
		// Session is finally flushed (i.e., in production code)
	}

	@Transactional
	@Test(expected = ...)
	public void updateWithSessionFlush() {
		updateEntityInHibernateSession();
		// Manual flush is required to avoid false positive in test
		sessionFactory.getCurrentSession().flush();
	}

	// ...
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// ...

	@Autowired
	lateinit var sessionFactory: SessionFactory

	@Transactional
	@Test // no expected exception!
	fun falsePositive() {
		updateEntityInHibernateSession()
		// False positive: an exception will be thrown once the Hibernate
		// Session is finally flushed (i.e., in production code)
	}

	@Transactional
	@Test(expected = ...)
	fun updateWithSessionFlush() {
		updateEntityInHibernateSession()
		// Manual flush is required to avoid false positive in test
		sessionFactory.getCurrentSession().flush()
	}

	// ...
----

The following example shows matching methods for JPA:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// ...

	@PersistenceContext
	EntityManager entityManager;

	@Transactional
	@Test // no expected exception!
	public void falsePositive() {
		updateEntityInJpaPersistenceContext();
		// False positive: an exception will be thrown once the JPA
		// EntityManager is finally flushed (i.e., in production code)
	}

	@Transactional
	@Test(expected = ...)
	public void updateWithEntityManagerFlush() {
		updateEntityInJpaPersistenceContext();
		// Manual flush is required to avoid false positive in test
		entityManager.flush();
	}

	// ...
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// ...

	@PersistenceContext
	lateinit var entityManager:EntityManager

	@Transactional
	@Test // no expected exception!
	fun falsePositive() {
		updateEntityInJpaPersistenceContext()
		// False positive: an exception will be thrown once the JPA
		// EntityManager is finally flushed (i.e., in production code)
	}

	@Transactional
	@Test(expected = ...)
	void updateWithEntityManagerFlush() {
		updateEntityInJpaPersistenceContext()
		// Manual flush is required to avoid false positive in test
		entityManager.flush()
	}

	// ...
----
=====


[[testcontext-executing-sql]]
==== Executing SQL Scripts

When writing integration tests against a relational database, it is often beneficial to
execute SQL scripts to modify the database schema or insert test data into tables. The
`spring-jdbc` module provides support for _initializing_ an embedded or existing database
by executing SQL scripts when the Spring `ApplicationContext` is loaded. See
<<data-access.adoc#jdbc-embedded-database-support, Embedded database support>> and
<<data-access.adoc#jdbc-embedded-database-dao-testing, Testing data access logic with an
embedded database>> for details.

Although it is very useful to initialize a database for testing _once_ when the
`ApplicationContext` is loaded, sometimes it is essential to be able to modify the
database _during_ integration tests. The following sections explain how to execute SQL
scripts programmatically and declaratively during integration tests.

[[testcontext-executing-sql-programmatically]]
===== Executing SQL scripts programmatically

Spring provides the following options for executing SQL scripts programmatically within
integration test methods.

* `org.springframework.jdbc.datasource.init.ScriptUtils`
* `org.springframework.jdbc.datasource.init.ResourceDatabasePopulator`
* `org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests`
* `org.springframework.test.context.testng.AbstractTransactionalTestNGSpringContextTests`

`ScriptUtils` provides a collection of static utility methods for working with SQL
scripts and is mainly intended for internal use within the framework. However, if you
require full control over how SQL scripts are parsed and executed, `ScriptUtils` may suit
your needs better than some of the other alternatives described later. See the
{api-spring-framework}/jdbc/datasource/init/ScriptUtils.html[javadoc] for individual
methods in `ScriptUtils` for further details.

`ResourceDatabasePopulator` provides an object-based API for programmatically populating,
initializing, or cleaning up a database by using SQL scripts defined in external
resources. `ResourceDatabasePopulator` provides options for configuring the character
encoding, statement separator, comment delimiters, and error handling flags used when
parsing and running the scripts. Each of the configuration options has a reasonable
default value. See the
{api-spring-framework}/jdbc/datasource/init/ResourceDatabasePopulator.html[javadoc] for
details on default values. To run the scripts configured in a
`ResourceDatabasePopulator`, you can invoke either the `populate(Connection)` method to
execute the populator against a `java.sql.Connection` or the `execute(DataSource)` method
to execute the populator against a `javax.sql.DataSource`. The following example
specifies SQL scripts for a test schema and test data, sets the statement separator to
`@@`, and executes the scripts against a `DataSource`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Test
	void databaseTest() {
		ResourceDatabasePopulator populator = new ResourceDatabasePopulator();
		populator.addScripts(
				new ClassPathResource("test-schema.sql"),
				new ClassPathResource("test-data.sql"));
		populator.setSeparator("@@");
		populator.execute(this.dataSource);
		// execute code that uses the test schema and data
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Test
	fun databaseTest() {
		val populator = ResourceDatabasePopulator()
		populator.addScripts(
				ClassPathResource("test-schema.sql"),
				ClassPathResource("test-data.sql"))
		populator.setSeparator("@@")
		populator.execute(dataSource)
		// execute code that uses the test schema and data
	}
----

Note that `ResourceDatabasePopulator` internally delegates to `ScriptUtils` for parsing
and running SQL scripts. Similarly, the `executeSqlScript(..)` methods in
<<testcontext-support-classes-junit4, `AbstractTransactionalJUnit4SpringContextTests`>>
and <<testcontext-support-classes-testng, `AbstractTransactionalTestNGSpringContextTests`>>
internally use a `ResourceDatabasePopulator` to run SQL scripts. See the javadoc for the
various `executeSqlScript(..)` methods for further details.

[[testcontext-executing-sql-declaratively]]
===== Executing SQL scripts declaratively with @Sql

In addition to the aforementioned mechanisms for running SQL scripts programmatically,
you can declaratively configure SQL scripts in the Spring TestContext Framework.
Specifically, you can declare the `@Sql` annotation on a test class or test method to
configure individual SQL statements or the resource paths to SQL scripts that should be
run against a given database before or after an integration test method. Support for
`@Sql` is provided by the `SqlScriptsTestExecutionListener`, which is enabled by default.

NOTE: Method-level `@Sql` declarations override class-level declarations by default. As
of Spring Framework 5.2, however, this behavior may be configured per test class or per
test method via `@SqlMergeMode`. See
<<testcontext-executing-sql-declaratively-script-merging>> for further details.

[[testcontext-executing-sql-declaratively-script-resources]]
====== Path Resource Semantics

Each path is interpreted as a Spring `Resource`. A plain path (for example,
`"schema.sql"`) is treated as a classpath resource that is relative to the package in
which the test class is defined. A path starting with a slash is treated as an absolute
classpath resource (for example, `"/org/example/schema.sql"`). A path that references a
URL (for example, a path prefixed with `classpath:`, `file:`, `http:`) is loaded by using
the specified resource protocol.

The following example shows how to use `@Sql` at the class level and at the method level
within a JUnit Jupiter based integration test class:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@SpringJUnitConfig
	@Sql("/test-schema.sql")
	class DatabaseTests {

		@Test
		void emptySchemaTest() {
			// execute code that uses the test schema without any test data
		}

		@Test
		@Sql({"/test-schema.sql", "/test-user-data.sql"})
		void userTest() {
			// execute code that uses the test schema and test data
		}
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@SpringJUnitConfig
	@Sql("/test-schema.sql")
	class DatabaseTests {

		@Test
		fun emptySchemaTest() {
			// execute code that uses the test schema without any test data
		}

		@Test
		@Sql("/test-schema.sql", "/test-user-data.sql")
		fun userTest() {
			// execute code that uses the test schema and test data
		}
	}
----

[[testcontext-executing-sql-declaratively-script-detection]]
====== Default Script Detection

If no SQL scripts or statements are specified, an attempt is made to detect a `default`
script, depending on where `@Sql` is declared. If a default cannot be detected, an
`IllegalStateException` is thrown.

* Class-level declaration: If the annotated test class is `com.example.MyTest`, the
  corresponding default script is `classpath:com/example/MyTest.sql`.
* Method-level declaration: If the annotated test method is named `testMethod()` and is
  defined in the class `com.example.MyTest`, the corresponding default script is
  `classpath:com/example/MyTest.testMethod.sql`.

[[testcontext-executing-sql-declaratively-multiple-annotations]]
====== Declaring Multiple `@Sql` Sets

If you need to configure multiple sets of SQL scripts for a given test class or test
method but with different syntax configuration, different error handling rules, or
different execution phases per set, you can declare multiple instances of `@Sql`. With
Java 8, you can use `@Sql` as a repeatable annotation. Otherwise, you can use the
`@SqlGroup` annotation as an explicit container for declaring multiple instances of
`@Sql`.

The following example shows how to use `@Sql` as a repeatable annotation with Java 8:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Test
	@Sql(scripts = "/test-schema.sql", config = @SqlConfig(commentPrefix = "`"))
	@Sql("/test-user-data.sql")
	void userTest() {
		// execute code that uses the test schema and test data
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// Repeatable annotations with non-SOURCE retention are not yet supported by Kotlin
----

In the scenario presented in the preceding example, the `test-schema.sql` script uses a
different syntax for single-line comments.

The following example is identical to the preceding example, except that the `@Sql`
declarations are grouped together within `@SqlGroup`. With Java 8 and above, the use of
`@SqlGroup` is optional, but you may need to use `@SqlGroup` for compatibility with
other JVM languages such as Kotlin.

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Test
	@SqlGroup({
		@Sql(scripts = "/test-schema.sql", config = @SqlConfig(commentPrefix = "`")),
		@Sql("/test-user-data.sql")
	)}
	void userTest() {
		// execute code that uses the test schema and test data
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Test
	@SqlGroup(
		Sql("/test-schema.sql", config = SqlConfig(commentPrefix = "`")),
		Sql("/test-user-data.sql"))
	fun userTest() {
		// execute code that uses the test schema and test data
	}
----

[[testcontext-executing-sql-declaratively-script-execution-phases]]
====== Script Execution Phases

By default, SQL scripts are executed before the corresponding test method. However, if
you need to run a particular set of scripts after the test method (for example, to clean
up database state), you can use the `executionPhase` attribute in `@Sql`, as the
following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Test
	@Sql(
		scripts = "create-test-data.sql",
		config = @SqlConfig(transactionMode = ISOLATED)
	)
	@Sql(
		scripts = "delete-test-data.sql",
		config = @SqlConfig(transactionMode = ISOLATED),
		executionPhase = AFTER_TEST_METHOD
	)
	void userTest() {
		// execute code that needs the test data to be committed
		// to the database outside of the test's transaction
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Test
	@SqlGroup(
		Sql("create-test-data.sql",
			config = SqlConfig(transactionMode = ISOLATED)),
		Sql("delete-test-data.sql",
			config = SqlConfig(transactionMode = ISOLATED),
			executionPhase = AFTER_TEST_METHOD))
	fun userTest() {
		// execute code that needs the test data to be committed
		// to the database outside of the test's transaction
	}
----

Note that `ISOLATED` and `AFTER_TEST_METHOD` are statically imported from
`Sql.TransactionMode` and `Sql.ExecutionPhase`, respectively.

[[testcontext-executing-sql-declaratively-script-configuration]]
====== Script Configuration with `@SqlConfig`

You can configure script parsing and error handling by using the `@SqlConfig` annotation.
When declared as a class-level annotation on an integration test class, `@SqlConfig`
serves as global configuration for all SQL scripts within the test class hierarchy. When
declared directly by using the `config` attribute of the `@Sql` annotation, `@SqlConfig`
serves as local configuration for the SQL scripts declared within the enclosing `@Sql`
annotation. Every attribute in `@SqlConfig` has an implicit default value, which is
documented in the javadoc of the corresponding attribute. Due to the rules defined for
annotation attributes in the Java Language Specification, it is, unfortunately, not
possible to assign a value of `null` to an annotation attribute. Thus, in order to
support overrides of inherited global configuration, `@SqlConfig` attributes have an
explicit default value of either `""` (for Strings), `{}` (for arrays), or `DEFAULT` (for
enumerations). This approach lets local declarations of `@SqlConfig` selectively override
individual attributes from global declarations of `@SqlConfig` by providing a value other
than `""`, `{}`, or `DEFAULT`. Global `@SqlConfig` attributes are inherited whenever
local `@SqlConfig` attributes do not supply an explicit value other than `""`, `{}`, or
`DEFAULT`. Explicit local configuration, therefore, overrides global configuration.

The configuration options provided by `@Sql` and `@SqlConfig` are equivalent to those
supported by `ScriptUtils` and `ResourceDatabasePopulator` but are a superset of those
provided by the `<jdbc:initialize-database/>` XML namespace element. See the javadoc of
individual attributes in {api-spring-framework}/test/context/jdbc/Sql.html[`@Sql`] and
{api-spring-framework}/test/context/jdbc/SqlConfig.html[`@SqlConfig`] for details.

[[testcontext-executing-sql-declaratively-tx]]
*Transaction management for `@Sql`*

By default, the `SqlScriptsTestExecutionListener` infers the desired transaction
semantics for scripts configured by using `@Sql`. Specifically, SQL scripts are run
without a transaction, within an existing Spring-managed transaction (for example, a
transaction managed by the `TransactionalTestExecutionListener` for a test annotated with
`@Transactional`), or within an isolated transaction, depending on the configured value
of the `transactionMode` attribute in `@SqlConfig` and the presence of a
`PlatformTransactionManager` in the test's `ApplicationContext`. As a bare minimum,
however, a `javax.sql.DataSource` must be present in the test's `ApplicationContext`.

If the algorithms used by `SqlScriptsTestExecutionListener` to detect a `DataSource` and
`PlatformTransactionManager` and infer the transaction semantics do not suit your needs,
you can specify explicit names by setting the `dataSource` and `transactionManager`
attributes of `@SqlConfig`. Furthermore, you can control the transaction propagation
behavior by setting the `transactionMode` attribute of `@SqlConfig` (for example, whether
scripts should be run in an isolated transaction). Although a thorough discussion of all
supported options for transaction management with `@Sql` is beyond the scope of this
reference manual, the javadoc for
{api-spring-framework}/test/context/jdbc/SqlConfig.html[`@SqlConfig`] and
{api-spring-framework}/test/context/jdbc/SqlScriptsTestExecutionListener.html[`SqlScriptsTestExecutionListener`]
provide detailed information, and the following example shows a typical testing scenario
that uses JUnit Jupiter and transactional tests with `@Sql`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@SpringJUnitConfig(TestDatabaseConfig.class)
	@Transactional
	class TransactionalSqlScriptsTests {

		final JdbcTemplate jdbcTemplate;

		@Autowired
		TransactionalSqlScriptsTests(DataSource dataSource) {
			this.jdbcTemplate = new JdbcTemplate(dataSource);
		}

		@Test
		@Sql("/test-data.sql")
		void usersTest() {
			// verify state in test database:
			assertNumUsers(2);
			// execute code that uses the test data...
		}

		int countRowsInTable(String tableName) {
			return JdbcTestUtils.countRowsInTable(this.jdbcTemplate, tableName);
		}

		void assertNumUsers(int expected) {
			assertEquals(expected, countRowsInTable("user"),
				"Number of rows in the [user] table.");
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@SpringJUnitConfig(TestDatabaseConfig::class)
	@Transactional
	class TransactionalSqlScriptsTests @Autowired constructor(dataSource: DataSource) {

		val jdbcTemplate: JdbcTemplate = JdbcTemplate(dataSource)

		@Test
		@Sql("/test-data.sql")
		fun usersTest() {
			// verify state in test database:
			assertNumUsers(2)
			// execute code that uses the test data...
		}

		fun countRowsInTable(tableName: String): Int {
			return JdbcTestUtils.countRowsInTable(jdbcTemplate, tableName)
		}

		fun assertNumUsers(expected: Int) {
			assertEquals(expected, countRowsInTable("user"),
					"Number of rows in the [user] table.")
		}
	}
----

Note that there is no need to clean up the database after the `usersTest()` method is
run, since any changes made to the database (either within the test method or within the
`/test-data.sql` script) are automatically rolled back by the
`TransactionalTestExecutionListener` (see <<testcontext-tx,transaction management>> for
details).

[[testcontext-executing-sql-declaratively-script-merging]]
====== Merging and Overriding Configuration with `@SqlMergeMode`

As of Spring Framework 5.2, it is possible to merge method-level `@Sql` declarations with
class-level declarations. For example, this allows you to provide the configuration for a
database schema or some common test data once per test class and then provide additional,
use case specific test data per test method. To enable `@Sql` merging, annotate either
your test class or test method with `@SqlMergeMode(MERGE)`. To disable merging for a
specific test method (or specific test subclass), you can switch back to the default mode
via `@SqlMergeMode(OVERRIDE)`. Consult the <<spring-testing-annotation-sqlmergemode,
`@SqlMergeMode` annotation documentation section>> for examples and further details.


[[testcontext-parallel-test-execution]]
==== Parallel Test Execution

Spring Framework 5.0 introduced basic support for executing tests in parallel within a
single JVM when using the Spring TestContext Framework. In general, this means that most
test classes or test methods can be executed in parallel without any changes to test code
or configuration.

TIP: For details on how to set up parallel test execution, see the documentation for your
testing framework, build tool, or IDE.

Keep in mind that the introduction of concurrency into your test suite can result in
unexpected side effects, strange runtime behavior, and tests that fail intermittently or
seemingly randomly. The Spring Team therefore provides the following general guidelines
for when not to execute tests in parallel.

Do not execute tests in parallel if the tests:

* Use Spring Framework's `@DirtiesContext` support.
* Use Spring Boot's `@MockBean` or `@SpyBean` support.
* Use JUnit 4's `@FixMethodOrder` support or any testing framework feature
  that is designed to ensure that test methods run in a particular order. Note,
  however, that this does not apply if entire test classes are executed in parallel.
* Change the state of shared services or systems such as a database, message broker,
  filesystem, and others. This applies to both embedded and external systems.

[TIP]
====
If parallel test execution fails with an exception stating that the `ApplicationContext`
for the current test is no longer active, this typically means that the
`ApplicationContext` was removed from the `ContextCache` in a different thread.

This may be due to the use of `@DirtiesContext` or due to automatic eviction from the
`ContextCache`. If `@DirtiesContext` is the culprit, you either need to find a way to
avoid using `@DirtiesContext` or exclude such tests from parallel execution. If the
maximum size of the `ContextCache` has been exceeded, you can increase the maximum size
of the cache. See the discussion on <<testcontext-ctx-management-caching, 上下文缓存>>
for details.
====

WARNING: Parallel test execution in the Spring TestContext Framework is only possible if
the underlying `TestContext` implementation provides a copy constructor, as explained in
the javadoc for {api-spring-framework}/test/context/TestContext.html[`TestContext`]. The
`DefaultTestContext` used in Spring provides such a constructor. However, if you use a
third-party library that provides a custom `TestContext` implementation, you need to
verify that it is suitable for parallel test execution.


[[testcontext-support-classes]]
==== TestContext Framework Support Classes

This section describes the various classes that support the Spring TestContext Framework.

[[testcontext-junit4-runner]]
===== Spring JUnit 4 Runner

The Spring TestContext Framework offers full integration with JUnit 4 through a custom
runner (supported on JUnit 4.12 or higher). By annotating test classes with
`@RunWith(SpringJUnit4ClassRunner.class)` or the shorter `@RunWith(SpringRunner.class)`
variant, developers can implement standard JUnit 4-based unit and integration tests and
simultaneously reap the benefits of the TestContext framework, such as support for
loading application contexts, dependency injection of test instances, transactional test
method execution, and so on. If you want to use the Spring TestContext Framework with an
alternative runner (such as JUnit 4's `Parameterized` runner) or third-party runners
(such as the `MockitoJUnitRunner`), you can, optionally, use
<<testcontext-junit4-rules, Spring's support for JUnit rules>> instead.

The following code listing shows the minimal requirements for configuring a test class to
run with the custom Spring `Runner`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RunWith(SpringRunner.class)
	@TestExecutionListeners({})
	public class SimpleTest {

		@Test
		public void testMethod() {
			// execute test logic...
		}
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RunWith(SpringRunner::class)
	@TestExecutionListeners
	class SimpleTest {

		@Test
		fun testMethod() {
			// execute test logic...
		}
	}
----

In the preceding example, `@TestExecutionListeners` is configured with an empty list, to
disable the default listeners, which otherwise would require an `ApplicationContext` to
be configured through `@ContextConfiguration`.

[[testcontext-junit4-rules]]
===== Spring JUnit 4 Rules

The `org.springframework.test.context.junit4.rules` package provides the following JUnit
4 rules (supported on JUnit 4.12 or higher):

* `SpringClassRule`
* `SpringMethodRule`

`SpringClassRule` is a JUnit `TestRule` that supports class-level features of the Spring
TestContext Framework, whereas `SpringMethodRule` is a JUnit `MethodRule` that supports
instance-level and method-level features of the Spring TestContext Framework.

In contrast to the `SpringRunner`, Spring's rule-based JUnit support has the advantage of
being independent of any `org.junit.runner.Runner` implementation and can, therefore, be
combined with existing alternative runners (such as JUnit 4's `Parameterized`) or
third-party runners (such as the `MockitoJUnitRunner`).

To support the full functionality of the TestContext framework, you must combine a
`SpringClassRule` with a `SpringMethodRule`. The following example shows the proper way
to declare these rules in an integration test:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// Optionally specify a non-Spring Runner via @RunWith(...)
	@ContextConfiguration
	public class IntegrationTest {

		@ClassRule
		public static final SpringClassRule springClassRule = new SpringClassRule();

		@Rule
		public final SpringMethodRule springMethodRule = new SpringMethodRule();

		@Test
		public void testMethod() {
			// execute test logic...
		}
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// Optionally specify a non-Spring Runner via @RunWith(...)
	@ContextConfiguration
	class IntegrationTest {

		@Rule
		val springMethodRule = SpringMethodRule()

		@Test
		fun testMethod() {
			// execute test logic...
		}

		companion object {
			@ClassRule
			val springClassRule = SpringClassRule()
		}
	}
----

[[testcontext-support-classes-junit4]]
===== JUnit 4 Support Classes

The `org.springframework.test.context.junit4` package provides the following support
classes for JUnit 4-based test cases (supported on JUnit 4.12 or higher):

* `AbstractJUnit4SpringContextTests`
* `AbstractTransactionalJUnit4SpringContextTests`

`AbstractJUnit4SpringContextTests` is an abstract base test class that integrates the
Spring TestContext Framework with explicit `ApplicationContext` testing support in a
JUnit 4 environment. When you extend `AbstractJUnit4SpringContextTests`, you can access a
`protected` `applicationContext` instance variable that you can use to perform explicit
bean lookups or to test the state of the context as a whole.

`AbstractTransactionalJUnit4SpringContextTests` is an abstract transactional extension of
`AbstractJUnit4SpringContextTests` that adds some convenience functionality for JDBC
access. This class expects a `javax.sql.DataSource` bean and a
`PlatformTransactionManager` bean to be defined in the `ApplicationContext`. When you
extend `AbstractTransactionalJUnit4SpringContextTests`, you can access a `protected`
`jdbcTemplate` instance variable that you can use to run SQL statements to query the
database. You can use such queries to confirm database state both before and after
running database-related application code, and Spring ensures that such queries run in
the scope of the same transaction as the application code. When used in conjunction with
an ORM tool, be sure to avoid <<testcontext-tx-false-positives, false positives>>.
As mentioned in <<integration-testing-support-jdbc>>,
`AbstractTransactionalJUnit4SpringContextTests` also provides convenience methods that
delegate to methods in `JdbcTestUtils` by using the aforementioned `jdbcTemplate`.
Furthermore, `AbstractTransactionalJUnit4SpringContextTests` provides an
`executeSqlScript(..)` method for running SQL scripts against the configured `DataSource`.

TIP: These classes are a convenience for extension. If you do not want your test classes
to be tied to a Spring-specific class hierarchy, you can configure your own custom test
classes by using `@RunWith(SpringRunner.class)` or <<testcontext-junit4-rules, Spring's
JUnit rules>>.

[[testcontext-junit-jupiter-extension]]
===== SpringExtension for JUnit Jupiter

The Spring TestContext Framework offers full integration with the JUnit Jupiter testing
framework, introduced in JUnit 5. By annotating test classes with
`@ExtendWith(SpringExtension.class)`, you can implement standard JUnit Jupiter-based unit
and integration tests and simultaneously reap the benefits of the TestContext framework,
such as support for loading application contexts, dependency injection of test instances,
transactional test method execution, and so on.

Furthermore, thanks to the rich extension API in JUnit Jupiter, Spring provides the
following features above and beyond the feature set that Spring supports for JUnit 4 and
TestNG:

* Dependency injection for test constructors, test methods, and test lifecycle callback
  methods. See <<testcontext-junit-jupiter-di>> for further details.
* Powerful support for link:https://junit.org/junit5/docs/current/user-guide/#extensions-conditions[conditional
  test execution] based on SpEL expressions, environment variables, system properties,
  and so on. See the documentation for `@EnabledIf` and `@DisabledIf` in
  <<integration-testing-annotations-junit-jupiter>> for further details and examples.
* Custom composed annotations that combine annotations from Spring and JUnit Jupiter. See
  the `@TransactionalDevTestConfig` and `@TransactionalIntegrationTest` examples in
  <<integration-testing-annotations-meta>> for further details.

The following code listing shows how to configure a test class to use the
`SpringExtension` in conjunction with `@ContextConfiguration`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// Instructs JUnit Jupiter to extend the test with Spring support.
	@ExtendWith(SpringExtension.class)
	// Instructs Spring to load an ApplicationContext from TestConfig.class
	@ContextConfiguration(classes = TestConfig.class)
	class SimpleTests {

		@Test
		void testMethod() {
			// execute test logic...
		}
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// Instructs JUnit Jupiter to extend the test with Spring support.
	@ExtendWith(SpringExtension::class)
	// Instructs Spring to load an ApplicationContext from TestConfig::class
	@ContextConfiguration(classes = [TestConfig::class])
	class SimpleTests {

		@Test
		fun testMethod() {
			// execute test logic...
		}
	}
----

Since you can also use annotations in JUnit 5 as meta-annotations, Spring provides the
`@SpringJUnitConfig` and `@SpringJUnitWebConfig` composed annotations to simplify the
configuration of the test `ApplicationContext` and JUnit Jupiter.

The following example uses `@SpringJUnitConfig` to reduce the amount of configuration
used in the previous example:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// Instructs Spring to register the SpringExtension with JUnit
	// Jupiter and load an ApplicationContext from TestConfig.class
	@SpringJUnitConfig(TestConfig.class)
	class SimpleTests {

		@Test
		void testMethod() {
			// execute test logic...
		}
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// Instructs Spring to register the SpringExtension with JUnit
	// Jupiter and load an ApplicationContext from TestConfig.class
	@SpringJUnitConfig(TestConfig::class)
	class SimpleTests {

		@Test
		fun testMethod() {
			// execute test logic...
		}
	}
----

Similarly, the following example uses `@SpringJUnitWebConfig` to create a
`WebApplicationContext` for use with JUnit Jupiter:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// Instructs Spring to register the SpringExtension with JUnit
	// Jupiter and load a WebApplicationContext from TestWebConfig.class
	@SpringJUnitWebConfig(TestWebConfig.class)
	class SimpleWebTests {

		@Test
		void testMethod() {
			// execute test logic...
		}
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// Instructs Spring to register the SpringExtension with JUnit
	// Jupiter and load a WebApplicationContext from TestWebConfig::class
	@SpringJUnitWebConfig(TestWebConfig::class)
	class SimpleWebTests {

		@Test
		fun testMethod() {
			// execute test logic...
		}
	}
----

See the documentation for `@SpringJUnitConfig` and `@SpringJUnitWebConfig` in
<<integration-testing-annotations-junit-jupiter>> for further details.

[[testcontext-junit-jupiter-di]]
===== Dependency Injection with `SpringExtension`

`SpringExtension` implements the
link:https://junit.org/junit5/docs/current/user-guide/#extensions-parameter-resolution[`ParameterResolver`]
extension API from JUnit Jupiter, which lets Spring provide dependency injection for test
constructors, test methods, and test lifecycle callback methods.

Specifically, `SpringExtension` can inject dependencies from the test's
`ApplicationContext` into test constructors and methods that are annotated with
`@BeforeAll`, `@AfterAll`, `@BeforeEach`, `@AfterEach`, `@Test`, `@RepeatedTest`,
`@ParameterizedTest`, and others.

[[testcontext-junit-jupiter-di-constructor]]
====== Constructor Injection

If a specific parameter in a constructor for a JUnit Jupiter test class is of type
`ApplicationContext` (or a sub-type thereof) or is annotated or meta-annotated with
`@Autowired`, `@Qualifier`, or `@Value`, Spring injects the value for that specific
parameter with the corresponding bean or value from the test's `ApplicationContext`.

Spring can also be configured to autowire all arguments for a test class constructor if
the constructor is considered to be _autowirable_. A constructor is considered to be
autowirable if one of the following conditions is met (in order of precedence).

* The constructor is annotated with `@Autowired`.
* `@TestConstructor` is present or meta-present on the test class with the `autowireMode`
  attribute set to `ALL`.
* The default _test constructor autowire mode_ has been changed to `ALL`.

See <<integration-testing-annotations-testconstructor>> for details on the use of
`@TestConstructor` and how to change the global _test constructor autowire mode_.

WARNING: If the constructor for a test class is considered to be _autowirable_, Spring
assumes the responsibility for resolving arguments for all parameters in the constructor.
Consequently, no other `ParameterResolver` registered with JUnit Jupiter can resolve
parameters for such a constructor.

[WARNING]
====
Constructor injection for test classes must not be used in conjunction with JUnit
Jupiter's `@TestInstance(PER_CLASS)` support if `@DirtiesContext` is used to close the
test's `ApplicationContext` before or after test methods.

The reason is that `@TestInstance(PER_CLASS)` instructs JUnit Jupiter to cache the test
instance between test method invocations. Consequently, the test instance will retain
references to beans that were originally injected from an `ApplicationContext` that has
been subsequently closed. Since the constructor for the test class will only be invoked
once in such scenarios, dependency injection will not occur again, and subsequent tests
will interact with beans from the closed `ApplicationContext` which may result in errors.

To use `@DirtiesContext` with "before test method" or "after test method" modes in
conjunction with `@TestInstance(PER_CLASS)`, one must configure dependencies from Spring
to be supplied via field or setter injection so that they can be re-injected between test
method invocations.
====

In the following example, Spring injects the `OrderService` bean from the
`ApplicationContext` loaded from `TestConfig.class` into the
`OrderServiceIntegrationTests` constructor.

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@SpringJUnitConfig(TestConfig.class)
	class OrderServiceIntegrationTests {

		private final OrderService orderService;

		@Autowired
		OrderServiceIntegrationTests(OrderService orderService) {
			this.orderService = orderService;
		}

		// tests that use the injected OrderService
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@SpringJUnitConfig(TestConfig::class)
	class OrderServiceIntegrationTests @Autowired constructor(private val orderService: OrderService){
		// tests that use the injected OrderService
	}

----

Note that this feature lets test dependencies be `final` and therefore immutable.

If the `spring.test.constructor.autowire.mode` property is to `all` (see
<<integration-testing-annotations-testconstructor>>), we can omit the declaration of
`@Autowired` on the constructor in the previous example, resulting in the following.

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@SpringJUnitConfig(TestConfig.class)
	class OrderServiceIntegrationTests {

		private final OrderService orderService;

		OrderServiceIntegrationTests(OrderService orderService) {
			this.orderService = orderService;
		}

		// tests that use the injected OrderService
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@SpringJUnitConfig(TestConfig::class)
	class OrderServiceIntegrationTests(val orderService:OrderService) {
		// tests that use the injected OrderService
	}
----

[[testcontext-junit-jupiter-di-method]]
====== Method Injection

If a parameter in a JUnit Jupiter test method or test lifecycle callback method is of
type `ApplicationContext` (or a sub-type thereof) or is annotated or meta-annotated with
`@Autowired`, `@Qualifier`, or `@Value`, Spring injects the value for that specific
parameter with the corresponding bean from the test's `ApplicationContext`.

In the following example, Spring injects the `OrderService` from the `ApplicationContext`
loaded from `TestConfig.class` into the `deleteOrder()` test method:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@SpringJUnitConfig(TestConfig.class)
	class OrderServiceIntegrationTests {

		@Test
		void deleteOrder(@Autowired OrderService orderService) {
			// use orderService from the test's ApplicationContext
		}
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@SpringJUnitConfig(TestConfig::class)
	class OrderServiceIntegrationTests {

		@Test
		fun deleteOrder(@Autowired orderService: OrderService) {
			// use orderService from the test's ApplicationContext
		}
	}
----

Due to the robustness of the `ParameterResolver` support in JUnit Jupiter, you can also
have multiple dependencies injected into a single method, not only from Spring but also
from JUnit Jupiter itself or other third-party extensions.

The following example shows how to have both Spring and JUnit Jupiter inject dependencies
into the `placeOrderRepeatedly()` test method simultaneously.

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@SpringJUnitConfig(TestConfig.class)
	class OrderServiceIntegrationTests {

		@RepeatedTest(10)
		void placeOrderRepeatedly(RepetitionInfo repetitionInfo,
				@Autowired OrderService orderService) {

			// use orderService from the test's ApplicationContext
			// and repetitionInfo from JUnit Jupiter
		}
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@SpringJUnitConfig(TestConfig::class)
	class OrderServiceIntegrationTests {

		@RepeatedTest(10)
		fun placeOrderRepeatedly(repetitionInfo:RepetitionInfo, @Autowired orderService:OrderService) {

			// use orderService from the test's ApplicationContext
			// and repetitionInfo from JUnit Jupiter
		}
	}
----

Note that the use of `@RepeatedTest` from JUnit Jupiter lets the test method gain access
to the `RepetitionInfo`.

[[testcontext-support-classes-testng]]
===== TestNG Support Classes

The `org.springframework.test.context.testng` package provides the following support
classes for TestNG based test cases:

* `AbstractTestNGSpringContextTests`
* `AbstractTransactionalTestNGSpringContextTests`

`AbstractTestNGSpringContextTests` is an abstract base test class that integrates the
Spring TestContext Framework with explicit `ApplicationContext` testing support in a
TestNG environment. When you extend `AbstractTestNGSpringContextTests`, you can access a
`protected` `applicationContext` instance variable that you can use to perform explicit
bean lookups or to test the state of the context as a whole.

`AbstractTransactionalTestNGSpringContextTests` is an abstract transactional extension of
`AbstractTestNGSpringContextTests` that adds some convenience functionality for JDBC
access. This class expects a `javax.sql.DataSource` bean and a
`PlatformTransactionManager` bean to be defined in the `ApplicationContext`. When you
extend `AbstractTransactionalTestNGSpringContextTests`, you can access a `protected`
`jdbcTemplate` instance variable that you can use to execute SQL statements to query the
database. You can use such queries to confirm database state both before and after
running database-related application code, and Spring ensures that such queries run in
the scope of the same transaction as the application code. When used in conjunction with
an ORM tool, be sure to avoid <<testcontext-tx-false-positives, false positives>>.
As mentioned in <<integration-testing-support-jdbc>>,
`AbstractTransactionalTestNGSpringContextTests` also provides convenience methods that
delegate to methods in `JdbcTestUtils` by using the aforementioned `jdbcTemplate`.
Furthermore, `AbstractTransactionalTestNGSpringContextTests` provides an
`executeSqlScript(..)` method for running SQL scripts against the configured `DataSource`.

TIP: These classes are a convenience for extension. If you do not want your test classes
to be tied to a Spring-specific class hierarchy, you can configure your own custom test
classes by using `@ContextConfiguration`, `@TestExecutionListeners`, and so on and by
manually instrumenting your test class with a `TestContextManager`. See the source code
of `AbstractTestNGSpringContextTests` for an example of how to instrument your test class.



[[spring-mvc-test-framework]]
=== Spring MVC Test Framework

The Spring MVC Test framework provides first class support for testing Spring MVC code
with a fluent API that you can use with JUnit, TestNG, or any other testing framework. It
is built on the {api-spring-framework}/mock/web/package-summary.html[Servlet API mock objects]
from the `spring-test` module and, hence, does not use a running Servlet container. It
uses the `DispatcherServlet` to provide full Spring MVC runtime behavior and provides
support for loading actual Spring configuration with the TestContext framework in
addition to a standalone mode, in which you can manually instantiate controllers and test
them one at a time.

Spring MVC Test also provides client-side support for testing code that uses the
`RestTemplate`. Client-side tests mock the server responses and also do not use a running
server.

TIP: Spring Boot provides an option to write full, end-to-end integration tests that
include a running server. If this is your goal, see the
{doc-spring-boot}/html/spring-boot-features.html#boot-features-testing[Spring Boot Reference Guide].
For more information on the differences between out-of-container and end-to-end
integration tests, see <<spring-mvc-test-vs-end-to-end-integration-tests>>.


[[spring-mvc-test-server]]
==== Server-Side Tests

You can write a plain unit test for a Spring MVC controller by using JUnit or TestNG. To
do so, instantiate the controller, inject it with mocked or stubbed dependencies, and
call its methods (passing `MockHttpServletRequest`, `MockHttpServletResponse`, and
others, as necessary). However, when writing such a unit test, much remains untested: for
example, request mappings, data binding, type conversion, validation, and much more.
Furthermore, other controller methods such as `@InitBinder`, `@ModelAttribute`, and
`@ExceptionHandler` may also be invoked as part of the request processing lifecycle.

The goal of Spring MVC Test is to provide an effective way to test controllers by
performing requests and generating responses through the actual `DispatcherServlet`.

Spring MVC Test builds on the familiar <<mock-objects-servlet, "`mock`" implementations of
the Servlet API>> available in the `spring-test` module. This allows performing requests
and generating responses without the need for running in a Servlet container. For the
most part, everything should work as it does at runtime with a few notable exceptions, as
explained in <<spring-mvc-test-vs-end-to-end-integration-tests>>. The following JUnit
Jupiter-based example uses Spring MVC Test:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
	import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

	@SpringJUnitWebConfig(locations = "test-servlet-context.xml")
	class ExampleTests {

		MockMvc mockMvc;

		@BeforeEach
		void setup(WebApplicationContext wac) {
			this.mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();
		}

		@Test
		void getAccount() throws Exception {
			this.mockMvc.perform(get("/accounts/1")
					.accept(MediaType.APPLICATION_JSON))
				.andExpect(status().isOk())
				.andExpect(content().contentType("application/json"))
				.andExpect(jsonPath("$.name").value("Lee"));
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.test.web.servlet.get

	@SpringJUnitWebConfig(locations = ["test-servlet-context.xml"])
	class ExampleTests {

		lateinit var mockMvc: MockMvc

		@BeforeEach
		fun setup(wac: WebApplicationContext) {
			this.mockMvc = MockMvcBuilders.webAppContextSetup(wac).build()
		}

		@Test
		fun getAccount() {
			mockMvc.get("/accounts/1") {
				accept = MediaType.APPLICATION_JSON
			}.andExpect {
				status { isOk }
				content { contentType(MediaType.APPLICATION_JSON) }
				jsonPath("$.name") { value("Lee") }
			}
		}
	}
----

NOTE: A dedicated <<languages.adoc#mockmvc-dsl, MockMvc DSL>> is available in Kotlin

The preceding test relies on the `WebApplicationContext` support of the TestContext
framework to load Spring configuration from an XML configuration file located in the same
package as the test class, but Java-based and Groovy-based configuration are also
supported. See these
https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/servlet/samples/context[sample tests].

The `MockMvc` instance is used to perform a `GET` request to `/accounts/1` and verify
that the resulting response has status 200, the content type is `application/json`, and
the response body has a JSON property called `name` with the value `Lee`. The `jsonPath`
syntax is supported through the Jayway https://github.com/jayway/JsonPath[JsonPath
project]. Many other options for verifying the result of the performed request are
discussed later in this document.

[[spring-mvc-test-server-static-imports]]
===== Static Imports

The fluent API in the example from the <<spring-mvc-test-server, preceding section>>
requires a few static imports, such as `MockMvcRequestBuilders.{asterisk}`,
`MockMvcResultMatchers.{asterisk}`, and `MockMvcBuilders.{asterisk}`. An easy way to find
these classes is to search for types that match `MockMvc*`. If you use Eclipse or the
Eclipse-based Spring Tool Suite, be sure to add them as "`favorite static members`" in
the Eclipse preferences under Java -> Editor -> Content Assist -> Favorites. Doing so
lets you use content assist after typing the first character of the static method name.
Other IDEs (such as IntelliJ) may not require any additional configuration. Check the
support for code completion on static members.

[[spring-mvc-test-server-setup-options]]
===== Setup Choices

You have two main options for creating an instance of `MockMvc`. The first is to load
Spring MVC configuration through the TestContext framework, which loads the Spring
configuration and injects a `WebApplicationContext` into the test to use to build a
`MockMvc` instance. The following example shows how to do so:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@SpringJUnitWebConfig(locations = "my-servlet-context.xml")
	class MyWebTests {

		MockMvc mockMvc;

		@BeforeEach
		void setup(WebApplicationContext wac) {
			this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();
		}

		// ...

	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@SpringJUnitWebConfig(locations = ["my-servlet-context.xml"])
	class MyWebTests {

		lateinit var mockMvc: MockMvc

		@BeforeEach
		fun setup(wac: WebApplicationContext) {
			mockMvc = MockMvcBuilders.webAppContextSetup(wac).build()
		}

		// ...

	}
----

Your second option is to manually create a controller instance without loading Spring
configuration. Instead, basic default configuration, roughly comparable to that of the
MVC JavaConfig or the MVC namespace, is automatically created. You can customize it to a
degree. The following example shows how to do so:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	class MyWebTests {

		MockMvc mockMvc;

		@BeforeEach
		void setup() {
			this.mockMvc = MockMvcBuilders.standaloneSetup(new AccountController()).build();
		}

		// ...

	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MyWebTests {

		lateinit var mockMvc : MockMvc

		@BeforeEach
		fun setup() {
			mockMvc = MockMvcBuilders.standaloneSetup(AccountController()).build()
		}

		// ...

	}
----

Which setup option should you use?

The `webAppContextSetup` loads your actual Spring MVC configuration, resulting in a more
complete integration test. Since the TestContext framework caches the loaded Spring
configuration, it helps keep tests running fast, even as you introduce more tests in your
test suite. Furthermore, you can inject mock services into controllers through Spring
configuration to remain focused on testing the web layer. The following example declares
a mock service with Mockito:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="accountService" class="org.mockito.Mockito" factory-method="mock">
		<constructor-arg value="org.example.AccountService"/>
	</bean>
----

You can then inject the mock service into the test to set up and verify your
expectations, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@SpringJUnitWebConfig(locations = "test-servlet-context.xml")
	class AccountTests {

		@Autowired
		AccountService accountService;

		MockMvc mockMvc;

		@BeforeEach
		void setup(WebApplicationContext wac) {
			this.mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();
		}

		// ...

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@SpringJUnitWebConfig(locations = ["test-servlet-context.xml"])
	class AccountTests {

		@Autowired
		lateinit var accountService: AccountService

		lateinit mockMvc: MockMvc

		@BeforeEach
		fun setup(wac: WebApplicationContext) {
			mockMvc = MockMvcBuilders.webAppContextSetup(wac).build()
		}

		// ...

	}
----

The `standaloneSetup`, on the other hand, is a little closer to a unit test. It tests one
controller at a time. You can manually inject the controller with mock dependencies, and
it does not involve loading Spring configuration. Such tests are more focused on style
and make it easier to see which controller is being tested, whether any specific Spring
MVC configuration is required to work, and so on. The `standaloneSetup` is also a very
convenient way to write ad-hoc tests to verify specific behavior or to debug an issue.

As with most "`integration versus unit testing`" debates, there is no right or wrong
answer. However, using the `standaloneSetup` does imply the need for additional
`webAppContextSetup` tests in order to verify your Spring MVC configuration.
Alternatively, you can write all your tests with `webAppContextSetup`, in order to always
test against your actual Spring MVC configuration.

[[spring-mvc-test-server-setup-steps]]
===== Setup Features

No matter which MockMvc builder you use, all `MockMvcBuilder` implementations provide
some common and very useful features. For example, you can declare an `Accept` header for
all requests and expect a status of 200 as well as a `Content-Type` header in all
responses, as follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// static import of MockMvcBuilders.standaloneSetup

	MockMvc mockMvc = standaloneSetup(new MusicController())
		.defaultRequest(get("/").accept(MediaType.APPLICATION_JSON))
		.alwaysExpect(status().isOk())
		.alwaysExpect(content().contentType("application/json;charset=UTF-8"))
		.build();
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed
----

In addition, third-party frameworks (and applications) can pre-package setup
instructions, such as those in a `MockMvcConfigurer`. The Spring Framework has one such
built-in implementation that helps to save and re-use the HTTP session across requests.
You can use it as follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// static import of SharedHttpSessionConfigurer.sharedHttpSession

	MockMvc mockMvc = MockMvcBuilders.standaloneSetup(new TestController())
			.apply(sharedHttpSession())
			.build();

	// Use mockMvc to perform requests...
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed
----

See the javadoc for
{api-spring-framework}/test/web/servlet/setup/ConfigurableMockMvcBuilder.html[`ConfigurableMockMvcBuilder`]
for a list of all MockMvc builder features or use the IDE to explore the available options.

[[spring-mvc-test-server-performing-requests]]
===== Performing Requests

You can perform requests that use any HTTP method, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	mockMvc.perform(post("/hotels/{id}", 42).accept(MediaType.APPLICATION_JSON));
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.test.web.servlet.post

	mockMvc.post("/hotels/{id}", 42) {
		accept = MediaType.APPLICATION_JSON
	}
----

You can also perform file upload requests that internally use
`MockMultipartHttpServletRequest` so that there is no actual parsing of a multipart
request. Rather, you have to set it up to be similar to the following example:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	mockMvc.perform(multipart("/doc").file("a1", "ABC".getBytes("UTF-8")));
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.test.web.servlet.multipart

	mockMvc.multipart("/doc") {
		file("a1", "ABC".toByteArray(charset("UTF8")))
	}
----

You can specify query parameters in URI template style, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	mockMvc.perform(get("/hotels?thing={thing}", "somewhere"));
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	mockMvc.get("/hotels?thing={thing}", "somewhere")
----

You can also add Servlet request parameters that represent either query or form
parameters, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	mockMvc.perform(get("/hotels").param("thing", "somewhere"));
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.test.web.servlet.get

	mockMvc.get("/hotels") {
		param("thing", "somewhere")
	}
----

If application code relies on Servlet request parameters and does not check the query
string explicitly (as is most often the case), it does not matter which option you use.
Keep in mind, however, that query parameters provided with the URI template are decoded
while request parameters provided through the `param(...)` method are expected to already
be decoded.

In most cases, it is preferable to leave the context path and the Servlet path out of the
request URI. If you must test with the full request URI, be sure to set the `contextPath`
and `servletPath` accordingly so that request mappings work, as the following example
shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	mockMvc.perform(get("/app/main/hotels/{id}").contextPath("/app").servletPath("/main"))
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.test.web.servlet.get

	mockMvc.get("/app/main/hotels/{id}") {
		contextPath = "/app"
		servletPath = "/main"
	}
----

In the preceding example, it would be cumbersome to set the `contextPath` and
`servletPath` with every performed request. Instead, you can set up default request
properties, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	class MyWebTests {

		MockMvc mockMvc;

		@BeforeEach
		void setup() {
			mockMvc = standaloneSetup(new AccountController())
				.defaultRequest(get("/")
				.contextPath("/app").servletPath("/main")
				.accept(MediaType.APPLICATION_JSON)).build();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed
----

The preceding properties affect every request performed through the `MockMvc` instance.
If the same property is also specified on a given request, it overrides the default
value. That is why the HTTP method and URI in the default request do not matter, since
they must be specified on every request.

[[spring-mvc-test-server-defining-expectations]]
===== Defining Expectations

You can define expectations by appending one or more `.andExpect(..)` calls after
performing a request, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	mockMvc.perform(get("/accounts/1")).andExpect(status().isOk());
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.test.web.servlet.get

	mockMvc.get("/accounts/1").andExpect {
		status().isOk()
	}
----

`MockMvcResultMatchers.*` provides a number of expectations, some of which are further
nested with more detailed expectations.

Expectations fall in two general categories. The first category of assertions verifies
properties of the response (for example, the response status, headers, and content).
These are the most important results to assert.

The second category of assertions goes beyond the response. These assertions let you
inspect Spring MVC specific aspects, such as which controller method processed the
request, whether an exception was raised and handled, what the content of the model is,
what view was selected, what flash attributes were added, and so on. They also let you
inspect Servlet specific aspects, such as request and session attributes.

The following test asserts that binding or validation failed:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	mockMvc.perform(post("/persons"))
		.andExpect(status().isOk())
		.andExpect(model().attributeHasErrors("person"));
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.test.web.servlet.post

	mockMvc.post("/persons").andExpect {
		status().isOk()
		model {
			attributeHasErrors("person")
		}
	}
----

Many times, when writing tests, it is useful to dump the results of the performed
request. You can do so as follows, where `print()` is a static import from
`MockMvcResultHandlers`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	mockMvc.perform(post("/persons"))
		.andDo(print())
		.andExpect(status().isOk())
		.andExpect(model().attributeHasErrors("person"));
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.test.web.servlet.post

	mockMvc.post("/persons").andDo {
			print()
		}.andExpect {
			status().isOk()
			model {
				attributeHasErrors("person")
			}
		}
----

As long as request processing does not cause an unhandled exception, the `print()` method
prints all the available result data to `System.out`. There is also a `log()` method and
two additional variants of the `print()` method, one that accepts an `OutputStream` and
one that accepts a `Writer`. For example, invoking `print(System.err)` prints the result
data to `System.err`, while invoking `print(myWriter)` prints the result data to a custom
writer. If you want to have the result data logged instead of printed, you can invoke the
`log()` method, which logs the result data as a single `DEBUG` message under the
`org.springframework.test.web.servlet.result` logging category.

In some cases, you may want to get direct access to the result and verify something that
cannot be verified otherwise. This can be achieved by appending `.andReturn()` after all
other expectations, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	MvcResult mvcResult = mockMvc.perform(post("/persons")).andExpect(status().isOk()).andReturn();
	// ...
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	var mvcResult = mockMvc.post("/persons").andExpect { status().isOk() }.andReturn()
	// ...
----

If all tests repeat the same expectations, you can set up common expectations once when
building the `MockMvc` instance, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	standaloneSetup(new SimpleController())
		.alwaysExpect(status().isOk())
		.alwaysExpect(content().contentType("application/json;charset=UTF-8"))
		.build()
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed
----

Note that common expectations are always applied and cannot be overridden without
creating a separate `MockMvc` instance.

When a JSON response content contains hypermedia links created with
https://github.com/spring-projects/spring-hateoas[Spring HATEOAS], you can verify the
resulting links by using JsonPath expressions, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	mockMvc.perform(get("/people").accept(MediaType.APPLICATION_JSON))
		.andExpect(jsonPath("$.links[?(@.rel == 'self')].href").value("http://localhost:8080/people"));
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	mockMvc.get("/people") {
		accept(MediaType.APPLICATION_JSON)
	}.andExpect {
		jsonPath("$.links[?(@.rel == 'self')].href") {
			value("http://localhost:8080/people")
		}
	}
----

When XML response content contains hypermedia links created with
https://github.com/spring-projects/spring-hateoas[Spring HATEOAS], you can verify the
resulting links by using XPath expressions:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	Map<String, String> ns = Collections.singletonMap("ns", "http://www.w3.org/2005/Atom");
	mockMvc.perform(get("/handle").accept(MediaType.APPLICATION_XML))
		.andExpect(xpath("/person/ns:link[@rel='self']/@href", ns).string("http://localhost:8080/people"));
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val ns = mapOf("ns" to "http://www.w3.org/2005/Atom")
	mockMvc.get("/handle") {
		accept(MediaType.APPLICATION_XML)
	}.andExpect {
		xpath("/person/ns:link[@rel='self']/@href", ns) {
			string("http://localhost:8080/people")
		}
	}
----

[[spring-mvc-test-async-requests]]
===== Async Requests

Servlet 3.0 asynchronous requests,
<<web.adoc#mvc-ann-async,supported in Spring MVC>>, work by exiting the Servlet container
thread and allowing the application to compute the response asynchronously, after which
an async dispatch is made to complete processing on a Servlet container thread.

In Spring MVC Test, async requests can be tested by asserting the produced async value
first, then manually performing the async dispatch, and finally verifying the response.
Below is an example test for controller methods that return `DeferredResult`, `Callable`,
or reactive type such as Reactor `Mono`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Test
	void test() throws Exception {
        MvcResult mvcResult = this.mockMvc.perform(get("/path"))
                .andExpect(status().isOk()) <1>
                .andExpect(request().asyncStarted()) <2>
                .andExpect(request().asyncResult("body")) <3>
                .andReturn();

        this.mockMvc.perform(asyncDispatch(mvcResult)) <4>
                .andExpect(status().isOk()) <5>
                .andExpect(content().string("body"));
    }
----
<1> Check response status is still unchanged
<2> Async processing must have started
<3> Wait and assert the async result
<4> Manually perform an ASYNC dispatch (as there is no running container)
<5> Verify the final response

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Test
	fun test() {
		var mvcResult = mockMvc.get("/path").andExpect {
			status().isOk() // <1>
			request { asyncStarted() } // <2>
			// TODO Remove unused generic parameter
			request { asyncResult<Nothing>("body") } // <3>
		}.andReturn()


		mockMvc.perform(asyncDispatch(mvcResult)) // <4>
				.andExpect {
					status().isOk() // <5>
					content().string("body")
				}
	}
----
<1> Check response status is still unchanged
<2> Async processing must have started
<3> Wait and assert the async result
<4> Manually perform an ASYNC dispatch (as there is no running container)
<5> Verify the final response


[[spring-mvc-test-vs-streaming-response]]
===== Streaming Responses

There are no options built into Spring MVC Test for container-less testing of streaming
responses. Applications that make use of
<<web.adoc#mvc-ann-async-http-streaming,Spring MVC streaming>> options can use the
<<testing.adoc#webtestclient-stream,WebTestClient>> to perform end-to-end, integration
tests against a running server. This is also supported in Spring Boot where you can
{doc-spring-boot}/html/spring-boot-features.html#boot-features-testing-spring-boot-applications-testing-with-running-server[test a running server]
with `WebTestClient`. One extra advantage is the ability to use the `StepVerifier` from
project Reactor that allows declaring expectations on a stream of data.


[[spring-mvc-test-server-filters]]
===== Filter Registrations

When setting up a `MockMvc` instance, you can register one or more Servlet `Filter`
instances, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	mockMvc = standaloneSetup(new PersonController()).addFilters(new CharacterEncodingFilter()).build();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed
----

Registered filters are invoked through the `MockFilterChain` from `spring-test`, and the
last filter delegates to the `DispatcherServlet`.


[[spring-mvc-test-vs-end-to-end-integration-tests]]
===== Spring MVC Test vs End-to-End Tests

Spring MVC Test is built on Servlet API mock implementations from the
`spring-test` module and does not rely on a running container. Therefore, there are
some differences when compared to full end-to-end integration tests with an actual
client and a live server running.

The easiest way to think about this is by starting with a blank `MockHttpServletRequest`.
Whatever you add to it is what the request becomes. Things that may catch you by surprise
are that there is no context path by default; no `jsessionid` cookie; no forwarding,
error, or async dispatches; and, therefore, no actual JSP rendering. Instead,
"`forwarded`" and "`redirected`" URLs are saved in the `MockHttpServletResponse` and can
be asserted with expectations.

This means that, if you use JSPs, you can verify the JSP page to which the request was
forwarded, but no HTML is rendered. In other words, the JSP is not invoked. Note,
however, that all other rendering technologies that do not rely on forwarding, such as
Thymeleaf and Freemarker, render HTML to the response body as expected. The same is true
for rendering JSON, XML, and other formats through `@ResponseBody` methods.

Alternatively, you may consider the full end-to-end integration testing support from
Spring Boot with `@SpringBootTest`. See the
{doc-spring-boot}/html/spring-boot-features.html#boot-features-testing[Spring Boot Reference Guide].

There are pros and cons for each approach. The options provided in Spring MVC Test are
different stops on the scale from classic unit testing to full integration testing. To be
certain, none of the options in Spring MVC Test fall under the category of classic unit
testing, but they are a little closer to it. For example, you can isolate the web layer
by injecting mocked services into controllers, in which case you are testing the web
layer only through the `DispatcherServlet` but with actual Spring configuration, as you
might test the data access layer in isolation from the layers above it. Also, you can use
the stand-alone setup, focusing on one controller at a time and manually providing the
configuration required to make it work.

Another important distinction when using Spring MVC Test is that, conceptually, such
tests are the server-side, so you can check what handler was used, if an exception was
handled with a HandlerExceptionResolver, what the content of the model is, what binding
errors there were, and other details. That means that it is easier to write expectations,
since the server is not a black box, as it is when testing it through an actual HTTP
client. This is generally an advantage of classic unit testing: It is easier to write,
reason about, and debug but does not replace the need for full integration tests. At the
same time, it is important not to lose sight of the fact that the response is the most
important thing to check. In short, there is room here for multiple styles and strategies
of testing even within the same project.

[[spring-mvc-test-server-resources]]
===== Further Examples

The framework's own tests include
https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/servlet/samples[many
sample tests] intended to show how to use Spring MVC Test. You can browse these examples
for further ideas. Also, the
https://github.com/spring-projects/spring-mvc-showcase[`spring-mvc-showcase`] project has
full test coverage based on Spring MVC Test.


[[spring-mvc-test-server-htmlunit]]
==== HtmlUnit Integration

Spring provides integration between <<spring-mvc-test-server, MockMvc>> and
http://htmlunit.sourceforge.net/[HtmlUnit]. This simplifies performing end-to-end testing
when using HTML-based views. This integration lets you:

* Easily test HTML pages by using tools such as
  http://htmlunit.sourceforge.net/[HtmlUnit],
  https://www.seleniumhq.org[WebDriver], and
  http://www.gebish.org/manual/current/#spock-junit-testng[Geb] without the need to
  deploy to a Servlet container.
* Test JavaScript within pages.
* Optionally, test using mock services to speed up testing.
* Share logic between in-container end-to-end tests and out-of-container integration tests.

NOTE: MockMvc works with templating technologies that do not rely on a Servlet Container
(for example, Thymeleaf, FreeMarker, and others), but it does not work with JSPs, since
they rely on the Servlet container.

[[spring-mvc-test-server-htmlunit-why]]
===== Why HtmlUnit Integration?

The most obvious question that comes to mind is "`Why do I need this?`" The answer is
best found by exploring a very basic sample application. Assume you have a Spring MVC web
application that supports CRUD operations on a `Message` object. The application also
supports paging through all messages. How would you go about testing it?

With Spring MVC Test, we can easily test if we are able to create a `Message`, as follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	MockHttpServletRequestBuilder createMessage = post("/messages/")
			.param("summary", "Spring Rocks")
			.param("text", "In case you didn't know, Spring Rocks!");

	mockMvc.perform(createMessage)
			.andExpect(status().is3xxRedirection())
			.andExpect(redirectedUrl("/messages/123"));
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Test
	fun test() {
		mockMvc.post("/messages/") {
			param("summary", "Spring Rocks")
			param("text", "In case you didn't know, Spring Rocks!")
		}.andExpect {
			status().is3xxRedirection()
			redirectedUrl("/messages/123")
		}
	}
----

What if we want to test the form view that lets us create the message? For example,
assume our form looks like the following snippet:

[source,xml,indent=0]
----
	<form id="messageForm" action="/messages/" method="post">
		<div class="pull-right"><a href="/messages/">Messages</a></div>

		<label for="summary">Summary</label>
		<input type="text" class="required" id="summary" name="summary" value="" />

		<label for="text">Message</label>
		<textarea id="text" name="text"></textarea>

		<div class="form-actions">
			<input type="submit" value="Create" />
		</div>
	</form>
----

How do we ensure that our form produce the correct request to create a new message? A
naive attempt might resemble the following:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	mockMvc.perform(get("/messages/form"))
			.andExpect(xpath("//input[@name='summary']").exists())
			.andExpect(xpath("//textarea[@name='text']").exists());
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	mockMvc.get("/messages/form").andExpect {
		xpath("//input[@name='summary']") { exists() }
		xpath("//textarea[@name='text']") { exists() }
	}
----

This test has some obvious drawbacks. If we update our controller to use the parameter
`message` instead of `text`, our form test continues to pass, even though the HTML form
is out of synch with the controller. To resolve this we can combine our two tests, as
follows:

[[spring-mvc-test-server-htmlunit-mock-mvc-test]]
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	String summaryParamName = "summary";
	String textParamName = "text";
	mockMvc.perform(get("/messages/form"))
			.andExpect(xpath("//input[@name='" + summaryParamName + "']").exists())
			.andExpect(xpath("//textarea[@name='" + textParamName + "']").exists());

	MockHttpServletRequestBuilder createMessage = post("/messages/")
			.param(summaryParamName, "Spring Rocks")
			.param(textParamName, "In case you didn't know, Spring Rocks!");

	mockMvc.perform(createMessage)
			.andExpect(status().is3xxRedirection())
			.andExpect(redirectedUrl("/messages/123"));
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val summaryParamName = "summary";
	val textParamName = "text";
	mockMvc.get("/messages/form").andExpect {
		xpath("//input[@name='$summaryParamName']") { exists() }
		xpath("//textarea[@name='$textParamName']") { exists() }
	}
	mockMvc.post("/messages/") {
		param(summaryParamName, "Spring Rocks")
		param(textParamName, "In case you didn't know, Spring Rocks!")
	}.andExpect {
		status().is3xxRedirection()
		redirectedUrl("/messages/123")
	}
----

This would reduce the risk of our test incorrectly passing, but there are still some
problems:

* What if we have multiple forms on our page? Admittedly, we could update our XPath
  expressions, but they get more complicated as we take more factors into account: Are
  the fields the correct type? Are the fields enabled? And so on.
* Another issue is that we are doing double the work we would expect. We must first
  verify the view, and then we submit the view with the same parameters we just verified.
  Ideally, this could be done all at once.
* Finally, we still cannot account for some things. For example, what if the form has
  JavaScript validation that we wish to test as well?

The overall problem is that testing a web page does not involve a single interaction.
Instead, it is a combination of how the user interacts with a web page and how that web
page interacts with other resources. For example, the result of a form view is used as
the input to a user for creating a message. In addition, our form view can potentially
use additional resources that impact the behavior of the page, such as JavaScript
validation.

[[spring-mvc-test-server-htmlunit-why-integration]]
====== Integration Testing to the Rescue?

To resolve the issues mentioned earlier, we could perform end-to-end integration testing,
but this has some drawbacks. Consider testing the view that lets us page through the
messages. We might need the following tests:

* Does our page display a notification to the user to indicate that no results are
  available when the messages are empty?
* Does our page properly display a single message?
* Does our page properly support paging?

To set up these tests, we need to ensure our database contains the proper messages. This
leads to a number of additional challenges:

* Ensuring the proper messages are in the database can be tedious. (Consider foreign key
  constraints.)
* Testing can become slow, since each test would need to ensure that the database is in
  the correct state.
* Since our database needs to be in a specific state, we cannot run tests in parallel.
* Performing assertions on such items as auto-generated ids, timestamps, and others can
  be difficult.

These challenges do not mean that we should abandon end-to-end integration testing
altogether. Instead, we can reduce the number of end-to-end integration tests by
refactoring our detailed tests to use mock services that run much faster, more reliably,
and without side effects. We can then implement a small number of true end-to-end
integration tests that validate simple workflows to ensure that everything works together
properly.

[[spring-mvc-test-server-htmlunit-why-mockmvc]]
====== Enter HtmlUnit Integration

So how can we achieve a balance between testing the interactions of our pages and still
retain good performance within our test suite? The answer is: "`By integrating MockMvc
with HtmlUnit.`"

[[spring-mvc-test-server-htmlunit-options]]
====== HtmlUnit Integration Options

You have a number of options when you want to integrate MockMvc with HtmlUnit:

* <<spring-mvc-test-server-htmlunit-mah,MockMvc and HtmlUnit>>: Use this option if you
  want to use the raw HtmlUnit libraries.
* <<spring-mvc-test-server-htmlunit-webdriver,MockMvc and WebDriver>>: Use this option to
  ease development and reuse code between integration and end-to-end testing.
* <<spring-mvc-test-server-htmlunit-geb,MockMvc and Geb>>: Use this option if you want to
  use Groovy for testing, ease development, and reuse code between integration and
  end-to-end testing.

[[spring-mvc-test-server-htmlunit-mah]]
===== MockMvc and HtmlUnit

This section describes how to integrate MockMvc and HtmlUnit. Use this option if you want
to use the raw HtmlUnit libraries.

[[spring-mvc-test-server-htmlunit-mah-setup]]
====== MockMvc and HtmlUnit Setup

First, make sure that you have included a test dependency on
`net.sourceforge.htmlunit:htmlunit`. In order to use HtmlUnit with Apache HttpComponents
4.5+, you need to use HtmlUnit 2.18 or higher.

We can easily create an HtmlUnit `WebClient` that integrates with MockMvc by using the
`MockMvcWebClientBuilder`, as follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	WebClient webClient;

	@BeforeEach
	void setup(WebApplicationContext context) {
		webClient = MockMvcWebClientBuilder
				.webAppContextSetup(context)
				.build();
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	lateinit var webClient: WebClient

	@BeforeEach
	fun setup(context: WebApplicationContext) {
		webClient = MockMvcWebClientBuilder
				.webAppContextSetup(context)
				.build()
	}
----

NOTE: This is a simple example of using `MockMvcWebClientBuilder`. For advanced usage,
see <<spring-mvc-test-server-htmlunit-mah-advanced-builder>>.

This ensures that any URL that references `localhost` as the server is directed to our
`MockMvc` instance without the need for a real HTTP connection. Any other URL is
requested by using a network connection, as normal. This lets us easily test the use of
CDNs.

[[spring-mvc-test-server-htmlunit-mah-usage]]
====== MockMvc and HtmlUnit Usage

Now we can use HtmlUnit as we normally would but without the need to deploy our
application to a Servlet container. For example, we can request the view to create a
message with the following:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	HtmlPage createMsgFormPage = webClient.getPage("http://localhost/messages/form");
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val createMsgFormPage = webClient.getPage("http://localhost/messages/form")
----

NOTE: The default context path is `""`. Alternatively, we can specify the context path,
as described in <<spring-mvc-test-server-htmlunit-mah-advanced-builder>>.

Once we have a reference to the `HtmlPage`, we can then fill out the form and submit it
to create a message, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	HtmlForm form = createMsgFormPage.getHtmlElementById("messageForm");
	HtmlTextInput summaryInput = createMsgFormPage.getHtmlElementById("summary");
	summaryInput.setValueAttribute("Spring Rocks");
	HtmlTextArea textInput = createMsgFormPage.getHtmlElementById("text");
	textInput.setText("In case you didn't know, Spring Rocks!");
	HtmlSubmitInput submit = form.getOneHtmlElementByAttribute("input", "type", "submit");
	HtmlPage newMessagePage = submit.click();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val form = createMsgFormPage.getHtmlElementById("messageForm")
	val summaryInput = createMsgFormPage.getHtmlElementById("summary")
	summaryInput.setValueAttribute("Spring Rocks")
	val textInput = createMsgFormPage.getHtmlElementById("text")
	textInput.setText("In case you didn't know, Spring Rocks!")
	val submit = form.getOneHtmlElementByAttribute("input", "type", "submit")
	val newMessagePage = submit.click()
----

Finally, we can verify that a new message was created successfully. The following
assertions use the https://joel-costigliola.github.io/assertj/[AssertJ] library:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	assertThat(newMessagePage.getUrl().toString()).endsWith("/messages/123");
	String id = newMessagePage.getHtmlElementById("id").getTextContent();
	assertThat(id).isEqualTo("123");
	String summary = newMessagePage.getHtmlElementById("summary").getTextContent();
	assertThat(summary).isEqualTo("Spring Rocks");
	String text = newMessagePage.getHtmlElementById("text").getTextContent();
	assertThat(text).isEqualTo("In case you didn't know, Spring Rocks!");
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	assertThat(newMessagePage.getUrl().toString()).endsWith("/messages/123")
	val id = newMessagePage.getHtmlElementById("id").getTextContent()
	assertThat(id).isEqualTo("123")
	val summary = newMessagePage.getHtmlElementById("summary").getTextContent()
	assertThat(summary).isEqualTo("Spring Rocks")
	val text = newMessagePage.getHtmlElementById("text").getTextContent()
	assertThat(text).isEqualTo("In case you didn't know, Spring Rocks!")
----

The preceding code improves on our
<<spring-mvc-test-server-htmlunit-mock-mvc-test, MockMvc test>> in a number of ways.
First, we no longer have to explicitly verify our form and then create a request that
looks like the form. Instead, we request the form, fill it out, and submit it, thereby
significantly reducing the overhead.

Another important factor is that http://htmlunit.sourceforge.net/javascript.html[HtmlUnit
uses the Mozilla Rhino engine] to evaluate JavaScript. This means that we can also test
the behavior of JavaScript within our pages.

See the http://htmlunit.sourceforge.net/gettingStarted.html[HtmlUnit documentation] for
additional information about using HtmlUnit.

[[spring-mvc-test-server-htmlunit-mah-advanced-builder]]
====== Advanced `MockMvcWebClientBuilder`

In the examples so far, we have used `MockMvcWebClientBuilder` in the simplest way
possible, by building a `WebClient` based on the `WebApplicationContext` loaded for us by
the Spring TestContext Framework. This approach is repeated in the following example:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	WebClient webClient;

	@BeforeEach
	void setup(WebApplicationContext context) {
		webClient = MockMvcWebClientBuilder
				.webAppContextSetup(context)
				.build();
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	lateinit var webClient: WebClient

	@BeforeEach
	fun setup(context: WebApplicationContext) {
		webClient = MockMvcWebClientBuilder
				.webAppContextSetup(context)
				.build()
	}
----

We can also specify additional configuration options, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	WebClient webClient;

	@BeforeEach
	void setup() {
		webClient = MockMvcWebClientBuilder
			// demonstrates applying a MockMvcConfigurer (Spring Security)
			.webAppContextSetup(context, springSecurity())
			// for illustration only - defaults to ""
			.contextPath("")
			// By default MockMvc is used for localhost only;
			// the following will use MockMvc for example.com and example.org as well
			.useMockMvcForHosts("example.com","example.org")
			.build();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	lateinit var webClient: WebClient

	@BeforeEach
	fun setup() {
		webClient = MockMvcWebClientBuilder
			// demonstrates applying a MockMvcConfigurer (Spring Security)
			.webAppContextSetup(context, springSecurity())
			// for illustration only - defaults to ""
			.contextPath("")
			// By default MockMvc is used for localhost only;
			// the following will use MockMvc for example.com and example.org as well
			.useMockMvcForHosts("example.com","example.org")
			.build()
	}
----

As an alternative, we can perform the exact same setup by configuring the `MockMvc`
instance separately and supplying it to the `MockMvcWebClientBuilder`, as follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	MockMvc mockMvc = MockMvcBuilders
			.webAppContextSetup(context)
			.apply(springSecurity())
			.build();

	webClient = MockMvcWebClientBuilder
			.mockMvcSetup(mockMvc)
			// for illustration only - defaults to ""
			.contextPath("")
			// By default MockMvc is used for localhost only;
			// the following will use MockMvc for example.com and example.org as well
			.useMockMvcForHosts("example.com","example.org")
			.build();
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed
----

This is more verbose, but, by building the `WebClient` with a `MockMvc` instance, we have
the full power of MockMvc at our fingertips.

TIP: For additional information on creating a `MockMvc` instance, see
<<spring-mvc-test-server-setup-options>>.

[[spring-mvc-test-server-htmlunit-webdriver]]
===== MockMvc and WebDriver

In the previous sections, we have seen how to use MockMvc in conjunction with the raw
HtmlUnit APIs. In this section, we use additional abstractions within the Selenium
https://docs.seleniumhq.org/projects/webdriver/[WebDriver] to make things even easier.

[[spring-mvc-test-server-htmlunit-webdriver-why]]
====== Why WebDriver and MockMvc?

We can already use HtmlUnit and MockMvc, so why would we want to use WebDriver? The
Selenium WebDriver provides a very elegant API that lets us easily organize our code. To
better show how it works, we explore an example in this section.

NOTE: Despite being a part of https://docs.seleniumhq.org/[Selenium], WebDriver does not
require a Selenium Server to run your tests.

Suppose we need to ensure that a message is created properly. The tests involve finding
the HTML form input elements, filling them out, and making various assertions.

This approach results in numerous separate tests because we want to test error conditions
as well. For example, we want to ensure that we get an error if we fill out only part of
the form. If we fill out the entire form, the newly created message should be displayed
afterwards.

If one of the fields were named "`summary`", we might have something that resembles the
following repeated in multiple places within our tests:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	HtmlTextInput summaryInput = currentPage.getHtmlElementById("summary");
	summaryInput.setValueAttribute(summary);
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val summaryInput = currentPage.getHtmlElementById("summary")
	summaryInput.setValueAttribute(summary)
----

So what happens if we change the `id` to `smmry`? Doing so would force us to update all
of our tests to incorporate this change. This violates the DRY principle, so we should
ideally extract this code into its own method, as follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public HtmlPage createMessage(HtmlPage currentPage, String summary, String text) {
		setSummary(currentPage, summary);
		// ...
	}

	public void setSummary(HtmlPage currentPage, String summary) {
		HtmlTextInput summaryInput = currentPage.getHtmlElementById("summary");
		summaryInput.setValueAttribute(summary);
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun createMessage(currentPage: HtmlPage, summary:String, text:String) :HtmlPage{
		setSummary(currentPage, summary);
		// ...
	}

	fun setSummary(currentPage:HtmlPage , summary: String) {
		val summaryInput = currentPage.getHtmlElementById("summary")
		summaryInput.setValueAttribute(summary)
	}
----

Doing so ensures that we do not have to update all of our tests if we change the UI.

We might even take this a step further and place this logic within an `Object` that
represents the `HtmlPage` we are currently on, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class CreateMessagePage {

		final HtmlPage currentPage;

		final HtmlTextInput summaryInput;

		final HtmlSubmitInput submit;

		public CreateMessagePage(HtmlPage currentPage) {
			this.currentPage = currentPage;
			this.summaryInput = currentPage.getHtmlElementById("summary");
			this.submit = currentPage.getHtmlElementById("submit");
		}

		public <T> T createMessage(String summary, String text) throws Exception {
			setSummary(summary);

			HtmlPage result = submit.click();
			boolean error = CreateMessagePage.at(result);

			return (T) (error ? new CreateMessagePage(result) : new ViewMessagePage(result));
		}

		public void setSummary(String summary) throws Exception {
			summaryInput.setValueAttribute(summary);
		}

		public static boolean at(HtmlPage page) {
			return "Create Message".equals(page.getTitleText());
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class CreateMessagePage(private val currentPage: HtmlPage) {

		val summaryInput: HtmlTextInput = currentPage.getHtmlElementById("summary")

		val submit: HtmlSubmitInput = currentPage.getHtmlElementById("submit")

		fun <T> createMessage(summary: String, text: String): T {
			setSummary(summary)

			val result = submit.click()
			val error = at(result)

			return (if (error) CreateMessagePage(result) else ViewMessagePage(result)) as T
		}

		fun setSummary(summary: String) {
			summaryInput.setValueAttribute(summary)
		}

		fun at(page: HtmlPage): Boolean {
			return "Create Message" == page.getTitleText()
		}
	}
}
----

Formerly, this pattern was known as the
https://github.com/SeleniumHQ/selenium/wiki/PageObjects[Page Object Pattern]. While we
can certainly do this with HtmlUnit, WebDriver provides some tools that we explore in the
following sections to make this pattern much easier to implement.

[[spring-mvc-test-server-htmlunit-webdriver-setup]]
====== MockMvc and WebDriver Setup

To use Selenium WebDriver with the Spring MVC Test framework, make sure that your project
includes a test dependency on `org.seleniumhq.selenium:selenium-htmlunit-driver`.

We can easily create a Selenium WebDriver that integrates with MockMvc by using the
`MockMvcHtmlUnitDriverBuilder` as the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	WebDriver driver;

	@BeforeEach
	void setup(WebApplicationContext context) {
		driver = MockMvcHtmlUnitDriverBuilder
				.webAppContextSetup(context)
				.build();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	lateinit var driver: WebDriver

	@BeforeEach
	fun setup(context: WebApplicationContext) {
		driver = MockMvcHtmlUnitDriverBuilder
				.webAppContextSetup(context)
				.build()
	}
----

NOTE: This is a simple example of using `MockMvcHtmlUnitDriverBuilder`. For more advanced
usage, see <<spring-mvc-test-server-htmlunit-webdriver-advanced-builder>>.

The preceding example ensures that any URL that references `localhost` as the server is
directed to our `MockMvc` instance without the need for a real HTTP connection. Any other
URL is requested by using a network connection, as normal. This lets us easily test the
use of CDNs.

[[spring-mvc-test-server-htmlunit-webdriver-usage]]
====== MockMvc and WebDriver Usage

Now we can use WebDriver as we normally would but without the need to deploy our
application to a Servlet container. For example, we can request the view to create a
message with the following:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	CreateMessagePage page = CreateMessagePage.to(driver);
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val page = CreateMessagePage.to(driver)
----

We can then fill out the form and submit it to create a message, as follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	ViewMessagePage viewMessagePage =
			page.createMessage(ViewMessagePage.class, expectedSummary, expectedText);
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val viewMessagePage =
		page.createMessage(ViewMessagePage::class, expectedSummary, expectedText)
----

This improves on the design of our <<spring-mvc-test-server-htmlunit-mah-usage, HtmlUnit test>>
by leveraging the Page Object Pattern. As we mentioned in
<<spring-mvc-test-server-htmlunit-webdriver-why>>, we can use the Page Object Pattern
with HtmlUnit, but it is much easier with WebDriver. Consider the following
`CreateMessagePage` implementation:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class CreateMessagePage
			extends AbstractPage { // <1>

		// <2>
		private WebElement summary;
		private WebElement text;

		// <3>
		@FindBy(css = "input[type=submit]")
		private WebElement submit;

		public CreateMessagePage(WebDriver driver) {
			super(driver);
		}

		public <T> T createMessage(Class<T> resultPage, String summary, String details) {
			this.summary.sendKeys(summary);
			this.text.sendKeys(details);
			this.submit.click();
			return PageFactory.initElements(driver, resultPage);
		}

		public static CreateMessagePage to(WebDriver driver) {
			driver.get("http://localhost:9990/mail/messages/form");
			return PageFactory.initElements(driver, CreateMessagePage.class);
		}
	}
----
<1> `CreateMessagePage` extends the `AbstractPage`. We do not go over the details of
`AbstractPage`, but, in summary, it contains common functionality for all of our pages.
For example, if our application has a navigational bar, global error messages, and other
features, we can place this logic in a shared location.
<2> We have a member variable for each of the parts of the HTML page in which we are
interested. These are of type `WebElement`. WebDriver's
https://github.com/SeleniumHQ/selenium/wiki/PageFactory[`PageFactory`] lets us remove a
lot of code from the HtmlUnit version of `CreateMessagePage` by automatically resolving
each `WebElement`. The
https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/PageFactory.html#initElements-org.openqa.selenium.WebDriver-java.lang.Class-[`PageFactory#initElements(WebDriver,Class<T>)`]
method automatically resolves each `WebElement` by using the field name and looking it up
by the `id` or `name` of the element within the HTML page.
<3> We can use the
https://github.com/SeleniumHQ/selenium/wiki/PageFactory#making-the-example-work-using-annotations[`@FindBy` annotation]
to override the default lookup behavior. Our example shows how to use the `@FindBy`
annotation to look up our submit button with a `css` selector (*input[type=submit]*).

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class CreateMessagePage(private val driver: WebDriver) : AbstractPage(driver) { // <1>

		// <2>
		private lateinit var summary: WebElement
		private lateinit var text: WebElement

		// <3>
		@FindBy(css = "input[type=submit]")
		private lateinit var submit: WebElement

		fun <T> createMessage(resultPage: Class<T>, summary: String, details: String): T {
			this.summary.sendKeys(summary)
			text.sendKeys(details)
			submit.click()
			return PageFactory.initElements(driver, resultPage)
		}
		companion object {
			fun to(driver: WebDriver): CreateMessagePage {
				driver.get("http://localhost:9990/mail/messages/form")
				return PageFactory.initElements(driver, CreateMessagePage::class.java)
			}
		}
	}
----
<1> `CreateMessagePage` extends the `AbstractPage`. We do not go over the details of
`AbstractPage`, but, in summary, it contains common functionality for all of our pages.
For example, if our application has a navigational bar, global error messages, and other
features, we can place this logic in a shared location.
<2> We have a member variable for each of the parts of the HTML page in which we are
interested. These are of type `WebElement`. WebDriver's
https://github.com/SeleniumHQ/selenium/wiki/PageFactory[`PageFactory`] lets us remove a
lot of code from the HtmlUnit version of `CreateMessagePage` by automatically resolving
each `WebElement`. The
https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/PageFactory.html#initElements-org.openqa.selenium.WebDriver-java.lang.Class-[`PageFactory#initElements(WebDriver,Class<T>)`]
method automatically resolves each `WebElement` by using the field name and looking it up
by the `id` or `name` of the element within the HTML page.
<3> We can use the
https://github.com/SeleniumHQ/selenium/wiki/PageFactory#making-the-example-work-using-annotations[`@FindBy` annotation]
to override the default lookup behavior. Our example shows how to use the `@FindBy`
annotation to look up our submit button with a `css` selector (*input[type=submit]*).


Finally, we can verify that a new message was created successfully. The following
assertions use the https://joel-costigliola.github.io/assertj/[AssertJ] assertion library:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	assertThat(viewMessagePage.getMessage()).isEqualTo(expectedMessage);
	assertThat(viewMessagePage.getSuccess()).isEqualTo("Successfully created a new message");
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	assertThat(viewMessagePage.message.isEqualTo(expectedMessage)
	assertThat(viewMessagePage.success.isEqualTo("Successfully created a new message")
----

We can see that our `ViewMessagePage` lets us interact with our custom domain model. For
example, it exposes a method that returns a `Message` object:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public Message getMessage() throws ParseException {
		Message message = new Message();
		message.setId(getId());
		message.setCreated(getCreated());
		message.setSummary(getSummary());
		message.setText(getText());
		return message;
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun getMessage() = Message(getId(), getCreated(), getSummary(), getText())
----

We can then use the rich domain objects in our assertions.

Lastly, we must not forget to close the `WebDriver` instance when the test is complete,
as follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@AfterEach
	void destroy() {
		if (driver != null) {
			driver.close();
		}
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@AfterEach
	fun destroy() {
		if (driver != null) {
			driver.close()
		}
	}
----

For additional information on using WebDriver, see the Selenium
https://github.com/SeleniumHQ/selenium/wiki/Getting-Started[WebDriver documentation].

[[spring-mvc-test-server-htmlunit-webdriver-advanced-builder]]
====== Advanced `MockMvcHtmlUnitDriverBuilder`

In the examples so far, we have used `MockMvcHtmlUnitDriverBuilder` in the simplest way
possible, by building a `WebDriver` based on the `WebApplicationContext` loaded for us by
the Spring TestContext Framework. This approach is repeated here, as follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	WebDriver driver;

	@BeforeEach
	void setup(WebApplicationContext context) {
		driver = MockMvcHtmlUnitDriverBuilder
				.webAppContextSetup(context)
				.build();
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	lateinit var driver: WebDriver

	@BeforeEach
	fun setup(context: WebApplicationContext) {
		driver = MockMvcHtmlUnitDriverBuilder
				.webAppContextSetup(context)
				.build()
	}
----

We can also specify additional configuration options, as follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	WebDriver driver;

	@BeforeEach
	void setup() {
		driver = MockMvcHtmlUnitDriverBuilder
				// demonstrates applying a MockMvcConfigurer (Spring Security)
				.webAppContextSetup(context, springSecurity())
				// for illustration only - defaults to ""
				.contextPath("")
				// By default MockMvc is used for localhost only;
				// the following will use MockMvc for example.com and example.org as well
				.useMockMvcForHosts("example.com","example.org")
				.build();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	lateinit var driver: WebDriver

	@BeforeEach
	fun setup() {
		driver = MockMvcHtmlUnitDriverBuilder
				// demonstrates applying a MockMvcConfigurer (Spring Security)
				.webAppContextSetup(context, springSecurity())
				// for illustration only - defaults to ""
				.contextPath("")
				// By default MockMvc is used for localhost only;
				// the following will use MockMvc for example.com and example.org as well
				.useMockMvcForHosts("example.com","example.org")
				.build()
	}
----

As an alternative, we can perform the exact same setup by configuring the `MockMvc`
instance separately and supplying it to the `MockMvcHtmlUnitDriverBuilder`, as follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	MockMvc mockMvc = MockMvcBuilders
			.webAppContextSetup(context)
			.apply(springSecurity())
			.build();

	driver = MockMvcHtmlUnitDriverBuilder
			.mockMvcSetup(mockMvc)
			// for illustration only - defaults to ""
			.contextPath("")
			// By default MockMvc is used for localhost only;
			// the following will use MockMvc for example.com and example.org as well
			.useMockMvcForHosts("example.com","example.org")
			.build();
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed
----

This is more verbose, but, by building the `WebDriver` with a `MockMvc` instance, we have
the full power of MockMvc at our fingertips.

TIP: For additional information on creating a `MockMvc` instance, see
<<spring-mvc-test-server-setup-options>>.

[[spring-mvc-test-server-htmlunit-geb]]
===== MockMvc and Geb

In the previous section, we saw how to use MockMvc with WebDriver. In this section, we
use http://www.gebish.org/[Geb] to make our tests even Groovy-er.

[[spring-mvc-test-server-htmlunit-geb-why]]
====== Why Geb and MockMvc?

Geb is backed by WebDriver, so it offers many of the
<<spring-mvc-test-server-htmlunit-webdriver-why, same benefits>> that we get from
WebDriver. However, Geb makes things even easier by taking care of some of the
boilerplate code for us.

[[spring-mvc-test-server-htmlunit-geb-setup]]
====== MockMvc and Geb Setup

We can easily initialize a Geb `Browser` with a Selenium WebDriver that uses MockMvc, as
follows:

[source,groovy]
----
def setup() {
	browser.driver = MockMvcHtmlUnitDriverBuilder
		.webAppContextSetup(context)
		.build()
}
----

NOTE: This is a simple example of using `MockMvcHtmlUnitDriverBuilder`. For more advanced
usage, see <<spring-mvc-test-server-htmlunit-webdriver-advanced-builder>>.

This ensures that any URL referencing `localhost` as the server is directed to our
`MockMvc` instance without the need for a real HTTP connection. Any other URL is
requested by using a network connection as normal. This lets us easily test the use of
CDNs.

[[spring-mvc-test-server-htmlunit-geb-usage]]
====== MockMvc and Geb Usage

Now we can use Geb as we normally would but without the need to deploy our application to
a Servlet container. For example, we can request the view to create a message with the
following:

[source,groovy]
----
to CreateMessagePage
----

We can then fill out the form and submit it to create a message, as follows:

[source,groovy]
----
when:
form.summary = expectedSummary
form.text = expectedMessage
submit.click(ViewMessagePage)
----

Any unrecognized method calls or property accesses or references that are not found are
forwarded to the current page object. This removes a lot of the boilerplate code we
needed when using WebDriver directly.

As with direct WebDriver usage, this improves on the design of our
<<spring-mvc-test-server-htmlunit-mah-usage, HtmlUnit test>> by using the Page Object
Pattern. As mentioned previously, we can use the Page Object Pattern with HtmlUnit and
WebDriver, but it is even easier with Geb. Consider our new Groovy-based
`CreateMessagePage` implementation:

[source,groovy]
----
class CreateMessagePage extends Page {
	static url = 'messages/form'
	static at = { assert title == 'Messages : Create'; true }
	static content =  {
		submit { $('input[type=submit]') }
		form { $('form') }
		errors(required:false) { $('label.error, .alert-error')?.text() }
	}
}
----

Our `CreateMessagePage` extends `Page`. We do not go over the details of `Page`, but, in
summary, it contains common functionality for all of our pages. We define a URL in which
this page can be found. This lets us navigate to the page, as follows:

[source,groovy]
----
to CreateMessagePage
----

We also have an `at` closure that determines if we are at the specified page. It should
return `true` if we are on the correct page. This is why we can assert that we are on the
correct page, as follows:

[source,groovy]
----
then:
at CreateMessagePage
errors.contains('This field is required.')
----

NOTE: We use an assertion in the closure so that we can determine where things went wrong
if we were at the wrong page.

Next, we create a `content` closure that specifies all the areas of interest within the
page. We can use a
http://www.gebish.org/manual/current/#the-jquery-ish-navigator-api[jQuery-ish Navigator
API] to select the content in which we are interested.

Finally, we can verify that a new message was created successfully, as follows:

[source,groovy]
----
then:
at ViewMessagePage
success == 'Successfully created a new message'
id
date
summary == expectedSummary
message == expectedMessage
----

For further details on how to get the most out of Geb, see
http://www.gebish.org/manual/current/[The Book of Geb] user's manual.


[[spring-mvc-test-client]]
==== Client-Side REST Tests

You can use client-side tests to test code that internally uses the `RestTemplate`. The
idea is to declare expected requests and to provide "`stub`" responses so that you can
focus on testing the code in isolation (that is, without running a server). The following
example shows how to do so:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	RestTemplate restTemplate = new RestTemplate();

	MockRestServiceServer mockServer = MockRestServiceServer.bindTo(restTemplate).build();
	mockServer.expect(requestTo("/greeting")).andRespond(withSuccess());

	// Test code that uses the above RestTemplate ...

	mockServer.verify();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val restTemplate = RestTemplate()

	val mockServer = MockRestServiceServer.bindTo(restTemplate).build()
	mockServer.expect(requestTo("/greeting")).andRespond(withSuccess())

	// Test code that uses the above RestTemplate ...

	mockServer.verify()
----

In the preceding example, `MockRestServiceServer` (the central class for client-side REST
tests) configures the `RestTemplate` with a custom `ClientHttpRequestFactory` that
asserts actual requests against expectations and returns "`stub`" responses. In this
case, we expect a request to `/greeting` and want to return a 200 response with
`text/plain` content. We can define additional expected requests and stub responses as
needed. When we define expected requests and stub responses, the `RestTemplate` can be
used in client-side code as usual. At the end of testing, `mockServer.verify()` can be
used to verify that all expectations have been satisfied.

By default, requests are expected in the order in which expectations were declared. You
can set the `ignoreExpectOrder` option when building the server, in which case all
expectations are checked (in order) to find a match for a given request. That means
requests are allowed to come in any order. The following example uses `ignoreExpectOrder`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	server = MockRestServiceServer.bindTo(restTemplate).ignoreExpectOrder(true).build();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	server = MockRestServiceServer.bindTo(restTemplate).ignoreExpectOrder(true).build()
----

Even with unordered requests by default, each request is allowed to execute once only.
The `expect` method provides an overloaded variant that accepts an `ExpectedCount`
argument that specifies a count range (for example, `once`, `manyTimes`, `max`, `min`,
`between`, and so on). The following example uses `times`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	RestTemplate restTemplate = new RestTemplate();

	MockRestServiceServer mockServer = MockRestServiceServer.bindTo(restTemplate).build();
	mockServer.expect(times(2), requestTo("/something")).andRespond(withSuccess());
	mockServer.expect(times(3), requestTo("/somewhere")).andRespond(withSuccess());

	// ...

	mockServer.verify();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val restTemplate = RestTemplate()

	val mockServer = MockRestServiceServer.bindTo(restTemplate).build()
	mockServer.expect(times(2), requestTo("/something")).andRespond(withSuccess())
	mockServer.expect(times(3), requestTo("/somewhere")).andRespond(withSuccess())

	// ...

	mockServer.verify()
----

Note that, when `ignoreExpectOrder` is not set (the default), and, therefore, requests
are expected in order of declaration, then that order applies only to the first of any
expected request. For example if "/something" is expected two times followed by
"/somewhere" three times, then there should be a request to "/something" before there is
a request to "/somewhere", but, aside from that subsequent "/something" and "/somewhere",
requests can come at any time.

As an alternative to all of the above, the client-side test support also provides a
`ClientHttpRequestFactory` implementation that you can configure into a `RestTemplate` to
bind it to a `MockMvc` instance. That allows processing requests using actual server-side
logic but without running a server. The following example shows how to do so:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();
	this.restTemplate = new RestTemplate(new MockMvcClientHttpRequestFactory(mockMvc));

	// Test code that uses the above RestTemplate ...
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build()
	restTemplate = RestTemplate(MockMvcClientHttpRequestFactory(mockMvc))

	// Test code that uses the above RestTemplate ...
----

[[spring-mvc-test-client-static-imports]]
===== Static Imports

As with server-side tests, the fluent API for client-side tests requires a few static
imports. Those are easy to find by searching for `MockRest*`. Eclipse users should add
`MockRestRequestMatchers.{asterisk}` and `MockRestResponseCreators.{asterisk}` as
"`favorite static members`" in the Eclipse preferences under Java -> Editor -> Content
Assist -> Favorites. That allows using content assist after typing the first character of
the static method name. Other IDEs (such IntelliJ) may not require any additional
configuration. Check for the support for code completion on static members.

[[spring-mvc-test-client-resources]]
===== Further Examples of Client-side REST Tests

Spring MVC Test's own tests include
https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/client/samples[example
tests] of client-side REST tests.

include::testing-webtestclient.adoc[leveloffset=+2]



[[testing-resources]]
== Further Resources
See the following resources for more information about testing:

* https://www.junit.org/[JUnit]: "`A programmer-friendly testing framework for Java`".
  Used by the Spring Framework in its test suite and supported in the
  <<testcontext-framework, Spring TestContext Framework>>.
* https://testng.org/[TestNG]: A testing framework inspired by JUnit with added support
  for test groups, data-driven testing, distributed testing, and other features. Supported
  in the <<testcontext-framework, Spring TestContext Framework>>
* https://joel-costigliola.github.io/assertj/[AssertJ]: "`Fluent assertions for Java`",
  including support for Java 8 lambdas, streams, and other features.
* https://en.wikipedia.org/wiki/Mock_Object[Mock Objects]: Article in Wikipedia.
* http://www.mockobjects.com/[MockObjects.com]: Web site dedicated to mock objects, a
  technique for improving the design of code within test-driven development.
* https://mockito.github.io[Mockito]: Java mock library based on the
  http://xunitpatterns.com/Test%20Spy.html[Test Spy] pattern. Used by the Spring Framework
  in its test suite.
* https://easymock.org/[EasyMock]: Java library "`that provides Mock Objects for
  interfaces (and objects through the class extension) by generating them on the fly using
  Java's proxy mechanism.`"
* https://jmock.org/[JMock]: Library that supports test-driven development of Java code
  with mock objects.
* https://www.dbunit.org/[DbUnit]: JUnit extension (also usable with Ant and Maven) that
  is targeted at database-driven projects and, among other things, puts your database into
  a known state between test runs.
* https://sourceforge.net/projects/grinder/[The Grinder]: Java load testing framework.
* https://github.com/Ninja-Squad/springmockk[SpringMockK]: Support for Spring Boot
  integration tests written in Kotlin using https://mockk.io/[MockK] instead of Mockito.
