[[boot-features]]
= Spring Boot Features
include::attributes.adoc[]

本部分将介绍 Spring Boot 相关的细节内容。在这里，您可以学习到可能需要使用和自定义的主要功能。您如果还没有做好充分准备，可能需要阅读 "<<getting-started.adoc#getting-started,入门>>" 和 "<<using-spring-boot.adoc#using-boot,使用 Spring Boot>>" ，以便打下前期基础。

[[boot-features-spring-application]]
== SpringApplication
`SpringApplication` 类提供了一种可通过运行 `main()` 方法来启动 Spring 应用的简单方式。多数情况下，您只需要委托给静态的 `SpringApplication.run` 方法：

[source,java,indent=0]
----
	public static void main(String[] args) {
		SpringApplication.run(MySpringConfiguration.class, args);
	}
----

当应用启动时，您应该会看到类似以下的内容输出：

[indent=0,subs="attributes"]
----
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::   v{spring-boot-version}

2019-04-31 13:09:54.117  INFO 56603 --- [           main] o.s.b.s.app.SampleApplication            : Starting SampleApplication v0.1.0 on mycomputer with PID 56603 (/apps/myapp.jar started by pwebb)
2019-04-31 13:09:54.166  INFO 56603 --- [           main] ationConfigServletWebServerApplicationContext : Refreshing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@6e5a8246: startup date [Wed Jul 31 00:08:16 PDT 2013]; root of context hierarchy
2019-04-01 13:09:56.912  INFO 41370 --- [           main] .t.TomcatServletWebServerFactory : Server initialized with port: 8080
2019-04-01 13:09:57.501  INFO 41370 --- [           main] o.s.b.s.app.SampleApplication            : Started SampleApplication in 2.992 seconds (JVM running for 3.658)
----

默认情况下，将显示 `INFO` 级别的日志信息，包括一些应用启动相关信息。如果您需要修改 `INFO` 日志级别，请参考<<boot-features-custom-log-levels,日志等级>>。

使用主应用程序类包中的实现版本来确定应用程序版本。 可以通过将 `spring.main.log-startup-info` 设置为 `false` 来关闭启动信息记录。 这还将关闭对应用程序活动配置文件的日志记录。

TIP: 要在启动期间添加其他日志记录，可以在 `SpringApplication` 的子类中重写 `logStartupInfo(boolean)`。


[[boot-features-startup-failure]]
=== 启动失败
如果您的应用无法启动，注册的 `FailureAnalyzers` 可能会提供有相关的错误信息和解决问题的具体方法。例如，如果您在已经被占用的 `8080` 端口上启动了一个 web 应用，会看到类似以下的错误信息：

[indent=0]
----
	***************************
	APPLICATION FAILED TO START
	***************************

	Description:

	Embedded servlet container failed to start. Port 8080 was already in use.

	Action:

	Identify and stop the process that's listening on port 8080 or configure this application to listen on another port.
----

NOTE: Spring Boot 提供了许多的 `FailureAnalyzer` 实现，您也可以<<howto.adoc#howto-failure-analyzer,添加自己的实现>>。

如果没有失败分析器能够处理的异常，您仍然可以显示完整的条件报告以便更好地了解出现的问题。为此，您需要针对 `org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener` <<boot-features-external-config,启用 `debug` 属性>> 或者<<boot-features-custom-log-levels,开启 `DEBUG` 日志>>。

例如，如果您使用 `java -jar` 运行应用，可以按以下方式启用 `debug` 属性：

[indent=0,subs="attributes"]
----
	$ java -jar myproject-0.0.1-SNAPSHOT.jar --debug
----



[[boot-features-lazy-initialization]]
=== 延迟初始化
`SpringApplication` 允许延迟地初始化应用程序。 启用延迟初始化后，将根据需要创建bean，而不是在应用程序启动期间创建bean。 因此，启用延迟初始化可以减少应用程序启动所需的时间。 在Web应用程序中，启用延迟初始化将导致许多与Web相关的Bean直到收到HTTP请求后才被初始化。

延迟初始化的缺点是，它可能会延迟发现应用程序问题的时间。 如果错误配置的Bean延迟初始化，则启动期间将不再发生故障，并且只有在初始化Bean时问题才会变得明显。 还必须注意确保JVM有足够的内存来容纳所有应用程序的bean，而不仅仅是启动期间初始化的bean。 由于这些原因，默认情况下不会启用延迟初始化，因此建议在启用延迟初始化之前先对JVM的堆大小进行微调。

可以使用 `SpringApplicationBuilder` 上的 `lazyInitialization` 方法或 `SpringApplication` 上的 `setLazyInitialization` 方法以编程方式启用延迟初始化。 另外，可以使用 configprop:spring.main.lazy-initialization[] 属性启用它，如以下示例所示：

[source,properties,indent=0,configprops]
----
	spring.main.lazy-initialization=true
----

TIP: 如果要在对应用程序其余部分使用延迟初始化时禁用某些bean的延迟初始化，则可以使用 `@Lazy(false)` 注解将它们的延迟属性显式设置为 `false`。



[[boot-features-banner]]
=== 自定义 banner
可以通过在 classpath 下添加一个 `banner.txt` 文件，或者将 configprop:spring.banner.location[]  属性指向该文件的位置来更改启动时打印的 banner。如果文件采用了非 UTF-8 编码，您可以设置 `spring.banner.charset` 来解决。除了文本文件，
您还可以将 `banner.gif`、`banner.jpg` 或者 `banner.png` 图片文件添加到 classpath 下，或者设置 configprop:spring.banner.image.location[] 属性。指定的图片将会被转换成 ASCII 形式并打印在 banner 文本上方。

您可以在 `banner.txt` 文件中使用以下占位符：

.Banner 变量
|===
| 变量 | 描述

| `${application.version}`
| 您的应用版本号，声明在 `MANIFEST.MF` 中。例如，`Implementation-Version: 1.0` 将被打印为 `1.0`。

| `${application.formatted-version}`
| 您的应用版本号，声明在 `MANIFEST.MF` 中，格式化之后打印（用括号括起来，以 `v` 为前缀），例如 (`v1.0`)。

| `${spring-boot.version}`
| 您使用的 Spring Boot 版本。例如 `{spring-boot-version}`。

| `${spring-boot.formatted-version}`
| 您使用的 Spring Boot 版本格式化之后显示（用括号括起来，以 `v` 为前缀）。例如 `(v{spring-boot-version})`。

| `${Ansi.NAME}` (or `${AnsiColor.NAME}`, `${AnsiBackground.NAME}`, `${AnsiStyle.NAME}`)
| 其中 `NAME` 是 ANSI 转义码的名称。有关详细信息，请参阅 {spring-boot-module-code}/ansi/AnsiPropertySource.java[`AnsiPropertySource`]。

| `${application.title}`
| 您的应用标题，声明在 `MANIFEST.MF` 中，例如 `Implementation-Title: MyApp` 打印为 `MyApp`。
|===

TIP: 如果您想以编程的方式生成 banner，可以使用 `SpringApplication.setBanner(​...)` 方法。使用 `org.springframework.boot.Banner` 接口并实现自己的 `printBanner()` 方法。

您还可以使用 configprop:spring.main.banner-mode[] 属性来确定是否必须在  `System.out` (`console`) 上打印 banner，还是使用日志记录器 (`log`)或者都不打印(`off`)。

打印的 banner 被注册名为 `springBootBanner` 的单例 bean。

[[boot-features-customizing-spring-application]]
=== 自定义 SpringApplication
如果 `SpringApplication` 的默认设置不符合您的想法，您可以创建本地实例进行定制化。例如，要关闭 banner，您可以这样：

[source,java,indent=0]
----
	public static void main(String[] args) {
		SpringApplication app = new SpringApplication(MySpringConfiguration.class);
		app.setBannerMode(Banner.Mode.OFF);
		app.run(args);
	}
----

NOTE: 传入 `SpringApplication` 的构造参数是 spring bean 的配置源。大多情况下是引用 `@Configuration` 类，但您也可以引用 XML 配置或者被扫描的包。

也可以使用 `application.properties` 文件配置 `SpringApplication`。有关详细信息，请参见_<<boot-features-external-config,外部化配置>>_。

关于配置选项的完整列表，请参阅  {spring-boot-module-api}/SpringApplication.html[`SpringApplication` Javadoc]。

[[boot-features-fluent-builder-api]]
=== Fluent Builder API

如果您需要构建一个有层级关系的 `ApplicationContext`（具有父/子关系的多上下文），或者偏向使用 fluent（流式）构建器 API，可以使用 `SpringApplicationBuilder`。

`SpringApplicationBuilder` 允许您链式调用多个方法，包括能创建出具有层次结构的 `parent` 和 `child` 方法。

例如：

[source,java,indent=0]
----
include::{code-examples}/builder/SpringApplicationBuilderExample.java[tag=hierarchy]
----

NOTE: 创建层级的 `ApplicationContext` 时有部分限制，比如 Web 组件必须包含在子上下文中，并且相同的 `Environment` 将作用于父子上下文。有关详细信息，请参阅 {spring-boot-module-api}/builder/SpringApplicationBuilder.html[`SpringApplicationBuilder` Javadoc] 。

[[boot-features-application-events-and-listeners]]
=== 应用程序事件与监听器

除了常见的 Spring Framework 事件，比如  {spring-framework-api}/context/event/ContextRefreshedEvent.html[`ContextRefreshedEvent`]，`SpringApplication` 还会发送其他应用程序事件。

[NOTE]
====
在 `ApplicationContext` 创建之前，实际上触发了一些事件，因此您不能像 `@Bean` 一样注册监听器。您可以通过 `SpringApplication.addListeners(​...)` 或者 `SpringApplicationBuilder.listeners(...​)` 方法注册它们。
如果您希望无论应用使用何种创建方式都能自动注册这些监听器，您都可以将 `META-INF/spring.factories` 文件添加到项目中，并使用 `org.springframework.context.ApplicationListener` 属性键指向您的监听器。
比如：`org.springframework.context.ApplicationListener=com.example.project.MyListener`

[indent=0]
----
	org.springframework.context.ApplicationListener=com.example.project.MyListener
----

====

当您运行应用时，应用程序事件将按照以下顺序发送：

. 在开始应用开始运行但还没有进行任何处理时（除了注册监听器和初始化器[initializer]），将发送 `ApplicationStartingEvent`。
. 当 Environment 被上下文使用，但是在上下文创建之前，将发送 `ApplicationEnvironmentPreparedEvent`。
. 准备 `ApplicationContext` 并调用 `ApplicationContextInitializers` 之后但在加载任何bean定义之前，将发送 `ApplicationContextInitializedEvent`。
. 开始刷新之前，bean 定义被加载之后发送 `ApplicationPreparedEvent`。
. 在上下文刷新之后且所有的应用和命令行运行器（command-line runner）被调用之前发送 `ApplicationStartedEvent`。
. 在应用程序和命令行运行器（command-line runner）被调用之后，将发出 `ApplicationReadyEvent`，该事件用于通知应用已经准备处理请求。
. 如果启动时发生异常，将发送 `ApplicationFailedEvent`。

上面的列表仅包含绑定到 `SpringApplication` 的 `SpringApplicationEvents`。 除这些以外，以下事件也在 `ApplicationPreparedEvent` 之后和 `ApplicationStartedEvent` 之前发布：

. 刷新 `ApplicationContext` 时，将发送 `ContextRefreshedEvent`。
. `WebServer` 准备就绪后，将发送 `WebServerInitializedEvent`。 `ServletWebServerInitializedEvent` 和 `ReactiveWebServerInitializedEvent` 分别是servlet和reactive变量。

TIP: 您可能不会经常使用应用程序事件，但了解他们的存在还是很有必要的。在框架内部，Spring Boot 使用这些事件来处理各种任务。

应用程序事件发送使用了 Spring Framework 的事件发布机制。该部分机制确保在子上下文中发布给监听器的事件也会发布给所有祖先上下文中的监听器。因此，如果您的应用程序使用有层级结构的 `SpringApplication` 实例，则监听器可能会收到同种类型应用程序事件的多个实例。

为了让监听器能够区分其上下文事件和后代上下文事件，您应该注入其应用程序上下文，然后将注入的上下文与事件的上下文进行比较。可以通过实现 `ApplicationContextAware` 来注入上下文，如果监听器是 bean，则使用 `@Autowired` 注入上下文。

[[boot-features-web-environment]]
=== Web 环境
`SpringApplication` 试图为您创建正确类型的 `ApplicationContext`。确定 `WebApplicationType` 的算法非常简单：

* 如果存在 Spring MVC，则使用 `AnnotationConfigServletWebServerApplicationContext`
* 如果 Spring MVC 不存在且存在 Spring WebFlux，则使用 `AnnotationConfigReactiveWebServerApplicationContext`
* 否则，使用 `AnnotationConfigApplicationContext`

这意味着如果您在同一个应用程序中使用了 Spring MVC 和 Spring WebFlux 中的新 `WebClient`，默认情况下将使用 Spring MVC。您可以通过调用 `setWebApplicationType(WebApplicationType)` 修改默认行为。

也可以调用 `setApplicationContextClass(...)` 来完全控制 `ApplicationContext` 类型。

TIP: 在 JUnit 测试中使用 `SpringApplication` 时，通常需要调用 `setWebApplicationType(WebApplicationType.NONE)`。

[[boot-features-application-arguments]]
=== 访问应用程序参数
如果您需要访问从 `SpringApplication.run(​...)` 传入的应用程序参数，可以注入一个 `org.springframework.boot.ApplicationArguments` bean。`ApplicationArguments` 接口提供了访问原始 `String[]` 参数以及解析后的 `option` 和 `non-option` 参数的方法：

[source,java,indent=0]
----
	import org.springframework.boot.*;
	import org.springframework.beans.factory.annotation.*;
	import org.springframework.stereotype.*;

	@Component
	public class MyBean {

		@Autowired
		public MyBean(ApplicationArguments args) {
			boolean debug = args.containsOption("debug");
			List<String> files = args.getNonOptionArgs();
			// if run with "--debug logfile.txt" debug=true, files=["logfile.txt"]
		}

	}
----

TIP: Spring Boot 还向 Spring `Environment` 注册了一个 `CommandLinePropertySource`。这允许您可以使用 `@Value` 注解注入单个应用参数。

[[boot-features-command-line-runner]]
=== 使用 ApplicationRunner 或 CommandLineRunner
如果您需要在 `SpringApplication` 启动时运行一些代码，可以实现 `ApplicationRunner` 或者 `CommandLineRunner` 接口。这两个接口的工作方式是一样的，都提供了一个单独的 `run` 方法，它将在 `SpringApplication.run(​...)` 完成之前调用。

`CommandLineRunner` 接口提供了访问应用程序字符串数组形式参数的方法，而 `ApplicationRunner` 则使用了上述的 `ApplicationArguments` 接口。以下示例展示 `CommandLineRunner` 和 `run` 方法的使用：

[source,java,indent=0]
----
	import org.springframework.boot.*;
	import org.springframework.stereotype.*;

	@Component
	public class MyBean implements CommandLineRunner {

		public void run(String... args) {
			// Do something...
		}

	}
----

如果您定义了多个 `CommandLineRunner` 或者 `ApplicationRunner` bean，则必须指定调用顺序，您可以实现 `org.springframework.core.Ordered` 接口，也可以使用 `org.springframework.core.annotation.Order` 注解解决顺序问题。

[[boot-features-application-exit]]
=== 应用程序退出
每个 `SpringApplication` 注册了一个 JVM 关闭钩子，以确保 `ApplicationContext` 在退出时可以优雅关闭。所有标准的 Spring 生命周期回调（比如 `DisposableBean` 接口，或者 `@PreDestroy` 注解）都可以使用。

此外，如果希望在调用 `SpringApplication.exit()` 时返回特定的退出码，则 bean 可以实现 `org.springframework.boot.ExitCodeGenerator` 接口。之后退出码将传递给 `System.exit()` 以将其作为状态码返回，如示例所示：

[source,java,indent=0]
----
include::{code-examples}/ExitCodeApplication.java[tag=example]
----

此外，`ExitCodeGenerator` 接口可以通过异常实现。遇到这类异常时，Spring Boot 将返回实现的 `getExitCode()` 方法提供的退出码。

[[boot-features-application-admin]]
=== 管理功能
可以通过指定 configprop:spring.application.admin.enabled[]  属性来为应用程序启用管理相关的功能。其将在 `MBeanServer` 平台上暴露  {spring-boot-module-code}/admin/SpringApplicationAdminMXBean.java[`SpringApplicationAdminMXBean`]。您可以使用此功能来远程管理 Spring Boot 应用。该功能对服务包装器的实现也是非常有用的。

TIP: 如果您想知道应用程序在哪一个 HTTP 端口上运行，请使用 `local.server.port` 键获取该属性。



[[boot-features-external-config]]
== 外部化配置
Spring Boot 可以让您的配置外部化，以便可以在不同环境中使用相同的应用程序代码。您可以使用 properties 文件、YAML 文件、环境变量或者命令行参数来外部化配置。可以使用 `@Value` 注解将属性值直接注入到 bean 中，可通过 Spring 的 `Environment` 访问，
或者通过 `@ConfigurationProperties` <<boot-features-external-config-typesafe-configuration-properties,绑定到结构化对象>>。

Spring Boot 使用了一个非常特别的 `PropertySource` 指令，用于智能覆盖默认值。属性将按照以下顺序处理：

. 当 devtools 被激活， `$HOME/.config/spring-boot` 文件夹中的 <<using-spring-boot.adoc#using-boot-devtools-globalsettings,Devtools 全局设置属性>>。
. 在测试中使用到的 {spring-framework-api}/test/context/TestPropertySource.html[`@TestPropertySource`] 注解。
. 在测试中使用到的 `properties` 属性，可以是 {spring-boot-test-module-api}/context/SpringBootTest.html[`@SpringBootTest`] 和 <<boot-features-testing-spring-boot-applications-testing-autoconfigured-tests,用于测试应用程序某部分的测试注解>>。
. 命令行参数。
. 来自 `SPRING_APPLICATION_JSON` 的属性（嵌入在环境变量或者系统属性【system propert】中的内联 JSON）。
. `ServletConfig` 初始化参数。
. `ServletContext` 初始化参数。
. 来自 `java:comp/env` 的 JNDI 属性。
. Java 系统属性（`System.getProperties()`）。
. 操作系统环境变量。
. 只有 `random.*` 属性的 `RandomValuePropertySource`。
. 在已打包的 jar 外部的 <<boot-features-external-config-profile-specific-properties,指定 profile 的应用属性文件>> (`application-\{profile}.properties` 和 YAML 变量).
. 在已打包的 jar 内部的<<boot-features-external-config-profile-specific-properties,指定 profile 的应用属性文件>> (`application-\{profile}.properties` 和 YAML 变量).
. 在已打包的 jar 外部的应用属性文件 (`application.properties` 和 YAML 变量).
. 在已打包的 jar 内部的应用属性文件 (`application.properties` 和 YAML 变量).
. 在 `@Configuration` 类上的 {spring-framework-api}/context/annotation/PropertySource.html[`@PropertySource`]  注解。
请注意，在刷新应用程序上下文之前，不会将此类属性源添加到环境中。 现在配置某些属性（如 `logging.*` 和 `spring.main.*` ）为时已晚，这些属性在刷新开始之前就已读取。
. 默认属性（使用 `SpringApplication.setDefaultProperties` 指定）。

举个例子，假设开发的 `@Component` 使用了 `name` 属性，可以这样：

[source,java,indent=0]
----
	import org.springframework.stereotype.*;
	import org.springframework.beans.factory.annotation.*;

	@Component
	public class MyBean {

	    @Value("${name}")
	    private String name;

	    // ...

	}
----

在您的应用程序的 classpath 中（比如在 jar 中），您可以有一个 `application.properties`，它为 name 提供了一个合适的默认属性值。当在新环境中运行时，您可以在 jar 外面提供一个 `application.properties` 来覆盖 `name`。对于一次性测试，您可以使用命令行指定形式启动（比如 `java -jar app.jar --name="Spring"`）。

[[boot-features-external-config-application-json]]
[TIP]
====
`SPRING_APPLICATION_JSON` 属性可以在命令行中提供一个环境变量。比如在 UN*X shell 中：

[indent=0]
----
	$ SPRING_APPLICATION_JSON='{"acme":{"name":"test"}}' java -jar myapp.jar
----

在此示例中，您可以在 Spring `Environment` 中使用 `acme.name=test`，也可以在系统属性（System property）中将 JSON 作为 `spring.application.json` 属性提供：

[indent=0]
----
	$ java -Dspring.application.json='{"name":"test"}' -jar myapp.jar
----

或者以命令行参数形式：

[indent=0]
----
	$ java -jar myapp.jar --spring.application.json='{"name":"test"}'
----

或者将 JSON 作为一个 JNDI 变量：`java:comp/env/spring.application.json`。
====



[[boot-features-external-config-random-values]]
=== 配置随机值
`RandomValuePropertySource` 对于随机值注入非常有用（比如在保密场景或者测试用例中)。它可以产生 integer、long、uuid 和 string。如下示例：

[source,properties,indent=0]
----
	my.secret=${random.value}
	my.number=${random.int}
	my.bignumber=${random.long}
	my.uuid=${random.uuid}
	my.number.less.than.ten=${random.int(10)}
	my.number.in.range=${random.int[1024,65536]}
----

`random.int*` 语法为 `OPEN value (,max) CLOSE`，`OPEN,CLOSE` 可为任意字符，`value,max` 为整数。如果使用了 `max`，`value` 则为最小值，`max` 为最大值。

[[boot-features-external-config-command-line-args]]
=== 访问命令行属性
默认情况下，`SpringApplication` 将所有命令行选项参数（即以 `--` 开头的参数，比如 `--server.port=9000`）转换为属性，并将它们添加到 Spring `Environment` 中。如之前所述，命令行属性始终优先于其他属性源。

如果您不希望将命令行属性添加到 `Environment`，可以使用 `SpringApplication.setAddCommandLineProperties(false)` 来禁用它们。

[[boot-features-external-config-application-property-files]]
=== 应用程序属性文件
`SpringApplication` 从以下位置的 `application.properties` 文件中加载属性（properties），并将它们添加到 Spring `Environment` 中：
`SpringApplication` loads properties from `application.properties` files in the following locations and adds them to the Spring `Environment`:

. 当前目录的 `/config` 子目录
. 当前目录
. classpath 上的 `/config` 包
. classpath 根路径

列表按序号优先级排序，序号越小，优先级越高。

NOTE: 您还可以 <<boot-features-external-config-yaml, 使用 YAML（.yml） 文件>>来替代 '.properties'.

如果您不喜欢 `application.properties` 作为配置文件名，则可以通过指定  configprop:spring.config.name[]  环境属性来切换到另一个文件名。您还可以使用 `spring.config.location` 环境属性来引用一个显式位置（以逗号分隔的目录位置或文件路径列表）。
以下示例展示了如何指定其他文件名：

[indent=0]
----
	$ java -jar myproject.jar --spring.config.name=myproject
----

以下示例展示了如何指定两个位置：

[indent=0]
----
	$ java -jar myproject.jar --spring.config.location=classpath:/default.properties,classpath:/override.properties
----

WARNING: `spring.config.name` 和 `spring.config.location` 在程序启动早期就用来确定哪些文件必须加载，因此必须将它们定义为环境属性（通常是 OS 环境变量、系统属性或命令行参数）。

如果 `spring.config.location` 包含目录（而不是文件），则它们应该以 `/` 结尾（并且在运行期间，在加载之前追加从 `spring.config.name` 生成的名称，包括指定 profile 的文件名）。
`spring.config.location` 中指定的文件按原样使用，不支持指定 profile 形式，并且可被任何指定 profile 的文件的属性所覆盖。

配置位置以相反的顺序搜索。默认情况下，配置的位置为 `classpath:/,classpath:/config/,file:./,file:./config/`。生成的搜索顺序如下：

. `file:./config/`
. `file:./`
. `classpath:/config/`
. `classpath:/`

使用了 `spring.config.location` 配置自定义配置位置时，默认位置配置将被替代。例如，如果 `spring.config.location` 配置为 `classpath:/custom-config/,file:./custom-config/`，搜索顺序将变为以下：

. `file:./custom-config/`
. `classpath:custom-config/`

或者，当使用 `spring.config.additional-location` 配置自定义配置位置时，除了使用默认位置外，还会使用它们。这些其他（additional）位置将在默认位置之前搜索。例如，如果将其他位置配置为  `classpath:/custom-config/,file:./custom-config/` ，则搜索顺序将变为以下内容：

. `file:./custom-config/`
. `classpath:custom-config/`
. `file:./config/`
. `file:./`
. `classpath:/config/`
. `classpath:/`

该搜索顺序允许您在一个配置文件中指定默认值，然后有选择地覆盖另一个配置文件中的值。您可以在 `application.properties`（或您使用 `spring.config.name` 指定的其他文件）中的某个默认位置为应用程序提供默认值。之后，在运行时，这些默认值将被自定义位置中的某个文件所覆盖。

NOTE: 如果您使用的是环境变量而不是系统属性，大部分操作系统都不允许使用 . 分隔的键名，但您可以使用下划线来代替（例如，使用 `SPRING_CONFIG_NAME` 而不是 `spring.config.name`）。

NOTE: 如果应用程序在容器中运行，则可以使用 JNDI 属性（`java:comp/env`）或 servlet 上下文初始化参数来代替环境变量或系统属性。(in `java:comp/env`)



[[boot-features-external-config-profile-specific-properties]]
=== 特定 Profile 的属性文件
除 `application.properties` 文件外，还可以使用以下命名约定定义特定 profile 的属性文件：application-{profile}.properties。Environment 有一组默认配置文件（默认情况下为 `default`），如果未设置激活的（active）profile，则使用这些配置文件。换句话说，如果没有显式激活 profile，则会加载 `application-default.properties` 中的属性。

特定 profile 的属性文件从与标准 `application.properties` 相同的位置加载，特定 profile 的属性文件无论是否在打包的 jar 内部，都始终覆盖非特定文件。

如果指定了多个配置文件，则应用 last-wins 策略（优先采取最后一个）。例如，configprop:spring.profiles.active[] 属性指定的配置文件是在使用 `SpringApplication` API 配置的配置文件之后添加的，因此优先应用。

NOTE: 如果在 `spring.config.location` 中指定了文件，则不考虑这些文件的特定 profile 形式。如果您还想使用特定 profile 的属性文件，请在 `spring.config.location` 中使用目录形式。

[[boot-features-external-config-placeholders-in-properties]]
=== 属性中的占位符
`application.properties` 中的值在使用时通过现有的 `Environment` 进行过滤，因此您可以返回之前定义的值（例如，从系统属性）。

[source,properties,indent=0]
----
	app.name=MyApp
	app.description=${app.name} is a Spring Boot application
----

TIP: 您还可以使用此技术创建现有 Spring Boot 属性的简短形式。有关详细信息，请参见 _<<howto.adoc#howto-use-short-command-line-arguments,使用简短命令行参数>>_ 。

[[boot-features-encrypting-properties]]
=== 加密属性
Spring Boot 没有为加密属性值提供任何内置支持，然而，它提供了修改 Spring `Environment` 包含的值所必需的钩子。`EnvironmentPostProcessor` 接口允许您在应用程序启动之前操作 Environment。
有关详细信息，请参见 <<howto.adoc#howto-customize-the-environment-or-application-context,在启动前自定义 Environment 或 ApplicationContext>> 。

如果您正在寻找一种可用于存储凭据和密码的安全方法， https://cloud.spring.io/spring-cloud-vault/[Spring Cloud Vault]  项目支持在  https://www.vaultproject.io/[HashiCorp Vault] 中存储外部化配置。

[[boot-features-external-config-yaml]]
=== 使用 YAML 代替属性文件
https://yaml.org[YAML] 是 JSON 的超集，是一个可用于指定层级配置数据的便捷格式。只要在 classpath 上有 https://bitbucket.org/asomov/snakeyaml[SnakeYAML]  库，`SpringApplication` 类就会自动支持 YAML 作为属性文件（properties）的替代。

NOTE: 如果使用 `starter`，则 `spring-boot-starter` 会自动提供 SnakeYAML。

[[boot-features-external-config-loading-yaml]]
==== 加载 YAML
Spring Framework 提供了两个便捷类，可用于加载 YAML 文档。`YamlPropertiesFactoryBean` 将 YAML 加载为 `Properties`，`YamlMapFactoryBean` 将 YAML 加载为 `Map`。

例如以下 YAML 文档：

[source,yaml,indent=0]
----
	environments:
		dev:
			url: https://dev.example.com
			name: Developer Setup
		prod:
			url: https://another.example.com
			name: My Cool App
----

前面的示例将转换为以下属性（properties）：

[source,properties,indent=0]
----
	environments.dev.url=https://dev.example.com
	environments.dev.name=Developer Setup
	environments.prod.url=https://another.example.com
	environments.prod.name=My Cool App
----

YAML 列表表示带有 `[index]` 下标引用的属性键。例如以下 YAML：

[source,yaml,indent=0]
----
	 my:
		servers:
			- dev.example.com
			- another.example.com
----

以上示例将转成以下属性：

[source,properties,indent=0]
----
	my.servers[0]=dev.example.com
	my.servers[1]=another.example.com
----

要使用 Spring Boot 的 Binder 工具来绑定这样配置到属性（这是 `@ConfigurationProperties` 所做的），你需要在目标 bean 中有一个 `java.util.List`（或 `Set`）类型的属性，你需要为其提供一个 setter 或者使用可变值初始化它。 例如，以下示例展示将上述的配置与属性绑定：

[source,java,indent=0]
----
	@ConfigurationProperties(prefix="my")
	public class Config {

		private List<String> servers = new ArrayList<String>();

		public List<String> getServers() {
			return this.servers;
		}
	}
----



[[boot-features-external-config-exposing-yaml-to-spring]]
==== 在 Spring Environment 中将 YAML 暴露为属性
`YamlPropertySourceLoader` 类可用于在 Spring `Environment` 中将 YAML 暴露为 `PropertySource`。这样做可以让您使用带占位符语法的 `@Value` 注解来访问 YAML 属性。

[[boot-features-external-config-multi-profile-yaml]]
==== 多 profile YAML 文档
您可以使用 `spring.profiles` key 在单个文件中指定多个特定 profile 的 YAML 文档，以指示文档何时应用，如下所示：

[source,yaml,indent=0]
----
	server:
		address: 192.168.1.100
	---
	spring:
		profiles: development
	server:
		address: 127.0.0.1
	---
	spring:
		profiles: production & eu-central
	server:
		address: 192.168.1.120
----

在前面示例中，如果 `development` profile 处于激活状态，则 `server.address` 属性得值为 `127.0.0.1`。 同样，如果 `production` 和 `eu-central` profile 处于激活状态，则 `server.address` 属性的值为 `192.168.1.120`。
如果未激活 `development`、`production` 或 `eu-central` profile，则该属性的值为 `192.168.1.100`。

[NOTE]
====
因此，`spring.profiles` 可以包含一个简单的 profile 名称（例如 `production`）或一个 profile 表达式。profile 表达式允许表达更复杂的 profile 逻辑，例如  `production & (eu-central | eu-west)`。有关详细信息，请查阅{spring-framework-docs}core.html#beans-definition-profiles-java[reference guide]。
====

如果在应用程序上下文启动时没有显式激活，则激活默认 profile。因此，在以下 YAML 中，我们为 `spring.security.user.password` 设置了一个值，该值仅在 default profile 中可用：

[source,yaml,indent=0]
----
	server:
	  port: 8000
	---
	spring:
	  profiles: default
	  security:
	    user:
	      password: weak
----

然而，在以下示例中，始终设置密码，因为它未附加到任何 profile，如果需要更改，必须在所有其他 profile 中显式重置：

[source,yaml,indent=0]
----
	server:
	  port: 8000
	spring:
	  security:
	    user:
	      password: weak
----

使用 `spring.profiles` 元素来指定 Spring profile 可以选择通过使用 `!` 字符来取反（否定）。如果为单个文档指定了否定和非否定的 profile，则至少一个非否定的 profile 必须匹配，没有否定的 profile 可以匹配。

[[boot-features-external-config-yaml-shortcomings]]
==== YAML 的缺点
无法使用 `@PropertySource` 注解加载 YAML 文件。因此，如果您需要以这种方式加载值，请使用属性文件（properties）。

在特定于配置文件的YAML文件中使用多YAML文档语法可能会导致意外行为。 例如，考虑文件中的以下配置：

.application-dev.yml
[source,yaml,indent=0]
----
	server:
	  port: 8000
	---
	spring:
	  profiles: "!test"
	  security:
	    user:
	      password: "secret"
----

如果使用参数 `--spring.profiles.active=dev` 运行该应用程序，则可能希望将 `security.user.password` 设置为 "`secret`"，但事实并非如此。

嵌套文档将被过滤，因为主文件名为 `application-dev.yml`。 它已经被认为是特定于配置文件的，并且嵌套文档将被忽略。

TIP: 我们建议您不要混用特定于配置文件的YAML文件和多个YAML文档。 坚持只使用其中之一。

[[boot-features-external-config-typesafe-configuration-properties]]
=== 类型安全的配置属性
使用 `@Value("${property}")` 注解来注入配置属性有时会很麻烦，特别是如果您使用了多个属性或者您的数据本质上是分层结构。Spring Boot 提供了另一种使用属性的方法，该方法使用强类型的 bean 来管理和验证应用程序的配置，如下所示：

TIP: 另请参见<<boot-features-external-config-vs-value, `@Value` 和类型安全的配置属性之间的区别>>。

[[boot-features-external-config-java-bean-binding]]
==== JavaBean 属性绑定
可以绑定一个声明标准JavaBean属性的bean，如以下示例所示：

[source,java,indent=0]
----
	package com.example;

	import java.net.InetAddress;
	import java.util.ArrayList;
	import java.util.Collections;
	import java.util.List;

	import org.springframework.boot.context.properties.ConfigurationProperties;

	@ConfigurationProperties("acme")
	public class AcmeProperties {

		private boolean enabled;

		private InetAddress remoteAddress;

		private final Security security = new Security();

		public boolean isEnabled() { ... }

		public void setEnabled(boolean enabled) { ... }

		public InetAddress getRemoteAddress() { ... }

		public void setRemoteAddress(InetAddress remoteAddress) { ... }

		public Security getSecurity() { ... }

		public static class Security {

			private String username;

			private String password;

			private List<String> roles = new ArrayList<>(Collections.singleton("USER"));

			public String getUsername() { ... }

			public void setUsername(String username) { ... }

			public String getPassword() { ... }

			public void setPassword(String password) { ... }

			public List<String> getRoles() { ... }

			public void setRoles(List<String> roles) { ... }

		}
	}
----

前面的 POJO 定义了以下属性：

* `acme.enabled`, 默认值为 `false`。
* `acme.remote-address`, 可以从 `String` 强制转换的类型。
* `acme.security.username`, 内嵌一个 `security` 对象，其名称由属性名称决定。特别是，返回类型根本没有使用，可能是 `SecurityProperties`。
* `acme.security.password`.
* `acme.security.roles`, `String` 集合。 默认为 `USER`.

NOTE: Spring Boot自动配置大量使用 `@ConfigurationProperties` 来轻松配置自动配置的bean。 与自动配置类相似，Spring Boot中可用的 `@ConfigurationProperties` 类仅供内部使用。 通过属性文件，YAML文件，环境变量等配置的映射到该类的属性是公共API，
但是该类本身的内容并不意味着可以直接使用。

[NOTE]
====
getter 和 setter 通常是必需的，因为绑定是通过标准的 Java Bean 属性描述符来完成，就像在 Spring MVC 中一样。以下情况可以省略 setter：

* Map，只要它们要初始化，就需要一个 getter 但不一定需要setter，因为它们可以被 binder 修改。
* 集合和数组可以通过一个索引（通常使用 YAML）或使用单个逗号分隔值（属性）进行访问。最后一种情况必须使用 setter。我们建议始终为此类型添加 setter。如果初始化集合，请确保它是可变的（如上例所示）。
* 如果初始化嵌套的 POJO 属性（如前面示例中的 `Security` 字段），则不需要 setter。如果您希望 binder 使用其默认构造函数动态创建实例，则需要一个 setter。

有些人可能会使用 Project Lombok 来自动生成 getter 和 setter。请确保 Lombok 不为此类型生成任何特定构造函数，因为容器会自动使用它来实例化对象。

最后，考虑到标准 Java Bean 属性，不支持对静态属性的绑定。
====

[[boot-features-external-config-constructor-binding]]
==== 构造函数绑定
上一节中的示例可以以不变的方式重写，如下例所示：

[source,java,indent=0]
----
	package com.example;

	import java.net.InetAddress;
	import java.util.List;

	import org.springframework.boot.context.properties.ConfigurationProperties;
	import org.springframework.boot.context.properties.ConstructorBinding;
	import org.springframework.boot.context.properties.DefaultValue;

	@ConstructorBinding
	@ConfigurationProperties("acme")
	public class AcmeProperties {

		private final boolean enabled;

		private final InetAddress remoteAddress;

		private final Security security;

		public AcmeProperties(boolean enabled, InetAddress remoteAddress, Security security) {
			this.enabled = enabled;
			this.remoteAddress = remoteAddress;
			this.security = security;
		}

		public boolean isEnabled() { ... }

		public InetAddress getRemoteAddress() { ... }

		public Security getSecurity() { ... }

		public static class Security {

			private final String username;

			private final String password;

			private final List<String> roles;

			public Security(String username, String password,
					@DefaultValue("USER") List<String> roles) {
				this.username = username;
				this.password = password;
				this.roles = roles;
			}

			public String getUsername() { ... }

			public String getPassword() { ... }

			public List<String> getRoles() { ... }

		}

	}
----

在此设置中，`@ConstructorBinding` 注解用于指示应使用构造函数绑定。 这意味着绑定器将期望找到带有您希望绑定的参数的构造函数。

`@ConstructorBinding` 类的嵌套成员（例如上例中的 `Security` ）也将通过其构造函数进行绑定。

可以使用 `@DefaultValue` 指定默认值，并且将应用相同的转换服务将 `String` 值强制为缺少属性的目标类型。

NOTE: 要使用构造函数绑定，必须使用 `@EnableConfigurationProperties` 或配置属性扫描来启用该类。 您不能对通过常规Spring机制创建的bean使用构造函数绑定（例如 `@Component` bean，通过 `@Bean` 方法创建的bean或使用 `@Import` 加载的bean）

TIP: 如果您的类具有多个构造函数，则还可以直接在应绑定的构造函数上使用 `@ConstructorBinding`。



[[boot-features-external-config-enabling]]
==== 启用 `@ConfigurationProperties` 注解的类型
Spring Boot提供了绑定 `@ConfigurationProperties` 类型并将其注册为Bean的基础架构。 您可以逐类启用配置属性，也可以启用与组件扫描类似的方式进行配置属性扫描。

有时，用 `@ConfigurationProperties` 注释的类可能不适用于扫描，例如，如果您正在开发自己的自动配置，或者想要有条件地启用它们。 在这些情况下，请使用 `@EnableConfigurationProperties` 批注指定要处理的类型列表。 可以在任何 `@Configuration` 类上完成此操作，如以下示例所示：

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(AcmeProperties.class)
	public class MyConfiguration {
	}
----

要使用配置属性扫描，请将 `@ConfigurationPropertiesScan` 批注添加到您的应用程序。 通常，它被添加到使用 `@SpringBootApplication` 注释的主应用程序类中，但可以将其添加到任何 `@Configuration` 类中。
默认情况下，将从声明注释的类的包中进行扫描。 如果要定义要扫描的特定程序包，可以按照以下示例所示进行操作：

[source,java,indent=0]
----
	@SpringBootApplication
	@ConfigurationPropertiesScan({ "com.example.app", "org.acme.another" })
	public class MyApplication {
	}
----

[NOTE]
====
当以这种方式注册 `@ConfigurationProperties` bean 时，bean 具有一个固定格式的名称：`<prefix>-<fqn>`，其中 <prefix> 是 `@ConfigurationProperties` 注解中指定的环境 key 前缀，`<fqn>` 是 bean 的完全限定类名。如果注解未提供任何前缀，则仅使用 bean 的完全限定类名。

上面示例中的 bean 名称为 `acme-com.example.AcmeProperties`。
====

即使前面的配置为 `AcmeProperties` 创建了一个 bean，我们也建议 `@ConfigurationProperties` 只处理环境（environment），特别是不要从上下文中注入其他 bean。
对于极端情况，可以使用setter注入或框架提供的任何 `*Aware` 接口（例如，需要访问 `Environment` 的 `EnvironmentAware`）。 如果仍然想使用构造函数注入其他bean，则必须使用 `@Component` 注释配置属性bean，并使用基于JavaBean的属性绑定。

[[boot-features-external-config-using]]
==== 使用 `@ConfigurationProperties` 注解类型
这种配置样式与 `SpringApplication` 外部YAML配置特别有效，如以下示例所示：

[source,yaml,indent=0]
----
	# application.yml

	acme:
		remote-address: 192.168.1.1
		security:
			username: admin
			roles:
			  - USER
			  - ADMIN

	# additional configuration as required
----

要使用 `@ConfigurationProperties` bean，您可以使用与其他 bean 相同的方式注入它们，如下所示：

[source,java,indent=0]
----
	@Service
	public class MyService {

		private final AcmeProperties properties;

		@Autowired
		public MyService(AcmeProperties properties) {
		    this.properties = properties;
		}

	 	//...

		@PostConstruct
		public void openConnection() {
			Server server = new Server(this.properties.getRemoteAddress());
			// ...
		}

	}
----

TIP: 使用 `@ConfigurationProperties` 还可以生成元数据文件，IDE 可以通过这些文件来为您自己的 key 提供自动完成功能。有关详细信息，请参阅<<appendix-configuration-metadata.adoc#configuration-metadata,附录 B：配置元数据>> 。

[[boot-features-external-config-3rd-party-configuration]]
==== 第三方配置
`@ConfigurationProperties` 除了可以使用来注解类之外，您还可以在公共的 `@Bean` 方法上使用。当您想要将属性绑定到您掌控之外的第三方组件时，这样做特别有用。

要使用 `Environment` 属性配置 bean，请将 `@ConfigurationProperties` 添加到 bean 注册上，如下所示：

[source,java,indent=0]
----
	@ConfigurationProperties(prefix = "another")
	@Bean
	public AnotherComponent anotherComponent() {
		...
	}
----

使用 `another` 前缀定义的所有属性都使用与前面的 `AcmeProperties` 示例类似的方式映射到 `AnotherComponent` bean。

[[boot-features-external-config-relaxed-binding]]
==== 宽松绑定
Spring Boot 使用一些宽松的规则将 `Environment` 属性绑定到 `@ConfigurationProperties` bean，因此 `Environment` 属性名不需要和 bean 属性名精确匹配。
常见的示例包括使用了 `-` 符号分割的环境属性（例如，`context-path` 绑定到 `contextPath`）和大写环境属性（例如，`PORT` 绑定到 `port`）。

如下 `@ConfigurationProperties` 类：

[source,java,indent=0]
----
	@ConfigurationProperties(prefix="acme.my-project.person")
	public class OwnerProperties {

		private String firstName;

		public String getFirstName() {
			return this.firstName;
		}

		public void setFirstName(String firstName) {
			this.firstName = firstName;
		}

	}
----

在上述示例中，同样可以使用以下属性名称：

.宽松绑定
[cols="1,4"]
|===
| 属性 | 描述

| `acme.my-project.person.first-name`
| Kebab 风格（短横线命名），建议在 `.properties` 和 `.yml` 文件中使用。

| `acme.myProject.person.firstName`
| 标准驼峰式风格。

| `acme.my_project.person.first_name`
| 下划线表示法，`.properties` 和 `.yaml` 文件中的另外一种格式。

| `ACME_MYPROJECT_PERSON_FIRSTNAME`
| 大写风格，当使用系统环境变量时推荐使用该风格。
|===

NOTE: 注解的 `prefix` 值必须是 kebab (短横线命名)风格（小写并用 `-` 分隔，例如 `acme.my-project.person`）。

.每种属性源（property source）的宽松绑定规则
[cols="2,4,4"]
|===
| 属性源 | 简单类型 | 列表集合类型

| Properties 文件
| 驼峰式、短横线式或下划线式
| 	标准列表语法使用 `[ ]` 或逗号分隔值

| YAML 文件
| 驼峰式、短横线式或者下划线式
| 标准 YAML 列表语法或者逗号分隔值

| 环境变量
| 大写并且以下划线作为定界符，`_` 不能放在属性名之间使用
| 数字值两边使用下划线连接，例如 `MY_ACME_1_OTHER = my.acme[1].other`

| 系统属性
| 驼峰式、短横线式或者下划线式
| 标准列表语法使用 `[ ]` 或逗号分隔值
|===

TIP: 我们建议，属性尽可能以小写的短横线格式存储，比如 `my.property-name=acme`。

当绑定到 `Map` 属性时，如果 `key` 包含除小写字母数字字符或 `-` 以外的任何内容，则需要使用括号表示法来保留原始值。如果 key 没有使用 `[]` 包裹，则里面的任何非字母数字字符或 `-` 的字符都将被删除。例如，将以下属性绑定到一个 `Map`：

[source,yaml,indent=0]
----
	acme:
	  map:
	    "[/key1]": value1
	    "[/key2]": value2
	    /key3: value3

----

上面的属性将绑定到一个 `Map` 上，其中 `/key1`，`/key2` 和 `key3` 作为 map 的 key。

NOTE: 对于YAML文件，方括号需要用引号引起来，以便正确解析 keys。


[[boot-features-external-config-complex-type-merge]]
==== 合并复杂类型
当列表集合（list）在多个地方配置时，整个列表集合将被替换。

例如，假设带有 `name` 和 `description` 属性的 `MyPojo` 对象默认为 `null`。以下示例中，`AcmeProperties` 暴露了一个 `MyPojo` 对象列表集合：

[source,java,indent=0]
----
	@ConfigurationProperties("acme")
	public class AcmeProperties {

		private final List<MyPojo> list = new ArrayList<>();

		public List<MyPojo> getList() {
			return this.list;
		}

	}
----

配置可以如下：

[source,yaml,indent=0]
----
	acme:
	  list:
	    - name: my name
	      description: my description
	---
	spring:
	  profiles: dev
	acme:
	  list:
	    - name: my another name
----

如果 `dev` 配置文件未激活，则 `AcmeProperties.list` 只包含一条 `MyPojo` 条目，如之前所述。但是，如果激活了 `dev` 配置文件，列表集合仍然只包含一个条目（name 属性值为 `my another name`，description 为 `null`）。
此配置不会向列表集合中添加第二个 `MyPojo` 实例，也不会合并条目。

在多个配置文件中指定一个 `List` 时，最高优先级（并且只有一个）的列表集合将被使用。可做如下配置：

[source,yaml,indent=0]
----
	acme:
	  list:
	    - name: my name
	      description: my description
	    - name: another name
	      description: another description
	---
	spring:
	  profiles: dev
	acme:
	  list:
	    - name: my another name
----

在前面示例中，如果 `dev` 配置文件处于活动状态，则 `AcmeProperties.list` 包含一个 `MyPojo` 条目（name 为 `my another name`，description 为 `null`）。对于 YAML 而言，逗号分隔的列表和YAML 列表同样会完全覆盖列表集合的内容。

对于 Map 属性，您可以绑定来自多个源中提取的属性值。但是，对于多个源中的相同属性，则使用高优先级最高的属性。以下示例从 `AcmeProperties` 暴露了一个 `Map<String, MyPojo>`：

[source,java,indent=0]
----
	@ConfigurationProperties("acme")
	public class AcmeProperties {

		private final Map<String, MyPojo> map = new HashMap<>();

		public Map<String, MyPojo> getMap() {
			return this.map;
		}

	}
----

可以考虑以下配置：

[source,yaml,indent=0]
----
	acme:
	  map:
	    key1:
	      name: my name 1
	      description: my description 1
	---
	spring:
	  profiles: dev
	acme:
	  map:
	    key1:
	      name: dev name 1
	    key2:
	      name: dev name 2
	      description: dev description 2
----

如果 `dev` 配置文件未激活，则 `AcmeProperties.map` 只包含一个带 `key1` key 的条目（name 为 `my name 1`，description 为 `my description 1`）。
如果激活了 `dev` 配置文件，则 map 将包含两个条目， key 分别为 `key1`（name 为 `dev name 1` 和 description 为 `my description 1`）和 `key2`（name 为 `dev name 2` 和 description 为 `dev description 2`）。

NOTE: 前面的合并规则适用于所有不同属性源的属性，而不仅仅是 YAML 文件。

[[boot-features-external-config-conversion]]
==== 属性转换
当外部应用程序属性（application properties） 绑定到 `@ConfigurationProperties` bean 时，Spring Boot 会尝试将其属性强制转换为正确的类型。如果需要自定义类型转换，可以提供 `ConversionService` bean（名为 `conversionService` 的 bean）或自定义属性编辑器（通过 `CustomEditorConfigurer` bean）或自定义转换器（带有注解为 `@ConfigurationPropertiesBinding` 的 bean 定义）。

NOTE: 由于该 bean 在应用程序生命周期早期就被请求 ，因此请限制 `ConversionService` 使用的依赖。您在创建时可能无法完全初始化所需的依赖。如果配置 key 为非强制需要，您可能希望重命名自定义的 `ConversionService`，并仅依赖于使用 `@ConfigurationPropertiesBinding` 限定的自定义转换器。

[[boot-features-external-config-conversion-duration]]
===== 转换 duration
Spring Boot 支持持续时间（duration）表达。如果您暴露一个 `java.time.Duration` 属性，则可以在应用程序属性中使用以下格式：

* 常规 `long` 表示（除非指定 `@DurationUnit`，否则使用毫秒作为默认单位）
* {java-api}/java/time/Duration.html#parse-java.lang.CharSequence-[used by `java.time.Duration`] 使用的标准 ISO-8601 格式
* 一种更易读的格式，值和单位在一起（例如 `10s` 表示 10 秒）

思考以下示例：

[source,java,indent=0]
----
include::{code-examples}/context/properties/bind/AppSystemProperties.java[tag=example]
----

指定一个会话超时时间为 `30` 秒，使用 `30`、`PT30S` 和 `30s` 等形式都是可以的。读取超时时间设置为 `500ms`，可以采用以下任何一种形式：`500`、`PT0.5S` 和 `500ms`。

您也可以使用任何支持的单位来标识：

* `ns` 纳秒
* `us` 微秒
* `ms` 毫秒
* `s` 秒
* `m` 分
* `h` 小时
* `d` 天

默认单位是毫秒，可以使用 `@DurationUnit` 配合上面的单位示例重写。

TIP: 要从先前仅使用 `Long` 来表示持续时间的版本进行升级，如果切换到 `Duration` 时不是毫秒，请定义单位（使用 `@DurationUnit`）。这样做可以提供透明的升级路径，同时支持更丰富的格式。

[[boot-features-external-config-conversion-datasize]]
===== 转换 Data Size
Spring Framework 有一个 `DataSize` 值类型，允许以字节表示大小。如果暴露一个 `DataSize` 属性，则可以在应用程序属性中使用以下格式：

* 常规的 `long` 表示（使用字节作为默认单位，除非指定了 `@DataSizeUnit`）
* 更具有可读性的格式，值和单位在一起（例如 `10MB` 表示 10 兆字节）

请思考以下示例：

[source,java,indent=0]
----
include::{code-examples}/context/properties/bind/AppIoProperties.java[tag=example]
----

要指定 `10` 兆字节的缓冲大小，使用 `10` 和 `10MB` 是等效的。`256` 字节的大小可以指定为 `256` 或 `256B`。

您也可以使用任何支持的单位：

* `B` 字节
* `KB` 千字节
* `MB` 兆字节
* `GB` 千兆字节
* `TB` 兆兆字节

默认单位是字节，可以使用 `@DataSizeUnit` 配合上面的示例单位重写。

TIP: 要从先前仅使用 `Long` 来表示大小的版本进行升级，请确保在切换到 `DataSize` 不是字节的情况下定义单位（使用 `@DataSizeUnit`）。这样做可以提供透明的升级路径，同时支持更丰富的格式。

[[boot-features-external-config-validation]]
==== @ConfigurationProperties 验证
只要使用了 Spring 的 `@Validated` 注解，Spring Boot 就会尝试验证 `@ConfigurationProperties` 类。您可以直接在配置类上使用 JSR-303 `javax.validation` 约束注解。为此，请确保 JSR-303 实现在 classpath 上，然后将约束注解添加到字段上，如下所示：

[source,java,indent=0]
----
	@ConfigurationProperties(prefix="acme")
	@Validated
	public class AcmeProperties {

		@NotNull
		private InetAddress remoteAddress;

		// ... getters and setters

	}
----

TIP: 您还可以通过使用 `@Validated` 注解创建配置属性的 `@Bean` 方法来触发验证。

虽然绑定时也会验证嵌套属性，但最好的做法还是将关联字段注解上 `@Valid`。这可确保即使未找到嵌套属性也会触发验证。以下示例基于前面的 `AcmeProperties` 示例：

[source,java,indent=0]
----
	@ConfigurationProperties(prefix="acme")
	@Validated
	public class AcmeProperties {

		@NotNull
		private InetAddress remoteAddress;

		@Valid
		private final Security security = new Security();

		// ... getters and setters

		public static class Security {

			@NotEmpty
			public String username;

			// ... getters and setters

		}

	}
----

您还可以通过创建一个名为 `configurationPropertiesValidator` 的 bean 定义来添加自定义 Spring `Validator`。应该将 @Bean 方法声明为 `static`。
配置属性验证器在应用程序生命周期的早期创建，将 `@Bean` 方法声明为 `static` 可以无需实例化 `@Configuration` 类来创建 bean。这样做可以避免早期实例化可能导致的意外问题。这里有一个属性验证示例，讲解了如何设置。

TIP: `spring-boot-actuator` 模块包括一个暴露所有 `@ConfigurationPropertie`s bean 的端点。可将 Web 浏览器指向 `/actuator/configprops` 或使用等效的 JMX 端点。有关详细信息，请参阅 "<<production-ready-features.adoc#production-ready-endpoints, 生产就绪功能>>" 部分。

[[boot-features-external-config-vs-value]]
==== `@ConfigurationProperties` 与 `@Value` 对比
`@Value` 注解是核心容器功能，它不提供与类型安全配置属性相同的功能。下表总结了 `@ConfigurationProperties` 和 `@Value` 支持的功能：

[cols="4,2,2"]
|===
| 功能 |`@ConfigurationProperties` |`@Value`

| <<boot-features-external-config-relaxed-binding,宽松绑定>>
| Yes
| No

| <<appendix-configuration-metadata.adoc#configuration-metadata,元数据支持>>
| Yes
| No

| `SpEL` 表达式
| No
| Yes
|===

如果您要为自己的组件定义一组配置 key，我们建议您将它们分组到使用 `@ConfigurationProperties` 注解的 POJO 中。您应该知道，由于 `@Value` 不支持宽松绑定，因此如果您需要通过环境变量来提供值，它并不是一个好的选择。

最后，虽然您可以在 `@Value` 中编写 SpEL 表达式，但来自<<boot-features-external-config-application-property-files,应用程序属性文件>>的此类表达式并不会被处理。

[[boot-features-profiles]]
== Profiles
Spring Profile 提供了一种应用程序配置部分隔离并使其仅在特定环境中可用的方法。可以使用 `@Profile` 来注解任何 `@Component` 或 `@Configuration` 以指定何时加载它，如下所示：

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	@Profile("production")
	public class ProductionConfiguration {

		// ...

	}
----

NOTE: 如果 `@ConfigurationProperties` Bean是通过 `@EnableConfigurationProperties` 而非自动扫描注册的，则需要在 `@EnableConfigurationProperties` 注解的 `@Configuration` 类上指定 `@Profile` 注解。
在扫描 `@ConfigurationProperties` 的情况下，可以在 `@ConfigurationProperties` 类本身上指定 `@Profile`。

您可以使用 configprop:spring.profiles.active[] `Environment` 属性指定哪些配置文件处于激活状态。您可以使用本章前面介绍的任何方法指定属性。例如，您可以将其包含在 `application.properties` 中，如下所示：

[source,properties,indent=0,configprops]
----
	spring.profiles.active=dev,hsqldb
----

您还可以在命令行上使用以下开关指定它：`--spring.profiles.active=dev,hsqldb`。



[[boot-features-adding-active-profiles]]
=== 添加激活 Profile
configprop:spring.profiles.active[] 属性遵循与其他属性相同的排序规则：应用优先级最高的 `PropertySource`。这意味着您可以在 `application.properties` 中指定激活配置文件，然后使用命令行开关替换它们。

有时，将特定 profile 的属性添加到激活配置文件而不是替换它们，这种方式也是很有用的。 configprop:spring.profiles.include[]  属性可无条件地添加激活配置文件。`SpringApplication` 入口还有一个 Java API，用于设置其他 profile（即，在 `spring.profiles.active` 属性激活的 profile 之上）。请参阅 {spring-boot-module-api}/SpringApplication.html[SpringApplication] 中的 `setAdditionalProfiles()` 方法。

例如，当使用开关 `--spring.profiles.active=prod` 运行有以下属性的应用程序时，`proddb` 和 `prodmq` 配置文件也会被激活：

[source,yaml,indent=0]
----
	---
	my.property: fromyamlfile
	---
	spring.profiles: prod
	spring.profiles.include:
	  - proddb
	  - prodmq
----

NOTE: 请记住，可以在 YAML 文档中定义 `spring.profiles` 属性，以确定此特定文档何时包含在配置中。有关更多详细信息，请参见<<howto.adoc#howto-change-configuration-depending-on-the-environment,根据环境更改配置>>。

[[boot-features-programmatically-setting-profiles]]
=== 以编程方式设置 Profile
您可以在应用程序运行之前通过调用 `SpringApplication.setAdditionalProfiles(…)` 以编程方式设置活动配置文件。 也可以使用Spring的 `ConfigurableEnvironment` 接口激活 profile。

[[boot-features-profile-specific-configuration]]
=== 特定 Profile 的配置文件
特定 profile 的 `application.properties`（或 `application.yml`）和通过 `@ConfigurationProperties` 引用的文件被当做文件并加载。有关详细信息，请参见 "<<boot-features-external-config-profile-specific-properties,特定 Profile 的属性文件>>" 。

[[boot-features-logging]]
== 日志记录
Spring Boot 使用 https://commons.apache.org/logging[Commons Logging]  记录所有内部日志，但开放日志的底层实现。其为 {java-api}/java/util/logging/package-summary.html[Java Util Logging] 、https://logging.apache.org/log4j/2.x/[Log4J2] 和 https://logback.qos.ch/[Logback] 提供了默认配置。在每种情况下，日志记录器都预先配置为使用控制台输出，并且还提供可选的文件输出。

默认情况下，如果您使用了 `Starter`，则使用 Logback 进行日志记录。还包括合适的 Logback 路由，以确保在使用 Java Util Logging、Commons Logging、Log4J 或 SLF4J 的依赖库都能正常工作。

TIP: Java 有很多日志框架可供使用。如果以上列表让您感到困惑，请不要担心。通常，您不需要更改日志依赖，并且 Spring Boot 提供的默认配置可以保证日志正常工作。

TIP: 将应用程序部署到Servlet容器或应用程序服务器时，通过Java Util Logging API执行的日志记录不会路由到应用程序的日志中。 这样可以防止容器或其他已部署到容器中的应用程序执行的日志记录出现在应用程序的日志中。


[[boot-features-logging-format]]
=== 日志格式
Spring Boot 默认日志输出类似于以下示例：

[indent=0]
----
2019-03-05 10:57:51.112  INFO 45469 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/7.0.52
2019-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2019-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1358 ms
2019-03-05 10:57:51.698  INFO 45469 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: 'dispatcherServlet' to [/]
2019-03-05 10:57:51.702  INFO 45469 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]
----

输出以下项：

* 日期和时间：毫秒精度，易于排序。
* 日志级别：`ERROR`、`WARN`、`INFO`、`DEBUG` 或 `TRACE`。
* 进程 ID。
* 一个 `---` 分隔符，用于区分实际日志内容的开始。
* 线程名称：在方括号中（可能会截断控制台输出）。
* 日志记录器名称：这通常是源类名称（通常为缩写）。
* 日志内容。

NOTE: Logback 没有 `FATAL` 级别。该级别映射到 `ERROR`。

[[boot-features-logging-console-output]]
=== 控制台输出
默认日志配置会在写入时将消息回显到控制台。默认情况下，会记录 `ERROR`、`WARN` 和 `INFO` 级别的日志。您还可以通过使用 `--debug `标志启动应用程序来启用调试模式。

[indent=0]
----
	$ java -jar myapp.jar --debug
----

NOTE: 您还可以在 `application.properties` 中指定 `debug=true`。

启用调试模式后，核心日志记录器（内嵌容器、Hibernate 和 Spring Boot）将被配置为输出更多日志信息。启用调试模式不会将应用程序配置为使用 `DEBUG` 级别记录所有日志内容。

或者，您可以通过使用 `--trace` 标志（或在 `application.properties` 中的设置 `trace=true`）启动应用程序来启用跟踪模式。这样做可以为选择的核心日志记录器（内嵌容器、Hibernate 模式生成和整个 Spring 组合）启用日志追踪。

[[boot-features-logging-color-coded-output]]
==== 着色输出
如果您的终端支持 ANSI，则可以使用颜色输出来提高可读性。您可以将 `spring.output.ansi.enabled` 设置为 {spring-boot-module-api}/ansi/AnsiOutput.Enabled.html[受支持的值] 以覆盖自动检测。

可使用 `%clr`  转换字配置颜色编码。最简单形式是，转换器根据日志级别对输出进行着色，如下所示：

[source,indent=0]
----
%clr(%5p)
----

下表描述日志级别与颜色的映射关系：

|===
| Level | Color

| `FATAL`
| Red

| `ERROR`
| Red

| `WARN`
| Yellow

| `INFO`
| Green

| `DEBUG`
| Green

| `TRACE`
| Green
|===

或者，您可以通过将其作为转换选项指定应使用的颜色或样式。例如，要将文本变为黄色，请使用以下设置：

[source,indent=0]
----
%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){yellow}
----

支持以下颜色和样式：

* `blue`
* `cyan`
* `faint`
* `green`
* `magenta`
* `red`
* `yellow`



[[boot-features-logging-file-output]]
=== 文件输出
默认情况下，Spring Boot 仅记录到控制台，不会写入日志文件。想除了控制台输出之外还要写入日志文件，则需要设置 `logging.file` 或 `logging.path` 属性（例如，在 `application.properties` 中）。

下表展示了如何与 `logging.*` 属性一起使用：

.Logging 属性
[cols="1,1,1,4"]
|===
| configprop:logging.file.name[] | configprop:logging.file.path[] | Example | Description

| _(none)_
| _(none)_
|
| 仅在控制台输出

| 指定文件
| _(none)_
| `my.log`
| 写入指定的日志文件。名称可以是绝对位置或相对于当前目录。

| _(none)_
| 指定目录
| `/var/log`
| 将 `spring.log` 写入指定的目录。名称可以是绝对位置或相对于当前目录。
|===

日志文件在达到 `10MB` 时会轮转，并且与控制台输出一样，默认情况下会记录 `ERROR`、`WARN` 和 `INFO` 级别的内容。可以使用 `logging.file.max-size` 属性更改大小限制。除非已设置 `logging.file.max-history` 属性，否则以前轮转的文件将无限期归档。
可以使用 `logging.file.total-size-cap` 限制日志归档文件的总大小。 当日志归档的总大小超过该阈值时，将删除备份。 要在应用程序启动时强制清除日志归档文件，请使用 `logging.file.clean-history-on-start` 属性。

TIP: 日日志属性独立于实际的日志底层。因此，spring Boot 不管理特定的配置 key（例如 Logback 的 `logback.configurationFile`）。


[[boot-features-custom-log-levels]]
=== 日志等级
所有受支持的日志记录系统都可以使用 `logging.level.<logger-name>=<level>` 来设置 Spring `Environment` 中的记录器等级（例如，在 `application.properties` 中）。其中 level 是 `TRACE`、`DEBUG`、`INFO`、`WARN`、`ERROR`、`FATAL` 和 `OFF` 其中之一。可以使用 `logging.level.root` 配置 `root` 记录器。

以下示例展示了 `application.properties` 中默认的日志记录设置：

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	logging.level.root=warn
	logging.level.org.springframework.web=debug
	logging.level.org.hibernate=error
----

也可以使用环境变量设置日志记录级别。 例如， `LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_WEB=DEBUG` 会将 `org.springframework.web` 设置为 `DEBUG`。

NOTE: 以上方法仅适用于程序包级别的日志记录。 由于宽松的绑定总是将环境变量转换为小写，因此无法以这种方式为单个类配置日志记录。 如果需要为类配置日志记录，则可以使用  <<boot-features-external-config-application-json, the `SPRING_APPLICATION_JSON`>> 变量。

[[boot-features-custom-log-groups]]
=== 日志组
将相关记录器组合在一起以便可以同时配置，这通常很有用。例如，您可以更改所有 Tomcat 相关记录器的日志记录级别，但您无法轻松记住顶层的包名。

为了解决这个问题，Spring Boot 允许您在 Spring `Environment` 中定义日志记录组。例如，以下通过将 tomcat 组添加到 `application.properties` 来定义 tomcat 组：

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	logging.group.tomcat=org.apache.catalina, org.apache.coyote, org.apache.tomcat
----

定义后，您可以使用一行配置来更改组中所有记录器的级别：

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	logging.level.tomcat=TRACE
----

Spring Boot 包含以下预定义的日志记录组，可以直接使用：

[cols="1,4"]
|===
| 名称 | 日志记录器

| web
| `org.springframework.core.codec`, `org.springframework.http`, `org.springframework.web`, `org.springframework.boot.actuate.endpoint.web`, `org.springframework.boot.web.servlet.ServletContextInitializerBeans`

| sql
| `org.springframework.jdbc.core`, `org.hibernate.SQL`, `org.jooq.tools.LoggerListener`
|===



[[boot-features-custom-log-configuration]]
=== 自定义日志配置
可以通过在 classpath 中引入适合的库来激活各种日志记录系统，并且可以通过在 classpath 的根目录中或在以下 Spring Environment 属性指定的位置提供合适的配置文件来进一步自定义：logging.config。

您可以使用 `org.springframework.boot.logging.LoggingSystem` 系统属性强制 Spring Boot 使用特定的日志记录系统。该值应该是一个实现了 `LoggingSystem` 的类的完全限定类名。您还可以使用 `none` 值完全禁用 Spring Boot 的日志记录配置。


NOTE: 由于日志记录在创建 `ApplicationContext` 之前初始化，因此无法在 Spring `@Configuration` 文件中控制来自 `@PropertySources` 的日志记录。更改日志记录系统或完全禁用它的唯一方法是通过系统属性设置。

根据您的日志记录系统，将加载以下文件：

|===
| 日志记录系统 | 文件

| Logback
| `logback-spring.xml`, `logback-spring.groovy`, `logback.xml`, 或者 `logback.groovy`

| Log4j2
| `log4j2-spring.xml` 或者 `log4j2.xml`

| JDK (Java Util Logging)
| `logging.properties`
|===

NOTE: 如果可能，我们建议您使用 `-spring` 的形式来配置日志记录（比如 `logback-spring.xml` 而不是 `logback.xml`）。如果使用标准的配置位置，Spring 无法完全控制日志初始化。

WARNING: Java Util Logging 存在已知的类加载问题，这些问题在以 'executable jar' 运行时会触发。如果可能的话，我们建议您在使用可执行 jar 方式运行时避免使用它。 .

为了进行自定义，部分其他属性会从 Spring `Environment` 传输到 `System` 属性，如下表所述：

|===
| Spring Environment | 系统属性 | 说明

| configprop:logging.exception-conversion-word[]
| `LOG_EXCEPTION_CONVERSION_WORD`
| 记录异常时使用的转换字。

| configprop:logging.file.clean-history-on-start[]
| `LOG_FILE_CLEAN_HISTORY_ON_START`
| 是否在启动时清除存档日志文件（如果启用了LOG_FILE）。 （仅默认的Logback设置受支持。）

| configprop:logging.file.name[]
| `LOG_FILE`
| 如果已定义，则在默认日志配置中使用它。

| configprop:logging.file.max-size[]
| `LOG_FILE_MAX_SIZE`
| 最大日志文件大小（如果启用了 LOG_FILE）。（仅支持默认的 Logback 设置。）

| configprop:logging.file.max-history[]
| `LOG_FILE_MAX_HISTORY`
| 要保留的归档日志文件最大数量（如果启用了 LOG_FILE）。（仅支持默认的 Logback 设置。）

| configprop:logging.file.path[]
| `LOG_PATH`
| 如果已定义，则在默认日志配置中使用它。

| configprop:logging.file.total-size-cap[]
| `LOG_FILE_TOTAL_SIZE_CAP`
| 要保留的日志备份的总大小（如果启用了LOG_FILE）。 （仅默认的Logback设置受支持。）

| configprop:logging.pattern.console[]
| `CONSOLE_LOG_PATTERN`
| 要在控制台上使用的日志模式（stdout）。（仅支持默认的 Logback 设置。）

| configprop:logging.pattern.dateformat[]
| `LOG_DATEFORMAT_PATTERN`
| 日志日期格式的 Appender 模式。（仅支持默认的 Logback 设置。）

| configprop:logging.pattern.file[]
| `FILE_LOG_PATTERN`
| 要在文件中使用的日志模式（如果启用了 `LOG_FILE`）。（仅支持默认的 Logback 设置。）

| configprop:logging.pattern.level[]
| `LOG_LEVEL_PATTERN`
| 渲染日志级别时使用的格式（默认值为 `%5p`）。（仅支持默认的 Logback 设置。）

| configprop:logging.pattern.rolling-file-name[]
| `ROLLING_FILE_NAME_PATTERN`
| 过渡日志文件名的模式(默认 `$\{LOG_FILE}.%d\{yyyy-MM-dd}.%i.gz`)。

| `PID`
| `PID`
| 当前进程 ID（如果可能，则在未定义为 OS 环境变量时发现）。
|===

所有受支持的日志记录系统在解析其配置文件时都可以参考系统属性。有关示例，请参阅 `spring-boot.jar` 中的默认配置：

* {spring-boot-code}/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/logback/defaults.xml[Logback]
* {spring-boot-code}/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/log4j2/log4j2.xml[Log4j 2]
* {spring-boot-code}/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/java/logging-file.properties[Java Util logging]

[TIP]
====
如果要在日志记录属性中使用占位符，则应使用 <<boot-features-external-config-placeholders-in-properties,Spring Boot 的语法>>，而不是使用底层框架的语法。值得注意的是，如果使用 Logback，则应使用 `:` 作为属性名称与其默认值之间的分隔符，而不是使用 `:-`。
====

[TIP]
====
您可以通过仅覆盖 `LOG_LEVEL_PATTERN`（或带 Logback 的 `logging.pattern.level`）将 MDC 和其他特别的内容添加到日志行。例如，如果使用 `logging.pattern.level=user:%X{user} %5p`，则默认日志格式包含 user MDC 项（如果存在），如下所示:

[indent=0]
----
	2019-08-30 12:30:04.031 user:someone INFO 22174 --- [  nio-8080-exec-0] demo.Controller
	Handling authenticated request
----
====



[[boot-features-logback-extensions]]
=== Logback 扩展
Spring Boot 包含许多 Logback 扩展，可用于进行高级配置。您可以在 `logback-spring.xml` 配置文件中使用这些扩展。

NOTE: 由于标准的 `logback.xml` 配置文件加载过早，因此无法在其中使用扩展。您需要使用 `logback-spring.xml` 或定义 `logging.config` 属性。

WARNING: 扩展不能与 Logback 的 https://logback.qos.ch/manual/configuration.html#autoScan[配置扫描] 一起使用。如果尝试这样做，更改配置文件会导致发生类似以下错误日志： .

[indent=0]
----
	ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProperty], current ElementPath is [[configuration][springProperty]]
	ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProfile], current ElementPath is [[configuration][springProfile]]
----



==== 特定 Profile 配置
`<springProfile>` 标签允许您根据激活的 Spring profile 选择性地包含或排除配置部分。在 `<configuration>` 元素中的任何位置都支持配置 profile。使用 `name` 属性指定哪个 proifle 接受配置。`<springProfile>` 标记可以包含简单的 proifle 名称（例如 `staging`）或 profile 表达式。profile 表达式允许表达更复杂的 profile 逻辑，
例如 `production & (eu-central | eu-west)`。有关详细信息，请查阅 {spring-framework-docs}core.html#beans-definition-profiles-java[参考指南] 。以下清单展示了三个示例 profile：

[source,xml,indent=0]
----
	<springProfile name="staging">
		<!-- configuration to be enabled when the "staging" profile is active -->
	</springProfile>

	<springProfile name="dev | staging">
		<!-- configuration to be enabled when the "dev" or "staging" profiles are active -->
	</springProfile>

	<springProfile name="!production">
		<!-- configuration to be enabled when the "production" profile is not active -->
	</springProfile>
----



==== 环境属性
使用 `<springProperty>` 标签可以让您暴露 Spring 环境（`Environment`）中的属性，以便在 Logback 中使用。如果在 Logback 配置中访问来自 `application.properties` 文件的值，这样做很有用。标签的工作方式与 Logback 的标准 `<property>` 标签类似。但是，您可以指定属性（来自 `Environment`）的 `source`，而不是指定直接的 `value`。如果需要将属性存储在 `local` 范围以外的其他位置，则可以使用 `scope` 属性。
如果需要回退值（如果未在 `Environment` 中设置该属性），则可以使用 `defaultValue` 属性。以下示例展示了如何暴露属性以便在 Logback 中使用：

[source,xml,indent=0]
----
	<springProperty scope="context" name="fluentHost" source="myapp.fluentd.host"
			defaultValue="localhost"/>
	<appender name="FLUENT" class="ch.qos.logback.more.appenders.DataFluentAppender">
		<remoteHost>${fluentHost}</remoteHost>
		...
	</appender>
----

NOTE: 必须以 kebab 风格（短横线小写风格）指定 `source`（例如 `my.property-name`）。但可以使用宽松规则将属性添加到 `Environment` 中。

[[boot-features-internationalization]]
== 国际化
Spring Boot支持本地化消息，因此您的应用程序可以迎合不同语言首选项的用户。 默认情况下，Spring Boot在类路径的根目录下查找 `messages` 资源包的存在。

NOTE: 当已配置资源束的默认属性文件可用时（即默认情况下为 `messages.properties`），将应用自动配置。 如果您的资源包仅包含特定于语言的属性文件，则需要添加默认文件。 如果找不到与任何配置的基本名称匹配的属性文件，将没有自动配置的 `MessageSource`。

可以使用 `spring.messages` 命名空间配置资源包的基本名称以及其他几个属性，如以下示例所示：

[source,properties,indent=0,configprops]
----
	spring.messages.basename=messages,config.i18n.messages
	spring.messages.fallback-to-system-locale=false
----

TIP: `spring.messages.basename` 支持以逗号分隔的位置列表，可以是包限定符，也可以是从类路径根目录解析的资源。

有关更多支持的选项，请参见 {spring-boot-autoconfigure-module-code}/context/MessageSourceProperties.java[`MessageSourceProperties`]

[[boot-features-json]]
== JSON
Spring Boot 为三个 JSON 映射库提供了内置集成：

- Gson
- Jackson
- JSON-B

Jackson 是首选和默认的库。

[[boot-features-json-jackson]]
=== Jackson
Spring Boot 提供了 Jackson 的自动配置，Jackson 是 `spring-boot-starter-json` 的一部分。当 Jackson 在 classpath 上时，会自动配置 `ObjectMapper` bean。Spring Boot 提供了几个配置属性来 <<howto.adoc#howto-customize-the-jackson-objectmapper,自定义 `ObjectMapper` 的配置>>。

[[boot-features-json-gson]]
=== Gson
Spring Boot 提供 Gson 的自动配置。当 `Gson` 在 classpath 上时，会自动配置 Gson bean。Spring Boot 提供了几个 `spring.gson.*` 配置属性来自定义配置。为了获得更多控制，可以使用一个或多个 `GsonBuilderCustomizer` bean。

[[boot-features-json-json-b]]
=== JSON-B
Spring Boot 提供了 JSON-B 的自动配置。当 JSON-B API 和实现在 classpath 上时，将自动配置 `Jsonb` bean。首选的 JSON-B 实现是 Apache Johnzon，它提供了依赖管理。

[[boot-features-developing-web-applications]]
== 开发 Web 应用程序
Spring Boot 非常适合用于开发 web 应用程序。您可以使用嵌入式 Tomcat、Jetty 或者 Undertow 来创建一个独立（self-contained）的 HTTP 服务器。大多数 web 应用程序使用 `spring-boot-starter-web` 模块来快速搭建和运行，您也可以选择使用 `spring-boot-starter-webflux` 模块来构建响应式（reactive） web 应用程序。

如果您尚未开发过 Spring Boot web 应用程序，则可以按照 _<<getting-started.adoc#getting-started-first-application, 入门>>_  章节中的“Hello World!”示例进行操作。

[[boot-features-spring-mvc]]
=== Spring Web MVC 框架
{spring-framework-docs}web.html#mvc[Spring Web MVC 框架] （通常简称“Spring MVC”）是一个富模型-视图-控制器的 web 框架。Spring MVC 允许您创建 `@Controller` 或者 `@RestController` bean 来处理传入的 HTTP 请求。控制器中的方法通过 `@RequestMapping` 注解映射到 HTTP。

以下是一个使用了 `@RestController` 来响应 JSON 数据的典型示例：

[source,java,indent=0]
----
	@RestController
	@RequestMapping(value="/users")
	public class MyRestController {

		@RequestMapping(value="/{user}", method=RequestMethod.GET)
		public User getUser(@PathVariable Long user) {
			// ...
		}

		@RequestMapping(value="/{user}/customers", method=RequestMethod.GET)
		List<Customer> getUserCustomers(@PathVariable Long user) {
			// ...
		}

		@RequestMapping(value="/{user}", method=RequestMethod.DELETE)
		public User deleteUser(@PathVariable Long user) {
			// ...
		}

	}
----

Spring MVC 是 Spring Framework 核心的一部分，详细介绍可参考其 {spring-framework-docs}web.html#mvc[参考文档]。 https://spring.io/guides 还提供了几个 Spring MVC 相关的指南。

[[boot-features-spring-mvc-auto-configuration]]
==== Spring MVC 自动配置
Spring Boot 提供了适用于大多数 Spring MVC 应用的自动配置（auto-configuration）。

自动配置在 Spring 默认功能上添加了以下功能：

* 引入 `ContentNegotiatingViewResolver` 和 `BeanNameViewResolver` bean。
* 支持服务静态资源，包括对 WebJar 的支持（<<boot-features-spring-mvc-static-content,见下文>>）。
* 自动注册 `Converter`、`GenericConverter` 和 `Formatter` bean。
* 支持 `HttpMessageConverter`（ <<boot-features-spring-mvc-message-converters,见下文>>）。
* 自动注册 `MessageCodesResolver`（<<boot-features-spring-message-codes,见下文>>）。
* 支持静态 `index.html`。
* 支持自定义 `Favicon` （<<boot-features-spring-mvc-favicon,见下文>>）。
* 自动使用 `ConfigurableWebBindingInitializer` bean（<<boot-features-spring-mvc-web-binding-initializer,见下文>>）。

如果您想保留 Spring Boot MVC 的功能，并且需要添加其他  {spring-framework-docs}web.html#mvc[MVC configuration]（interceptor、formatter 和视图控制器等），可以添加自己的 `WebMvcConfigurerAdapter` 类型的 `@Configuration` 类，但不能带 `@EnableWebMvc` 注解。

如果您想自定义 `RequestMappingHandlerMapping`、`RequestMappingHandlerAdapter` 或者 `ExceptionHandlerExceptionResolver` 实例，可以声明一个 `WebMvcRegistrationsAdapter` 实例来提供这些组件。

如果您想完全掌控 Spring MVC，可以添加自定义注解了 `@EnableWebMvc` 的 `@Configuration` 配置类。

[[boot-features-spring-mvc-message-converters]]
==== HttpMessageConverters
Spring MVC 使用 `HttpMessageConverter` 接口来转换 HTTP 的请求和响应。开箱即用功能包含了合适的默认值，比如对象可以自动转换为 JSON（使用 Jackson 库）或者 XML（优先使用 Jackson XML 扩展，其次为 JAXB）。字符串默认使用 `UTF-8` 编码。

如果您需要添加或者自定义转换器（converter），可以使用 Spring Boot 的 `HttpMessageConverters` 类：

[source,java,indent=0]
----
	import org.springframework.boot.autoconfigure.http.HttpMessageConverters;
	import org.springframework.context.annotation.*;
	import org.springframework.http.converter.*;

	@Configuration(proxyBeanMethods = false)
	public class MyConfiguration {

		@Bean
		public HttpMessageConverters customConverters() {
			HttpMessageConverter<?> additional = ...
			HttpMessageConverter<?> another = ...
			return new HttpMessageConverters(additional, another);
		}

	}
----

上下文中的所有 `HttpMessageConverter` bean 都将被添加到转换器列表中。您也可以用这种方式来覆盖默认转换器。

[[boot-features-json-components]]
==== 自定义 JSON Serializer 和 Deserializer
如果您使用 Jackson 序列化和反序列化 JSON 数据，可能需要自己编写 `JsonSerializer` 和 `JsonDeserializer` 类。
自定义序列化器（serializer）的做法通常是 https://github.com/FasterXML/jackson-docs/wiki/JacksonHowToCustomSerializers[通过一个模块来注册 Jackson]， 然而 Spring Boot 提供了一个备选的 `@JsonComponent` 注解，它可以更加容易地直接注册 Spring Bean。

您可以直接在 `JsonSerializer` 或者 `JsonDeserializer` 实现上使用 `@JsonComponent` 注解。您也可以在将序列化器/反序列化器（deserializer）作为内部类的类上使用。例如：

[source,java,indent=0]
----
	import java.io.*;
	import com.fasterxml.jackson.core.*;
	import com.fasterxml.jackson.databind.*;
	import org.springframework.boot.jackson.*;

	@JsonComponent
	public class Example {

		public static class Serializer extends JsonSerializer<SomeObject> {
			// ...
		}

		public static class Deserializer extends JsonDeserializer<SomeObject> {
			// ...
		}

	}
----

`ApplicationContext` 中所有的 `@JsonComponent` bean 将被自动注册到 Jackson 中，由于 `@JsonComponent` 使用 `@Component` 注解标记，因此组件扫描（component-scanning）规则将对其生效。

Spring Boot 还提供了 {spring-boot-module-code}/jackson/JsonObjectSerializer.java[`JsonObjectSerializer`] 和 {spring-boot-module-code}/jackson/JsonObjectDeserializer.java[`JsonObjectDeserializer`] 基类，
它们在序列化对象时为标准的 Jackson 版本提供了有用的替代方案。有关详细信息，请参阅 Javadoc 中的 {spring-boot-module-api}/jackson/JsonObjectSerializer.html[`JsonObjectSerializer`] 和 {spring-boot-module-api}/jackson/JsonObjectDeserializer.html[`JsonObjectDeserializer`]。

[[boot-features-spring-message-codes]]
==== MessageCodesResolver
Spring MVC 有一个从绑定错误中生成错误码的策略，用于渲染错误信息：`MessageCodesResolver`。如果您设置了 `spring.mvc.message-codes-resolver.format` 属性值为 `PREFIX_ERROR_CODE` 或 `POSTFIX_ERROR_CODE`，
Spring Boot 将为你创建该策略（请参阅 {spring-framework-api}/validation/DefaultMessageCodesResolver.Format.html[`DefaultMessageCodesResolver.Format`] 中的枚举）。

[[boot-features-spring-mvc-static-content]]
==== 静态内容
默认情况下，Spring Boot 将在 classpath 或者 `ServletContext` 根目录下从名为 `/static` （`/public`、`/resources` 或 `/META-INF/resources`）目录中服务静态内容。它使用了 Spring MVC 的 `ResourceHttpRequestHandler`，因此您可以通过添加自己的 `WebMvcConfigurerAdapter` 并重写 `addResourceHandlers` 方法来修改此行为。

在一个独立的（stand-alone） web 应用程序中，来自容器的默认 servlet 也是被启用的，并充当一个回退支援，Spring 决定不处理 `ServletContext` 根目录下的静态资源，容器的默认 servlet 也将会处理。大多情况下，这是不会发生的（除非您修改了默认的 MVC 配置），因为 Spring 始终能通过 `DispatcherServlet` 来处理请求。

默认情况下，资源被映射到 `/**`，但可以通过 spring.mvc.static-path-pattern 属性调整。比如，将所有资源重定位到 `/resources/**`：

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	spring.mvc.static-path-pattern=/resources/**
----

您还可以使用 `spring.resources.static-locations` 属性来自定义静态资源的位置（使用一个目录位置列表替换默认值）。根 Servlet context path `/` 自动作为一个 location 添加进来。

除了上述提到的标准静态资源位置之外，还有一种特殊情况是用于 https://www.webjars.org/[Webjars content]。如果以 Webjar 格式打包，则所有符合 `/webjars/**` 的资源都将从 jar 文件中服务。

TIP: 如果您的应用程序要包成 jar，请不要使用 `src/main/webapp` 目录。虽然此目录是一个通用标准，但它只适用于 war 打包，如果生成的是一个 jar，它将被绝大多数的构建工具所忽略。

Spring Boot 还支持 Spring MVC 提供的高级资源处理功能，允许使用例如静态资源缓存清除（cache busting）或者 Webjar 版本无关 URL。

要使用 Webjar 版本无关 URL 功能，只需要添加 `webjars-locator-core` 依赖。然后声明您的 Webjar，以 jQuery 为例，添加的 `"/webjars/jquery/dist/jquery.min.js"` 将变成 `"/webjars/jquery/x.y.z/dist/jquery.min.js"`，其中 `x.y.z` 是 Webjar 的版本。

NOTE: 如果您使用 JBoss，则需要声明 `webjars-locator-jboss-vfs` 依赖，而不是 `webjars-locator-core`，否则所有 Webjar 将被解析成 `404`。

要使用缓存清除功能，以下配置为所有静态资源配置了一个缓存清除方案，实际上是在 URL 上添加了一个内容哈希，例如 `<link href="/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css"/>`：

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	spring.resources.chain.strategy.content.enabled=true
	spring.resources.chain.strategy.content.paths=/**
----

NOTE: 模板中的资源链接在运行时被重写，这得益于 `ResourceUrlEncodingFilter` 为 Thymeleaf 和 FreeMarker 自动配置。在使用 JSP 时，您应该手动声明此过滤器。其他模板引擎现在还不会自动支持，但可以与自定义模板宏（macro）/helper 和  {spring-framework-api}/web/servlet/resource/ResourceUrlProvider.html[`ResourceUrlProvider`] 结合使用。

当使用例如 Javascript 模块加载器动态加载资源时，重命名文件是不可选的。这也是为什么支持其他策略并且可以组合使用的原因。fixed策略将在 URL 中添加一个静态版本字符串，而不是更改文件名：

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	spring.resources.chain.strategy.content.enabled=true
	spring.resources.chain.strategy.content.paths=/**
	spring.resources.chain.strategy.fixed.enabled=true
	spring.resources.chain.strategy.fixed.paths=/js/lib/
	spring.resources.chain.strategy.fixed.version=v12
----

使用此配置，JavaScript 模块定位在 `"/js/lib/"` 下使用固定版本策略（`"/v12/js/lib/mymodule.js"`），而其他资源仍使用内容策略（`<link href="/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css"/>`）。

有关更多支持选项，请参阅 {spring-boot-autoconfigure-module-code}/web/ResourceProperties.java[`ResourceProperties`]。

[TIP]
====
该功能已经在一个专门的 https://spring.io/blog/2014/07/24/spring-framework-4-1-handling-static-web-resources[博客文章]和 {spring-framework-docs}web.html#mvc-config-static-resources[Spring 框架的参考文档]中进行了详细描述
====

[[boot-features-spring-mvc-welcome-page]]
==== 欢迎页面
Spring Boot 支持静态和模板化的欢迎页面。它首先在配置的静态内容位置中查找 `index.html` 文件。如果找不到，则查找 `index` 模板。如果找到其中任何一个，它将自动用作应用程序的欢迎页面。

[[boot-features-spring-mvc-favicon]]
==== 自定义 Favicon

Spring Boot 在配置的静态内容位置和根 classpath 中查找 `favicon.ico`（按顺序）。如果该文件存在，则将被自动用作应用程序的 favicon。

[[boot-features-spring-mvc-pathmatch]]
==== 路径匹配与内容协商
Spring MVC 可以通过查看请求路径并将其与应用程序中定义的映射相匹配，将传入的 HTTP 请求映射到处理程序（例如 Controller 方法上的 `@GetMapping` 注解）。

Spring Boot 默认选择禁用后缀模式匹配，这意味着像 `"GET /projects/spring-boot.json"` 这样的请求将不会与 `@GetMapping("/projects/spring-boot")` 映射匹配。这被视为是 {spring-framework-docs}web.html#mvc-ann-requestmapping-suffix-pattern-match[Spring MVC 应用程序的最佳实践] 。此功能在过去对于 HTTP 客户端没有发送正确的 Accept 请求头的情况还是很有用的，我们需要确保将正确的内容类型发送给客户端。如今，内容协商（Content Negotiation）更加可靠。

还有其他方法可以处理 HTTP 客户端发送不一致 Accept 请求头问题。我们可以使用查询参数来确保像 `"GET /projects/spring-boot?format=json"` 这样的请求映射到 `@GetMapping("/projects/spring-boot")`，而不是使用后缀匹配：

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	spring.mvc.contentnegotiation.favor-parameter=true

	# We can change the parameter name, which is "format" by default:
	# spring.mvc.contentnegotiation.parameter-name=myparam

	# We can also register additional file extensions/media types with:
	spring.mvc.contentnegotiation.media-types.markdown=text/markdown
----

如果您了解相关注意事项并仍希望应用程序使用后缀模式匹配，则需要以下配置：

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	spring.mvc.contentnegotiation.favor-path-extension=true
	spring.mvc.pathmatch.use-suffix-pattern=true
----

或者，不打开所有后缀模式，仅打开支持已注册的后缀模式更加安全：

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	spring.mvc.contentnegotiation.favor-path-extension=true
	spring.mvc.pathmatch.use-registered-suffix-pattern=true

	# You can also register additional file extensions/media types with:
	# spring.mvc.contentnegotiation.media-types.adoc=text/asciidoc
----



[[boot-features-spring-mvc-web-binding-initializer]]
==== ConfigurableWebBindingInitializer
Spring MVC 使用一个 `WebBindingInitializer` 为特定的请求初始化 `WebDataBinder`。如果您创建了自己的 `ConfigurableWebBindingInitializer` `@Bean`，Spring Boot 将自动配置 Spring MVC 使用它。

[[boot-features-spring-mvc-template-engines]]
==== 模板引擎
除了 REST web 服务之外，您还可以使用 Spring MVC 来服务动态 HTML 内容。Spring MVC 支持多种模板技术，包括 Thymeleaf、FreeMarker 和 JSP。当然，许多其他模板引擎也有自己的 Spring MVC 集成。

Spring Boot 包含了以下的模板引擎的自动配置支持：

 * https://freemarker.apache.org/docs/[FreeMarker]
 * http://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_the_markuptemplateengine[Groovy]
 * https://www.thymeleaf.org[Thymeleaf]
 * https://mustache.github.io/[Mustache]

TIP: 如果可以，请尽量避免使用 JSP，当使用了内嵌 servlet 容器，会有几个<<boot-features-jsp-limitations, 已知限制>>。

当您使用这些模板引擎的其中一个并附带了默认配置时，您的模板将从 `src/main/resources/templates` 自动获取。

TIP: IntelliJ IDEA 根据您运行应用程序的方式来对 classpath 进行不同的排序。在 IDE 中通过 main 方法来运行应用程序将导致与使用 Maven 或 Gradle 或来以 jar 包方式引用程序的排序有所不同，可能会导致 Spring Boot 找不到 classpath 中的模板。如果您碰到到此问题，可以重新排序 IDE 的 classpath 来放置模块的 classes 和 `resources` 到首位。或者，您可以配置模板前缀来搜索 classpath 中的每一个 `templates` 目录，比如：`classpath*:/templates/`。

[[boot-features-error-handling]]
==== 错误处理
默认情况下，Spring Boot 提供了一个使用了比较合理的方式来处理所有错误的 `/error` 映射，其在 servlet 容器中注册了一个全局错误页面。对于机器客户端而言，它将产生一个包含错误、HTTP 状态和异常消息的 JSON 响应。对于浏览器客户端而言，将以 HTML 格式呈现相同数据的 whitelabel 错误视图（可添加一个解析到 `error` 的 `View` 进行自定义）。
要完全替换默认行为，您可以实现 `ErrorController` 并注册该类型的 bean，或者简单地添加一个类型为 `ErrorAttributes` 的 bean 来替换内容，但继续使用现用机制。

TIP: `BasicErrorController` 可以作为自定义 `ErrorController` 的基类，这非常有用，尤其是在您想添加一个新的内容类型（默认专门处理 `text/html`，并为其他内容提供后备）处理器的情况下。要做到这点，您只需要继承 `BasicErrorController` 并添加一个带有 `produces` 属性的 `@RequestMapping` 注解的公共方法，之后创建一个新类型的 bean。

您还可以定义一个带有 `@ControllerAdvice` 注解的类来自定义为特定控制器或异常类型返回的 JSON 文档：

[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	@ControllerAdvice(basePackageClasses = AcmeController.class)
	public class AcmeControllerAdvice extends ResponseEntityExceptionHandler {

		@ExceptionHandler(YourException.class)
		@ResponseBody
		ResponseEntity<?> handleControllerException(HttpServletRequest request, Throwable ex) {
			HttpStatus status = getStatus(request);
			return new ResponseEntity<>(new CustomErrorType(status.value(), ex.getMessage()), status);
		}

		private HttpStatus getStatus(HttpServletRequest request) {
			Integer statusCode = (Integer) request.getAttribute("javax.servlet.error.status_code");
			if (statusCode == null) {
				return HttpStatus.INTERNAL_SERVER_ERROR;
			}
			return HttpStatus.valueOf(statusCode);
		}

	}
----

以上示例中，如果同包下定义的控制器 `AcmeController` 抛出了 `YourException`，则将使用 `CustomerErrorType` 类型的 POJO 来代替 `ErrorAttributes` 做 JSON 呈现。

[[boot-features-error-handling-custom-error-pages]]
===== 自定义错误页面
如果您想在自定义的 HTML 错误页面上显示给定的状态码，请将文件添加到 `/error` 文件夹中。错误页面可以是静态 HTML（添加在任意静态资源文件夹下) 或者使用模板构建。文件的名称应该是确切的状态码或者一个序列掩码。

例如，要将 404 映射到一个静态 HTML 文件，文件夹结构可以如下：

[source,indent=0,subs="verbatim,quotes,attributes"]
----
	src/
	 +- main/
	     +- java/
	     |   + <source code>
	     +- resources/
	         +- public/
	             +- error/
	             |   +- 404.html
	             +- <other public assets>
----

使用 FreeMarker 模板来映射所有 `5xx` 错误，文件夹的结构如下：

[source,indent=0,subs="verbatim,quotes,attributes"]
----
	src/
	 +- main/
	     +- java/
	     |   + <source code>
	     +- resources/
	         +- templates/
	             +- error/
	             |   +- 5xx.ftlh
	             +- <other templates>
----

对于更复杂的映射，您还通过可以添加实现了 `ErrorViewResolver` 接口的 bean 来处理：

[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	public class MyErrorViewResolver implements ErrorViewResolver {

		@Override
		public ModelAndView resolveErrorView(HttpServletRequest request,
				HttpStatus status, Map<String, Object> model) {
			// Use the request or status to optionally return a ModelAndView
			return ...
		}

	}
----

您还可以使用常规的 Spring MVC 功能，比如  {spring-framework-docs}web.html#mvc-exceptionhandlers[`@ExceptionHandler` methods]  方法和  {spring-framework-docs}web.html#mvc-ann-controller-advice[`@ControllerAdvice`]。之后，`ErrorController` 将能接收任何未处理的异常。

[[boot-features-error-handling-mapping-error-pages-without-mvc]]
===== 映射到 Spring MVC 之外的错误页面
对于不使用 Spring MVC 的应用程序，您可以使用 `ErrorPageRegistrar` 接口来直接注册 `ErrorPages`。抽象部分直接与底层的内嵌 servlet 容器一起工作，即使您没有 Spring MVC `DispatcherServlet` 也能使用。

[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	@Bean
	public ErrorPageRegistrar errorPageRegistrar(){
		return new MyErrorPageRegistrar();
	}

	// ...

	private static class MyErrorPageRegistrar implements ErrorPageRegistrar {

		@Override
		public void registerErrorPages(ErrorPageRegistry registry) {
			registry.addErrorPages(new ErrorPage(HttpStatus.BAD_REQUEST, "/400"));
		}

	}
----

NOTE: 如果您注册了一个 `ErrorPage`，它的路径最终由一个 `Filter`（例如，像一些非 Spring web 框架一样，比如 Jersey 和 Wicket）处理，则必须将 `Filter` 显式注册为一个 `ERROR` dispatcher，如下示例：

[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	@Bean
	public FilterRegistrationBean myFilter() {
		FilterRegistrationBean registration = new FilterRegistrationBean();
		registration.setFilter(new MyFilter());
		...
		registration.setDispatcherTypes(EnumSet.allOf(DispatcherType.class));
		return registration;
	}
----

请注意，默认的 `FilterRegistrationBean` 不包含 `ERROR` 调度器（dispatcher）类型。



[[boot-features-error-handling-websphere]]
当心：当部署到 servlet 容器时，Spring Boot 使用其错误页面过滤器会将有错误状态的请求转发到相应的错误页面。如果尚未提交响应，则只能将请求转发到正确的错误页面。
默认情况下，WebSphere Application Server 8.0 及更高版本在成功完成 servlet 的 service 方法后提交响应。您应该将 `com.ibm.ws.webcontainer.invokeFlushAfterService` 设置为 `false` 来禁用此行为。

[[boot-features-spring-hateoas]]
==== Spring HATEOAS
如果您想开发一个使用超媒体（hypermedia）的 RESTful API，Spring Boot 提供的 Spring HATEOAS 自动配置在大多数应用程序都工作得非常好。自动配置取代了 `@EnableHypermediaSupport` 的需要，
并注册了一些 bean，以便能轻松构建基于超媒体的应用程序，其包括了一个 `LinkDiscoverers` （用于客户端支持）和一个用于配置将响应正确呈现的 ObjectMapper。ObjectMapper 可以通过设置 `spring.jackson.*` 属性或者 `Jackson2ObjectMapperBuilder` bean （如果存在）自定义。

您可以使用 `@EnableHypermediaSupport` 来控制 Spring HATEOAS 的配置。请注意，这使得上述的自定义 `ObjectMapper` 被禁用。

[[boot-features-cors]]
==== CORS 支持
https://en.wikipedia.org/wiki/Cross-origin_resource_sharing[Cross-origin resource sharing] 跨域资源共享（Cross-origin resource sharing，CORS）是 https://caniuse.com/#feat=cors[most browsers]实现的一个 https://www.w3.org/TR/cors/[W3C specification] ，其可允许您以灵活的方式指定何种跨域请求可以被授权，而不是使用一些不太安全和不太强大的方式（比如 IFRAME 或者 JSONP）。

Spring MVC 从 4.2 版本起开始 {spring-framework-docs}web.html#mvc-cors[支持 CORS]。您可在 Spring Boot 应用程序中使用 {spring-framework-api}/web/bind/annotation/CrossOrigin.html[`@CrossOrigin`]  注解 {spring-framework-docs}web.html#mvc-cors-controller[配置控制器方法]启用 CORS。
还可以通过注册一个 `WebMvcConfigurer` bean 并自定义 `addCorsMappings(CorsRegistry)` 方法来定义 {spring-framework-docs}web.html#mvc-cors-global[全局 CORS 配置] ：

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	public class MyConfiguration {

		@Bean
		public WebMvcConfigurer corsConfigurer() {
			return new WebMvcConfigurer() {
				@Override
				public void addCorsMappings(CorsRegistry registry) {
					registry.addMapping("/api/**");
				}
			};
		}
	}
----



[[boot-features-webflux]]
=== Spring WebFlux 框架
Spring WebFlux 是 Spring Framework 5.0 中新引入的一个响应式 Web 框架。与 Spring MVC 不同，它不需要 Servlet API，完全异步且无阻塞，并通过 https://projectreactor.io/[Reactor 项目] 实现响应式流（https://www.reactive-streams.org/[Reactive Streams]）规范。

[source,java,indent=0]
----
	@RestController
	@RequestMapping("/users")
	public class MyRestController {

		@GetMapping("/{user}")
		public Mono<User> getUser(@PathVariable Long user) {
			// ...
		}

		@GetMapping("/{user}/customers")
		public Flux<Customer> getUserCustomers(@PathVariable Long user) {
			// ...
		}

		@DeleteMapping("/{user}")
		public Mono<User> deleteUser(@PathVariable Long user) {
			// ...
		}

	}
----

"`WebFlux.fn`" 为函数式调用方式，它将路由配置与请求处理分开，如下所示：

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	public class RoutingConfiguration {

		@Bean
		public RouterFunction<ServerResponse> monoRouterFunction(UserHandler userHandler) {
			return route(GET("/{user}").and(accept(APPLICATION_JSON)), userHandler::getUser)
					.andRoute(GET("/{user}/customers").and(accept(APPLICATION_JSON)), userHandler::getUserCustomers)
					.andRoute(DELETE("/{user}").and(accept(APPLICATION_JSON)), userHandler::deleteUser);
		}

	}

	@Component
	public class UserHandler {

		public Mono<ServerResponse> getUser(ServerRequest request) {
			// ...
		}

		public Mono<ServerResponse> getUserCustomers(ServerRequest request) {
			// ...
		}

		public Mono<ServerResponse> deleteUser(ServerRequest request) {
			// ...
		}
	}
----

WebFlux 是 Spring Framework 的一部分，详细信息可查看其 {spring-framework-docs}web-reactive.html#webflux-fn[参考文档]。

TIP: 您可以根据需要定义尽可能多的 `RouterFunction` bean 来模块化路由定义。如果需要设定优先级，Bean 可以指定顺序。

首先，将 `spring-boot-starter-webflux` 模块添加到您的应用程序中。

NOTE: 在应用程序中同时添加 `spring-boot-starter-web` 和 `spring-boot-starter-webflux` 模块会导致Spring Boot 自动配置 Spring MVC，而不是使用 `WebFlux`。这样做的原因是因为许多 Spring 开发人员将 `spring-boot-starter-webflux` 添加到他们的 Spring MVC 应用程序中只是为了使用响应式 `WebClient`。
您仍然可以通过设置 `SpringApplication.setWebApplicationType(WebApplicationType.REACTIVE)` 来强制执行您选择的应用程序类型。

[[boot-features-webflux-auto-configuration]]
==== Spring WebFlux 自动配置
Spring Boot 为 Spring WebFlux 提供自动配置，适用于大多数应用程序。

自动配置在 Spring 的默认基础上添加了以下功能：

* 为 `HttpMessageReader` 和 `HttpMessageWriter` 实例配置编解码器（<<boot-features-webflux-httpcodecs,稍后将介绍>>）。
* 支持提供静态资源，包括对 `WebJars` 的支持（<<boot-features-spring-mvc-static-content,稍后将介绍>>）。

如果你要保留 Spring Boot WebFlux 功能并且想要添加其他  {spring-framework-docs}web-reactive.html#webflux-config[`WebFlux` 配置]，可以添加自己的 `@Configuration` 类，类型为 `WebFluxConfigurer`，但不包含 `@EnableWebFlux`。

如果您想完全控制 Spring WebFlux，可以将 `@EnableWebFlux` 注解到自己的 `@Configuration`。

[[boot-features-webflux-httpcodecs]]
==== 使用 HttpMessageReader 和 HttpMessageWriter 作为 HTTP 编解码器
Spring WebFlux 使用 `HttpMessageReader` 和 `HttpMessageWriter` 接口来转换 HTTP 的请求和响应。它们通过检测 classpath 中可用的类库，配置了 `CodecConfigurer` 生成合适的默认值。

Spring Boot 通过使用 `CodecCustomizer` 实例加强定制。例如，`spring.jackson.*` 配置 key 应用于 Jackson 编解码器。

如果需要添加或自定义编解码器，您可以创建一个自定义的 `CodecCustomizer` 组件，如下所示：

[source,java,indent=0]
----
	import org.springframework.boot.web.codec.CodecCustomizer;

	@Configuration(proxyBeanMethods = false)
	public class MyConfiguration {

		@Bean
		public CodecCustomizer myCodecCustomizer() {
			return codecConfigurer -> {
				// ...
			};
		}

	}
----

您还可以利用 <<boot-features-json-components,Boot 自定义 JSON 序列化器和反序列化器>>。

[[boot-features-webflux-static-content]]
==== 静态内容
默认情况下，Spring Boot 将在 classpath 或者 `ServletContext` 根目录下从名为 `/static` （`/public`、`/resources` 或 `/META-INF/resources`）目录中服务静态内容。它使用了 Spring WebFlux 的 `ResourceWebHandler`，因此您可以通过添加自己的 `WebFluxConfigurer` 并重写 `addResourceHandlers` 方法来修改此行为。

默认情况下，资源被映射到 `/**`，但可以通过 `spring.webflux.static-path-pattern` 属性调整。比如，将所有资源重定位到 `/resources/**`：

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	spring.webflux.static-path-pattern=/resources/**
----

您还可以使用 `spring.resources.static-locations` 属性来自定义静态资源的位置（使用一个目录位置列表替换默认值），如果这样做，默认的欢迎页面检测会切换到您自定义的位置。因此，如果启动时有任何其中一个位置存在 `index.html`，那么它将是应用程序的主页。

除了上述提到的标准静态资源位置之外，还有一种特殊情况是用于 https://www.webjars.org/[Webjars 内容] 。如果以 Webjar 格式打包，则所有符合 `/webjars/**` 的资源都将从 jar 文件中服务。

TIP: Spring WebFlux 应用程序并不严格依赖于 Servlet API，因此它们不能作为 war 文件部署，也不能使用 `src/main/webapp` 目录。

[[boot-features-webflux-template-engines]]
==== 模板引擎
除了 REST web 服务之外，您还可以使用 Spring WebFlux 来服务动态 HTML 内容。Spring WebFlux 支持多种模板技术，包括 Thymeleaf、FreeMarker 和 Mustache。

Spring Boot 包含了以下的模板引擎的自动配置支持：

 * https://freemarker.apache.org/docs/[FreeMarker]
 * https://www.thymeleaf.org[Thymeleaf]
 * https://mustache.github.io/[Mustache]

当您使用这些模板引擎的其中一个并附带了默认配置时，您的模板将从 `src/main/resources/templates` 自动获取。



[[boot-features-webflux-error-handling]]
==== Error Handling
Spring Boot 提供了一个 `WebExceptionHandler`，它以合理的方式处理所有错误。它在处理顺序中的位置紧接在 WebFlux 提供的处理程序之前，这些处理器排序是最后的。对于机器客户端，它会生成一个 JSON 响应，其中包含错误详情、HTTP 状态和异常消息。对于浏览器客户端，有一个 whitelabel 错误处理程序，它以 HTML 格式呈现同样的数据。您还可以提供自己的 HTML 模板来显示错误（请参阅<<boot-features-webflux-error-handling-custom-error-pages,下一节>>）。

自定义此功能的第一步通常会沿用现有机制，但替换或扩充了错误内容。为此，您可以添加 `ErrorAttributes` 类型的 bean。

想要更改错误处理行为，可以实现 `ErrorWebExceptionHandler` 并注册该类型的 bean。因为 `WebExceptionHandler` 是一个非常底层的异常处理器，所以 Spring Boot 还提供了一个方便的 `AbstractErrorWebExceptionHandler` 来让你以 WebFlux 的方式处理错误，如下所示：

[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	public class CustomErrorWebExceptionHandler extends AbstractErrorWebExceptionHandler {

		// Define constructor here

		@Override
		protected RouterFunction<ServerResponse> getRoutingFunction(ErrorAttributes errorAttributes) {

			return RouterFunctions
					.route(aPredicate, aHandler)
					.andRoute(anotherPredicate, anotherHandler);
		}

	}
----

要获得更完整的功能，您还可以直接继承 `DefaultErrorWebExceptionHandler` 并覆盖相关方法。

[[boot-features-webflux-error-handling-custom-error-pages]]
===== 自定义错误页面
如果您想在自定义的 HTML 错误页面上显示给定的状态码，请将文件添加到 `/error` 文件夹中。错误页面可以是静态 HTML（添加在任意静态资源文件夹下) 或者使用模板构建。文件的名称应该是确切的状态码或者一个序列掩码。

例如，要将 404 映射到一个静态 HTML 文件，文件夹结构可以如下：

[source,indent=0,subs="verbatim,quotes,attributes"]
----
	src/
	 +- main/
	     +- java/
	     |   + <source code>
	     +- resources/
	         +- public/
	             +- error/
	             |   +- 404.html
	             +- <other public assets>
----

使用 Mustache 模板来映射所有 `5xx` 错误，文件夹的结构如下：

[source,indent=0,subs="verbatim,quotes,attributes"]
----
	src/
	 +- main/
	     +- java/
	     |   + <source code>
	     +- resources/
	         +- templates/
	             +- error/
	             |   +- 5xx.mustache
	             +- <other templates>
----



[[boot-features-webflux-web-filters]]
==== Web 过滤器
Spring WebFlux 提供了一个 `WebFilter` 接口，可以通过实现该接口来过滤 HTTP 请求/响应消息交换。在应用程序上下文中找到的 `WebFilter` bean 将自动用于过滤每个消息交换。

如果过滤器的执行顺序很重要，则可以实现 `Ordered` 接口或使用 `@Order` 注解来指定顺序。Spring Boot 自动配置可能为您配置了几个 Web 过滤器。执行此操作时，将使用下表中的顺序：

|===
| Web Filter | Order

| `MetricsWebFilter`
| `Ordered.HIGHEST_PRECEDENCE + 1`

| `WebFilterChainProxy` (Spring Security)
| `-100`

| `HttpTraceWebFilter`
| `Ordered.LOWEST_PRECEDENCE - 10`
|===



[[boot-features-jersey]]
=== JAX-RS 与 Jersey
如果您喜欢 JAX-RS 编程模型的 REST 端点，则可以使用一个实现来替代 Spring MVC。https://jersey.github.io/[Jersey] 和 https://cxf.apache.org/[Apache CXF] 都能开箱即用。CXF 要求在应用程序上下文中以 `@Bean` 的方式将它注册为一个 `Servlet` 或者 `Filter`。Jersey 有部分原生 Spring 支持，所以我们也在 starter 中提供了与 Spring Boot 整合的自动配置支持。

要使用 Jersey，只需要将 `spring-boot-starter-jersey` 作为依赖引入，然后您需要一个 `ResourceConfig` 类型的 `@Bean`，您可以在其中注册所有端点：

[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	@Component
	public class JerseyConfig extends ResourceConfig {

		public JerseyConfig() {
			register(Endpoint.class);
		}

	}
----

WARNING: Jersey 对于扫描可执行归档文件的支持是相当有限的。例如，它无法扫描一个<<deployment.adoc#deployment-install, 完整的可执行 jar 文件>>中的端点，同样，当运行一个可执行的 war 文件时，它也无法扫描包中 `WEB-INF/classes` 下的端点。为了避免该限制，您不应该使用 `packages` 方法，应该使用上述的 `register` 方法来单独注册每一个端点。

您可以注册任意数量实现了 `ResourceConfigCustomizer` 的 bean，以实现更高级的定制化。

所有注册的端点都应注解了 `@Components` 并具有 HTTP 资源注解（ `@GET` 等），例如：

[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	@Component
	@Path("/hello")
	public class Endpoint {

		@GET
		public String message() {
			return "Hello";
		}

	}
----

由于 Endpoint 是一个 Spring `@Component`，它的生命周期由 Spring 管理，您可以使用 `@Autowired` 注入依赖并使用 `@Value` 注入外部配置。默认情况下，Jersey servlet 将被注册并映射到 `/*`。您可以通过将 `@ApplicationPath` 添加到 `ResourceConfig` 来改变此行为。

默认情况下，Jersey 在 `ServletRegistrationBean` 类型的 @Bean 中被设置为一个名为 `jerseyServletRegistration` 的 Servlet。默认情况下，该 servlet 将被延迟初始化，您可以使用 `spring.jersey.servlet.load-on-startup` 自定义。
您可以禁用或通过创建一个自己的同名 bean 来覆盖该 bean。您还可以通过设置 `spring.jersey.type=filter` 使用过滤器替代 servlet（该情况下， 替代或覆盖 `@Bean` 的为 `jerseyFilterRegistration`）。
该过滤器有一个 `@Order`，您可以使用 `spring.jersey.filter.order` 设置。可以使用 `spring.jersey.init.*` 指定一个 map 类型的 property 以给定 servlet 和过滤器的初始化参数。

这里有一个 Jersey 示例，您可以解如何设置。

[[boot-features-embedded-container]]
=== 内嵌 Servlet 容器支持
Spring Boot 包含了对内嵌 https://tomcat.apache.org/[Tomcat], https://www.eclipse.org/jetty/[Jetty], 和 https://github.com/undertow-io/undertow[Undertow] 服务器的支持。大部分开发人员只需简单地使用对应的 Starter 来获取完整的配置实例。默认情况下，内嵌服务器将监听 `8080` 上的 HTTP 请求。

[[boot-features-embedded-container-servlets-filters-listeners]]
==== Servlets, Filters, 与  listeners
使用内嵌 servlet 容器时，您可以使用 Spring bean 或者扫描方式来注册 Servlet 规范中的 Servlet、Filter 和所有监听器（比如 `HttpSessionListener`）。

[[boot-features-embedded-container-servlets-filters-listeners-beans]]
===== 将 Servlet、Filter 和 Listener 注册为 Spring
任何 `Servlet`、`Filter` 或 `*Listener` 的 Spring bean 实例都将被注册到内嵌容器中。如果您想引用 `application.properties` 中的某个值，这可能会特别方便。

默认情况下，如果上下文只包含单个 Servlet，它将映射到 `/`。在多个 Servlet bean 的情况下，bean 的名称将用作路径的前缀。Filter 将映射到 `/*`。

如果基于约定配置的映射不够灵活，您可以使用 `ServletRegistrationBean`、`FilterRegistrationBean` 和 `ServletListenerRegistrationBean` 类来完全控制。

通常把过滤器 bean 无序是安全的。 如果需要特定的顺序，则应使用 `@Order` 注释 `Filter` 或使其实现 `Ordered`。 您不能通过使用 `@Order` 注释 `Filter` 的bean方法来配置 `Filter` 的顺序。
如果您不能更改 `Filter` 类以添加 `@Order` 或实现 `Ordered`，则必须为 `Filter` 定义一个 `FilterRegistrationBean` 并使用 `setOrder(int)` 方法设置注册bean的顺序。
则应避免在 `Ordered.HIGHEST_PRECEDENCE` 顺序点配置读取请求体的过滤器，因为它的字符编码可能与应用程序的字符编码配置不一致。如果一个 Servlet 过滤器包装了请求，则应使用小于或等于 `OrderedFilter.REQUEST_WRAPPER_FILTER_MAX_ORDER` 的顺序点对其进行配置。

TIP: 要查看应用程序中每个过滤器的顺序，请为 `web` <<boot-features-custom-log-groups,logging group>> (`logging.level.web=debug`) 启用调试级别的日志记录。 然后，将在启动时记录已注册过滤器的详细信息，包括其顺序和URL模式。.

WARNING: 注册 `Filter` Bean时要小心，因为它们是在应用程序生命周期中很早就初始化的。 如果需要注册与其他bean交互的 `Filter`，请考虑改用  {spring-boot-module-api}/web/servlet/DelegatingFilterProxyRegistrationBean.html[`DelegatingFilterProxyRegistrationBean`] 。

[[boot-features-embedded-container-context-initializer]]
==== Servlet 上下文初始化
内嵌 servlet 容器不会直接执行 Servlet 3.0+ 的 `javax.servlet.ServletContainerInitializer` 接口或 Spring 的 `org.springframework.web.WebApplicationInitializer` 接口。这是一个有意的设计决策，旨在降低在 war 内运行时第三方类库产生的风险，防止破坏 Sring Boot 应用程序。

如果您需要在 Spring Boot 应用程序中执行 servlet 上下文初始化，则应注册一个实现了 `org.springframework.boot.context.embedded.ServletContextInitializer` 接口的 bean。`onStartup` 方法提供了针对 `ServletContext` 的访问入口，如果需要，它可以容易作为现有 `WebApplicationInitializer` 的适配器。

[[boot-features-embedded-container-servlets-filters-listeners-scanning]]
===== 扫描 Servlet、Filter 和 Listener
使用内嵌容器时，可以使用 `@ServletComponentScan` 启用带 `@WebServlet`、`@WebFilter` 和 `@WebListener` 注解的类自动注册。

TIP: `@ServletComponentScan` 在独立（standalone）容器中不起作用，因容器将使用内置发现机制来代替。

[[boot-features-embedded-container-application-context]]
==== ServletWebServerApplicationContext
Spring Boot 底层使用了一个不同的 `ApplicationContext` 类型来支持内嵌 servlet。`ServletWebServerApplicationContext` 是一个特殊 `WebApplicationContext` 类型，它通过搜索单个 `ServletWebServerFactory` bean 来引导自身。通常，`TomcatServletWebServerFactory`、 `JettyServletWebServerFactory` 或者 `UndertowServletWebServerFactory` 中的一个将被自动配置。

NOTE: 通常，你不需要知道这些实现类。大部分应用程序会自动配置，并为您创建合适的 `ApplicationContext` 和 `ServletWebServerFactory`。

[[boot-features-customizing-embedded-containers]]
==== 自定义内嵌 Servlet 容器

可以使用 Spring `Environment` 属性来配置通用的 servlet 容器设置。通常，您可以在 `application.properties` 文件中定义这些属性。

常用服务器设置包括：

* 网络设置：监听 HTTP 请求的端口（`server.port`），绑定接口地址到 `server.address` 等。
* 会话设置：是否持久会话（`server.session.persistence`）、session 超时（`server.session.timeout`）、会话数据存放位置（`server.session.store-dir`）和 session-cookie 配置（`server.session.cookie.*`）。
* 错误管理：错误页面位置（`server.error.path`）等。
* <<howto.adoc#howto-configure-ssl,SSL>>
* <<howto.adoc#how-to-enable-http-response-compression,HTTP 压缩>>

Spring Boot 尽可能暴露通用的设置，但并不总是都可以。针对这些情况，专用的命名空间为特定的服务器提供了自定义功能（请参阅 `server.tomcat` 和 `server.undertow`）。例如，您可以使用内嵌 servlet 容器的特定功能来配置 <<howto.adoc#howto-configure-accesslogs,access logs>>。

TIP: 有关完整的内容列表，请参阅 {spring-boot-autoconfigure-module-code}/web/ServerProperties.java[`ServerProperties`]  类。

[[boot-features-programmatic-embedded-container-customization]]
===== 以编程方式自定义
如果您需要以编程的方式配置内嵌 servlet 容器，可以注册一个是实现了 `WebServerFactoryCustomizer` 接口的 Spring bean。`WebServerFactoryCustomizer` 提供了对 `ConfigurableServletWebServerFactory` 的访问入口，其中包含了许多自定义 setter 方法。以下示例使用了编程方式来设置端口：

[source,java,indent=0]
----
	import org.springframework.boot.web.server.WebServerFactoryCustomizer;
	import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;
	import org.springframework.stereotype.Component;

	@Component
	public class CustomizationBean implements WebServerFactoryCustomizer<ConfigurableServletWebServerFactory> {

		@Override
		public void customize(ConfigurableServletWebServerFactory server) {
			server.setPort(9000);
		}

	}
----

NOTE: `TomcatServletWebServerFactory`, `JettyServletWebServerFactory` 和 `UndertowServletWebServerFactory` 是 `ConfigurableServletWebServerFactory` 的具体子类，它们分别为 Tomcat、Jetty 和 Undertow 提供了额外的自定义 setter 方法。.



[[boot-features-customizing-configurableservletwebserverfactory-directly]]
===== 直接自定义 ConfigurableServletWebServerFactory
如果上述的自定义方式太局限，您可以自己注册 `TomcatServletWebServerFactory`、`JettyServletWebServerFactory` 或 `UndertowServletWebServerFactory` bean。

[source,java,indent=0]
----
	@Bean
	public ConfigurableServletWebServerFactory webServerFactory() {
		TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();
		factory.setPort(9000);
		factory.setSessionTimeout(10, TimeUnit.MINUTES);
		factory.addErrorPages(new ErrorPage(HttpStatus.NOT_FOUND, "/notfound.html"));
		return factory;
	}
----

Setter 方法提供了许多配置选项。还有几个 hook 保护方法供您深入定制。有关详细信息，请参阅 {spring-boot-module-api}/web/servlet/server/ConfigurableServletWebServerFactory.html[源码文档]。

[[boot-features-jsp-limitations]]
==== JSP 局限
当运行使用了内嵌 servlet 容器的 Spring Boot 应用程序时（打包为可执行归档文件），JSP 支持将存在一些限制。

* 如果您使用 war 打包，在 Jetty 和 Tomcat 中可以正常工作，使用 `java -jar` 启动时，可执行的 war 可正常使用，并且还可以部署到任何标准容器。使用可执行 jar 时不支持 JSP。

* Undertow 不支持 JSP。

* 创建自定义的 `error.jsp` 页面不会覆盖<<boot-features-error-handling,默认错误处理视图>>，应该使用<<boot-features-error-handling-custom-error-pages,自定义错误页面>>来代替。 .

[[boot-features-reactive-server]]
=== 内嵌响应式服务器支持
Spring Boot 包括对以下内嵌响应式 Web 服务器的支持：Reactor Netty、Tomcat、Jetty 和 Undertow。大多数开发人员使用对应的 Starter 来获取一个完全配置的实例。默认情况下，内嵌服务器在 8080 端口上监听 HTTP 请求。

[[boot-features-reactive-server-resources]]
=== 响应式服务器资源配置
在自动配置 Reactor Netty 或 Jetty 服务器时，Spring Boot 将创建特定的 bean 为服务器实例提供 HTTP 资源：`ReactorResourceFactory` 或 `JettyResourceFactory`。

默认情况下，这些资源也将与 Reactor Netty 和 Jetty 客户端共享以获得最佳性能，具体如下：

* 用于服务器和客户端的的相同技术
* 客户端实例使用了 Spring Boot 自动配置的 `WebClient.Builder` bean 构建。

开发人员可以通过提供自定义的 `ReactorResourceFactory` 或 `JettyResourceFactory` bean 来重写 Jetty 和 Reactor Netty 的资源配置 —— 将应用于客户端和服务器。

您可以在 <<boot-features-webclient-runtime, WebClient Runtime >>章节中了解有关客户端资源配置的更多内容。

[[boot-features-rsocket]]
== RSocket
https://rsocket.io[RSocket] 是用于字节流传输的二进制协议。 它通过通过单个连接传递的异步消息来启用对称交互模型。

Spring框架的 `spring-messaging` 模块在客户端和服务器端都支持RSocket请求者和响应者。 有关更多详细信息，请参见Spring Framework参考中的 {spring-framework-docs}web-reactive.html#rsocket-spring[RSocket 部分]，其中包括RSocket协议的概述。

[[boot-features-rsocket-strategies-auto-configuration]]
=== RSocket策略自动配置
Spring Boot自动配置一个 `RSocketStrategies` bean，该bean提供了编码和解码RSocket有效负载所需的所有基础结构。 默认情况下，自动配置将尝试（按顺序）配置以下内容：

. Jackson的  https://cbor.io/[CBOR] 编解码器
. Jackson的 JSON  编解码器

`spring-boot-starter-socket` 启动器提供了两个依赖项。 查阅 <<boot-features-json-jackson,Jackson支持>>部分，以了解有关定制可能性的更多信息。

开发人员可以通过创建实现 `RSocketStrategiesCustomizer` 接口的bean来自定义 `RSocketStrategies` 组件。 请注意，它们的 `@Order` 很重要，因为它确定编解码器的顺序。

[[boot-features-rsocket-server-auto-configuration]]
=== RSocket服务器自动配置
Spring Boot提供了RSocket服务器自动配置。 所需的依赖关系由 `spring-boot-starter-rsocket` 提供。

Spring Boot允许从WebFlux服务器通过WebSocket公开RSocket，或支持独立的RSocket服务器。 这取决于应用程序的类型及其配置。

对于WebFlux应用程序（即 `WebApplicationType.REACTIVE` 类型），仅当以下属性匹配时，RSocket服务器才会插入Web服务器：

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	spring.rsocket.server.mapping-path=/rsocket # a mapping path is defined
	spring.rsocket.server.transport=websocket # websocket is chosen as a transport
	#spring.rsocket.server.port= # no port is defined
----

WARNING: 由于RSocket本身是使用该库构建的，因此只有Reactor Netty支持将RSocket插入Web服务器。

另外，RSocket TCP或Websocket服务器也可以作为独立的嵌入式服务器启动。 除了依赖性要求之外，唯一需要的配置是为该服务器定义端口：

[source,properties,indent=0,subs="verbatim,quotes,attributes",configprops]
----
	spring.rsocket.server.port=9898 # the only required configuration
	spring.rsocket.server.transport=tcp # you're free to configure other properties
----



[[boot-features-rsocket-messaging]]
=== Spring Messaging RSocket支持
Spring Boot将为RSocket自动配置Spring Messaging基础结构。

这意味着Spring Boot将创建一个 `RSocketMessageHandler` bean，该bean将处理对您的应用程序的RSocket请求。


[[boot-features-rsocket-requester]]
=== 使用 `RSocketRequester` 调用RSocket服务
在服务器和客户端之间建立 `RSocket` 通道后，任何一方都可以向另一方发送或接收请求。

作为服务器，您可以在RSocket `@Controller` 的任何处理程序方法上注入 `RSocketRequester` 实例。 作为客户端，您需要首先配置和建立RSocket连接。 在这种情况下，Spring Boot会使用预期的编解码器自动配置 `RSocketRequester.Builder`。

`RSocketRequester.Builder` 实例是一个原型bean，这意味着每个注入点将为您提供一个新实例。 这样做是有目的的，因为此构建器是有状态的，因此您不应使用同一实例创建具有不同设置的请求者。

以下代码显示了一个典型示例：

[source,java,indent=0]
----
	@Service
	public class MyService {

		private final RSocketRequester rsocketRequester;

		public MyService(RSocketRequester.Builder rsocketRequesterBuilder) {
			this.rsocketRequester = rsocketRequesterBuilder
					.connectTcp("example.org", 9898).block();
		}

		public Mono<User> someRSocketCall(String name) {
			return this.requester.route("user").data(name)
					.retrieveMono(User.class);
		}

	}
----



[[boot-features-security]]
== 安全
默认情况下，如果 {spring-security}[Spring Security]  在 classpath 上，则 Web 应用程序是受保护的。Spring Boot 依赖 Spring Security 的内容协商策略来确定是使用 `httpBasic` 还是 `formLogin`。
要给 Web 应用程序添加方法级别的安全保护，可以使用 `@EnableGlobalMethodSecurity` 注解设置。有关更多其他信息，您可以在  {spring-security-docs}#jc-method[Spring Security 参考指南]中找到。

默认的 `UserDetailsService` 只有一个用户。用户名为 `user`，密码是随机的，在应用程序启动时会以 INFO 级别打印出来，如下所示：

[indent=0]
----
	Using generated security password: 78fa095d-3f4c-48b1-ad50-e24c31d5cf35
----

NOTE: 如果您对日志配置进行微调，请确保将 `org.springframework.boot.autoconfigure.security` 的级别设置为 `INFO`。否则，默认密码不会打印出来。

您可以通过提供 `spring.security.user.name` 和 `spring.security.user.password` 来更改用户名和密码。

您在 Web 应用程序中默认会获得以下基本功能：

* 一个 `UserDetailsService`（或 WebFlux 应用程序中的 `ReactiveUserDetailsService`）bean，采用内存存储形式，有一个自动生成密码的用户（有关用户属性，请参阅  {spring-boot-module-api}/autoconfigure/security/SecurityProperties.User.html[`SecurityProperties.User`] ）。
* 用于整个应用程序（如果 actuator 在 classpath 上，则包括 actuator 端点）基于表单登录或 HTTP Basic 认证（取决于 Content-Type）。
* 一个用于发布身份验证事件的 `DefaultAuthenticationEventPublisher`。

您可以通过为其添加一个 bean 来提供不同的 `AuthenticationEventPublisher`。

[[boot-features-security-mvc]]
=== MVC 安全
默认的安全配置在 `SecurityAutoConfiguration` 和 `UserDetailsServiceAutoConfiguration` 中实现。 `SecurityAutoConfiguration` 导入用于 Web 安全的 `SpringBootWebSecurityConfiguration`，`UserDetailsServiceAutoConfiguration` 配置身份验证，这同样适用于非 Web 应用程序。要完全关闭默认的 Web 应用程序安全配置，可以添加 `WebSecurityConfigurerAdapter` 类型的 bean（这样做不会禁用 `UserDetailsService` 配置或 `Actuator` 的安全保护）。

要同时关闭 `UserDetailsService` 配置，您可以添加 `UserDetailsService`、`AuthenticationProvider` 或 `AuthenticationManager` 类型的 bean。Spring Boot 示例中有几个使用了安全保护的应用程序，他们或许可以帮助到您。

可以通过添加自定义 `WebSecurityConfigurerAdapter` 来重写访问规则。Spring Boot 提供了便捷方法，可用于重写 `actuator` 端点和静态资源的访问规则。`EndpointRequest` 可用于创建一个基于 `management.endpoints.web.base-path` 属性的 `RequestMatcher`。`PathRequest` 可用于为常用位置中的资源创建一个 `RequestMatcher`。

[[boot-features-security-webflux]]
=== WebFlux 安全
与 Spring MVC 应用程序类似，您可以通过添加 `spring-boot-starter-security` 依赖来保护 WebFlux 应用程序。默认的安全配置在 `ReactiveSecurityAutoConfiguration` 和 `UserDetailsServiceAutoConfiguration` 中实现。`ReactiveSecurityAutoConfiguration` 导入用于 Web 安全的 `WebFluxSecurityConfiguration`，`UserDetailsServiceAutoConfiguration` 配置身份验证，这同样适用于非 Web 应用程序。要完全关闭默认的 Web 应用程序安全配置，可以添加 `WebFilterChainProxy` 类型的 bean（这样做不会禁用 `UserDetailsService` 配置或 `Actuator` 的安全保护）。

要同时关闭 `UserDetailsService` 配置，您可以添加 `ReactiveUserDetailsService` 或 `ReactiveAuthenticationManager` 类型的 bean。

可以通过添加自定义 `SecurityWebFilterChain` 来重写访问规则。Spring Boot 提供了便捷方法，可用于重写 `actuator` 端点和静态资源的访问规则。`EndpointRequest` 可用于创建一个基于 `management.endpoints.web.base-path` 属性的 `ServerWebExchangeMatcher`。

`PathRequest` 可用于为常用位置中的资源创建一个 `ServerWebExchangeMatcher`。

例如，您可以通过添加以下内容来自定义安全配置：

[source,java,indent=0]
----
include::{code-examples}/web/security/CustomWebFluxSecurityExample.java[tag=configuration]
----



[[boot-features-security-oauth2]]
=== OAuth2
https://oauth.net/2/[OAuth2] 是 Spring 支持的一种广泛使用的授权框架。



[[boot-features-security-oauth2-client]]
==== 客户端
如果您的 classpath 上有 `spring-security-oauth2-client`，则可以利用一些自动配置来轻松设置 OAuth2/Open ID Connect 客户端。该配置使用 `OAuth2ClientProperties` 的属性。相同的属性适用于 servlet 和响应式应用程序。

您可以在 `spring.security.oauth2.client` 前缀下注册多个 OAuth2 客户端和提供者（provider），如下所示：

[source,properties,indent=0,configprops]
----
	spring.security.oauth2.client.registration.my-client-1.client-id=abcd
	spring.security.oauth2.client.registration.my-client-1.client-secret=password
	spring.security.oauth2.client.registration.my-client-1.client-name=Client for user scope
	spring.security.oauth2.client.registration.my-client-1.provider=my-oauth-provider
	spring.security.oauth2.client.registration.my-client-1.scope=user
	spring.security.oauth2.client.registration.my-client-1.redirect-uri=https://my-redirect-uri.com
	spring.security.oauth2.client.registration.my-client-1.client-authentication-method=basic
	spring.security.oauth2.client.registration.my-client-1.authorization-grant-type=authorization_code

	spring.security.oauth2.client.registration.my-client-2.client-id=abcd
	spring.security.oauth2.client.registration.my-client-2.client-secret=password
	spring.security.oauth2.client.registration.my-client-2.client-name=Client for email scope
	spring.security.oauth2.client.registration.my-client-2.provider=my-oauth-provider
	spring.security.oauth2.client.registration.my-client-2.scope=email
	spring.security.oauth2.client.registration.my-client-2.redirect-uri=https://my-redirect-uri.com
	spring.security.oauth2.client.registration.my-client-2.client-authentication-method=basic
	spring.security.oauth2.client.registration.my-client-2.authorization-grant-type=authorization_code

	spring.security.oauth2.client.provider.my-oauth-provider.authorization-uri=https://my-auth-server/oauth/authorize
	spring.security.oauth2.client.provider.my-oauth-provider.token-uri=https://my-auth-server/oauth/token
	spring.security.oauth2.client.provider.my-oauth-provider.user-info-uri=https://my-auth-server/userinfo
	spring.security.oauth2.client.provider.my-oauth-provider.user-info-authentication-method=header
	spring.security.oauth2.client.provider.my-oauth-provider.jwk-set-uri=https://my-auth-server/token_keys
	spring.security.oauth2.client.provider.my-oauth-provider.user-name-attribute=name
----

对于支持 https://openid.net/specs/openid-connect-discovery-1_0.html[OpenID Connect discovery] 的 OpenID Connect 提供者，可以进一步简化配置。需要使用 `issuer-uri` 配置提供者，`issuer-uri` 是其 Issuer Identifier 的 URI。
例如，如果提供的 issuer-uri 是  "https://example.com"，则将对 "https://example.com/.well-known/openid-configuration" 发起一个  `OpenID Provider Configuration Request`。期望结果是一个 `OpenID Provider Configuration Response`。以下示例展示了如何使用 `issuer-uri` 配置一个 OpenID Connect Provider：

[source,properties,indent=0,configprops]
----
	spring.security.oauth2.client.provider.oidc-provider.issuer-uri=https://dev-123456.oktapreview.com/oauth2/default/
----

默认情况下，Spring Security 的 `OAuth2LoginAuthenticationFilter` 仅处理与 `/login/oauth2/code/*` 相匹配的 URL。如果要自定义 `redirect-uri` 以使用其他匹配模式，则需要提供配置以处理该自定义模式。例如，对于 servlet 应用程序，您可以添加类似于以下 `WebSecurityConfigurerAdapter`：

[source,java,indent=0]
----
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.authorizeRequests()
				.anyRequest().authenticated()
				.and()
			.oauth2Login()
				.redirectionEndpoint()
					.baseUri("/custom-callback");
	}
}
----

[[boot-features-security-oauth2-common-providers]]
===== OAuth2 客户端注册常见的提供者
对于常见的 OAuth2 和 OpenID 提供者（provider），包括 Google、Github、Facebook 和 Okta，我们提供了一组提供者默认设置（分别是 google、github、facebook 和 okta）。

如果您不需要自定义这些提供者，则可以将 `provider` 属性设置为您需要推断默认值的属性。此外，如果客户端注册的 key 与默认支持的提供者匹配，则 Spring Boot 也会推断出来。

换而言之，以下示例中的两个配置使用了 Google 提供者：

[source,properties,indent=0,configprops]
----
	spring.security.oauth2.client.registration.my-client.client-id=abcd
	spring.security.oauth2.client.registration.my-client.client-secret=password
	spring.security.oauth2.client.registration.my-client.provider=google

	spring.security.oauth2.client.registration.google.client-id=abcd
	spring.security.oauth2.client.registration.google.client-secret=password
----



[[boot-features-security-oauth2-server]]
==== 资源服务器
如果在 classpath 上有 `spring-security-oauth2-resource-server`，只要指定了 JWK Set URI 或 OIDC Issuer URI，Spring Boot 就可以设置 OAuth2 资源服务器，如下所示：

[source,properties,indent=0,configprops]
----
	spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://example.com/oauth2/default/v1/keys
----

[source,properties,indent=0,configprops]
----
	spring.security.oauth2.resourceserver.jwt.issuer-uri=https://dev-123456.oktapreview.com/oauth2/default/
----

NOTE: 如果授权服务器不支持JWK设置URI，则可以使用用于验证JWT签名的公共密钥来配置资源服务器。 可以使用 `spring.security.oauth2.resourceserver.jwt.public-key-location` 属性来完成此操作，该属性值需要指向包含PEM编码的x509格式的公钥的文件。

相同的属性适用于 servlet 和响应式应用程序。

或者，您可以为 servlet 应用程序定义自己的 JwtDecoder bean，或为响应式应用程序定义 `ReactiveJwtDecoder`。


如果使用不透明令牌而不是JWT，则可以配置以下属性以通过自省来验证令牌：

[source,properties,indent=0,configprops]
----
	spring.security.oauth2.resourceserver.opaquetoken.introspection-uri=https://example.com/check-token
	spring.security.oauth2.resourceserver.opaquetoken.client-id=my-client-id
	spring.security.oauth2.resourceserver.opaquetoken.client-secret=my-client-secret
----

同样，相同的属性适用于servlet和反应式应用程序。

另外，您可以为Servlet应用程序定义自己的 `OpaqueTokenIntrospector` Bean，或者为反应性应用程序定义 `ReactiveOpaqueTokenIntrospector`。

==== 授权服务器
目前，Spring Security 没有提供 OAuth 2.0 授权服务器实现。但此功能可从 {spring-security-oauth2}[Spring Security OAuth] 项目获得，该项目最终会被 Spring Security 所取代。在此之前，您可以使用 `spring-security-oauth2-autoconfigure` 模块轻松设置 OAuth 2.0 授权服务器，请参阅 https://docs.spring.io/spring-security-oauth2-boot[其文档]以获取详细信息。

[[boot-features-security-saml]]
=== SAML 2.0

[[boot-features-security-saml2-relying-party]]
==== 依赖方
如果您在类路径中具有 `spring-security-saml2-service-provider`，则可以利用一些自动配置功能来轻松设置SAML 2.0依赖方。 此配置利用 `Saml2RelyingPartyProperties` 下的属性。

依赖方注册代表身份提供商IDP和服务提供商SP之间的配对配置。 您可以在 `spring.security.saml2.relyingparty` 前缀下注册多个依赖方，如以下示例所示：

[source,properties,indent=0,configprops]
----
	spring.security.saml2.relyingparty.registration.my-relying-party1.signing.credentials[0].private-key-location=path-to-private-key
	spring.security.saml2.relyingparty.registration.my-relying-party1.signing.credentials[0].certificate-location=path-to-certificate
	spring.security.saml2.relyingparty.registration.my-relying-party1.identityprovider.verification.credentials[0].certificate-location=path-to-verification-cert
	spring.security.saml2.relyingparty.registration.my-relying-party1.identityprovider.entity-id=remote-idp-entity-id1
	spring.security.saml2.relyingparty.registration.my-relying-party1.identityprovider.sso-url=https://remoteidp1.sso.url

	spring.security.saml2.relyingparty.registration.my-relying-party2.signing.credentials[0].private-key-location=path-to-private-key
    spring.security.saml2.relyingparty.registration.my-relying-party2.signing.credentials[0].certificate-location=path-to-certificate
    spring.security.saml2.relyingparty.registration.my-relying-party2.identityprovider.verification.credentials[0].certificate-location=path-to-other-verification-cert
    spring.security.saml2.relyingparty.registration.my-relying-party2.identityprovider.entity-id=remote-idp-entity-id2
    spring.security.saml2.relyingparty.registration.my-relying-party2.identityprovider.sso-url=https://remoteidp2.sso.url
----



[[boot-features-security-actuator]]
=== Actuator 安全
出于安全考虑，默认情况下禁用除 `/health` 和 `/info` 之外的所有 actuator。可用 `management.endpoints.web.exposure.include` 属性启用 actuator。

如果 Spring Security 位于 classpath 上且没有其他 WebSecurityConfigurerAdapter，则除了 `/health` 和 `/info` 之外的所有 actuator 都由 Spring Boot 自动配置保护。如果您定义了自定义 `WebSecurityConfigurerAdapter`，则 Spring Boot 自动配置将不再生效，您可以完全控制 actuator 的访问规则。

NOTE: 在设置 `management.endpoints.web.exposure.include` 之前，请确保暴露的 actuator 没有包含敏感信息和 / 或被防火墙保护亦或受 Spring Security 之类的保护。

[[boot-features-security-csrf]]
==== 跨站请求伪造保护
由于 Spring Boot 依赖 Spring Security 的默认值配置，因此默认情况下会启用 CSRF 保护。这意味着当使用默认安全配置时，需要 `POST`（shutdown 和 loggers 端点）、`PUT` 或 `DELETE` 的 actuator 端点将返回 403 禁止访问错误。

NOTE: 我们建议仅在创建非浏览器客户端使用的服务时才完全禁用 CSRF 保护。

有关 CSRF 保护的其他信息，请参阅 {spring-security-docs}#csrf[Spring Security 参考指南]



[[boot-features-sql]]
== 使用 SQL 数据库
{spring-framework}[Spring Framework]  为 SQL 数据库提供了广泛的支持。从直接使用 `JdbcTemplate` 进行 JDBC 访问到完全的对象关系映射（object relational mapping）技术，比如 Hibernate。{spring-data}[Spring Data]提供了更多级别的功能，直接从接口创建的 `Repository` 实现，并使用了约定从方法名生成查询。

[[boot-features-configure-datasource]]
=== 配置数据源
Java 的 `javax.sql.DataSource` 接口提供了一个使用数据库连接的标准方法。通常，数据源使用 URL 和一些凭据信息来建立数据库连接。

TIP: 查看 <<howto.adoc#howto-configure-a-datasource,"`How-to`" 部分>> 获取更多高级示例，通常您可以完全控制数据库的配置。

[[boot-features-embedded-database-support]]
==== 内嵌数据库支持
使用内嵌内存数据库来开发应用程序非常方便的。显然，内存数据库不提供持久存储。在应用启动时，您需要填充数据库，并在应用程序结束时丢弃数据。

TIP: How-to 部分包含了<<howto.adoc#howto-database-initialization, 如何初始化数据库>>方面的内容。

Spring Boot 可以自动配置内嵌 https://www.h2database.com[H2], http://hsqldb.org/[HSQL], 和 https://db.apache.org/derby/[Derby]  数据库。您不需要提供任何连接 URL，只需为您想要使用的内嵌数据库引入特定的构建依赖。

[NOTE]
====
如果您在测试中使用此功能，您可能会注意到，无论使用了多少应用程序上下文，整个测试套件都会重复使用相同的数据库。如果您想确保每个上下文都有一个单独的内嵌数据库，则应该将 `spring.datasource.generate-unique-name` 设置为 `true`。
====

以下是 POM 依赖示例：

[source,xml,indent=0]
----
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-data-jpa</artifactId>
	</dependency>
	<dependency>
		<groupId>org.hsqldb</groupId>
		<artifactId>hsqldb</artifactId>
		<scope>runtime</scope>
	</dependency>
----

NOTE: 要自动配置内嵌数据库，您需要一个 `spring-jdbc` 依赖。在这个例子中，它是通过 `spring-boot-starter-data-jpa` 引入。

TIP: 如果出于某些原因，您需要配置内嵌数据库的连接 URL，则应注意确保禁用数据库的自动关闭功能。
如果您使用 H2，则应该使用 `DB_CLOSE_ON_EXIT=FALSE` 来设置。如果您使用 HSQLDB，则确保不使用 `shutdown=true`。禁用数据库的自动关闭功能允许 Spring Boot 控制数据库何时关闭，从而确保一旦不再需要访问数据库时就触发。

[[boot-features-connect-to-production-database]]
==== 连接生产数据库
生产数据库连接也可以使用使用 `DataSource` 自动配置。Spring Boot 使用以下算法来选择一个特定的实现：

. 出于性能和并发性的考虑，我们更喜欢 https://github.com/brettwooldridge/HikariCP[HikariCP]  连接池。如果 HikariCP 可用，我们总是选择它。
. 否则，如果 Tomcat 池 DataSource 可用，我们将使用它。
. 如果 HikariCP 和 Tomcat 池数据源不可用，但 https://commons.apache.org/proper/commons-dbcp/[Commons DBCP2]  可用，我们将使用它。

如果您使用了 `spring-boot-starter-jdbc` 或者 `spring-boot-starter-data-jpa starter`，您将自动得到 HikariCP 依赖。

NOTE: 您完全可以绕过该算法，并通过 `spring.datasource.type` 属性指定要使用的连接池。如果您在 Tomcat 容器中运行应用程序，默认提供 `tomcat-jdbc`，这点尤其重要。

TIP: 可以手动配置其他连接池。如果您定义了自己的 `DataSource` bean，则自动配置将不会触发。

数据源配置由 `spring.datasource.*` 中的外部属性所控制。例如，您可以在 `application.properties` 中声明以下部分：

[source,properties,indent=0,configprops]
----
	spring.datasource.url=jdbc:mysql://localhost/test
	spring.datasource.username=dbuser
	spring.datasource.password=dbpass
	spring.datasource.driver-class-name=com.mysql.jdbc.Driver
----

NOTE: 您至少应该使用 `spring.datasource.url` 属性来指定 URL，否则 Spring Boot 将尝试自动配置内嵌数据库。

TIP: 通常您不需要指定 `driver-class-name`，因为 Spring boot 可以从 `url` 推导出大多数数据库。

NOTE: 对于要创建的池 `DataSource`，我们需要能够验证有效的 Driver 类是否可用，因此我们在使用之前进行检查。例如，如果您设置了 `spring.datasource.driver-class-name=com.mysql.jdbc.Driver`，那么该类必须可加载。

有关更多支持选项，请参阅  {spring-boot-autoconfigure-module-code}/jdbc/DataSourceProperties.java[`DataSourceProperties`] 。
这些都是标准选项，与实际的实现无关。还可以使用各自的前缀（`spring.datasource.hikari.*`、`spring.datasource.tomcat.*` 和 `spring.datasource.dbcp2.*`）微调实现特定的设置。请参考您现在使用的连接池实现的文档来获取更多信息。

例如，如果你使用  https://tomcat.apache.org/tomcat-8.0-doc/jdbc-pool.html#Common_Attributes[Tomcat connection pool]，则可以自定义许多其他设置，如下：

[source,properties,indent=0,configprops]
----
	# Number of ms to wait before throwing an exception if no connection is available.
	spring.datasource.tomcat.max-wait=10000

	# Maximum number of active connections that can be allocated from this pool at the same time.
	spring.datasource.tomcat.max-active=50

	# Validate the connection before borrowing it from the pool.
	spring.datasource.tomcat.test-on-borrow=true
----



[[boot-features-connecting-to-a-jndi-datasource]]
==== 连接 JNDI 数据源
如果要将 Spring Boot 应用程序部署到应用服务器（Application Server）上，您可能想使用应用服务器的内置功能和 JNDI 访问方式来配置和管理数据源。

`spring.datasource.jndi-name` 属性可作为 `spring.datasource.url`、`spring.datasource.username` 和 `spring.datasource.password` 属性的替代方法，用于从特定的 JNDI 位置访问 `DataSource`。例如，`application.properties` 中的以下部分展示了如何访问 JBoss AS 定义的 `DataSource`：

[source,properties,indent=0,configprops]
----
	spring.datasource.jndi-name=java:jboss/datasources/customers
----

[[boot-features-using-jdbc-template]]
=== 使用 JdbcTemplate
Spring 的 `JdbcTemplate` 和 `NamedParameterJdbcTemplate` 类是自动配置的，您可以使用 `@Autowire` 将它们直接注入您的 bean 中：

[source,java,indent=0]
----
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.jdbc.core.JdbcTemplate;
	import org.springframework.stereotype.Component;

	@Component
	public class MyBean {

		private final JdbcTemplate jdbcTemplate;

		@Autowired
		public MyBean(JdbcTemplate jdbcTemplate) {
			this.jdbcTemplate = jdbcTemplate;
		}

		// ...

	}
----

您可以使用 `spring.jdbc.template.*` 属性来自定义一些 template 的属性，如下：

[source,properties,indent=0,configprops]
----
	spring.jdbc.template.max-rows=500
----

NOTE: `NamedParameterJdbcTemplate` 在底层重用了相同的 `JdbcTemplate` 实例。如果定义了多个 `JdbcTemplate` 且没有声明 primary 主候选，则不会自动配置 `NamedParameterJdbcTemplate`。

[[boot-features-jpa-and-spring-data]]
=== JPA 与 Spring Data JPA
Java Persistence API（Java 持久化 API）是一项标准技术，可让您将对象映射到关系数据库。`spring-boot-starter-data-jpa` POM 提供了一个快速起步的方法。它提供了以下关键依赖：

* Hibernate:  最受欢迎的 JPA 实现之一。
* Spring Data JPA: 可以轻松地实现基于 JPA 的资源库。
* Spring ORMs:  Spring Framework 的核心 ORM 支持

TIP: 我们不会在这里介绍太多关于 JPA 或者  {spring-data}[Spring Data]  的相关内容。您可以在 https://spring.io 上查看使用 https://spring.io/guides/gs/accessing-data-jpa/["`JPA 访问数据`"]，获取阅读 {spring-data-jpa}[Spring Data JPA] 和 https://hibernate.org/orm/documentation/[Hibernate] 的参考文档。

[[boot-features-entity-classes]]
==== 实体类
通常，JPA Entity（实体）类是在 `persistence.xml` 文件中指定的。使用了 Spring Boot，该文件将不是必需的，可以使用 Entity Scanning（实体扫描）来代替。默认情况下，将搜索主配置类（使用了 `@EnableAutoConfiguration` 或 `@SpringBootApplication` 注解）下面的所有包。

任何用了 `@Entity`、`@Embeddable` 或者 `@MappedSuperclass` 注解的类将被考虑。一个典型的实体类如下：

[source,java,indent=0]
----
	package com.example.myapp.domain;

	import java.io.Serializable;
	import javax.persistence.*;

	@Entity
	public class City implements Serializable {

		@Id
		@GeneratedValue
		private Long id;

		@Column(nullable = false)
		private String name;

		@Column(nullable = false)
		private String state;

		// ... additional members, often include @OneToMany mappings

		protected City() {
			// no-args constructor required by JPA spec
			// this one is protected since it shouldn't be used directly
		}

		public City(String name, String state) {
			this.name = name;
			this.state = state;
		}

		public String getName() {
			return this.name;
		}

		public String getState() {
			return this.state;
		}

		// ... etc

	}
----

TIP: 您可以使用 `@EntityScan` 注解自定义实体类的扫描位置。请参见 "`<<howto.adoc#howto-separate-entity-definitions-from-spring-configuration,从 Spring configuration 配置中分离 @Entity 定义>>`"  章节。

[[boot-features-spring-data-jpa-repositories]]
==== Spring Data JPA 资源库
{spring-data-jpa}[Spring Data JPA]  资源库（repository）是接口，您可以定义用于访问数据。JAP 查询是根据您的方法名自动创建。例如，`CityRepository` 接口可以声明 `findAllByState(String state)` 方法来查找指定状态下的所有城市。

对于更加复杂的查询，您可以使用 Spring Data 的 {spring-data-jpa-api}/repository/Query.html[`Query`] 注解

Spring Data 资源库通常继承自 {spring-data-commons-api}/repository/Repository.html[`Repository`] 或者 {spring-data-commons-api}/repository/CrudRepository.html[`CrudRepository`] 接口。如果您使用了自动配置，则将从包含主配置类（使用了 `@EnableAutoConfiguration` 或 `@SpringBootApplication` 注解）的包中搜索资源库：

以下是一个典型的 Spring Data 资源库接口定义：

[source,java,indent=0]
----
	package com.example.myapp.domain;

	import org.springframework.data.domain.*;
	import org.springframework.data.repository.*;

	public interface CityRepository extends Repository<City, Long> {

		Page<City> findAll(Pageable pageable);

		City findByNameAndStateAllIgnoringCase(String name, String state);

	}
----

Spring Data JPA 资源库支持三种不同的引导模式：`default`、`deferred` 和 `lazy`。要启用延迟或懒惰引导，请将 `spring.data.jpa.repositories.bootstrap-mode` 分别设置为 `deferred` 或 `lazy`。使用延迟或延迟引导时，自动配置的 `EntityManagerFactoryBuilder` 将使用上下文的 `AsyncTaskExecutor` （如果有）作为 `applicationTaskExecutor`。

TIP: 我们几乎没有接触到 Spring Data JPA 的表面内容。有关详细信息，请查阅 {spring-data-jdbc-docs}[Spring Data JPA 参考文档]。

[[boot-features-creating-and-dropping-jpa-databases]]
==== 创建和删除 JPA 数据库
默认情况下，仅当您使用了内嵌数据库（H2、HSQL 或 Derby）时才会自动创建 JPA 数据库。您可以使用 `spring.jpa.*` 属性显式配置 JPA 设置。例如，要创建和删除表，您可以将以下内容添加到 `application.properties` 中：

[indent=0]
----
	spring.jpa.hibernate.ddl-auto=create-drop
----

NOTE: 关于上述功能，Hibernate 自己的内部属性名称（如果您记住更好）为 `hibernate.hbm2ddl.auto`。您可以使用 `spring.jpa.properties.*`（在添加到实体管理器之前，该前缀将被删除）来将 Hibernate 原生属性一同设置：

[indent=0]
----
	spring.jpa.properties.hibernate.globally_quoted_identifiers=true
----

上面示例中将 `true` 值设置给 `hibernate.globally_quoted_identifiers` 属性，该属性将传给 Hibernate 实体管理器。

默认情况下，DDL 执行（或验证）将延迟到 `ApplicationContext` 启动后。还有一个 `spring.jpa.generate-ddl` 标志，如果 Hibernate 自动配置是激活的，那么它将不会被使用，因为 `ddl-auto` 设置更细粒度。

[[boot-features-jpa-in-web-environment]]
==== 在视图中打开 EntityManager
如果您正在运行 web 应用程序，Spring Boot 将默认注册  {spring-framework-api}/orm/jpa/support/OpenEntityManagerInViewInterceptor.html[`OpenEntityManagerInViewInterceptor`] 用于在视图中打开 EntityManager 模式，即运允许在 web 视图中延迟加载。如果您不想开启这个行为，则应在 `application.properties` 中将 `spring.jpa.open-in-view` 设置为 `false`。

[[boot-features-data-jdbc]]
=== Spring Data JDBC
Spring Data 包含了对 JDBC 资源库的支持，并将自动为 `CrudRepository` 上的方法生成 SQL。对于更高级的查询，它提供了 `@Query` 注解。

当 classpath 下存在必要的依赖时，Spring Boot 将自动配置 Spring Data 的 JDBC 资源库。可以通过添加单个 `spring-boot-starter-data-jdbc` 依赖引入到项目中。如有必要，可通过在应用程序中添加 `@EnableJdbcRepositories` 注解或 `JdbcConfiguration` 子类来控制 Spring Data JDBC 的配置。

TIP: 有关 Spring Data JDBC 的完整详细信息，请参阅 {spring-data-jdbc-docs}[参考文档]。

[[boot-features-sql-h2-console]]
=== 使用 H2 的 Web 控制台
https://www.h2database.com[H2 database] 数据库提供了一个 https://www.h2database.com/html/quickstart.html#h2_console[基于浏览器的控制台]基于浏览器的控制台，Spring Boot 可以为您自动配置。当满足以下条件时，控制台将自动配置：

* 您开发的是一个基于 servlet 的 web 应用程序
* `com.h2database:h2` 在 classpath 上
* 您使用了 <<using-spring-boot.adoc#using-boot-devtools,Spring Boot 的开发者工具>>.

TIP: 如果您不使用 Spring Boot 的开发者工具，但仍希望使用 H2 的控制台，则可以通过将 `spring.h2.console.enabled` 属性设置为 `true` 来实现。

NOTE: H2 控制台仅用于开发期间，因此应注意确保 `spring.h2.console.enabled` 在生产环境中没有设置为 `true`。

[[boot-features-sql-h2-console-custom-path]]
==== 更改 H2 控制台的路径
默认情况下，控制台的路径为 `/h2-console`。你可以使用 `spring.h2.console.path` 属性来自定义控制台的路径。

[[boot-features-jooq]]
=== 使用 jOOQ
Java 面向对象查询（Java Object Oriented Querying，https://www.jooq.org/[jOOQ]）是一款广受欢迎的产品，出自  https://www.datageekery.com/[Data Geekery]，它可以通过数据库生成 Java 代码，并允许您使用流式 API 来构建类型安全的 SQL 查询。商业版和开源版都可以与 Spring Boot 一起使用。

==== 代码生成
要使用 jOOQ 的类型安全查询，您需要从数据库模式生成 Java 类。您可以按照 {jooq-docs}/#jooq-in-7-steps-step3[jOOQ 用户手册]中的说明进行操作。如果您使用了 `jooq-codegen-maven` 插件，并且还使用了 `spring-boot-starter-parent` 父 POM，则可以安全地省略掉插件的 `<version>` 标签。
您还可以使用 Spring Boot 定义的版本变量（例如 `h2.version`）来声明插件的数据库依赖。以下是一个示例：

[source,xml,indent=0]
----
	<plugin>
		<groupId>org.jooq</groupId>
		<artifactId>jooq-codegen-maven</artifactId>
		<executions>
			...
		</executions>
		<dependencies>
			<dependency>
				<groupId>com.h2database</groupId>
				<artifactId>h2</artifactId>
				<version>${h2.version}</version>
			</dependency>
		</dependencies>
		<configuration>
			<jdbc>
				<driver>org.h2.Driver</driver>
				<url>jdbc:h2:~/yourdatabase</url>
			</jdbc>
			<generator>
				...
			</generator>
		</configuration>
	</plugin>
----



==== 使用 DSLContext
jOOQ 提供的流式 API 是通过 `org.jooq.DSLContext` 接口初始化的。Spring Boot 将自动配置一个 `DSLContext` 作为 Spring Bean，并且将其连接到应用程序的 `DataSource`。要使用 `DSLContext`，您只需要 `@Autowire` 它：

[source,java,indent=0]
----
	@Component
	public class JooqExample implements CommandLineRunner {

		private final DSLContext create;

		@Autowired
		public JooqExample(DSLContext dslContext) {
			this.create = dslContext;
		}

	}
----

TIP: jOOQ 手册建议使用名为 `create` 的变量来保存 `DSLContext`。

您可以使用 `DSLContext` 构建查询：

[source,java,indent=0]
----
	public List<GregorianCalendar> authorsBornAfter1980() {
		return this.create.selectFrom(AUTHOR)
			.where(AUTHOR.DATE_OF_BIRTH.greaterThan(new GregorianCalendar(1980, 0, 1)))
			.fetch(AUTHOR.DATE_OF_BIRTH);
	}
----



==== jOOQ SQL 方言
除非配置了 `spring.jooq.sql-dialect` 属性，否则 Spring Boot 会自动判定用于数据源的 SQL 方言。如果 Spring Boot 无法检测到方言，则使用 `DEFAULT`。

NOTE: Spring Boot 只能自动配置 jOOQ 开源版本支持的方言。



==== 自定义  jOOQ
可通过定义自己的 `@Bean` 来实现更高级的功能，这些自定义将在创建 jOOQ `Configuration` 时使用。您可以为以下 jOOQ 类型定义 bean：

* `ConnectionProvider`
* `ExecutorProvider`
* `TransactionProvider`
* `RecordMapperProvider`
* `RecordUnmapperProvider`
* `Settings`
* `RecordListenerProvider`
* `ExecuteListenerProvider`
* `VisitListenerProvider`
* `TransactionListenerProvider`

如果要完全控制 jOOQ 配置，您可以创建自己的 `org.jooq.Configuration` `@Bean`。



[[boot-features-nosql]]
== 使用 NoSQL 技术
Spring Data提供了其他项目来帮助您访问各种NoSQL技术，包括：

* {spring-data-mongodb}[MongoDB]
* {spring-data-neo4j}[Neo4J]
* {spring-data-elasticsearch}[Elasticsearch]
* {spring-data-solr}[Solr]
* {spring-data-redis}[Redis]
* {spring-data-gemfire}[GemFire] or {spring-data-geode}[Geode]
* {spring-data-cassandra}[Cassandra]
* {spring-data-couchbase}[Couchbase]
* {spring-data-ldap}[LDAP]

Spring Boot为Redis，MongoDB，Neo4j，Elasticsearch，Solr Cassandra，Couchbase和LDAP提供自动配置。 您可以使用其他项目，但必须自己进行配置。 请参阅 {spring-data} 中的相应参考文档。

[[boot-features-redis]]
=== Redis
https://redis.io/[Redis] 是一个集缓存、消息代理和键值存储等丰富功能的数据库。Spring Boot 为 https://github.com/lettuce-io/lettuce-core/[Lettuce] 和 https://github.com/xetorthio/jedis/[Jedis] 客户端类库提供了基本自动配置，https://github.com/spring-projects/spring-data-redis[Spring Data Redis] 为他们提供了上层抽象。

使用 `spring-boot-starter-data-redis` starter 可方便地引入相关依赖。默认情况下，它使用 https://github.com/lettuce-io/lettuce-core/[Lettuce]。该 starter 可处理传统应用程序和响应式应用程序。

TIP: 我们还提供了一个 `spring-boot-starter-data-redis-reactive` starter，以便与其他带有响应式支持的存储保持一致。

[[boot-features-connecting-to-redis]]
==== 连接 Redis
您可以像所有 Spring Bean 一样注入自动配置的 `RedisConnectionFactory`、`StringRedisTemplate` 或普通的 `RedisTemplate` 实例。默认情况下，实例将尝试在 `localhost:6379` 上连接 Redis 服务器，以下是 bean 示例：

[source,java,indent=0]
----
	@Component
	public class MyBean {

		private StringRedisTemplate template;

		@Autowired
		public MyBean(StringRedisTemplate template) {
			this.template = template;
		}

		// ...

	}
----

TIP: 您还可以注册任意数量个实现了 `LettuceClientConfigurationBuilderCustomizer` 的 bean，以进行更高级的自定义。如果你使用 Jedis，则可以使用 `JedisClientConfigurationBuilderCustomizer`。

如果您添加了自己的任何一个自动配置类型的 `@Bean`，它将替换默认设置（除了 `RedisTemplate`，由于排除是基于 bean 名称，而 `redisTemplate` 不是它的类型）。默认情况下，如果 `commons-pool2` 在 classpath 上，您将获得一个连接池工厂。

[[boot-features-mongodb]]
=== MongoDB
https://www.mongodb.com/[MongoDB] 是一个开源的 NoSQL 文档数据库，其使用了类似 JSON 的模式（schema）来替代传统基于表的关系数据。Spring Boot 为 MongoDB 提供了几种便利的使用方式，包括 `spring-boot-starter-data-mongodb` 和 `spring-boot-starter-data-mongodb-reactive` starter。

[[boot-features-connecting-to-mongodb]]
==== 连接 MongoDB 数据库
您可以注入一个自动配置的 `org.springframework.data.mongodb.MongoDbFactory` 来访问 Mongo 数据库。默认情况下，该实例将尝试在 `mongodb://localhost/test` 上连接 MongoDB 服务器，以下示例展示了如何连接到 MongoDB 数据库：

[source,java,indent=0]
----
	import org.springframework.data.mongodb.MongoDbFactory;
	import com.mongodb.DB;

	@Component
	public class MyBean {

		private final MongoDbFactory mongo;

		@Autowired
		public MyBean(MongoDbFactory mongo) {
			this.mongo = mongo;
		}

		// ...

		public void example() {
			DB db = mongo.getDb();
			// ...
		}

	}
----

您可以通过设置 `spring.data.mongodb.uri` 属性来更改 URL 和配置其他设置，如副本集（replica set）：

[source,properties,indent=0,configprops]
----
	spring.data.mongodb.uri=mongodb://user:secret@mongo1.example.com:12345,mongo2.example.com:23456/test
----

另外，只要您使用了 Mongo 2.x，请指定 `host/port`。比如，您可能要在 `application.properties` 中声明以下内容：

[source,properties,indent=0,configprops]
----
	spring.data.mongodb.host=mongoserver
	spring.data.mongodb.port=27017
----

如果您已经定义了自己的 `MongoClient`，它将被用于自动配置合适的 `MongoDbFactory`。支持 `com.mongodb.MongoClient` 和 `com.mongodb.client.MongoClient`。

NOTE: 如果您使用 Mongo 3.0 Java 驱动，则不支持 `spring.data.mongodb.host` 和 `spring.data.mongodb.port`。这种情况下，应该使用 `spring.data.mongodb.uri` 来提供所有配置。

TIP: 如果未指定 `spring.data.mongodb.port`，则使用默认值 `27017`。您可以将上述示例中的改行配置删除掉。

TIP: 如果您不使用 Spring Data Mongo，则可以注入 `com.mongodb.MongoClient` bean 来代替 `MongoDbFactory`。如果要完全控制建立 MongoDB 连接，您还可以声明自己的 `MongoDbFactory` 或者 `MongoClient` bean。

NOTE: 如果您使用的是响应式驱动，则 SSL 需要 Netty。 如果 Netty 可用且 factory 尚未自定义，则自动配置会自动配置此 factory。

[[boot-features-mongo-template]]
==== MongoTemplate
{spring-data-mongodb}[Spring Data MongoDB] 提供了一个 {spring-data-mongodb-api}/core/MongoTemplate.html[`MongoTemplate`]  类，它的设计与 Spring 的 `JdbcTemplate` 非常相似。与 `JdbcTemplate` 一样，Spring Boot 会自动配置一个 bean，以便您能注入模板：

[source,java,indent=0]
----
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.data.mongodb.core.MongoTemplate;
	import org.springframework.stereotype.Component;

	@Component
	public class MyBean {

		private final MongoTemplate mongoTemplate;

		@Autowired
		public MyBean(MongoTemplate mongoTemplate) {
			this.mongoTemplate = mongoTemplate;
		}

		// ...

	}
----

更多详细信息，参照 {spring-data-mongodb-api}/core/MongoOperations.html[`MongoOperations` Javadoc] 。

[[boot-features-spring-data-mongo-repositories]]
[[boot-features-spring-data-mongodb-repositories]]
==== Spring Data MongoDB Repositories
Spring Data 包含了对 MongoDB 资源库（repository）的支持。与之前讨论的 JPA 资源库一样，基本原理是根据方法名称自动构建查询。

事实上，Spring Data JPA 和 Spring Data MongoDB 共享通用的底层代码，因此你可以拿之前提到的 JPA 示例作为基础，假设 `City` 现在是一个 Mongo 数据类，而不是一个 JPA `@Entity`，他们方式工作相同：

[source,java,indent=0]
----
	package com.example.myapp.domain;

	import org.springframework.data.domain.*;
	import org.springframework.data.repository.*;

	public interface CityRepository extends Repository<City, Long> {

		Page<City> findAll(Pageable pageable);

		City findByNameAndStateAllIgnoringCase(String name, String state);

	}
----

TIP: 您可以使用 `@EntityScan` 注解来自定义文档扫描位置。

TIP: 有关 Spring Data MongoDB 的完整详细内容，包括其丰富的对象关系映射技术，请参考其 {spring-data-mongodb}[参考文档].



[[boot-features-mongo-embedded]]
==== 内嵌 Mongo
Spring Boot 提供了 https://github.com/flapdoodle-oss/de.flapdoodle.embed.mongo[内嵌 Mongo]的自动配置。要在 Spring Boot 应用程序中使用它，请添加依赖 `de.flapdoodle.embed:de.flapdoodle.embed.mongo`。

可以使用 `spring.data.mongodb.port` 属性来配置 Mongo 的监听端口。如果想随机分配空闲端口，请把值设置为 0。`MongoAutoConfiguration` 创建的 `MongoClient` 将自动配置随机分配的端口。

NOTE: 如果您不配置一个自定义端口，内嵌支持将默认使用一个随机端口（而不是 27017）。

如果您的 classpath 上有 SLF4J，Mongo 产生的输出将自动路由到名为 `org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongo` 的 logger。

您可以声明自己的 `IMongodConfig` 和 `IRuntimeConfig` bean 来控制 Mongo 实例的配置和日志路由。

可以通过声明 `DownloadConfigBuilderCustomizer` bean来定制下载配置。

[[boot-features-neo4j]]
=== Neo4j
https://neo4j.com/[Neo4j] 是一个开源的 NoSQL 图形数据库，它使用了一个节点由关系连接的富数据模型，比传统 RDBMS 的方式更适合连接大数据。Spring Boot 为 Neo4j 提供了便捷引入方式，包括 `spring-boot-starter-data-neo4j` starter。

[[boot-features-connecting-to-neo4j]]
==== 连接 Neo4j 数据库
您可以像任何 Spring Bean 一样注入一个自动配置的 `org.neo4j.ogm.session.Session`。默认情况下， 该实例将尝试使用在 `localhost:7687` 上使用 Bolt 协议连接到 Neo4j 服务器，以下示例展示了如何注入 一个 Neo4j `Session`：

[source,java,indent=0]
----
	@Component
	public class MyBean {

		private final Session session;

		@Autowired
		public MyBean(Session session) {
			this.session = session;
		}

		// ...

	}
----

您可以通过配置 `spring.data.neo4j.*` 属性来设置 uri 和凭据：

[source,properties,indent=0,configprops]
----
	spring.data.neo4j.uri=bolt://my-server:7687
	spring.data.neo4j.username=neo4j
	spring.data.neo4j.password=secret
----

您可以通过添加自己的 `org.neo4j.ogm.config.Configuration` Bean 来完全控制 session 创建。此外，添加 `SessionFactory` 类型的 Bean 会禁用自动配置，因此您可以掌控所有。

[[boot-features-connecting-to-neo4j-embedded]]
==== 使用内嵌模式
如果您将 `org.neo4j:neo4j-ogm-embedded-driver` 添加到应用程序的依赖中，Spring Boot 将自动配置一个进程内内嵌的 Neo4j 实例，当您的应用程序关闭时，该实例将不会保留任何数据。

NOTE: 内嵌 Neo4j OGM 驱动本身不提供 Neo4j 您必须自己声明 `org.neo4j:neo4j` 依赖，请参考 https://neo4j.com/docs/ogm-manual/current/reference/#reference:getting-started[the Neo4j OGM 文档] 获取兼容版本列表。

您可以通过设置 `spring.data.neo4j.embedded.enabled = false` 显式禁用嵌入式模式。

如果嵌入式驱动程序和Neo4j内核位于上述类路径上，则 <<boot-features-testing-spring-boot-applications-testing-autoconfigured-neo4j-test,Data Neo4j Tests>>会自动使用嵌入式Neo4j实例。

NOTE: 您可以通过在配置中提供数据库文件路径来为内嵌模式启用持久化，例如：`spring.data.neo4j.uri=file://var/tmp/graph.db`。

[[boot-features-neo4j-ogm-native-types]]
==== 使用本机类型
Neo4j-OGM可以将某些类型（例如  `java.time.*` 中的类型）映射到基于 `String` 的属性或Neo4j提供的本机类型之一。 出于向后兼容的原因，Neo4j-OGM的默认设置是使用基于字符串的表示形式。 要使用本机类型，请添加对 `org.neo4j:neo4j-ogm-embedded-native-types` 或 `org.neo4j：neo4j-ogm-embedded-native-types` 的依赖关系，并配置 `spring.data.neo4j.use-native-types` 属性，如以下示例所示：

[source,properties,indent=0,configprops]
----
	spring.data.neo4j.use-native-types=true
----

[[boot-features-neo4j-ogm-session]]
==== Neo4jSession
默认情况下，如果您正在运行 Web 应用程序，会话（session）将被绑定到当前请求的整个处理线程（即 Open Session in View 模式）。如果不希望此行为，您可以在 `application.properties` 中添加以下内容：

[source,properties,indent=0,configprops]
----
	spring.data.neo4j.open-in-view=false
----

[[boot-features-spring-data-neo4j-repositories]]
==== Spring Data Neo4j 资源库
Spring Data 包括了对 Neo4j 资源库的支持。

Spring Data Neo4j 与 Spring Data JPA 共享相同的通用底层代码，因此您可以直接把之前的 JPA 示例作为基础，假设 `City` 现在是一个 Neo4j OGM `@NodeEntity`，而不是一个 JPA `@Entity`，并且资源库抽象以相同的方式工作：

[source,java,indent=0]
----
	package com.example.myapp.domain;

	import java.util.Optional;

	import org.springframework.data.neo4j.repository.*;

	public interface CityRepository extends Neo4jRepository<City, Long> {

		Optional<City> findOneByNameAndState(String name, String state);

	}
----

`spring-boot-starter-data-neo4j` starter 支持资源库和事务管理。您可以在 `@Configuration` bean 上分别使用 `@EnableNeo4jRepositories` 和 `@EntityScan` 来自定义位置以查找资源库和实体。

TIP: 有关 Spring Data Neo4j 的完整详细信息，包括其对象映射技术，请参阅 {spring-data-neo4j-docs}[参考文档]。.

[[boot-features-solr]]
=== Solr
https://lucene.apache.org/solr/[Apache Solr] 是一个搜素引擎。Spring Boot 为 Solr 5 客户端类库提供了基本的自动配置，并且  https://github.com/spring-projects/spring-data-solr[Spring Data Solr] 为其提供给了顶层抽象。相关的依赖包含在了 `spring-boot-starter-data-solr` starter 中。

[[boot-features-connecting-to-solr]]
==== 连接 Solr
您可以像其他 Spring Bean 一样注入一个自动配置的 `SolrClient` 实例。默认情况下，该实例将尝试通过 `localhost:8983/solr` 连接到服务器，以下示例展示了如何注入一个 Solr bean：

[source,java,indent=0]
----
	@Component
	public class MyBean {

		private SolrClient solr;

		@Autowired
		public MyBean(SolrClient solr) {
			this.solr = solr;
		}

		// ...

	}
----

如果您添加了自己的 `SolrClient` 类型的 `@Bean`，它将替换掉默认配置。



[[boot-features-spring-data-solr-repositories]]
==== Spring Data Solr 资源库
Spring Data 包含了对 Apache Solr 资源库的支持。与之前讨论的 JPA 资源库一样，基本原理是根据方法名称自动构造查询。

事实上，Spring Data JPA 和 Spring Data Solr 共享了相同的通用底层代码，因此您可以使用之前的 JPA 示例作为基础，假设 `City` 现在是一个 `@SolrDocument` 类，而不是一个 JPA `@Entity`，它的工作方式相同。

TIP: 有关 Spring Data Solr 的完整详细内容，请参考其 {spring-data-solr-docs}[参考文档]。



[[boot-features-elasticsearch]]
=== Elasticsearch
https://www.elastic.co/products/elasticsearch[Elasticsearch] 是一个开源、分布式、RESTful 的实时搜索分析引擎。Spring Boot 为 Elasticsearch 提供了基本的自动配置。

Spring Boot 支持以下 HTTP 客户端：

Spring Boot 支持以下 HTTP 客户端：

* 官方 Java Low Level（低级） 和 High Level（高级） REST 客户端
* Spring Data Elasticsearch提供的 `ReactiveElasticsearchClient`

https://github.com/spring-projects/spring-data-elasticsearch[Spring Data Elasticsearch] 依旧使用传输客户端，但是Spring Data Elasticsearch和Elasticsearch本身已弃用了它的支持。 它将在将来的版本中删除。您可以使用 spring-boot-starter-data-elasticsearch starter 引入使用它。

由于Elasticsearch和Spring Data Elasticsearch为REST客户端提供了官方支持，因此  https://github.com/searchbox-io/Jest[Jest]  客户端也已被弃用。

[[boot-features-connecting-to-elasticsearch-rest]]
==== 使用 REST 客户端连接 Elasticsearch
Elasticsearch 提供了 https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/index.html[两个可用于查询集群的 REST 客户端] ：Low Level（低级） 和 High Level（高级）。

如果您的 classpath 上存在 `org.elasticsearch.client:elasticsearch-rest-client` 依赖，则 Spring Boot 将自动配置并注册默认目标为 `localhost:9200` 的 `RestClient` bean。您可以进一步调整 `RestClient` 的配置，如下所示：

[source,properties,indent=0,configprops]
----
	spring.elasticsearch.rest.uris=https://search.example.com:9200
	spring.elasticsearch.rest.read-timeout=10s
	spring.elasticsearch.rest.username=user
	spring.elasticsearch.rest.password=secret
----

您还可以注册实现任意数量的 `RestClientBuilderCustomizer` bean，以进行更高级的自定义。要完全控制注册流程，请定义 RestClient bean。

如果你 classpath 上有 `org.elasticsearch.client:elasticsearch-rest-high-level-client` 依赖，Spring Boot 将自动配置一个 `RestHighLevelClient`，它包装了所有现有的 `RestClient` bean，重用其 HTTP 配置。

[[boot-features-connecting-to-elasticsearch-reactive-rest]]
==== 使用 Reactive REST 客户端连接
{spring-data-elasticsearch}[Spring Data Elasticsearch] 提供了 `ReactiveElasticsearchClient`，用于以响应式查询 `Elasticsearch` 实例。 它基于 `WebFlux的WebClient` 构建，因此 `spring-boot-starter-elasticsearch` 和 `spring-boot-starter-webflux` 依赖。

默认情况下，Spring Boot将自动配置并注册一个针对  `http://localhost:9200` 的 `ReactiveElasticsearchClient` bean。 您可以进一步调整其配置，如以下示例所示：

[source,properties,indent=0,configprops]
----
	spring.data.elasticsearch.client.reactive.endpoints=search.example.com:9200
	spring.data.elasticsearch.client.reactive.use-ssl=true
	spring.data.elasticsearch.client.reactive.socket-timeout=10s
	spring.data.elasticsearch.client.reactive.username=user
	spring.data.elasticsearch.client.reactive.password=secret
----

如果配置属性不够，并且您想完全控制客户端配置，则可以注册自定义 `ClientConfiguration` bean。

[[boot-features-connecting-to-elasticsearch-jest]]
==== 使用 Jest 连接 Elasticsearch

现在，Spring Boot支持官方的 `RestHighLevelClient`，不再支持 `Jest`。

如果您的 classpath 上存在 `Jest`，则可以注入一个默认目标为 `http://localhost:9200`. 的自动配置 `JestClient`。您还可以进一步调整客户端配置：

[source,properties,indent=0,configprops]
----
	spring.elasticsearch.jest.uris=https://search.example.com:9200
	spring.elasticsearch.jest.read-timeout=10000
	spring.elasticsearch.jest.username=user
	spring.elasticsearch.jest.password=secret
----

您还可以注册任何数量实现了 `HttpClientConfigBuilderCustomizer` 的 bean，以进行更加高级的自定义。以下示例调整了其他 HTTP 设置：

[source,java,indent=0]
----
include::{code-examples}/elasticsearch/jest/JestClientCustomizationExample.java[tag=customizer]
----

要完全控制注册流程，请定义一个 `JestClient` bean。

[[boot-features-connecting-to-elasticsearch-spring-data]]
==== 使用 Spring Data 连接 Elasticsearch
要连接 Elasticsearch，必须定义由Spring Boot自动配置或由应用程序手动提供的 `RestHighLevelClient` bean（请参阅前面的部分）。 有了此配置后，可以像其他任何Spring bean一样注入 `ElasticsearchRestTemplate`，如以下示例所示：

[source,java,indent=0]
----
	@Component
	public class MyBean {

		private final ElasticsearchRestTemplate template;

		public MyBean(ElasticsearchRestTemplate template) {
			this.template = template;
		}

		// ...

	}
----

如果存在 `spring-data-elasticsearch` 和使用 `WebClient` 所需的依赖关系（通常是 `spring-boot-starter-webflux`）的情况下，Spring Boot还可以将 <<boot-features-connecting-to-elasticsearch-reactive-rest,ReactiveElasticsearchClient>>  和 `ReactiveElasticsearchTemplate` 自动配置为bean。 它们与其他REST客户端是等效的。

[[boot-features-spring-data-elasticsearch-repositories]]
==== Spring Data Elasticsearch 资源库
Spring Data 包含了对 Elasticsearch 资源库的支持，与之前讨论的 JPA 资源库一样，其原理是根据方法名称自动构造查询。

事实上，Spring Data JPA 与 Spring Data Elasticsearch 共享了相同的通用底层代码，因此您可以使用之前的 JPA 示例作为基础，假设 `City` 此时是一个 Elasticsearch `@Document` 类，而不是一个 JPA `@Entity`，它以相同的方式工作。

TIP: 有关 Spring Data Elasticsearch 的完整详细内容，请参阅其 {spring-data-elasticsearch-docs}[参考文]。 .

Spring Boot使用 `ElasticsearchRestTemplate` 或 `ReactiveElasticsearchTemplate` bean支持经典和响应式式 Elasticsearch 资源库。 给定所需的依赖项，最有可能由Spring Boot自动配置这些bean。

如果您希望使用自己的模板来支持Elasticsearch存储库，则可以添加自己的 `ElasticsearchRestTemplate` 或 `ElasticsearchOperations` @Bean，只要它名为 "elasticsearchTemplate" 即可。 同样适用于 `ReactiveElasticsearchTemplate` 和 `ReactiveElasticsearchOperations`，其bean名称为 "reactiveElasticsearchTemplate"。

您可以选择使用以下属性禁用存储库支持：

[source,properties,indent=0,configprops]
----
    spring.data.elasticsearch.repositories.enabled=false
----


[[boot-features-cassandra]]
=== Cassandra
https://cassandra.apache.org/[Cassandra] 是一个开源的分布式数据库管理系统，旨在处理商用服务器上的大量数据。Spring Boot 为 Cassandra 提供了自动配置，且 https://github.com/spring-projects/spring-data-cassandra[Spring Data Cassandra] 为其提供了顶层抽象。相关依赖包含在 spring-boot-starter-data-cassandra starter 中。

[[boot-features-connecting-to-cassandra]]
==== 连接 Cassandra
您可以像其他 Spring Bean 一样注入一个自动配置的 `CassandraTemplate` 或 Cassandra `Session` 实例。spring.data.cassandra.* 属性可用于自定义连接。通常，您会提供 `keyspace-name` 和 `contact-points` 属性：

[source,properties,indent=0,configprops]
----
	spring.data.cassandra.keyspace-name=mykeyspace
	spring.data.cassandra.contact-points=cassandrahost1,cassandrahost2
----

您还可以注册任意数量实现了 `ClusterBuilderCustomizer` 的 bean，以进行更高级的自定义。

以下代码展示了如何注入一个 Cassandra bean：

[source,java,indent=0]
----
	@Component
	public class MyBean {

		private CassandraTemplate template;

		@Autowired
		public MyBean(CassandraTemplate template) {
			this.template = template;
		}

		// ...

	}
----

如果您添加了自己的类的为 `@CassandraTemplate` 的 `@Bean`，则其将替代默认值。



[[boot-features-spring-data-cassandra-repositories]]
==== Spring Data Cassandra 资源库
Spring Data 包含了基本的 Cassandra 资源库支持。目前，其限制要比之前讨论的 JPA 资源库要多，并且需要在 finder 方法上使用 `@Query` 注解。

TIP: 有关 Spring Data Cassandra 的完整详细内容，请参阅其 https://docs.spring.io/spring-data/cassandra/docs/[参考文档]。

[[boot-features-couchbase]]
=== Couchbase
https://www.couchbase.com/[Couchbase] 是一个开源、分布式多模型的 NoSQL 面向文档数据库，其针对交互式应用程序做了优化。Spring Boot 为 Couchbase 提供了自动配置，
且 https://github.com/spring-projects/spring-data-couchbase[Spring Data Couchbase] 为其提供了顶层抽象。相关的依赖包含在了 spring-boot-starter-data-couchbase starter 中。

[[boot-features-connecting-to-couchbase]]
==== 连接 Couchbase
您可以通过添加 Couchbase SDK 和一些配置来轻松获取 `Bucket` 和 `Cluster`。`spring.couchbase.*` 属性可用于自定义连接。通常您会配置 bootstrap host、bucket name 和 password：

[source,properties,indent=0,configprops]
----
	spring.couchbase.bootstrap-hosts=my-host-1,192.168.1.123
	spring.couchbase.bucket.name=my-bucket
	spring.couchbase.bucket.password=secret
----

TIP: 您至少需要提供 bootstrap host，这种情况下，bucket name 为 `default` 且 password 为空字符串。或者，您可以定义自己的 `org.springframework.data.couchbase.config.CouchbaseConfigurer` `@Bean`  来控制整个配置。

[source,properties,indent=0,configprops]
----
	spring.couchbase.env.timeouts.connect=3000
	spring.couchbase.env.ssl.key-store=/location/of/keystore.jks
	spring.couchbase.env.ssl.key-store-password=secret
----

查看 `spring.couchbase.env.*` 获取更多详细内容。



[[boot-features-spring-data-couchbase-repositories]]
==== Spring Data Couchbase 资源库
Spring Data 包含了 Couchbase 资源库支持。有关 Spring Data Couchbase 的完整详细信息，请参阅其 https://docs.spring.io/spring-data/couchbase/docs/current/reference/html/[参考文档]。

您可以像使用其他 Spring Bean 一样注入自动配置的 `CouchbaseTemplate` 实例，前提是有一个默认的 `CouchbaseConfigurer`（当您启用 Couchbase 支持时会发生这种情况，如之前所述）。

以下示例展示了如何注入一个 Couchbase bean：

[source,java,indent=0]
----
	@Component
	public class MyBean {

		private final CouchbaseTemplate template;

		@Autowired
		public MyBean(CouchbaseTemplate template) {
			this.template = template;
		}

		// ...

	}
----

您可以在自己的配置中定义以下几个 bean，以覆盖自动配置提供的配置：

* 一个名为 `couchbaseTemplate` 的 `CouchbaseTemplate` `@Bean`
* 一个名为 `couchbaseIndexManager` 的 `IndexManager` `@Bean`
* 一个名为 `couchbaseCustomConversions` 的 `CustomConversions` `@Bean`

为了避免在自己的配置中硬编码这些名称，您可以重用 Spring Data Couchbase 提供的 `BeanNames`，例如，您可以自定义转换器，如下：

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	public class SomeConfiguration {

		@Bean(BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)
		public CustomConversions myCustomConversions() {
			return new CustomConversions(...);
		}

		// ...

	}
----

TIP: 如果您想要安全绕开 Spring Data Couchbase 的自动配置，请提供自己的 `org.springframework.data.couchbase.config.AbstractCouchbaseDataConfiguration` 实现。

[[boot-features-ldap]]
=== LDAP
https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol[LDAP] （Lightweight Directory Access Protocol，轻量级目录访问协议）是一个开放、厂商中立的行业标准应用协议，其通过 IP 网络访问和维护分布式目录信息服务。
Spring Boot 为兼容 LDAP 服务器提供了自动配置，以及支持从 https://www.ldap.com/unboundid-ldap-sdk-for-java[UnboundID] 内嵌内存式 LDAP 服务器。

https://github.com/spring-projects/spring-data-ldap[Spring Data LDAP] 提供了 LDAP 抽象。相关依赖包含在了 `spring-boot-starter-data-ldap` starter 中。

[[boot-features-ldap-connecting]]
==== 连接 LDAP 服务器
要连接 LDAP 服务器，请确保您已经声明了 `spring-boot-starter-data-ldap` starter 或者 `spring-ldap-core` 依赖，然后在 `application.properties` 声明服务器的 URL：

[source,properties,indent=0,configprops]
----
	spring.ldap.urls=ldap://myserver:1235
	spring.ldap.username=admin
	spring.ldap.password=secret
----

如果需要自定义连接设置，您可以使用 `spring.ldap.base` 和 `spring.ldap.base-environment` 属性。

`LdapContextSource` 将根据这些设置自动配置。如果您需要自定义它，例如使用一个 `PooledContextSource`，则仍然可以注入自动配置的 `LdapContextSource`。确保将自定义的 `ContextSource` 标记为 `@Primary`，以便自动配置的 `LdapTemplate` 能使用它。

[[boot-features-ldap-spring-data-repositories]]
==== Spring Data LDAP 资源库
Spring Data 包含了 LDAP 资源库支持。有关 Spring Data LDAP 的完整详细信息，请参阅其 https://docs.spring.io/spring-data/ldap/docs/1.0.x/reference/html/[参考文档]。

您还可以像其他 Spring Bean 一样注入一个自动配置的 `LdapTemplate` 实例：

[source,java,indent=0]
----
	@Component
	public class MyBean {

		private final LdapTemplate template;

		@Autowired
		public MyBean(LdapTemplate template) {
			this.template = template;
		}

		// ...

	}
----

[[boot-features-ldap-embedded]]
==== 内嵌内存式 LDAP 服务器
为了测试目的，Spring Boot 支持从 https://www.ldap.com/unboundid-ldap-sdk-for-java[UnboundID] 自动配置一个内存式 LDAP 服务器。要配置服务器，请添加 `com.unboundid:unboundid-ldapsdk` 依赖并声明一个 `spring.ldap.embedded.base-dn` 属性：

[source,properties,indent=0,configprops]
----
	spring.ldap.embedded.base-dn=dc=spring,dc=io
----

[NOTE]
====
可以定义多个 base-dn 值，但是，由于名称包含逗号，存在歧义，因此必须使用正确的符号来定义它们。

在 yaml 文件中，您可以使用 yaml 列表表示法：

[source,yaml,indent=0]
----
	spring.ldap.embedded.base-dn:
	  - dc=spring,dc=io
	  - dc=pivotal,dc=io
----

在属性文件中，必须使用索引方式：

[source,properties,indent=0,configprops]
----
	spring.ldap.embedded.base-dn[0]=dc=spring,dc=io
	spring.ldap.embedded.base-dn[1]=dc=pivotal,dc=io
----

====

默认情况下，服务器将在一个随机端口上启动，并触发常规的 LDAP 支持（不需要指定 `spring.ldap.urls` 属性）。

如果您的 classpath 上存在一个 `schema.ldif` 文件，其将用于初始化服务器。如果您想从不同的资源中加载脚本，可以使用 `spring.ldap.embedded.ldif` 属性。

默认情况下，将使用一个标准模式（schema）来校验 `LDIF` 文件。您可以使用 `spring.ldap.embedded.validation.enabled` 属性来关闭所有校验。如果您有自定义的属性，则可以使用 `spring.ldap.embedded.validation.schema` 来定义自定义属性类型或者对象类。

[[boot-features-influxdb]]
=== InfluxDB
https://www.influxdata.com/[InfluxDB]  是一个开源时列数据库，其针对运营监控、应用程序指标、物联网传感器数据和实时分析等领域中的时间序列数据在速度、高可用存储和检索方面进行了优化。

[[boot-features-connecting-to-influxdb]]
==== 连接 InfluxDB
Spring Boot 自动配置 `InfluxDB` 实例，前提是 `Influxdb-java` 客户端在 classpath 上并且设置了数据库的 URL，如下所示：

[source,properties,indent=0,configprops]
----
	spring.influx.url=https://172.0.0.1:8086
----

如果与 InfluxDB 的连接需要用户和密码，则可以相应地设置 `spring.influx.user` 和 `spring.influx.password` 属性。

`InfluxDB` 依赖于 OkHttp。如果你需要调整 InfluxDB 在底层使用的 http 客户端，则可以注册一个 `InfluxDbOkHttpClientBuilderProvider` bean。

[[boot-features-caching]]
== 缓存
Spring Framework 支持以透明的方式向应用程序添加缓存。从本质上讲，将缓存应用于方法上，根据缓存数据减少方法的执行次数。缓存逻辑是透明的，不会对调用者造成任何干扰。通过 `@EnableCaching` 注解启用缓存支持，Spring Boot 就会自动配置缓存设置。

NOTE: 有关更多详细信息，请查看 Spring Framework 参考文档的 {spring-framework-docs}integration.html#cache[相关部分] 。

简而言之，为服务添加缓存的操作就像在其方法中添加注解一样简单，如下所示：

[source,java,indent=0]
----
	import org.springframework.cache.annotation.Cacheable;
	import org.springframework.stereotype.Component;

	@Component
	public class MathService {

		@Cacheable("piDecimals")
		public int computePiDecimal(int i) {
			// ...
		}

	}
----

此示例展示了如何在代价可能高昂的操作上使用缓存。在调用 `computePiDecimal` 之前，缓存支持会在 `piDecimals` 缓存中查找与 `i` 参数匹配的项。如果找到，则缓存中的内容会立即返回给调用者，并不会调用该方法。否则，将调用该方法，并在返回值之前更新缓存。

CAUTION: 您还可以使用标准 JSR-107（JCache）注解（例如 `@CacheResult`）。但是，我们强烈建议您不要将 Spring Cache 和 JCache 注解混合使用。

如果您不添加任何指定的缓存库，Spring Boot 会自动配置一个使用并发 map 的 <<boot-features-caching-provider-simple,simple provider>> 。当需要缓存时（例如前面示例中的 `piDecimals`），该 simple provider 会为您创建缓存。不推荐将 simple provider 用于生产环境，但它非常适合入门并帮助您了解这些功能。
当您决定使用缓存提供者时，请务必阅读其文档以了解如何配置应用程序。几乎所有提供者都要求您显式配置应用程序中使用的每个缓存。有些提供了自定义 `spring.cache.cache-names` 属性以定义默认缓存。

TIP: 还可以透明地从缓存中 {spring-framework-docs}integration.html#cache-annotations-put[更新]或 {spring-framework-docs}integration.html#cache-annotations-evict[删除] 数据。

[[boot-features-caching-provider]]
=== 支持的缓存提供者
缓存抽象不提供存储实现，其依赖于 `org.springframework.cache.Cache` 和 `org.springframework.cache.CacheManager` 接口实现的抽象。

如果您未定义 `CacheManager` 类型的 bean 或名为 `cacheResolver` 的 `CacheResolver`（请参阅 {spring-framework-api}/cache/annotation/CachingConfigurer.html[`CachingConfigurer`]），则 Spring Boot 会尝试检测以下提供者（按序号顺序）：

. <<boot-features-caching-provider-generic,Generic>>
. <<boot-features-caching-provider-jcache,JCache (JSR-107)>> (EhCache 3, Hazelcast, Infinispan, and others)
. <<boot-features-caching-provider-ehcache2,EhCache 2.x>>
. <<boot-features-caching-provider-hazelcast,Hazelcast>>
. <<boot-features-caching-provider-infinispan,Infinispan>>
. <<boot-features-caching-provider-couchbase,Couchbase>>
. <<boot-features-caching-provider-redis,Redis>>
. <<boot-features-caching-provider-caffeine,Caffeine>>
. <<boot-features-caching-provider-simple,Simple>>

TIP: 也可以通过设置 `spring.cache.type` 属性来强制指定缓存提供者。如果您需要在某些环境（比如测试）中完全禁用缓存，请使用此属性。

TIP: 使用 `spring-boot-starter-cache` starter 快速添加基本的缓存依赖。starter 引入了 `spring-context-support`。如果手动添加依赖，则必须包含 spring-context-support 才能使用 JCache、EhCache 2.x 或 Guava 支持。

如果通过 Spring Boot 自动配置 `CacheManager`，则可以通过暴露一个实现了 `CacheManagerCustomizer` 接口的 bean，在完全初始化之前进一步调整其配置。以下示例设置了一个 flag，表示应将 `null` 值传递给底层 map：

[source,java,indent=0]
----
	@Bean
	public CacheManagerCustomizer<ConcurrentMapCacheManager> cacheManagerCustomizer() {
		return new CacheManagerCustomizer<ConcurrentMapCacheManager>() {
			@Override
			public void customize(ConcurrentMapCacheManager cacheManager) {
				cacheManager.setAllowNullValues(false);
			}
		};
	}
----

NOTE: 在前面示例中，需要一个自动配置的 `ConcurrentMapCacheManager`。如果不是这种情况（您提供了自己的配置或自动配置了不同的缓存提供者），则根本不会调用 customizer。您可以拥有多个 customizer，也可以使用 `@Order` 或 `Ordered` 来排序它们。

[[boot-features-caching-provider-generic]]
==== Generic
如果上下文定义了至少一个 `org.springframework.cache.Cache` bean，则使用 Generic 缓存。将创建一个包装所有该类型 bean 的 `CacheManager`。

[[boot-features-caching-provider-jcache]]
==== JCache (JSR-107)
https://jcp.org/en/jsr/detail?id=107[JCache] 通过 classpath 上的 `javax.cache.spi.CachingProvider`（即 classpath 上存在符合 JSR-107 的缓存库）来引导，`jCacheCacheManager` 由 `spring-boot-starter-cache` starter 提供。您可以使用各种兼容库，Spring Boot 为 Ehcache 3、Hazelcast 和 Infinispan 提供依赖管理。您还可以添加任何其他兼容库。

可能存在多个提供者，在这种情况下必须明确指定提供者。即使 JSR-107 标准没有强制规定一个定义配置文件位置的标准化方法，Spring Boot 也会尽其所能设置一个包含实现细节的缓存，如下所示：

[source,properties,indent=0,configprops]
----
    # Only necessary if more than one provider is present
	spring.cache.jcache.provider=com.acme.MyCachingProvider
	spring.cache.jcache.config=classpath:acme.xml
----

NOTE: 当缓存库同时提供原生实现和 JSR-107 支持时，Spring Boot 更倾向 JSR-107 支持，因此当您切换到不同的 JSR-107 实现时，还可以使用相同的功能。

TIP: Spring Boot 对 <<boot-features-hazelcast,Hazelcast 的支持一般>>。如果有一个 `HazelcastInstance` 可用，它也会自动为 `CacheManager` 复用，除非指定了 `spring.cache.jcache.config` 属性。

有两种方法可以自定义底层的 `javax.cache.cacheManager`：

* 可以通过设置 `spring.cache.cache-names` 属性在启动时创建缓存。如果定义了自定义 `javax.cache.configuration.Configuration` bean，则会使用它来自定义。
* 使用 `CacheManager` 的引用调用 `org.springframework.boot.autoconfigure.cache.JCacheManagerCustomizer` bean 以进行完全自定义。

TIP: 如果定义了一个标准的 ``j``avax.cache.CacheManager` bean，它将自动包装进一个抽象所需的 `org.springframework.cache.CacheManager` 实现中，而不会应用自定义配置。

[[boot-features-caching-provider-ehcache2]]
==== EhCache 2.x
如果可以在 classpath 的根目录中找到名为 ehcache.xml 的文件，则使用 https://www.ehcache.org/[EhCache] 2.x。如果找到 EhCache 2.x，则使用 `spring-boot-starter-cache` starter 提供的 `EhCacheCacheManager` 来启动缓存管理器。还可以提供其他配置文件，如下所示：

[source,properties,indent=0,configprops]
----
	spring.cache.ehcache.config=classpath:config/another-config.xml
----



[[boot-features-caching-provider-hazelcast]]
==== Hazelcast
Spring Boot 对 <<boot-features-hazelcast,Hazelcast 的支持一般>>。如果自动配置了一个 `HazelcastInstance`，它将自动包装进 `CacheManager` 中。

[[boot-features-caching-provider-infinispan]]
==== Infinispan
https://infinispan.org/[Infinispan] 没有默认的配置文件位置，因此必须明确指定。否则将使用默认配置引导。

[source,properties,indent=0,configprops]
----
	spring.cache.infinispan.config=infinispan.xml
----

可以通过设置 `spring.cache.cache-names` 属性在启动时创建缓存。如果定义了自定义 `ConfigurationBuilder` bean，则它将用于自定义缓存。

NOTE: Infinispan 在 Spring Boot 中的支持仅限于内嵌模式，非常简单。如果你想要更多选项，你应该使用官方的 Infinispan Spring Boot starter。有关更多详细信息，请参阅 https://github.com/infinispan/infinispan-spring-boot[Infinispan 文档] 。

[[boot-features-caching-provider-couchbase]]
==== Couchbase
如果 https://www.couchbase.com/[Couchbase] Java 客户端和 `couchbase-spring-cache` 实现可用且已经<<boot-features-couchbase,配置>>了 `Couchbase`，则应用程序会自动配置一个 `CouchbaseCacheManager`。也可以通过设置 `spring.cache.cache-names` 属性在启动时创建其他缓存。这些缓存在自动配置的 `Bucket` 上操作。
您还可以使用 customizer 在其他 `Bucket` 上创建缓存。假设您需要在 main `Bucket` 上有两个缓存（`cache1` 和 `cache2`），并且 "`another`" `Bucket` 有一个过期时间为 2 秒的缓存（`cache3`）。您可以通过配置创建这两个缓存，如下所示：

[source,properties,indent=0,configprops]
----
	spring.cache.cache-names=cache1,cache2
----

然后，您可以定义一个 `@Configuration` 类来配置其他 `Bucket` 和 `cache3` 缓存，如下所示：

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	public class CouchbaseCacheConfiguration {

		private final Cluster cluster;

		public CouchbaseCacheConfiguration(Cluster cluster) {
			this.cluster = cluster;
		}

		@Bean
		public Bucket anotherBucket() {
			return this.cluster.openBucket("another", "secret");
		}

		@Bean
		public CacheManagerCustomizer<CouchbaseCacheManager> cacheManagerCustomizer() {
			return c -> {
				c.prepareCache("cache3", CacheBuilder.newInstance(anotherBucket())
						.withExpiration(2));
			};
		}

	}
----

此示例配置复用了通过自动配置创建的 `Cluster`。

[[boot-features-caching-provider-redis]]
==== Redis
如果 https://redis.io/[Redis] 可用并已经配置，则应用程序会自动配置一个 `RedisCacheManager`。通过设置 `spring.cache.cache-names` 属性可以在启动时创建其他缓存，并且可以使用 `spring.cache.redis.*` 属性配置缓存默认值。例如，以下配置创建 `cache1` 和 `cache2` 缓存，他们的有效时间为 10 分钟：

[source,properties,indent=0,configprops]
----
	spring.cache.cache-names=cache1,cache2
	spring.cache.redis.time-to-live=600000
----

NOTE: 默认情况下，会添加一个 key 前缀，这样做是因为如果两个单独的缓存使用了相同的键，Redis 不支持重叠 key，而缓存也不能返回无效值。如果您创建自己的 `RedisCacheManager`，我们强烈建议您启用此设置。

TIP: 您可以通过添加自己的 `RedisCacheConfiguration` `@Bean` 来完全控制配置。如果您想自定义序列化策略，这种方式可能很有用。

[[boot-features-caching-provider-caffeine]]
==== Caffeine
https://github.com/ben-manes/caffeine[Caffeine]  是一个使用了 Java 8 重写 Guava 缓存，用于取代 Guava 支持的缓存库。如果 Caffeine 存在，则应用程序会自动配置一个 `CaffeineCacheManager`（由 `spring-boot-starter-cache` starter 提供）。
可以通过设置 `spring.cache.cache-names` 属性在启动时创建缓存，并且可以通过以下方式之一（按序号顺序）自定义缓存：

. 一个由 `spring.cache.caffeine.spec` 定义的缓存规范
. 一个已定义的 `com.github.benmanes.caffeine.cache.CaffeineSpec` bean
. 一个已定义的 `com.github.benmanes.caffeine.cache.Caffeine` bean

例如，以下配置创建 `cache1` 和 `cache2` 缓存，最大大小为 500，有效时间 为 10 分钟：

[source,properties,indent=0,configprops]
----
	spring.cache.cache-names=cache1,cache2
	spring.cache.caffeine.spec=maximumSize=500,expireAfterAccess=600s
----

如果定义了 `com.github.benmanes.caffeine.cache.CacheLoader` bean，它将自动与 `CaffeineCacheManager` 关联。由于 `CacheLoader` 将与缓存管理器管理的所有缓存相关联，因此必须将其定义为 `CacheLoader<Object, Object>`。自动配置会忽略所有其他泛型类型。

[[boot-features-caching-provider-simple]]
==== Simple
如果找不到其他提供者，则配置使用一个 `ConcurrentHashMap` 作为缓存存储的简单实现。如果您的应用程序中没有缓存库，则该项为默认值。默认情况下，会根据需要创建缓存，但您可以通过设置 `cache-names` 属性来限制可用缓存的列表。例如，如果只需要 `cache1` 和 `cache2` 缓存，请按如下设置 `cache-names` 属性：

[source,properties,indent=0,configprops]
----
	spring.cache.cache-names=cache1,cache2
----

如果这样做了，并且您的应用程序使用了未列出的缓存，则运行时在它需要缓存时会触发失败，但在启动时则不会。这类似于真实缓存提供者在使用未声明的缓存时触发的行为方式。

[[boot-features-caching-provider-none]]
==== None
当配置中存在 `@EnableCaching` 时，也需要合适的缓存配置。如果需要在某些环境中完全禁用缓存，请将缓存类型强制设置为 `none` 以使用 no-op 实现，如下所示：

[source,properties,indent=0,configprops]
----
	spring.cache.type=none
----

[[boot-features-messaging]]
== 消息传递
Spring Framework 为消息传递系统集成提供了广泛的支持，从使用 `JmsTemplate` 简化 JMS API 的使用到异步接收消息的完整基础设施。Spring AMQP 为高级消息队列协议（Advanced Message Queuing Protocol，AMQP）提供了类似的功能集合。Spring Boot 还为 `RabbitTemplate` 和 RabbitMQ 提供自动配置选项。Spring WebSocket 本身包含了对 STOMP 消息传递的支持，Spring Boot 通过 starter 和少量自动配置即可支持它。Spring Boot 同样支持 Apache Kafka。

[[boot-features-jms]]
=== JMS
`javax.jms.ConnectionFactory` 接口提供了一种创建 `javax.jms.Connection` 的标准方法，可与 JMS broker（代理）进行交互。虽然 Spring 需要一个 `ConnectionFactory` 来与 JMS 一同工作，但是您通常不需要自己直接使用它，而是可以依赖更高级别的消息传递抽象。（有关详细信息，请参阅 {spring-framework-docs}integration.html#jms[Spring Framework 参考文档的相关部分]。）Spring Boot 还会自动配置发送和接收消息所需的基础设施。

[[boot-features-activemq]]
==== ActiveMQ 支持
当 https://activemq.apache.org/[ActiveMQ]  在 classpath 上可用时，Spring Boot 也可以配置一个 `ConnectionFactory`。如果 broker 存在，则会自动启动并配置一个内嵌式 broker（前提是未通过配置指定 broder URL）。

NOTE: 如果使用 `spring-boot-starter-activemq`，则提供了连接到 ActiveMQ 实例必须依赖或内嵌一个 ActiveMQ 实例，以及与 JMS 集成的 Spring 基础设施。

ActiveMQ 配置由 `spring.activemq.*` 中的外部配置属性控制。例如，您可以在 `application.properties` 中声明以下部分：

[source,properties,indent=0,configprops]
----
	spring.activemq.broker-url=tcp://192.168.1.210:9876
	spring.activemq.user=admin
	spring.activemq.password=secret
----

默认情况下，`CachingConnectionFactory` 将原生的 `ConnectionFactory` 使用可由 `spring.jms.*` 中的外部配置属性控制的合理设置包装起来：

[source,properties,indent=0,configprops]
----
	spring.jms.cache.session-cache-size=5
----

如果您更愿意使用原生池，则可以通过向 `org.messaginghub:pooled-jms` 添加一个依赖并相应地配置 `JmsPoolConnectionFactory` 来实现，如下所示：

[source,properties,indent=0,configprops]
----
	spring.activemq.pool.enabled=true
	spring.activemq.pool.max-connections=50
----

TIP: 有关更多支持的选项，请参阅 {spring-boot-autoconfigure-module-code}/jms/activemq/ActiveMQProperties.java[`ActiveMQProperties`]。您还可以注册多个实现了 `ActiveMQConnectionFactoryCustomizer` 的的 bean，以进行更高级的自定义。

默认情况下，ActiveMQ 会创建一个 destination（目标）（如果它尚不存在），以便根据提供的名称解析 destination。

[[boot-features-artemis]]
==== Artemis 支持
Spring Boot 可以在检测到 https://activemq.apache.org/artemis/[Artemis] 在 classpath 上可用时自动配置一个 `ConnectionFactory`。如果存在 broker，则会自动启动并配置一个内嵌 broker（除非已明确设置 mode 属性）。
支持的 mode 为 `embedded`（明确表示需要一个内嵌 broker，如果 broker 在 classpath 上不可用则发生错误）和 `native`（使用 `netty` 传输协议连接到 broker）。配置后者后，Spring Boot 会使用默认设置配置一个 `ConnectionFactory`，该 `ConnectionFactory` 连接到在本地计算机上运行的 broker。

NOTE: 如果使用了 `spring-boot-starter-artemis`，则会提供连接到现有的 Artemis 实例的必须依赖，以及与 JMS 集成的Spring 基础设施。将 `org.apache.activemq:artemis-jms-server` 添加到您的应用程序可让您使用内嵌模式。

Artemis 配置由 `spring.artemis.*` 中的外部配置属性控制。例如，您可以在 `application.properties` 中声明以下部分：

[source,properties,indent=0,configprops]
----
	spring.artemis.mode=native
	spring.artemis.host=192.168.1.210
	spring.artemis.port=9876
	spring.artemis.user=admin
	spring.artemis.password=secret
----

内嵌 broker 时，您可以选择是否要启用持久化并列出应该可用的 destination。可以将这些指定为以逗号分隔的列表，以使用默认选项创建它们，也可以定义类型为 `org.apache.activemq.artemis.jms.server.config.JMSQueueConfiguration` 或 `org.apache.activemq.artemis.jms.server.config.TopicConfiguration` 的 bean，分别用于高级队列和 topic（主题）配置。

默认情况下，`CachingConnectionFactory` 将原生的 `ConnectionFactory` 使用可由 `spring.jms.*` 中的外部配置属性控制的合理设置包装起来：

[source,properties,indent=0,configprops]
----
	spring.jms.cache.session-cache-size=5
----

如果您更愿意使用原生池，则可以通过向 `org.messaginghub:pooled-jms` 添加一个依赖并相应地配置 `JmsPoolConnectionFactory` 来实现，如下所示：

[source,properties,indent=0,configprops]
----
	spring.artemis.pool.enabled=true
	spring.artemis.pool.max-connections=50
----

有关更多支持的选项，请参阅  {spring-boot-autoconfigure-module-code}/jms/artemis/ArtemisProperties.java[`ArtemisProperties`] 。

不涉及 JNDI 查找，使用 Artemis 配置中的 `name` 属性或通过配置提供的名称来解析目标（destination）名称。

[[boot-features-jms-jndi]]
==== 使用 JNDI ConnectionFactory
如果您在应用程序服务器中运行应用程序，Spring Boot 会尝试使用 JNDI 找到 JMS `ConnectionFactory`。默认情况下，将检查 `java:/JmsXA` 和 `java:/XAConnectionFactory` 这两个位置。如果需要指定其他位置，可以使用 `spring.jms.jndi-name` 属性，如下所示：

[source,properties,indent=0,configprops]
----
	spring.jms.jndi-name=java:/MyConnectionFactory
----



[[boot-features-using-jms-sending]]
==== 发送消息
Spring 的 `JmsTemplate` 是自动配置的，你可以直接将它注入到你自己的 bean 中，如下所示：

[source,java,indent=0]
----
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.jms.core.JmsTemplate;
	import org.springframework.stereotype.Component;

	@Component
	public class MyBean {

		private final JmsTemplate jmsTemplate;

		@Autowired
		public MyBean(JmsTemplate jmsTemplate) {
			this.jmsTemplate = jmsTemplate;
		}

		// ...

	}
----

NOTE: {spring-framework-api}/jms/core/JmsMessagingTemplate.html[`JmsMessagingTemplate`] 可以以类似的方式注入。如果定义了 `DestinationResolver` 或 `MessageConverter` bean，它将自动关联到自动配置的 `JmsTemplate`。

[[boot-features-using-jms-receiving]]
==== 接收消息
当存在 JMS 基础设施时，可以使用 `@JmsListener` 对任何 bean 进行注解以创建监听器（listener）端点。如果未定义 `JmsListenerContainerFactory`，则会自动配置一个默认的（factory）。如果定义了 `DestinationResolver` 或 `MessageConverter` bean，它将自动关联到默认的 factory。

默认情况下，默认 factory 是具有事务特性的。如果您在存在有 `JtaTransactionManager` 的基础设施中运行，则默认情况下它与监听器容器相关联。如果不是，则 `sessionTransacted` flag 将为启用（enabled）。在后一种情况下，您可以通过在监听器方法（或其委托）上添加 `@Transactional`，将本地数据存储事务与传入消息的处理相关联。这确保了在本地事务完成后传入消息能被告知。这还包括了发送已在同一 JMS 会话上执行的响应消息。

以下组件在 `someQueue` destination 上创建一个监听器端点：

[source,java,indent=0]
----
	@Component
	public class MyBean {

		@JmsListener(destination = "someQueue")
		public void processMessage(String content) {
			// ...
		}

	}
----

TIP: 有关更多详细信息，请参阅  {spring-framework-api}/jms/annotation/EnableJms.html[the Javadoc of `@EnableJms`] 的 Javadoc。

如果需要创建更多 `JmsListenerContainerFactory` 实例或覆盖缺省值，Spring Boot 会提供一个 `DefaultJmsListenerContainerFactoryConfigurer`，您可以使用它来初始化 `DefaultJmsListenerContainerFactory`，其设置与自动配置的 factory 设置相同。

例如，以下示例暴露了另一个使用特定 `MessageConverter` 的 factory：

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	static class JmsConfiguration {

		@Bean
		public DefaultJmsListenerContainerFactory myFactory(
				DefaultJmsListenerContainerFactoryConfigurer configurer) {
			DefaultJmsListenerContainerFactory factory =
					new DefaultJmsListenerContainerFactory();
			configurer.configure(factory, connectionFactory());
			factory.setMessageConverter(myMessageConverter());
			return factory;
		}

	}
----

然后，您可以在任何 `@JmsListener` 注解的方法中使用该 factory，如下所示：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Component
	public class MyBean {

		@JmsListener(destination = "someQueue", **containerFactory="myFactory"**)
		public void processMessage(String content) {
			// ...
		}

	}
----



[[boot-features-amqp]]
=== AMQP
高级消息队列协议（Advanced Message Queuing Protocol，AMQP）是一个平台无关，面向消息中间件的连接级协议。Spring AMQP 项目将核心 Spring 概念应用于基于 AMQP 消息传递解决方案的开发。Spring Boot 为通过 RabbitMQ 使用 AMQP 提供了一些快捷方法，包括 `spring-boot-starter-amqp` starter。

[[boot-features-rabbitmq]]
==== RabbitMQ 支持
https://www.rabbitmq.com/[RabbitMQ] 是一个基于 AMQP 协议的轻量级、可靠、可扩展且可移植的消息代理。Spring 使用 RabbitMQ 通过 AMQP 协议进行通信。

RabbitMQ 配置由 `spring.rabbitmq.*` 中的外部配置属性控制。例如，您可以在 `application.properties` 中声明以下部分：

[source,properties,indent=0,configprops]
----
	spring.rabbitmq.host=localhost
	spring.rabbitmq.port=5672
	spring.rabbitmq.username=admin
	spring.rabbitmq.password=secret
----

另外，您可以配置相同 `addresses` 属性的连接：

[source,properties,indent=0]
----
	spring.rabbitmq.addresses=amqp://admin:secret@localhost
----

如果上下文中存在 `ConnectionNameStrategy` bean，它将自动用于命名由自动配置的 `ConnectionFactory` 所创建的连接。有关更多支持的选项，请参阅 {spring-boot-autoconfigure-module-code}/amqp/RabbitProperties.java[`RabbitProperties`] 。

TIP: 有关详细信息，请参阅理解  https://spring.io/blog/2010/06/14/understanding-amqp-the-protocol-used-by-rabbitmq/[AMQP、RabbitMQ 使用的协议] f。

[[boot-features-using-amqp-sending]]
==== 发送消息
Spring 的 `AmqpTemplate` 和 `AmqpAdmin` 是自动配置的，您可以将它们直接注入自己的 bean 中，如下所示：

[source,java,indent=0]
----
	import org.springframework.amqp.core.AmqpAdmin;
	import org.springframework.amqp.core.AmqpTemplate;
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.stereotype.Component;

	@Component
	public class MyBean {

		private final AmqpAdmin amqpAdmin;
		private final AmqpTemplate amqpTemplate;

		@Autowired
		public MyBean(AmqpAdmin amqpAdmin, AmqpTemplate amqpTemplate) {
			this.amqpAdmin = amqpAdmin;
			this.amqpTemplate = amqpTemplate;
		}

		// ...

	}
----

NOTE: {spring-amqp-api}/rabbit/core/RabbitMessagingTemplate.html[`RabbitMessagingTemplate`] 可以以类似的方式注入。如果定义了 `MessageConverter` bean，它将自动关联到自动配置的 `AmqpTemplate`。

如有必要，所有定义为 bean 的 `org.springframework.amqp.core.Queue` 都会自动在 RabbitMQ 实例上声明相应的队列。

要重试操作，可以在 `AmqpTemplate` 上启用重试（例如，在 broker 连接丢失的情况下）：

[source,properties,indent=0,configprops]
----
	spring.rabbitmq.template.retry.enabled=true
	spring.rabbitmq.template.retry.initial-interval=2s
----

默认情况下禁用重试。您还可以通过声明 `RabbitRetryTemplateCustomizer` bean 以编程方式自定义 `RetryTemplate`。

[[boot-features-using-amqp-receiving]]
==== 接收消息
当 Rabbit 基础设施存在时，可以使用 `@RabbitListener` 注解任何 bean 以创建监听器端点。如果未定义 `RabbitListenerContainerFactory`，则会自动配置一个默认的 `SimpleRabbitListenerContainerFactory`，您可以使用 `spring.rabbitmq.listener.type` 属性切换到一个直接容器。如果定义了 `MessageConverter` 或 `MessageRecoverer` bean，它将自动与默认 factory 关联。

以下示例组件在 `someQueue` 队列上创建一个侦听监听器端点：

[source,java,indent=0]
----
	@Component
	public class MyBean {

		@RabbitListener(queues = "someQueue")
		public void processMessage(String content) {
			// ...
		}

	}
----

TIP: 有关更多详细信息，请参阅 {spring-amqp-api}/rabbit/annotation/EnableRabbit.html[the Javadoc of `@EnableRabbit`] 的 Javadoc。

如果需要创建更多 `RabbitListenerContainerFactory` 实例或覆盖缺省值，Spring Boot 提供了一个 `SimpleRabbitListenerContainerFactoryConfigurer` 和一个 `DirectRabbitListenerContainerFactoryConfigurer`，您可以使用它来初始化 `SimpleRabbitListenerContainerFactory` 和 `DirectRabbitListenerContainerFactory`，其设置与使用自动配置的 factory 相同。

TIP: 这两个 bean 与您选择的容器类型没有关系，它们通过自动配置暴露。

例如，以下配置类暴露了另一个使用特定 `MessageConverter` 的 factory：

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	static class RabbitConfiguration {

		@Bean
		public SimpleRabbitListenerContainerFactory myFactory(
				SimpleRabbitListenerContainerFactoryConfigurer configurer) {
			SimpleRabbitListenerContainerFactory factory =
					new SimpleRabbitListenerContainerFactory();
			configurer.configure(factory, connectionFactory);
			factory.setMessageConverter(myMessageConverter());
			return factory;
		}

	}
----

然后，您可以在任何 `@RabbitListener` 注解的方法中使用该 factory，如下所示：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Component
	public class MyBean {

		@RabbitListener(queues = "someQueue", **containerFactory="myFactory"**)
		public void processMessage(String content) {
			// ...
		}

	}
----

您可以启用重试机制来处理监听器的异常抛出情况。默认情况下使用 `RejectAndDontRequeueRecoverer`，但您可以定义自己的 `MessageRecoverer`。如果 broker 配置了重试机制，当重试次数耗尽时，则拒绝消息并将其丢弃或路由到死信（dead-letter）exchange 中。
默认情况下重试机制为禁用。您还可以通过声明 `RabbitRetryTemplateCustomizer` bean 以编程方式自定义 `RetryTemplate`。

IMPORTANT: 默认情况下，如果禁用重试并且监听器异常抛出，则会无限期地重试传递。您可以通过两种方式修改此行为：将 `defaultRequeueRejected` 属性设置为 `false`，以便尝试零重传或抛出 `AmqpRejectAndDontRequeueException` 以指示拒绝该消息。后者是启用重试并且达到最大传递尝试次数时使用的机制。

[[boot-features-kafka]]
=== Apache Kafka 支持
通过提供 `spring-kafka` 项目的自动配置来支持 https://kafka.apache.org/[Apache Kafka]

Kafka 配置由 `spring.kafka.*` 中的外部配置属性控制。例如，您可以在 `application.properties` 中声明以下部分：

[source,properties,indent=0,configprops]
----
	spring.kafka.bootstrap-servers=localhost:9092
	spring.kafka.consumer.group-id=myGroup
----

TIP: 要在启动时创建主题（topic），请添加 `NewTopic` 类型的 Bean。如果主题已存在，则忽略该 bean。

有关更多支持的选项，请参阅 {spring-boot-autoconfigure-module-code}/kafka/KafkaProperties.java[`KafkaProperties`] 。

[[boot-features-kafka-sending-a-message]]
==== 发送消息
Spring 的 `KafkaTemplate` 是自动配置的，您可以直接在自己的 bean 中装配它，如下所示：

[source,java,indent=0]
----
@Component
public class MyBean {

	private final KafkaTemplate kafkaTemplate;

	@Autowired
	public MyBean(KafkaTemplate kafkaTemplate) {
		this.kafkaTemplate = kafkaTemplate;
	}

	// ...

}
----

NOTE: 如果定义了属性 `spring.kafka.producer.transaction-id-prefix`，则会自动配置一个 `KafkaTransactionManager`。此外，如果定义了 `RecordMessageConverter` bean，它将自动关联到自动配置的 `KafkaTemplate`。

[[boot-features-kafka-receiving-a-message]]
==== 接收消息
当存在 Apache Kafka 基础设施时，可以使用 `@KafkaListener` 注解任何 bean 以创监听器端点。如果未定义 `KafkaListenerContainerFactory`，则会使用 `spring.kafka.listener.*` 中定义的 key 自动配置一个默认的 factory。

以下组件在 `someTopic` topic 上创建一个监听器端点：

[source,java,indent=0]
----
	@Component
	public class MyBean {

		@KafkaListener(topics = "someTopic")
		public void processMessage(String content) {
			// ...
		}

	}
----

如果定义了 `KafkaTransactionManager` bean，它将自动关联到容器 factory。同样，如果定义了 `RecordMessageConverter`、`ErrorHandler` 或 `AfterRollbackProcessor` bean，它将自动关联到默认的 factory。

根据监听器类型，将 `RecordMessageConverter` 或 `BatchMessageConverter` bean与默认工厂关联。 如果对于批处理监听器仅存在一个 `RecordMessageConverter` bean，则将其包装在 `BatchMessageConverter` 中。

TIP: 自定义 `ChainedKafkaTransactionManager` 必须标记为 `@Primary`，因为它通常引用自动配置的 `KafkaTransactionManager` bean。

[[boot-features-kafka-streams]]
==== Kafka Streams
Spring for Apache Kafka 提供了一个工厂 bean 来创建 `StreamsBuilder` 对象并管理其 stream（流）的生命周期。只要 `kafka-streams` 在 classpath 上并且通过 `@EnableKafkaStreams` 注解启用了 Kafka Stream，Spring Boot 就会自动配置所需的 `KafkaStreamsConfiguration` bean。

启用 Kafka Stream 意味着必须设置应用程序 id 和引导服务器（bootstrap server）。可以使用 `spring.kafka.streams.application-id` 配置前者，如果未设置则默认为 `spring.application.name`。后者可以全局设置或专门为 stream 而重写。

使用专用 properties 可以设置多个其他属性，可以使用 `spring.kafka.streams.properties` 命名空间设置其他任意 Kafka 属性。有关更多信息，另请参见 <<boot-features-kafka-extra-props,Kafka 属性>> 。

要使用 factory bean，只需将 `StreamsBuilder` 装配到您的 `@Bean` 中，如下所示：

[source,java,indent=0]
----
include::{code-examples}/kafka/KafkaStreamsBeanExample.java[tag=configuration]
----

默认情况下，由其创建的 `StreamBuilder` 对象管理的流会自动启动。您可以使用 `spring.kafka.streams.auto-startup` 属性自定义此行为。

[[boot-features-kafka-extra-props]]
==== 其他 Kafka 属性
自动配置支持的属性可在<<appendix-application-properties.adoc#common-application-properties,常见应用程序属性>>常见应用程序属性中找到。请注意，在大多数情况下，这些属性（连接符或驼峰命名）直接映射到 Apache Kafka 点连形式属性。有关详细信息，请参阅 Apache Kafka 文档。

这些属性中的前几个适用于所有组件（生产者【producer】、使用者【consumer】、管理者【admin】和流【stream】），但如果您希望使用不同的值，则可以在组件级别指定。Apache Kafka 重要性（优先级）属性设定为 HIGH、MEDIUM 或 LOW。Spring Boot 自动配置支持所有 HIGH 重要性属性，一些选择的 MEDIUM 和 LOW 属性，以及所有没有默认值的属性。

只有 Kafka 支持的属性的子集可以直接通过 `KafkaProperties` 类获得。如果您希望使用不受支持的其他属性配置生产者或消费者，请使用以下属性：

[source,properties,indent=0,configprops]
----
	spring.kafka.properties.prop.one=first
	spring.kafka.admin.properties.prop.two=second
	spring.kafka.consumer.properties.prop.three=third
	spring.kafka.producer.properties.prop.four=fourth
	spring.kafka.streams.properties.prop.five=fifth
----

这将常见的 `prop.one` Kafka 属性设置为 `first`（适用于生产者、消费者和管理者），`prop.two` 管理者属性为 `second`，`prop.three` 消费者属性为 `third`，`prop.four` 生产者属性为 `fourth`，`prop.five` 流属性为 `fifth`。

您还可以按如下方式配置 Spring Kafka `JsonDeserializer`：

[source,properties,indent=0,configprops]
----
	spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer
	spring.kafka.consumer.properties.spring.json.value.default.type=com.example.Invoice
	spring.kafka.consumer.properties.spring.json.trusted.packages=com.example,org.acme
----

同样，您可以禁用 `JsonSerializer` 在 header 中发送类型信息的默认行为：

[source,properties,indent=0,configprops]
----
	spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer
	spring.kafka.producer.properties.spring.json.add.type.headers=false
----

IMPORTANT: 以这种方式设置的属性将覆盖 Spring Boot 明确支持的任何配置项。

[[boot-features-embedded-kafka]]
==== 使用嵌入式 Kafka 进行测试
Spring 为 Apache Kafka 提供了一种使用嵌入式Apache Kafka代理测试项目的便捷方法。 要使用此功能，请在 `spring-kafka-test` 模块中使用 `@EmbeddedKafka` 注解测试类。 有关更多信息，请参阅Spring for Apache Kafka https://docs.spring.io/spring-kafka/docs/current/reference/html/#embedded-kafka-annotation[参考手册]。

要使Spring Boot自动配置与上述嵌入式Apache Kafka代理一起使用，您需要将嵌入式代理地址（由 `EmbeddedKafkaBroker` 填充）的系统属性重新映射到Apache Kafka的Spring Boot配置属性中。 有几种方法可以做到这一点：

* 提供一个系统属性，以将嵌入式代理地址映射到测试类中的 `spring.kafka.bootstrap-servers` 中：

[source,java,indent=0]
----
static {
    System.setProperty(EmbeddedKafkaBroker.BROKER_LIST_PROPERTY, "spring.kafka.bootstrap-servers");
}
----

* 在 `@EmbeddedKafka` 注解上配置属性名称：

[source,java,indent=0]
----
@EmbeddedKafka(topics = "someTopic",
        bootstrapServersProperty = "spring.kafka.bootstrap-servers")
----

* 在配置属性中使用占位符：

[source,properties,indent=0,configprops]
----
spring.kafka.bootstrap-servers=${spring.embedded.kafka.brokers}
----

[[boot-features-resttemplate]]
== 使用 `RestTemplate` 调用 REST 服务
如果您的应用程序需要调用远程 REST 服务，这可以使用 Spring Framework 的 RestTemplate 类。由于 {spring-framework-api}/web/client/RestTemplate.html[`RestTemplate`]  实例在使用之前通常需要进行自定义，因此 Spring Boot 不提供任何自动配置的 `RestTemplate` bean。但是，
它会自动配置 `RestTemplateBuilder`，可在需要时创建 `RestTemplate` 实例。自动配置的 `RestTemplateBuilder` 确保将合适的 `HttpMessageConverters` 应用于 `RestTemplate` 实例。

以下代码展示了一个典型示例：

[source,java,indent=0]
----
	@Service
	public class MyService {

		private final RestTemplate restTemplate;

		public MyService(RestTemplateBuilder restTemplateBuilder) {
			this.restTemplate = restTemplateBuilder.build();
		}

		public Details someRestCall(String name) {
			return this.restTemplate.getForObject("/{name}/details", Details.class, name);
		}

	}
----

TIP: `RestTemplateBuilder` 包含许多可用于快速配置 `RestTemplate` 的方法。例如，要添加 BASIC auth 支持，可以使用 `builder.basicAuthentication("user", "password").build()`。

[[boot-features-resttemplate-customization]]
=== 自定义 RestTemplate
`RestTemplate` 自定义有三种主要方法，具体取决于您希望自定义的程度。

要想自定义的范围尽可能地窄，请注入自动配置的 `RestTemplateBuilder`，然后根据需要调用其方法。每个方法调用都返回一个新的 `RestTemplateBuilder` 实例，因此自定义只会影响当前构建器。

要在应用程序范围内添加自定义配置，请使用 `RestTemplateCustomizer` bean。所有这些 bean 都会自动注册到自动配置的 `RestTemplateBuilder`，并应用于使用它构建的所有模板。

以下示例展示了一个 customizer，它为除 `192.168.0.5` 之外的所有主机配置代理：

[source,java,indent=0]
----
include::{code-examples}/web/client/RestTemplateProxyCustomizationExample.java[tag=customizer]
----

最后，最极端（也很少使用）的选择是创建自己的 `RestTemplateBuilder` bean。这样做会关闭 `RestTemplateBuilder` 的自动配置，并阻止使用任何 `RestTemplateCustomizer` bean。

[[boot-features-webclient]]
== 使用 `WebClient` 调用 REST 服务
如果在 classpath 上存在 Spring WebFlux，则还可以选择使用 `WebClient` 来调用远程 REST 服务。与 `RestTemplate` 相比，该客户端更具函数式风格并且完全响应式。您可以在 {spring-framework-docs}web-reactive.html#webflux-client[ Spring Framework 文档的相关部分]中了解有关 `WebClient` 的更多信息。

Spring Boot 为您创建并预配置了一个 `WebClient.Builder`。强烈建议将其注入您的组件中并使用它来创建 `WebClient` 实例。Spring Boot 配置该构建器以共享 HTTP 资源，以与服务器相同的方式反射编解码器设置（请参阅 <<boot-features-webflux-httpcodecs,WebFlux HTTP 编解码器自动配置>>）等。

以下代码是一个典型示例：

[source,java,indent=0]
----
	@Service
	public class MyService {

		private final WebClient webClient;

		public MyService(WebClient.Builder webClientBuilder) {
			this.webClient = webClientBuilder.baseUrl("https://example.org").build();
		}

		public Mono<Details> someRestCall(String name) {
			return this.webClient.get().uri("/{name}/details", name)
							.retrieve().bodyToMono(Details.class);
		}

	}
----

[[boot-features-webclient-runtime]]
=== WebClient 运行时
Spring Boot 将自动检测用于驱动 `WebClient` 的 `ClientHttpConnector`，具体取决于应用程序 classpath 上可用的类库。目前支持 Reactor Netty 和 Jetty RS 客户端。

默认情况下 `spring-boot-starter-webflux` starter 依赖于 `io.projectreactor.netty:reactor-netty`，它包含了服务器和客户端的实现。如果您选择将 Jetty 用作响应式服务器，则应添加 Jetty Reactive HTTP 客户端库依赖项 `org.eclipse.jetty:jetty-reactive-httpclient`。服务器和客户端使用相同的技术具有一定优势，因为它会自动在客户端和服务器之间共享 HTTP 资源。

开发人员可以通过提供自定义的 `ReactorResourceFactory` 或 `JettyResourceFactory` bean 来覆盖 Jetty 和 Reactor Netty 的资源配置 —— 这将同时应用于客户端和服务器。

如果您只希望覆盖客户端选项，则可以定义自己的 `ClientHttpConnector` bean 并完全控制客户端配置。

您可以在 Spring Framework 参考文档中了解有关 {spring-framework-docs}web-reactive.html#webflux-client-builder[`WebClient` 配置选项的更多信息]。

[[boot-features-webclient-customization]]
=== 自定义 WebClient
`WebClient` 自定义有三种主要方法，具体取决于您希望自定义的程度。

要想自定义的范围尽可能地窄，请注入自动配置的 `WebClient.Builder`，然后根据需要调用其方法。`WebClient.Builder` 实例是有状态的：构建器上的任何更改都会影响到之后所有使用它创建的客户端。如果要使用相同的构建器创建多个客户端，可以考虑使用 `WebClient.Builder other = builder.clone()`; 的方式克隆构建器。

要在应用程序范围内对所有 `WebClient.Builder` 实例添加自定义，可以声明 `WebClientCustomizer` bean 并在注入点局部更改 `WebClient.Builder`。

最后，您可以回退到原始 API 并使用 WebClient.create()。在这种情况下，不会应用自动配置或 WebClientCustomizer。

[[boot-features-validation]]
== 验证
只要 classpath 上存在 JSR-303 实现（例如 Hibernate 验证器），就会自动启用 Bean Validation 1.1 支持的方法验证功能。这允许 bean 方法在其参数和/或返回值上使用 `javax.validation` 约束进行注解。带有此类注解方法的目标类需要在类级别上使用 `@Validated` 进行注解，以便搜索其内联约束注解的方法。

例如，以下服务触发第一个参数的验证，确保其大小在 8 到 10 之间：

[source,java,indent=0]
----
	@Service
	@Validated
	public class MyBean {

		public Archive findByCodeAndAuthor(@Size(min = 8, max = 10) String code,
				Author author) {
			...
		}

	}
----



[[boot-features-email]]
== 发送邮件
Spring Framework 提供了一个使用 `JavaMailSender` 接口发送电子邮件的简单抽象，Spring Boot 为其提供了自动配置以及一个 starter 模块。

TIP: 有关如何使用 JavaMailSender 的详细说明，请参阅 {spring-framework-docs}integration.html#mail[参考文档]。

如果 `spring.mail.host` 和相关库（由 `spring-boot-starter-mail` 定义）可用，则创建默认的 `JavaMailSender`（如果不存在）。可以通过 `spring.mail` 命名空间中的配置项进一步自定义发件人。有关更多详细信息，请参阅 {spring-boot-autoconfigure-module-code}/mail/MailProperties.java[`MailProperties`]。

特别是，某些默认超时时间的值是无限的，您可能想更改它以避免线程被无响应的邮件服务器阻塞，如下示例所示：

[source,properties,indent=0,configprops]
----
	spring.mail.properties.mail.smtp.connectiontimeout=5000
	spring.mail.properties.mail.smtp.timeout=3000
	spring.mail.properties.mail.smtp.writetimeout=5000
----

也可以使用 JNDI 中的现有 `Session` 配置一个 `JavaMailSender`：

[source,properties,indent=0,configprops]
----
	spring.mail.jndi-name=mail/Session
----

设置 `jndi-name` 时，它优先于所有其他与 Session 相关的设置。

[[boot-features-jta]]
== JTA 分布式事务
Spring Boot 通过使用  https://www.atomikos.com/[Atomikos] 或  https://github.com/bitronix/btm[Bitronix] 嵌入式事务管理器来支持跨多个 XA 资源的分布式 JTA 事务。部署在某些 Java EE 应用服务器（Application Server）上也支持 JTA 事务。

当检测到 JTA 环境时，Spring 的 `JtaTransactionManager` 将用于管理事务。自动配置的 JMS、DataSource 和 JPA bean 已升级为支持 XA 事务。您可以使用标准的 Spring 方式（例如 `@Transactional`）来使用分布式事务。如果您处于 JTA 环境中并且仍想使用本地事务，则可以将 `spring.jta.enabled` 属性设置为 `false` 以禁用 JTA 自动配置。

[[boot-features-jta-atomikos]]
=== 使用 Atomikos 事务管理器
https://www.atomikos.com/[Atomikos] 是一个流行的开源事务管理器，可以嵌入到 Spring Boot 应用程序中。您可以使用 `spring-boot-starter-jta-atomikos` starter 来获取相应的 Atomikos 库。Spring Boot 自动配置 Atomikos 并确保将合适的依赖设置应用于 Spring bean，以确保启动和关闭顺序正确。

默认情况下，Atomikos 事务日志将写入应用程序主目录（应用程序 jar 文件所在的目录）中的 `transaction-logs` 目录。您可以通过在 `application.properties` 文件中设置 `spring.jta.log-dir` 属性来自定义此目录的位置。也可用 `spring.jta.atomikos.properties` 开头的属性来自定义 Atomikos `UserTransactionServiceImp`。有关完整的详细信息，请参阅 {spring-boot-module-api}/jta/atomikos/AtomikosProperties.html[`AtomikosProperties` Javadoc]。

NOTE: 为确保多个事务管理器可以安全地协调相同的资源管理器，必须为每个 Atomikos 实例配置唯一 ID。默认情况下，此 ID 是运行 Atomikos 的计算机的 IP 地址。在生产环境中要确保唯一性，应为应用程序的每个实例配置 `spring.jta.transaction-manager-id` 属性，并使用不同的值。

[[boot-features-jta-bitronix]]
=== 使用 Bitronix 事务管理器
https://github.com/bitronix/btm[Bitronix] 是一个流行的开源 JTA 事务管理器实现。您可以使用 `spring-boot-starter-jta-bitronix` starter 为您的项目添加合适的 Bitronix 依赖。与 Atomikos 一样，Spring Boot 会自动配置 Bitronix 并对 bean 进行后处理（post-processes），以确保启动和关闭顺序正确。

默认情况下，Bitronix 事务日志文件（`part1.btm` 和 `part2.btm`）将写入应用程序主目录中的 `transaction-logs` 目录。您可以通过设置 `spring.jta.log-dir` 属性来自定义此目录的位置。以 `spring.jta.bitronix.properties` 开头的属性绑定到了 `bitronix.tm.Configuration` bean，允许完全自定义。有关详细信息，请参阅 https://github.com/bitronix/btm/wiki/Transaction-manager-configuration[Bitronix 文档]。

NOTE: 为确保多个事务管理器能够安全地协调相同的资源管理器，必须为每个 Bitronix 实例配置唯一的 ID。默认情况下，此 ID 是运行 Bitronix 的计算机的 IP 地址。生产环境要确保唯一性，应为应用程序的每个实例配置 `spring.jta.transaction-manager-id` 属性，并使用不同的值。

[[boot-features-jta-javaee]]
=== 使用 Java EE 管理的事务管理器
如果将 Spring Boot 应用程序打包为 `war` 或 `ear` 文件并将其部署到 Java EE 应用程序服务器，则可以使用应用程序服务器的内置事务管理器。Spring Boot 尝试通过查找常见的 JNDI 位置（`java:comp/UserTransaction`、`java:comp/TransactionManager` 等）来自动配置事务管理器。如果使用应用程序服务器提供的事务服务，
通常还需要确保所有资源都由服务器管理并通过 JNDI 暴露。Spring Boot 尝试通过在 JNDI 路径（`java:/JmsXA` 或 `java:/JmsXA`）中查找 `ConnectionFactory` 来自动配置 JMS，并且可以使用 <<boot-features-connecting-to-a-jndi-datasource, `spring.datasource.jndi-name` 属性>> 属性来配置 `DataSource`。

[[boot-features-jta-mixed-jms]]
=== 混合使用 XA 与非 XA JMS 连接
使用 JTA 时，主 JMS `ConnectionFactory` bean 可识别 XA 并参与分布式事务。在某些情况下，您可能希望使用非 XA `ConnectionFactory` 处理某些 JMS 消息。例如，您的 JMS 处理逻辑可能需要比 XA 超时时间更长的时间。

如果要使用非 XA `ConnectionFactory`，可以注入 `nonXaJmsConnectionFactory` bean 而不是 `@Primary` `jmsConnectionFactory` bean。为了保持一致性，提供的 `jmsConnectionFactory` bean 还需要使用 `xaJmsConnectionFactory` 别名。

以下示例展示了如何注入 `ConnectionFactory` 实例：

[source,java,indent=0,subs="verbatim,quotes,attributes"]
----
	// Inject the primary (XA aware) ConnectionFactory
	@Autowired
	private ConnectionFactory defaultConnectionFactory;

	// Inject the XA aware ConnectionFactory (uses the alias and injects the same as above)
	@Autowired
	@Qualifier("xaJmsConnectionFactory")
	private ConnectionFactory xaConnectionFactory;

	// Inject the non-XA aware ConnectionFactory
	@Autowired
	@Qualifier("nonXaJmsConnectionFactory")
	private ConnectionFactory nonXaConnectionFactory;
----

[[boot-features-jta-supporting-alternative-embedded]]
=== 支持嵌入式事务管理器
{spring-boot-module-code}/jms/XAConnectionFactoryWrapper.java[`XAConnectionFactoryWrapper`] 和  {spring-boot-module-code}/jdbc/XADataSourceWrapper.java[`XADataSourceWrapper`]  接口可用于支持其他嵌入式事务管理器。接口负责包装 `XAConnectionFactory` 和 `XADataSource` bean，并将它们公开为普通的 `ConnectionFactory` 和 `DataSource` bean，它们透明地加入分布式事务。`DataSource` 和 JMS 自动配置使用 JTA 变体，前提是您需要有一个 `JtaTransactionManager` bean 和在 `ApplicationContext` 中注册有的相应 XA 包装器（wrapper） bean。

{spring-boot-module-code}/jta/bitronix/BitronixXAConnectionFactoryWrapper.java[BitronixXAConnectionFactoryWrapper] 和 {spring-boot-module-code}/jta/bitronix/BitronixXADataSourceWrapper.java[BitronixXADataSourceWrapper] 为如何编写 XA 包装器提供了很好示例。

[[boot-features-hazelcast]]
== Hazelcast
如果  https://hazelcast.com/[Hazelcast] 在 classpath 上并有合适的配置，则 Spring Boot 会自动配置一个可以在应用程序中注入的 `HazelcastInstance`。

如果定义了 `com.hazelcast.config.Config` bean，则 Spring Boot 会使用它。如果您的配置定义了实例名称，Spring Boot 会尝试查找现有的实例，而不是创建新实例。

您还可以指定通过配置使用的 Hazelcast 配置文件，如以下示例所示：

[source,properties,indent=0,configprops]
----
	spring.hazelcast.config=classpath:config/my-hazelcast.xml
----
否则，Spring Boot 会尝试从默认位置查找 Hazelcast 配置：工作目录或 classpath 根目录中的 `hazelcast.xml`，或相同位置中的 `.yaml` 文件。 我们还检查是否设置了 `hazelcast.config` 系统属性。 有关更多详细信息，请参见 https://docs.hazelcast.org/docs/latest/manual/html-single/[Hazelcast documentation]。
如果 classpath 中存在 `hazelcast-client`，则 Spring Boot 会首先尝试通过检查以下配置项来创建客户端：

* 存在 `com.hazelcast.client.config.ClientConfig` bean。
* `spring.hazelcast.config` 属性定义的配置文件。
* 存在 `hazelcast.client.config` 系统属性。
* 工作目录中或 classpath 根目录下的 `hazelcast-client.xml`。
* 工作目录中或 classpath 根目录下的 `hazelcast-client.yaml`。

NOTE: Spring Boot 还为 <<boot-features-caching-provider-hazelcast,Hazelcast 提供了缓存支持>>。如果启用了缓存，`HazelcastInstance` 将自动包装在 `CacheManager` 实现中。

[[boot-features-quartz]]
== Quartz 调度器

Spring Boot 提供了几种使用  https://www.quartz-scheduler.org/[Quartz 调度器]的便捷方式，它们来自 `spring-boot-starter-quartz` starter。如果 Quartz 可用，则 Spring Boot 将自动配置 `Scheduler`（通过 `SchedulerFactoryBean` 抽象）。

自动选取以下类型的 Bean 并将其与 `Scheduler` 关联起来：

* `JobDetail`: 定义一个特定的 job。可以使用 `JobBuilder` API 构建 `JobDetail` 实例。
* `Calendar`.
* `Trigger`: 定义何时触发 job。

默认使用内存存储方式的 `JobStore`。 但如果应用程序中有 `DataSource` bean，并且配置了 `spring.quartz.job-store-type` 属性，则可以配置基于 JDBC 的存储，如下所示：

[source,properties,indent=0,configprops]
----
	spring.quartz.job-store-type=jdbc
----

使用 JDBC 存储时，可以在启动时初始化 schema（表结构），如下所示：

[source,properties,indent=0,configprops]
----
	spring.quartz.jdbc.initialize-schema=always
----

WARNING: 默认将使用 Quartz 库提供的标准脚本检测并初始化数据库。这些脚本会删除现有表，在每次重启时删除所有触发器。可以通过设置 `spring.quartz.jdbc.schema` 属性来提供自定义脚本。

要让 Quartz 使用除应用程序主 `DataSource` 之外的 `DataSource`，请声明一个 `DataSource` bean，使用 `@QuartzDataSource` 注解其 `@Bean` 方法。这样做可确保 `SchedulerFactoryBean` 和 schema 初始化都使用 Quartz 指定的 `DataSource`。

默认情况下，配置创建的 job 不会覆盖已从持久 job 存储读取的已注册的 job。要启用覆盖现有的 job 定义，请设置 `spring.quartz.overwrite-existing-jobs` 属性。

Quartz 调取器配置可以使用 `spring.quartz` 属性和 `SchedulerFactoryBeanCustomizer` bean 进行自定义，它们允许以编程方式的 `SchedulerFactoryBean` 自定义。可以使用 `spring.quartz.properties.*` 自定义高级 Quartz 配置属性。

NOTE: 需要强调的是，`Executor` bean 与调度程序没有关联，因为 Quartz 提供了通过 `spring.quartz.properties` 配置调度器的方法。如果需要自定义执行器，请考虑实现 `SchedulerFactoryBeanCustomizer`。

job 可以定义 setter 以注入数据映射属性。也可以以类似的方式注入常规的 bean，如下所示：

[source,java,indent=0]
----
	public class SampleJob extends QuartzJobBean {

		private MyService myService;

		private String name;

		// Inject "MyService" bean
		public void setMyService(MyService myService) { ... }

		// Inject the "name" job data property
		public void setName(String name) { ... }

		@Override
		protected void executeInternal(JobExecutionContext context)
				throws JobExecutionException {
			...
		}

	}
----

[[boot-features-task-execution-scheduling]]
== 任务执行与调度
在上下文中没有 `Executor` bean 的情况下，Spring Boot 会自动配置一个有合理默认值的 `ThreadPoolTaskExecutor`，它可以自动与异步任务执行（`@EnableAsync`）和 Spring MVC 异步请求处理相关联。

[TIP]
====
如果您在上下文中定义了自定义 `Executor`，则常规任务执行（即 `@EnableAsync`）将透明地使用它，但不会配置 Spring MVC 支持，因为它需要 `AsyncTaskExecutor` 实现（名为 `applicationTaskExecutor`）。根据您的目标安排，您可以将 `Executor` 更改为 `ThreadPoolTaskExecutor`，或者定义 `Executor` 的 `ThreadPoolTaskExecutor` 和 `AsyncConfigurer` 来包装自定义的 `Executor`。

您可以使用自动配置的 `TaskExecutorBuilder` 来轻松创建实例，以复制默认的自动配置。
====

线程池使用 8 个核心线程，可根据负载情况增加和减少。可以使用 `spring.task.execution` 命名空间对这些默认设置进行微调，如下所示：

[source,properties,indent=0,configprops]
----
	spring.task.execution.pool.max-size=16
	spring.task.execution.pool.queue-capacity=100
	spring.task.execution.pool.keep-alive=10s
----

这会将线程池更改为使用有界队列，在队列满（100 个任务）时，线程池将增加到最多 16 个线程。当线程在闲置10 秒（而不是默认的 60 秒）时回收线程，池的收缩更为明显。

如果需要与调度任务执行（`@EnableScheduling`）相关联，可以自动配置一个 `ThreadPoolTaskScheduler`。默认情况下，线程池使用一个线程，可以使用 `spring.task.scheduling` 命名空间对这些设置进行微调。

如果需要创建自定义执行器或调度器，则在上下文中可以使用 `TaskExecutorBuilder` bean 和 `TaskSchedulerBuilder` bean。

[[boot-features-integration]]
== Spring Integration
Spring Boot 为 {spring-integration}[Spring Integration] 提供了一些便捷的使用方式，它们包含在 `spring-boot-starter-integration` starter 中。Spring Integration 为消息传递以及其他传输（如 HTTP、TCP 等）提供了抽象。
如果 classpath 上存在 Spring Integration，则 Spring Boot 会通过 `@EnableIntegration` 注解对其进行初始化。

Spring Boot 还配置了一些由其他 Spring Integration 模块触发的功能。如果 `spring-integration-jmx` 也在 classpath 上，则消息处理统计信息将通过 JMX 发布。如果 `spring-integration-jdbc` 可用，则可以在启动时创建默认数据库模式，如下所示：

[source,properties,indent=0,configprops]
----
	spring.integration.jdbc.initialize-schema=always
----

有关更多详细信息，请参阅 {spring-boot-autoconfigure-module-code}/integration/IntegrationAutoConfiguration.java[`IntegrationAutoConfiguration`]  和  {spring-boot-autoconfigure-module-code}/integration/IntegrationProperties.java[`IntegrationProperties`]  类。

默认情况下，如果存在 Micrometer `meterRegistry` bean，则 Micrometer 将管理 Spring Integration 的指标。如果您希望使用旧版 Spring Integration 度量，请将 `DefaultMetricsFactory` bean 添加到应用程序上下文中。

[[boot-features-session]]
== Spring Session
Spring Boot 为各种数据存储提供 {spring-session}[Spring Session]  自动配置。在构建 Servlet Web 应用程序时，可以自动配置以下存储：

* JDBC
* Redis
* Hazelcast
* MongoDB

构建响应式 Web 应用程序时，可以自动配置以下存储：

* Redis
* MongoDB

如果 classpath 上存在单个 Spring Session 模块，则 Spring Boot 会自动使用该存储实现。如果您有多个实现，则必须选择要用于存储会话的 {spring-boot-autoconfigure-module-code}/session/StoreType.java[`StoreType`]。 例如，要使用 JDBC 作为后端存储，您可以按如下方式配置应用程序：

[source,properties,indent=0,configprops]
----
    spring.session.store-type=jdbc
----

TIP: 可以将 `store-type` 设置为 `none` 来禁用 Spring Session。

每个 store 都有自己的额外设置。例如，可以为 JDBC 存储定制表的名称，如下所示：

[source,properties,indent=0,configprops]
----
    spring.session.jdbc.table-name=SESSIONS
----

可以使用 `spring.session.timeout` 属性来设置会话的超时时间。如果未设置该属性，则自动配置将使用 `server.servlet.session.timeout` 的值。

[[boot-features-jmx]]
== 通过 JMX 监控和管理
Java Management Extensions（JMX，Java 管理扩展）提供了一种监视和管理应用程序的标准机制。默认情况下，Spring Boot 会创建一个 ID 为 `mbeanServer` 的 `MBeanServer` bean，并暴露使用 Spring JMX 注解（`@ManagedResource`、`@ManagedAttribute` 或 `@ManagedOperation`）的 bean。

有关更多详细信息，请参阅 {spring-boot-autoconfigure-module-code}/jmx/JmxAutoConfiguration.java[`JmxAutoConfiguration`] 类。

[[boot-features-testing]]
== 测试

Spring Boot提供了许多工具类和注解，可以在测试应用程序时提供帮助。 主要由两个模块提供：`spring-boot-test` 包含核心项，`spring-boot-test-autoconfigure` 支持测试的自动配置。

大多数开发人员都使用 `spring-boot-starter-test` "`Starter`"，它会导入Spring Boot 测试模块以及 JUnit Jupiter，AssertJ，Hamcrest和许多其他有用的库。

[TIP]
====
启动程序还带来了老式引擎，因此您可以运行JUnit 4和JUnit 5测试。 如果已将测试迁移到JUnit 5，则应排除对JUnit 4的支持，如以下示例所示：

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-test</artifactId>
		<scope>test</scope>
		<exclusions>
			<exclusion>
				<groupId>org.junit.vintage</groupId>
				<artifactId>junit-vintage-engine</artifactId>
			</exclusion>
		</exclusions>
	</dependency>
----
====



[[boot-features-test-scope-dependencies]]
=== 依赖范围测试
`spring-boot-starter-test` "`Starter`" (在 `test` `scope`) 包含以下的库：:

* https://junit.org/junit5[JUnit 5] (包括用于与JUnit 4向后兼容的老式引擎): 用于进行Java应用程序单元测试的事实上的标准。
* {spring-framework-docs}testing.html#integration-testing[Spring 测试] & Spring Boot 测试: 对Spring Boot应用程序的实用程序和集成测试支持。
* https://joel-costigliola.github.io/assertj/[AssertJ]: 流式的断言库。
* https://github.com/hamcrest/JavaHamcrest[Hamcrest]: 匹配对象库（也称为约束或谓词）。
* https://mockito.github.io[Mockito]: 一个Java模拟框架。
* https://github.com/skyscreamer/JSONassert[JSONassert]: JSON的断言库。
* https://github.com/jayway/JsonPath[JsonPath]: JSON的XPath。

通常，我们发现这些通用库在编写测试时很有用。 如果这些库不满足您的需求，则可以添加自己的其他测试依赖项。

[[boot-features-testing-spring-applications]]
=== 测试 Spring 应用程序
依赖注入的主要优点之一是，它应该使您的代码更易于进行单元测试。 您可以使用 `new` 运算符实例化对象，甚至无需使用 Spring。 您还可以使用模拟对象而不是实际的依赖项。

通常，您需要超越单元测试并开始集成测试（使用Spring `ApplicationContext`）。 能够进行集成测试而无需部署应用程序或连接到其他基础结构是很有用的。

Spring框架包括用于此类集成测试的专用测试模块。 您可以直接向 `org.springframework：spring-test` 声明依赖项，也可以使用 `spring-boot-starter-test` "`Starter`" 将其传递。

如果您以前没有使用过 `spring-test` 模块，则应先阅读 {spring-framework-docs}testing.html#testing[Spring Framework参考文档的相关部分] 。

[[boot-features-testing-spring-boot-applications]]
=== 测试 Spring Boot 应用程序
Spring Boot应用程序是Spring `ApplicationContext`，因此除了对普通Spring上下文进行常规测试以外，无需执行任何其他特殊操作即可对其进行测试。

NOTE: 默认情况下，仅当您使用 `SpringApplication` 创建Spring Boot的外部属性，日志记录和其他功能时，才将它们安装在上下文中。

Spring Boot提供了 `@SpringBootTest` 注解，当您需要Spring Boot功能时，可以将其用作标准 `spring-test` `@ContextConfiguration` 注解的替代方法。 <<boot-features-testing-spring-boot-applications-detecting-config,注解通过创建 `SpringApplication` 在测试中使用的 `ApplicationContext` 来起作用>>。
除了 `@SpringBootTest` 之外，还提供了许多其他注解来测试应用程序的<<boot-features-testing-spring-boot-applications-testing-autoconfigured-tests,特定的部分>>。


TIP: 如果您使用的是JUnit 4，请不要忘记也将 `@RunWith(SpringRunner.class)` 添加到测试中，否则注释将被忽略。 如果您使用的是JUnit 5，则无需将等效的 `@ExtendWith(SpringExtension.class)`  添加为 `@SpringBootTest`，而其他 `@…Test` 注释已经在其中进行了注释。

默认情况下，`@SpringBootTest` 将不会启动服务器。 您可以使用 `@SpringBootTest` 的 `webEnvironment` 属性来进一步完善测试的运行方式：

* `MOCK`(默认) : 加载Web ApplicationContext 并提供模拟Web环境。 使用此注释时，不会启动嵌入式服务器。
如果您的类路径上没有Web环境，则此模式将透明地退回到创建常规的非Web `ApplicationContext`。 它可以与  <<boot-features-testing-spring-boot-applications-testing-with-mock-environment, `@AutoConfigureMockMvc` 或 `@AutoConfigureWebTestClient`>> 结合使用，以对Web应用程序进行基于模拟的测试。
* `RANDOM_PORT`: 加载 `WebServerApplicationContext` 并提供真实的Web环境。 在随机的端口启动并监听嵌入式服务器。
* `DEFINED_PORT`: 加载 `WebServerApplicationContext` 并提供真实的Web环境。 在定义的端口(来自 `application.properties`) 或 `8080` 端口启动并监听嵌入式服务器
* `NONE`: 使用 `SpringApplication` 加载 `ApplicationContext`，但不提供任何Web环境（模拟或其他方式）。

NOTE: 如果您的测试是 `@Transactional`，则默认情况下它将在每个测试方法的末尾回滚事务。 但是，由于将这种安排与 `RANDOM_PORT` 或 `DEFINED_PORT` 一起使用隐式提供了一个真实的Servlet环境，因此HTTP客户端和服务器在单独的线程中运行，因此在单独的事务中运行。 在这种情况下，服务器上启动的任何事务都不会回滚。

NOTE: 如果您的应用程序将不同的端口用于管理服务器，则 `@SpringBootTest` 的 `webEnvironment=WebEnvironment.RANDOM_PORT` 也将在单独的随机端口上启动管理服务器。

[[boot-features-testing-spring-boot-applications-detecting-web-app-type]]
==== 检测 Web 应用程序类型
如果Spring MVC可用，则配置基于常规MVC的应用程序上下文。 如果您只有Spring WebFlux，我们将检测到该情况并配置基于WebFlux的应用程序上下文。

如果两者都存在，则Spring MVC优先。 如果要在这种情况下测试反应式Web应用程序，则必须设置 `spring.main.web-application-type` 属性：

[source,java,indent=0]
----
	@SpringBootTest(properties = "spring.main.web-application-type=reactive")
	class MyWebFluxTests { ... }
----



[[boot-features-testing-spring-boot-applications-detecting-config]]
==== 检测测试配置
如果您熟悉Spring Test Framework，则可能习惯于使用 `@ContextConfiguration(classes=...)` 以指定要加载哪个Spring `@Configuration`。 另外，您可能经常在测试中使用嵌套的 `@Configuration` 类。

在测试Spring Boot应用程序时，通常不需要这样做。 只要您没有明确定义，Spring Boot的 `@*Test` 注释就会自动搜索您的主要配置。

搜索算法从包含测试的程序包开始工作，直到找到带有 `@SpringBootApplication` 或 `@SpringBootConfiguration` 注释的类。 只要您以合理的方式对<<using-spring-boot.adoc#using-boot-structuring-your-code, 代码进行结构化>> ，通常就可以找到您的主要配置。

[NOTE]
====
如果您使用<<boot-features-testing-spring-boot-applications-testing-autoconfigured-tests, 测试注释来测试应用程序的特定部分>>,，则应避免在 <<boot-features-testing-spring-boot-applications-testing-user-configuration, 应用程序的 main方法>> 中添加特定于特定区域的配置设置。

`@SpringBootApplication` 的基础组件扫描配置定义了排除过滤器，这些过滤器用于确保切片按预期工作。 如果在 `@SpringBootApplication` 注释的类上使用显式的 `@ComponentScan` 指令，请注意这些过滤器将被禁用。 如果使用切片，则应再次定义它们。
====

如果要自定义主要配置，则可以使用嵌套的 `@TestConfiguration` 类。 与将使用嵌套的 `@Configuration` 类代替应用程序的主要配置不同的是，在应用程序的主要配置之外还使用了嵌套的 `@TestConfiguration` 类。

NOTE: Spring的测试框架在测试之间缓存应用程序上下文。 因此，只要您的测试共享相同的配置（无论如何发现），加载上下文的潜在耗时过程就只会发生一次。

[[boot-features-testing-spring-boot-applications-excluding-config]]
==== 排除测试配置
如果您的应用程序使用组件扫描（例如，如果使用 `@SpringBootApplication` 或 `@ComponentScan` ），则可能会发现偶然为各地创建的仅为特定测试创建的顶级配置类。

<<boot-features-testing-spring-boot-applications-detecting-config,如前所述>>，`@TestConfiguration` 可以用于测试的内部类以自定义主要配置。 当放置在顶级类上时， `@TestConfiguration` 指示不应通过扫描选择 `src/test/java` 中的类。 然后，可以在需要的位置显式导入该类，如以下示例所示：

[source,java,indent=0]
----
	@SpringBootTest
	@Import(MyTestsConfiguration.class)
	class MyTests {

		@Test
		void exampleTest() {
			...
		}

	}
----

NOTE: 如果直接使用 `@ComponentScan`（即不是通过 `@SpringBootApplication`），则需要向其中注册 `TypeExcludeFilter`。 有关详细信息，请参见 {spring-boot-module-api}/context/TypeExcludeFilter.html[ Javadoc]。

[[boot-features-testing-spring-boot-application-arguments]]
==== 使用应用程序参数
如果您的应用程序需要<<boot-features-application-arguments,参数>>，则可以使用 `args` 属性让 `@SpringBootTest` 注入参数。

[source,java,indent=0]
----
include::{code-examples}/test/context/ApplicationArgumentsExampleTests.java[tag=example]
----



[[boot-features-testing-spring-boot-applications-testing-with-mock-environment]]
==== 在模拟环境中进行测试

默认情况下，`@SpringBootTest` 不会启动服务器。 如果您有要在此模拟环境下进行测试的Web终结点，则可以另外配置 {spring-framework-docs}/testing.html#spring-mvc-test-framework[`MockMvc`]，如以下示例所示：

[source,java,indent=0]
----
include::{code-examples}/test/web/MockMvcExampleTests.java[tag=test-mock-mvc]
----

TIP: 如果只想关注Web层而不希望启动完整的 `ApplicationContext`，请考虑使用<<boot-features-testing-spring-boot-applications-testing-autoconfigured-mvc-tests, `@WebMvcTest`>>。

另外，您可以配置 {spring-framework-docs}testing.html#webtestclient-tests[`WebTestClient`] ，如以下示例所示：

[source,java,indent=0]
----
include::{code-examples}/test/web/MockWebTestClientExampleTests.java[tag=test-mock-web-test-client]
----

[TIP]
====
在模拟环境中进行测试通常比在完整的Servlet容器中运行更快。 但是，由于模拟发生在Spring MVC层，因此无法使用MockMvc直接测试依赖于较低级别Servlet容器行为的代码。

例如，Spring Boot的错误处理基于Servlet容器提供的  "`error page`"  支持。 这意味着，尽管您可以按预期测试MVC层引发并处理异常，但是您无法直接测试是否呈现了特定的<<boot-features-error-handling-custom-error-pages, 自定义错误页面>>。 如果需要测试这些较低级别的问题，则可以按照下一节中的描述启动一个完全运行的服务器。
====

[[boot-features-testing-spring-boot-applications-testing-with-running-server]]
==== Testing with a running server
If you need to start a full running server, we recommend that you use random ports.
If you use `@SpringBootTest(webEnvironment=WebEnvironment.RANDOM_PORT)`, an available port is picked at random each time your test runs.

The `@LocalServerPort` annotation can be used to <<howto.adoc#howto-discover-the-http-port-at-runtime,inject the actual port used>> into your test.
For convenience, tests that need to make REST calls to the started server can additionally `@Autowire` a {spring-framework-docs}testing.html#webtestclient-tests[`WebTestClient`], which resolves relative links to the running server and comes with a dedicated API for verifying responses, as shown in the following example:

[source,java,indent=0]
----
include::{code-examples}/test/web/RandomPortWebTestClientExampleTests.java[tag=test-random-port]
----

This setup requires `spring-webflux` on the classpath.
If you can't or won't add webflux, Spring Boot also provides a `TestRestTemplate` facility:

[source,java,indent=0]
----
include::{code-examples}/test/web/RandomPortTestRestTemplateExampleTests.java[tag=test-random-port]
----



[[boot-features-testing-spring-boot-applications-customizing-web-test-client]]
==== Customizing WebTestClient
To customize the `WebTestClient` bean, configure a `WebTestClientBuilderCustomizer` bean.
Any such beans are called with the `WebTestClient.Builder` that is used to create the `WebTestClient`.



[[boot-features-testing-spring-boot-applications-jmx]]
==== Using JMX
As the test context framework caches context, JMX is disabled by default to prevent identical components to register on the same domain.
If such test needs access to an `MBeanServer`, consider marking it dirty as well:

[source,java,indent=0]
----
include::{test-examples}/jmx/SampleJmxTests.java[tag=test]
----



[[boot-features-testing-spring-boot-applications-mocking-beans]]
==== Mocking and Spying Beans
When running tests, it is sometimes necessary to mock certain components within your application context.
For example, you may have a facade over some remote service that is unavailable during development.
Mocking can also be useful when you want to simulate failures that might be hard to trigger in a real environment.

Spring Boot includes a `@MockBean` annotation that can be used to define a Mockito mock for a bean inside your `ApplicationContext`.
You can use the annotation to add new beans or replace a single existing bean definition.
The annotation can be used directly on test classes, on fields within your test, or on `@Configuration` classes and fields.
When used on a field, the instance of the created mock is also injected.
Mock beans are automatically reset after each test method.

[NOTE]
====
If your test uses one of Spring Boot's test annotations (such as `@SpringBootTest`), this feature is automatically enabled.
To use this feature with a different arrangement, a listener must be explicitly added, as shown in the following example:

[source,java,indent=0]
----
	@TestExecutionListeners(MockitoTestExecutionListener.class)
----

====

The following example replaces an existing `RemoteService` bean with a mock implementation:

[source,java,indent=0]
----
	import org.junit.jupiter.api.Test;
	import org.springframework.beans.factory.annotation.*;
	import org.springframework.boot.test.context.*;
	import org.springframework.boot.test.mock.mockito.*;

	import static org.assertj.core.api.Assertions.*;
	import static org.mockito.BDDMockito.*;

	@SpringBootTest
	class MyTests {

		@MockBean
		private RemoteService remoteService;

		@Autowired
		private Reverser reverser;

		@Test
		void exampleTest() {
			// RemoteService has been injected into the reverser bean
			given(this.remoteService.someCall()).willReturn("mock");
			String reverse = reverser.reverseSomeCall();
			assertThat(reverse).isEqualTo("kcom");
		}

	}
----

NOTE: `@MockBean` cannot be used to mock the behavior of a bean that's exercised during application context refresh.
By the time the test is executed, the application context refresh has completed and it is too late to configure the mocked behavior.
We recommend using a `@Bean` method to create and configure the mock in this situation.

Additionally, you can use `@SpyBean` to wrap any existing bean with a Mockito `spy`.
See the {spring-boot-test-module-api}/mock/mockito/SpyBean.html[Javadoc] for full details.

NOTE: CGLib proxies, such as those created for scoped beans, declare the proxied methods as `final`.
This stops Mockito from functioning correctly as it cannot mock or spy on `final` methods in its default configuration.
If you want to mock or spy on such a bean, configure Mockito to use its inline mock maker by adding `org.mockito:mockito-inline` to your application's test dependencies.
This allows Mockito to mock and spy on `final` methods.

NOTE: While Spring's test framework caches application contexts between tests and reuses a context for tests sharing the same configuration, the use of `@MockBean` or `@SpyBean` influences the cache key, which will most likely increase the number of contexts.

TIP: If you are using `@SpyBean` to spy on a bean with `@Cacheable` methods that refer to parameters by name, your application must be compiled with `-parameters`.
This ensures that the parameter names are available to the caching infrastructure once the bean has been spied upon.



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-tests]]
==== Auto-configured Tests
Spring Boot's auto-configuration system works well for applications but can sometimes be a little too much for tests.
It often helps to load only the parts of the configuration that are required to test a "`slice`" of your application.
For example, you might want to test that Spring MVC controllers are mapping URLs correctly, and you do not want to involve database calls in those tests, or you might want to test JPA entities, and you are not interested in the web layer when those tests run.

The `spring-boot-test-autoconfigure` module includes a number of annotations that can be used to automatically configure such "`slices`".
Each of them works in a similar way, providing a `@...Test` annotation that loads the `ApplicationContext` and one or more `@AutoConfigure...` annotations that can be used to customize auto-configuration settings.

NOTE: Each slice restricts component scan to appropriate components and loads a very restricted set of auto-configuration classes.
If you need to exclude one of them, most `@...Test` annotations provide an `excludeAutoConfiguration` attribute.
Alternatively, you can use `@ImportAutoConfiguration#exclude`.

NOTE: Including multiple "`slices`" by using several `@...Test` annotations in one test is not supported.
If you need multiple "`slices`", pick one of the `@...Test` annotations and include the `@AutoConfigure...` annotations of the other "`slices`" by hand.

TIP: It is also possible to use the `@AutoConfigure...` annotations with the standard `@SpringBootTest` annotation.
You can use this combination if you are not interested in "`slicing`" your application but you want some of the auto-configured test beans.



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-json-tests]]
==== Auto-configured JSON Tests
To test that object JSON serialization and deserialization is working as expected, you can use the `@JsonTest` annotation.
`@JsonTest` auto-configures the available supported JSON mapper, which can be one of the following libraries:

* Jackson `ObjectMapper`, any `@JsonComponent` beans and any Jackson ``Module``s
* `Gson`
* `Jsonb`

TIP: A list of the auto-configurations that are enabled by `@JsonTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

If you need to configure elements of the auto-configuration, you can use the `@AutoConfigureJsonTesters` annotation.

Spring Boot includes AssertJ-based helpers that work with the JSONAssert and JsonPath libraries to check that JSON appears as expected.
The `JacksonTester`, `GsonTester`, `JsonbTester`, and `BasicJsonTester` classes can be used for Jackson, Gson, Jsonb, and Strings respectively.
Any helper fields on the test class can be `@Autowired` when using `@JsonTest`.
The following example shows a test class for Jackson:

[source,java,indent=0]
----
	import org.junit.jupiter.api.Test;
	import org.springframework.beans.factory.annotation.*;
	import org.springframework.boot.test.autoconfigure.json.*;
	import org.springframework.boot.test.context.*;
	import org.springframework.boot.test.json.*;

	import static org.assertj.core.api.Assertions.*;

	@JsonTest
	class MyJsonTests {

		@Autowired
		private JacksonTester<VehicleDetails> json;

		@Test
		void testSerialize() throws Exception {
			VehicleDetails details = new VehicleDetails("Honda", "Civic");
			// Assert against a `.json` file in the same package as the test
			assertThat(this.json.write(details)).isEqualToJson("expected.json");
			// Or use JSON path based assertions
			assertThat(this.json.write(details)).hasJsonPathStringValue("@.make");
			assertThat(this.json.write(details)).extractingJsonPathStringValue("@.make")
					.isEqualTo("Honda");
		}

		@Test
		void testDeserialize() throws Exception {
			String content = "{\"make\":\"Ford\",\"model\":\"Focus\"}";
			assertThat(this.json.parse(content))
					.isEqualTo(new VehicleDetails("Ford", "Focus"));
			assertThat(this.json.parseObject(content).getMake()).isEqualTo("Ford");
		}

	}
----

NOTE: JSON helper classes can also be used directly in standard unit tests.
To do so, call the `initFields` method of the helper in your `@Before` method if you do not use `@JsonTest`.

If you're using Spring Boot's AssertJ-based helpers to assert on a number value at a given JSON path, you might not be able to use `isEqualTo` depending on the type.
Instead, you can use AssertJ's `satisfies` to assert that the value matches the given condition.
For instance, the following example asserts that the actual number is a float value close to `0.15` within an offset of `0.01`.

[source,java,indent=0]
----
assertThat(json.write(message))
    .extractingJsonPathNumberValue("@.test.numberValue")
    .satisfies((number) -> assertThat(number.floatValue()).isCloseTo(0.15f, within(0.01f)));
----



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-mvc-tests]]
==== Auto-configured Spring MVC Tests
To test whether Spring MVC controllers are working as expected, use the `@WebMvcTest` annotation.
`@WebMvcTest` auto-configures the Spring MVC infrastructure and limits scanned beans to `@Controller`, `@ControllerAdvice`, `@JsonComponent`, `Converter`, `GenericConverter`, `Filter`, `HandlerInterceptor`, `WebMvcConfigurer`, and `HandlerMethodArgumentResolver`.
Regular `@Component` beans are not scanned when using this annotation.

TIP: A list of the auto-configuration settings that are enabled by `@WebMvcTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

TIP: If you need to register extra components, such as the Jackson `Module`, you can import additional configuration classes by using `@Import` on your test.

Often, `@WebMvcTest` is limited to a single controller and is used in combination with `@MockBean` to provide mock implementations for required collaborators.

`@WebMvcTest` also auto-configures `MockMvc`.
Mock MVC offers a powerful way to quickly test MVC controllers without needing to start a full HTTP server.

TIP: You can also auto-configure `MockMvc` in a non-`@WebMvcTest` (such as `@SpringBootTest`) by annotating it with `@AutoConfigureMockMvc`.
The following example uses `MockMvc`:

[source,java,indent=0]
----
	import org.junit.jupiter.api.*;
	import org.springframework.beans.factory.annotation.*;
	import org.springframework.boot.test.autoconfigure.web.servlet.*;
	import org.springframework.boot.test.mock.mockito.*;

	import static org.assertj.core.api.Assertions.*;
	import static org.mockito.BDDMockito.*;
	import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
	import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

	@WebMvcTest(UserVehicleController.class)
	class MyControllerTests {

		@Autowired
		private MockMvc mvc;

		@MockBean
		private UserVehicleService userVehicleService;

		@Test
		void testExample() throws Exception {
			given(this.userVehicleService.getVehicleDetails("sboot"))
					.willReturn(new VehicleDetails("Honda", "Civic"));
			this.mvc.perform(get("/sboot/vehicle").accept(MediaType.TEXT_PLAIN))
					.andExpect(status().isOk()).andExpect(content().string("Honda Civic"));
		}

	}
----

TIP: If you need to configure elements of the auto-configuration (for example, when servlet filters should be applied) you can use attributes in the `@AutoConfigureMockMvc` annotation.

If you use HtmlUnit or Selenium, auto-configuration also provides an HtmlUnit `WebClient` bean and/or a Selenium `WebDriver` bean.
The following example uses HtmlUnit:

[source,java,indent=0]
----
	import com.gargoylesoftware.htmlunit.*;
	import org.junit.jupiter.api.*;
	import org.springframework.beans.factory.annotation.*;
	import org.springframework.boot.test.autoconfigure.web.servlet.*;
	import org.springframework.boot.test.mock.mockito.*;

	import static org.assertj.core.api.Assertions.*;
	import static org.mockito.BDDMockito.*;

	@WebMvcTest(UserVehicleController.class)
	class MyHtmlUnitTests {

		@Autowired
		private WebClient webClient;

		@MockBean
		private UserVehicleService userVehicleService;

		@Test
		void testExample() throws Exception {
			given(this.userVehicleService.getVehicleDetails("sboot"))
					.willReturn(new VehicleDetails("Honda", "Civic"));
			HtmlPage page = this.webClient.getPage("/sboot/vehicle.html");
			assertThat(page.getBody().getTextContent()).isEqualTo("Honda Civic");
		}

	}
----

NOTE: By default, Spring Boot puts `WebDriver` beans in a special "`scope`" to ensure that the driver exits after each test and that a new instance is injected.
If you do not want this behavior, you can add `@Scope("singleton")` to your `WebDriver` `@Bean` definition.

WARNING: The `webDriver` scope created by Spring Boot will replace any user defined scope of the same name.
If you define your own `webDriver` scope you may find it stops working when you use `@WebMvcTest`.

If you have Spring Security on the classpath, `@WebMvcTest` will also scan `WebSecurityConfigurer` beans.
Instead of disabling security completely for such tests, you can use Spring Security's test support.
More details on how to use Spring Security's `MockMvc` support can be found in this _<<howto.adoc#howto-use-test-with-spring-security>>_ how-to section.

TIP: Sometimes writing Spring MVC tests is not enough; Spring Boot can help you run <<boot-features-testing-spring-boot-applications-testing-with-running-server, full end-to-end tests with an actual server>>.



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-webflux-tests]]
==== Auto-configured Spring WebFlux Tests
To test that {spring-framework-docs}/web-reactive.html[Spring WebFlux] controllers are working as expected, you can use the `@WebFluxTest` annotation.
`@WebFluxTest` auto-configures the Spring WebFlux infrastructure and limits scanned beans to `@Controller`, `@ControllerAdvice`, `@JsonComponent`, `Converter`, `GenericConverter`, `WebFilter`, and `WebFluxConfigurer`.
Regular `@Component` beans are not scanned when the `@WebFluxTest` annotation is used.

TIP: A list of the auto-configurations that are enabled by `@WebFluxTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

TIP: If you need to register extra components, such as Jackson `Module`, you can import additional configuration classes using `@Import` on your test.

Often, `@WebFluxTest` is limited to a single controller and used in combination with the `@MockBean` annotation to provide mock implementations for required collaborators.

`@WebFluxTest` also auto-configures {spring-framework-docs}testing.html#webtestclient[`WebTestClient`], which offers a powerful way to quickly test WebFlux controllers without needing to start a full HTTP server.

TIP: You can also auto-configure `WebTestClient` in a non-`@WebFluxTest` (such as `@SpringBootTest`) by annotating it with `@AutoConfigureWebTestClient`.
The following example shows a class that uses both `@WebFluxTest` and a `WebTestClient`:

[source,java,indent=0]
----
	import org.junit.jupiter.api.Test;

	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest;
	import org.springframework.http.MediaType;
	import org.springframework.test.web.reactive.server.WebTestClient;

	@WebFluxTest(UserVehicleController.class)
	class MyControllerTests {

		@Autowired
		private WebTestClient webClient;

		@MockBean
		private UserVehicleService userVehicleService;

		@Test
		void testExample() throws Exception {
			given(this.userVehicleService.getVehicleDetails("sboot"))
					.willReturn(new VehicleDetails("Honda", "Civic"));
			this.webClient.get().uri("/sboot/vehicle").accept(MediaType.TEXT_PLAIN)
					.exchange()
					.expectStatus().isOk()
					.expectBody(String.class).isEqualTo("Honda Civic");
		}

	}
----

TIP: This setup is only supported by WebFlux applications as using `WebTestClient` in a mocked web application only works with WebFlux at the moment.

NOTE: `@WebFluxTest` cannot detect routes registered via the functional web framework.
For testing `RouterFunction` beans in the context, consider importing your `RouterFunction` yourself via `@Import` or using `@SpringBootTest`.

NOTE: `@WebFluxTest` cannot detect custom security configuration registered via a `@Bean` of type `SecurityWebFilterChain`.
To include that in your test, you will need to import the configuration that registers the bean via `@Import` or use `@SpringBootTest`.

TIP: Sometimes writing Spring WebFlux tests is not enough; Spring Boot can help you run <<boot-features-testing-spring-boot-applications-testing-with-running-server, full end-to-end tests with an actual server>>.



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-jpa-test]]
==== Auto-configured Data JPA Tests
You can use the `@DataJpaTest` annotation to test JPA applications.
By default, it scans for `@Entity` classes and configures Spring Data JPA repositories.
If an embedded database is available on the classpath, it configures one as well.
Regular `@Component` beans are not loaded into the `ApplicationContext`.

TIP: A list of the auto-configuration settings that are enabled by `@DataJpaTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

By default, data JPA tests are transactional and roll back at the end of each test.
See the {spring-framework-docs}testing.html#testcontext-tx-enabling-transactions[relevant section] in the Spring Framework Reference Documentation for more details.
If that is not what you want, you can disable transaction management for a test or for the whole class as follows:

[source,java,indent=0]
----
	import org.junit.jupiter.api.Test;
	import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
	import org.springframework.transaction.annotation.Propagation;
	import org.springframework.transaction.annotation.Transactional;

	@DataJpaTest
	@Transactional(propagation = Propagation.NOT_SUPPORTED)
	class ExampleNonTransactionalTests {

	}
----

Data JPA tests may also inject a {spring-boot-test-autoconfigure-module-code}/orm/jpa/TestEntityManager.java[`TestEntityManager`] bean, which provides an alternative to the standard JPA `EntityManager` that is specifically designed for tests.
If you want to use `TestEntityManager` outside of `@DataJpaTest` instances, you can also use the `@AutoConfigureTestEntityManager` annotation.
A `JdbcTemplate` is also available if you need that.
The following example shows the `@DataJpaTest` annotation in use:

[source,java,indent=0]
----
	import org.junit.jupiter.api.Test;
	import org.springframework.boot.test.autoconfigure.orm.jpa.*;

	import static org.assertj.core.api.Assertions.*;

	@DataJpaTest
	class ExampleRepositoryTests {

		@Autowired
		private TestEntityManager entityManager;

		@Autowired
		private UserRepository repository;

		@Test
		void testExample() throws Exception {
			this.entityManager.persist(new User("sboot", "1234"));
			User user = this.repository.findByUsername("sboot");
			assertThat(user.getUsername()).isEqualTo("sboot");
			assertThat(user.getVin()).isEqualTo("1234");
		}

	}
----

In-memory embedded databases generally work well for tests, since they are fast and do not require any installation.
If, however, you prefer to run tests against a real database you can use the `@AutoConfigureTestDatabase` annotation, as shown in the following example:

[source,java,indent=0]
----
	@DataJpaTest
	@AutoConfigureTestDatabase(replace=Replace.NONE)
	class ExampleRepositoryTests {

		// ...

	}
----



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-jdbc-test]]
==== Auto-configured JDBC Tests
`@JdbcTest` is similar to `@DataJpaTest` but is for tests that only require a `DataSource` and do not use Spring Data JDBC.
By default, it configures an in-memory embedded database and a `JdbcTemplate`.
Regular `@Component` beans are not loaded into the `ApplicationContext`.

TIP: A list of the auto-configurations that are enabled by `@JdbcTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

By default, JDBC tests are transactional and roll back at the end of each test.
See the {spring-framework-docs}testing.html#testcontext-tx-enabling-transactions[relevant section] in the Spring Framework Reference Documentation for more details.
If that is not what you want, you can disable transaction management for a test or for the whole class, as follows:

[source,java,indent=0]
----
	import org.junit.jupiter.api.Test;
	import org.springframework.boot.test.autoconfigure.jdbc.JdbcTest;
	import org.springframework.transaction.annotation.Propagation;
	import org.springframework.transaction.annotation.Transactional;

	@JdbcTest
	@Transactional(propagation = Propagation.NOT_SUPPORTED)
	class ExampleNonTransactionalTests {

	}
----

If you prefer your test to run against a real database, you can use the `@AutoConfigureTestDatabase` annotation in the same way as for `DataJpaTest`.
(See "<<boot-features-testing-spring-boot-applications-testing-autoconfigured-jpa-test>>".)



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-data-jdbc-test]]
==== Auto-configured Data JDBC Tests
`@DataJdbcTest` is similar to `@JdbcTest` but is for tests that use Spring Data JDBC repositories.
By default, it configures an in-memory embedded database, a `JdbcTemplate`, and Spring Data JDBC repositories.
Regular `@Component` beans are not loaded into the `ApplicationContext`.

TIP: A list of the auto-configurations that are enabled by `@DataJdbcTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

By default, Data JDBC tests are transactional and roll back at the end of each test.
See the {spring-framework-docs}testing.html#testcontext-tx-enabling-transactions[relevant section] in the Spring Framework Reference Documentation for more details.
If that is not what you want, you can disable transaction management for a test or for the whole test class as <<boot-features-testing-spring-boot-applications-testing-autoconfigured-jdbc-test,shown in the JDBC example>>.

If you prefer your test to run against a real database, you can use the `@AutoConfigureTestDatabase` annotation in the same way as for `DataJpaTest`.
(See "<<boot-features-testing-spring-boot-applications-testing-autoconfigured-jpa-test>>".)



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-jooq-test]]
==== Auto-configured jOOQ Tests
You can use `@JooqTest` in a similar fashion as `@JdbcTest` but for jOOQ-related tests.
As jOOQ relies heavily on a Java-based schema that corresponds with the database schema, the existing `DataSource` is used.
If you want to replace it with an in-memory database, you can use `@AutoConfigureTestDatabase` to override those settings.
(For more about using jOOQ with Spring Boot, see "<<boot-features-jooq>>", earlier in this chapter.)
Regular `@Component` beans are not loaded into the `ApplicationContext`.

TIP: A list of the auto-configurations that are enabled by `@JooqTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

`@JooqTest` configures a `DSLContext`.
Regular `@Component` beans are not loaded into the `ApplicationContext`.
The following example shows the `@JooqTest` annotation in use:

[source,java,indent=0]
----
	import org.jooq.DSLContext;
	import org.junit.jupiter.api.Test;
	import org.springframework.boot.test.autoconfigure.jooq.JooqTest;

	@JooqTest
	class ExampleJooqTests {

		@Autowired
		private DSLContext dslContext;
	}
----

JOOQ tests are transactional and roll back at the end of each test by default.
If that is not what you want, you can disable transaction management for a test or for the whole test class as <<boot-features-testing-spring-boot-applications-testing-autoconfigured-jdbc-test,shown in the JDBC example>>.



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-mongo-test]]
==== Auto-configured Data MongoDB Tests
You can use `@DataMongoTest` to test MongoDB applications.
By default, it configures an in-memory embedded MongoDB (if available), configures a `MongoTemplate`, scans for `@Document` classes, and configures Spring Data MongoDB repositories.
Regular `@Component` beans are not loaded into the `ApplicationContext`.
(For more about using MongoDB with Spring Boot, see "<<boot-features-mongodb>>", earlier in this chapter.)

TIP: A list of the auto-configuration settings that are enabled by `@DataMongoTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

The following class shows the `@DataMongoTest` annotation in use:

[source,java,indent=0]
----
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest;
	import org.springframework.data.mongodb.core.MongoTemplate;

	@DataMongoTest
	class ExampleDataMongoTests {

		@Autowired
		private MongoTemplate mongoTemplate;

		//
	}
----

In-memory embedded MongoDB generally works well for tests, since it is fast and does not require any developer installation.
If, however, you prefer to run tests against a real MongoDB server, you should exclude the embedded MongoDB auto-configuration, as shown in the following example:

[source,java,indent=0]
----
	import org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration;
	import org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest;

	@DataMongoTest(excludeAutoConfiguration = EmbeddedMongoAutoConfiguration.class)
	class ExampleDataMongoNonEmbeddedTests {

	}
----



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-neo4j-test]]
==== Auto-configured Data Neo4j Tests
You can use `@DataNeo4jTest` to test Neo4j applications.
By default, it uses an in-memory embedded Neo4j (if the embedded driver is available), scans for `@NodeEntity` classes, and configures Spring Data Neo4j repositories.
Regular `@Component` beans are not loaded into the `ApplicationContext`.
(For more about using Neo4J with Spring Boot, see "<<boot-features-neo4j>>", earlier in this chapter.)

TIP: A list of the auto-configuration settings that are enabled by `@DataNeo4jTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

The following example shows a typical setup for using Neo4J tests in Spring Boot:

[source,java,indent=0]
----
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest;

	@DataNeo4jTest
	class ExampleDataNeo4jTests {

		@Autowired
		private YourRepository repository;

		//
	}
----

By default, Data Neo4j tests are transactional and roll back at the end of each test.
See the {spring-framework-docs}testing.html#testcontext-tx-enabling-transactions[relevant section] in the Spring Framework Reference Documentation for more details.
If that is not what you want, you can disable transaction management for a test or for the whole class, as follows:

[source,java,indent=0]
----
	import org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest;
	import org.springframework.transaction.annotation.Propagation;
	import org.springframework.transaction.annotation.Transactional;

	@DataNeo4jTest
	@Transactional(propagation = Propagation.NOT_SUPPORTED)
	class ExampleNonTransactionalTests {

	}
----



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-redis-test]]
==== Auto-configured Data Redis Tests
You can use `@DataRedisTest` to test Redis applications.
By default, it scans for `@RedisHash` classes and configures Spring Data Redis repositories.
Regular `@Component` beans are not loaded into the `ApplicationContext`.
(For more about using Redis with Spring Boot, see "<<boot-features-redis>>", earlier in this chapter.)

TIP: A list of the auto-configuration settings that are enabled by `@DataRedisTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

The following example shows the `@DataRedisTest` annotation in use:

[source,java,indent=0]
----
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.boot.test.autoconfigure.data.redis.DataRedisTest;

	@DataRedisTest
	class ExampleDataRedisTests {

		@Autowired
		private YourRepository repository;

		//
	}
----



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-ldap-test]]
==== Auto-configured Data LDAP Tests
You can use `@DataLdapTest` to test LDAP applications.
By default, it configures an in-memory embedded LDAP (if available), configures an `LdapTemplate`, scans for `@Entry` classes, and configures Spring Data LDAP repositories.
Regular `@Component` beans are not loaded into the `ApplicationContext`.
(For more about using LDAP with Spring Boot, see "<<boot-features-ldap>>", earlier in this chapter.)

TIP: A list of the auto-configuration settings that are enabled by `@DataLdapTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

The following example shows the `@DataLdapTest` annotation in use:

[source,java,indent=0]
----
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest;
	import org.springframework.ldap.core.LdapTemplate;

	@DataLdapTest
	class ExampleDataLdapTests {

		@Autowired
		private LdapTemplate ldapTemplate;

		//
	}
----

In-memory embedded LDAP generally works well for tests, since it is fast and does not require any developer installation.
If, however, you prefer to run tests against a real LDAP server, you should exclude the embedded LDAP auto-configuration, as shown in the following example:

[source,java,indent=0]
----
	import org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration;
	import org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest;

	@DataLdapTest(excludeAutoConfiguration = EmbeddedLdapAutoConfiguration.class)
	class ExampleDataLdapNonEmbeddedTests {

	}
----



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-rest-client]]
==== Auto-configured REST Clients
You can use the `@RestClientTest` annotation to test REST clients.
By default, it auto-configures Jackson, GSON, and Jsonb support, configures a `RestTemplateBuilder`, and adds support for `MockRestServiceServer`.
Regular `@Component` beans are not loaded into the `ApplicationContext`.

TIP: A list of the auto-configuration settings that are enabled by `@RestClientTest` can be <<appendix-test-auto-configuration.adoc#test-auto-configuration,found in the appendix>>.

The specific beans that you want to test should be specified by using the `value` or `components` attribute of `@RestClientTest`, as shown in the following example:

[source,java,indent=0]
----
	@RestClientTest(RemoteVehicleDetailsService.class)
	class ExampleRestClientTest {

		@Autowired
		private RemoteVehicleDetailsService service;

		@Autowired
		private MockRestServiceServer server;

		@Test
		void getVehicleDetailsWhenResultIsSuccessShouldReturnDetails()
				throws Exception {
			this.server.expect(requestTo("/greet/details"))
					.andRespond(withSuccess("hello", MediaType.TEXT_PLAIN));
			String greeting = this.service.callRestService();
			assertThat(greeting).isEqualTo("hello");
		}

	}
----



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-rest-docs]]
==== Auto-configured Spring REST Docs Tests
You can use the `@AutoConfigureRestDocs` annotation to use {spring-restdocs}[Spring REST Docs] in your tests with Mock MVC, REST Assured, or WebTestClient.
It removes the need for the JUnit extension in Spring REST Docs.

`@AutoConfigureRestDocs` can be used to override the default output directory (`target/generated-snippets` if you are using Maven or `build/generated-snippets` if you are using Gradle).
It can also be used to configure the host, scheme, and port that appears in any documented URIs.



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-rest-docs-mock-mvc]]
===== Auto-configured Spring REST Docs Tests with Mock MVC
`@AutoConfigureRestDocs` customizes the `MockMvc` bean to use Spring REST Docs.
You can inject it by using `@Autowired` and use it in your tests as you normally would when using Mock MVC and Spring REST Docs, as shown in the following example:

[source,java,indent=0]
----
	import org.junit.jupiter.api.Test;

	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
	import org.springframework.http.MediaType;
	import org.springframework.test.web.servlet.MockMvc;

	import static org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.document;
	import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
	import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

	@WebMvcTest(UserController.class)
	@AutoConfigureRestDocs
	class UserDocumentationTests {

		@Autowired
		private MockMvc mvc;

		@Test
		void listUsers() throws Exception {
			this.mvc.perform(get("/users").accept(MediaType.TEXT_PLAIN))
					.andExpect(status().isOk())
					.andDo(document("list-users"));
		}

	}
----

If you require more control over Spring REST Docs configuration than offered by the attributes of `@AutoConfigureRestDocs`, you can use a `RestDocsMockMvcConfigurationCustomizer` bean, as shown in the following example:

[source,java,indent=0]
----
	@TestConfiguration
	static class CustomizationConfiguration
			implements RestDocsMockMvcConfigurationCustomizer {

		@Override
		public void customize(MockMvcRestDocumentationConfigurer configurer) {
			configurer.snippets().withTemplateFormat(TemplateFormats.markdown());
		}

	}
----

If you want to make use of Spring REST Docs support for a parameterized output directory, you can create a `RestDocumentationResultHandler` bean.
The auto-configuration calls `alwaysDo` with this result handler, thereby causing each `MockMvc` call to automatically generate the default snippets.
The following example shows a `RestDocumentationResultHandler` being defined:

[source,java,indent=0]
----
	@TestConfiguration(proxyBeanMethods = false)
	static class ResultHandlerConfiguration {

		@Bean
		public RestDocumentationResultHandler restDocumentation() {
			return MockMvcRestDocumentation.document("{method-name}");
		}

	}
----



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-rest-docs-web-test-client]]
===== Auto-configured Spring REST Docs Tests with WebTestClient
`@AutoConfigureRestDocs` can also be used with `WebTestClient`.
You can inject it by using `@Autowired` and use it in your tests as you normally would when using `@WebFluxTest` and Spring REST Docs, as shown in the following example:

[source,java,indent=0]
----
include::{code-examples}/test/autoconfigure/restdocs/webclient/UsersDocumentationTests.java[tag=source]
----

If you require more control over Spring REST Docs configuration than offered by the attributes of `@AutoConfigureRestDocs`, you can use a `RestDocsWebTestClientConfigurationCustomizer` bean, as shown in the following example:

[source,java,indent=0]
----
include::{code-examples}/test/autoconfigure/restdocs/webclient/AdvancedConfigurationExample.java[tag=configuration]
----



[[boot-features-testing-spring-boot-applications-testing-autoconfigured-rest-docs-rest-assured]]
===== Auto-configured Spring REST Docs Tests with REST Assured
`@AutoConfigureRestDocs` makes a `RequestSpecification` bean, preconfigured to use Spring REST Docs, available to your tests.
You can inject it by using `@Autowired` and use it in your tests as you normally would when using REST Assured and Spring REST Docs, as shown in the following example:

[source,java,indent=0]
----
include::{code-examples}/test/autoconfigure/restdocs/restassured/UserDocumentationTests.java[tag=source]
----

If you require more control over Spring REST Docs configuration than offered by the attributes of `@AutoConfigureRestDocs`, a `RestDocsRestAssuredConfigurationCustomizer` bean can be used, as shown in the following example:

[source,java,indent=0]
----
include::{code-examples}/test/autoconfigure/restdocs/restassured/AdvancedConfigurationExample.java[tag=configuration]
----



[[boot-features-testing-spring-boot-applications-testing-auto-configured-additional-auto-config]]
==== Additional Auto-configuration and Slicing
Each slice provides one or more `@AutoConfigure...` annotations that namely defines the auto-configurations that should be included as part of a slice.
Additional auto-configurations can be added by creating a custom `@AutoConfigure...` annotation or simply by adding `@ImportAutoConfiguration` to the test as shown in the following example:

[source,java,indent=0]
----
	@JdbcTest
	@ImportAutoConfiguration(IntegrationAutoConfiguration.class)
	class ExampleJdbcTests {

	}
----

NOTE: Make sure to not use the regular `@Import` annotation to import auto-configurations as they are handled in a specific way by Spring Boot.



[[boot-features-testing-spring-boot-applications-testing-user-configuration]]
==== User Configuration and Slicing
If you <<using-boot-structuring-your-code, structure your code>> in a sensible way, your `@SpringBootApplication` class is <<boot-features-testing-spring-boot-applications-detecting-config, used by default>> as the configuration of your tests.

It then becomes important not to litter the application's main class with configuration settings that are specific to a particular area of its functionality.

Assume that you are using Spring Batch and you rely on the auto-configuration for it.
You could define your `@SpringBootApplication` as follows:

[source,java,indent=0]
----
	@SpringBootApplication
	@EnableBatchProcessing
	public class SampleApplication { ... }
----

Because this class is the source configuration for the test, any slice test actually tries to start Spring Batch, which is definitely not what you want to do.
A recommended approach is to move that area-specific configuration to a separate `@Configuration` class at the same level as your application, as shown in the following example:

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	@EnableBatchProcessing
	public class BatchConfiguration { ... }
----

NOTE: Depending on the complexity of your application, you may either have a single `@Configuration` class for your customizations or one class per domain area.
The latter approach lets you enable it in one of your tests, if necessary, with the `@Import` annotation.

Test slices exclude `@Configuration` classes from scanning.
For example, for a `@WebMvcTest`, the following configuration will not include the given `WebMvcConfigurer` bean in the application context loaded by the test slice:

[source,java,indent=0]
----
	@Configuration
	public class WebConfiguration {
		@Bean
		public WebMvcConfigurer testConfigurer() {
			return new WebMvcConfigurer() {
				...
			};
		}
	}
----

The configuration below will, however, cause the custom `WebMvcConfigurer` to be loaded by the test slice.

[source,java,indent=0]
----
	@Component
	public class TestWebMvcConfigurer implements WebMvcConfigurer {
		...
	}
----

Another source of confusion is classpath scanning.
Assume that, while you structured your code in a sensible way, you need to scan an additional package.
Your application may resemble the following code:

[source,java,indent=0]
----
	@SpringBootApplication
	@ComponentScan({ "com.example.app", "org.acme.another" })
	public class SampleApplication { ... }
----

Doing so effectively overrides the default component scan directive with the side effect of scanning those two packages regardless of the slice that you chose.
For instance, a `@DataJpaTest` seems to suddenly scan components and user configurations of your application.
Again, moving the custom directive to a separate class is a good way to fix this issue.

TIP: If this is not an option for you, you can create a `@SpringBootConfiguration` somewhere in the hierarchy of your test so that it is used instead.
Alternatively, you can specify a source for your test, which disables the behavior of finding a default one.



[[boot-features-testing-spring-boot-applications-with-spock]]
==== Using Spock to Test Spring Boot Applications
If you wish to use Spock to test a Spring Boot application, you should add a dependency on Spock's `spock-spring` module to your application's build.
`spock-spring` integrates Spring's test framework into Spock.
It is recommended that you use Spock 1.2 or later to benefit from a number of improvements to Spock's Spring Framework and Spring Boot integration.
See http://spockframework.org/spock/docs/1.2/modules.html#_spring_module[the documentation for Spock's Spring module] for further details.



[[boot-features-test-utilities]]
=== Test Utilities
A few test utility classes that are generally useful when testing your application are packaged as part of `spring-boot`.



[[boot-features-configfileapplicationcontextinitializer-test-utility]]
==== ConfigFileApplicationContextInitializer
`ConfigFileApplicationContextInitializer` is an `ApplicationContextInitializer` that you can apply to your tests to load Spring Boot `application.properties` files.
You can use it when you do not need the full set of features provided by `@SpringBootTest`, as shown in the following example:

[source,java,indent=0]
----
	@ContextConfiguration(classes = Config.class,
		initializers = ConfigFileApplicationContextInitializer.class)
----

NOTE: Using `ConfigFileApplicationContextInitializer` alone does not provide support for `@Value("${...}")` injection.
Its only job is to ensure that `application.properties` files are loaded into Spring's `Environment`.
For `@Value` support, you need to either additionally configure a `PropertySourcesPlaceholderConfigurer` or use `@SpringBootTest`, which auto-configures one for you.



[[boot-features-test-property-values]]
==== TestPropertyValues
`TestPropertyValues` lets you quickly add properties to a `ConfigurableEnvironment` or `ConfigurableApplicationContext`.
You can call it with `key=value` strings, as follows:

[source,java,indent=0]
----
	TestPropertyValues.of("org=Spring", "name=Boot").applyTo(env);
----



[[boot-features-output-capture-test-utility]]
==== OutputCapture
`OutputCapture` is a JUnit `Extension` that you can use to capture `System.out` and `System.err` output.
To use add `@ExtendWith(OutputCaptureExtension.class)` and inject `CapturedOutput` as an argument to your test class constructor or test method as follows:

[source,java,indent=0]
----
include::{test-examples}/test/system/OutputCaptureTests.java[tag=test]
----



[[boot-features-rest-templates-test-utility]]
==== TestRestTemplate
`TestRestTemplate` is a convenience alternative to Spring's `RestTemplate` that is useful in integration tests.
You can get a vanilla template or one that sends Basic HTTP authentication (with a username and password).
In either case, the template behaves in a test-friendly way by not throwing exceptions on server-side errors.

TIP: Spring Framework 5.0 provides a new `WebTestClient` that works for <<boot-features-testing-spring-boot-applications-testing-autoconfigured-webflux-tests, WebFlux integration tests>> and both <<boot-features-testing-spring-boot-applications-testing-with-running-server, WebFlux and MVC end-to-end testing>>.
It provides a fluent API for assertions, unlike `TestRestTemplate`.

It is recommended, but not mandatory, to use the Apache HTTP Client (version 4.3.2 or better).
If you have that on your classpath, the `TestRestTemplate` responds by configuring the client appropriately.
If you do use Apache's HTTP client, some additional test-friendly features are enabled:

* Redirects are not followed (so you can assert the response location).
* Cookies are ignored (so the template is stateless).

`TestRestTemplate` can be instantiated directly in your integration tests, as shown in the following example:

[source,java,indent=0]
----
	public class MyTest {

		private TestRestTemplate template = new TestRestTemplate();

		@Test
		public void testRequest() throws Exception {
			HttpHeaders headers = this.template.getForEntity(
					"https://myhost.example.com/example", String.class).getHeaders();
			assertThat(headers.getLocation()).hasHost("other.example.com");
		}

	}
----

Alternatively, if you use the `@SpringBootTest` annotation with `WebEnvironment.RANDOM_PORT` or `WebEnvironment.DEFINED_PORT`, you can inject a fully configured `TestRestTemplate` and start using it.
If necessary, additional customizations can be applied through the `RestTemplateBuilder` bean.
Any URLs that do not specify a host and port automatically connect to the embedded server, as shown in the following example:

[source,java,indent=0]
----
include::{test-examples}/web/client/SampleWebClientTests.java[tag=test]
----



[[boot-features-websockets]]
== WebSockets
Spring Boot provides WebSockets auto-configuration for embedded Tomcat, Jetty, and Undertow.
If you deploy a war file to a standalone container, Spring Boot assumes that the container is responsible for the configuration of its WebSocket support.

Spring Framework provides {spring-framework-docs}web.html#websocket[rich WebSocket support] for MVC web applications that can be easily accessed through the `spring-boot-starter-websocket` module.

WebSocket support is also available for {spring-framework-docs}web-reactive.html#webflux-websocket[reactive web applications] and requires to include the WebSocket API alongside `spring-boot-starter-webflux`:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<dependency>
		<groupId>javax.websocket</groupId>
		<artifactId>javax.websocket-api</artifactId>
	</dependency>
----



[[boot-features-webservices]]
== Web Services
Spring Boot provides Web Services auto-configuration so that all you must do is define your `Endpoints`.

The {spring-webservices-docs}[Spring Web Services features] can be easily accessed with the `spring-boot-starter-webservices` module.

`SimpleWsdl11Definition` and `SimpleXsdSchema` beans can be automatically created for your WSDLs and XSDs respectively.
To do so, configure their location, as shown in the following example:


[source,properties,indent=0,configprops]
----
	spring.webservices.wsdl-locations=classpath:/wsdl
----



[[boot-features-webservices-template]]
=== Calling Web Services with `WebServiceTemplate`
If you need to call remote Web services from your application, you can use the {spring-webservices-docs}#client-web-service-template[`WebServiceTemplate`] class.
Since `WebServiceTemplate` instances often need to be customized before being used, Spring Boot does not provide any single auto-configured `WebServiceTemplate` bean.
It does, however, auto-configure a `WebServiceTemplateBuilder`, which can be used to create `WebServiceTemplate` instances when needed.

The following code shows a typical example:

[source,java,indent=0]
----
	@Service
	public class MyService {

		private final WebServiceTemplate webServiceTemplate;

		public MyService(WebServiceTemplateBuilder webServiceTemplateBuilder) {
			this.webServiceTemplate = webServiceTemplateBuilder.build();
		}

		public DetailsResp someWsCall(DetailsReq detailsReq) {
			 return (DetailsResp) this.webServiceTemplate.marshalSendAndReceive(detailsReq, new SoapActionCallback(ACTION));
		}

	}
----

By default, `WebServiceTemplateBuilder` detects a suitable HTTP-based `WebServiceMessageSender` using the available HTTP client libraries on the classpath.
You can also customize read and connection timeouts as follows:

[source,java,indent=0]
----
	@Bean
	public WebServiceTemplate webServiceTemplate(WebServiceTemplateBuilder builder) {
		return builder.messageSenders(new HttpWebServiceMessageSenderBuilder()
				.setConnectTimeout(5000).setReadTimeout(2000).build()).build();
	}
----



[[boot-features-developing-auto-configuration]]
== Creating Your Own Auto-configuration
If you work in a company that develops shared libraries, or if you work on an open-source or commercial library, you might want to develop your own auto-configuration.
Auto-configuration classes can be bundled in external jars and still be picked-up by Spring Boot.

Auto-configuration can be associated to a "`starter`" that provides the auto-configuration code as well as the typical libraries that you would use with it.
We first cover what you need to know to build your own auto-configuration and then we move on to the <<boot-features-custom-starter,typical steps required to create a custom starter>>.

TIP: A https://github.com/snicoll-demos/spring-boot-master-auto-configuration[demo project] is available to showcase how you can create a starter step-by-step.



[[boot-features-understanding-auto-configured-beans]]
=== Understanding Auto-configured Beans
Under the hood, auto-configuration is implemented with standard `@Configuration` classes.
Additional `@Conditional` annotations are used to constrain when the auto-configuration should apply.
Usually, auto-configuration classes use `@ConditionalOnClass` and `@ConditionalOnMissingBean` annotations.
This ensures that auto-configuration applies only when relevant classes are found and when you have not declared your own `@Configuration`.

You can browse the source code of {spring-boot-autoconfigure-module-code}[`spring-boot-autoconfigure`] to see the `@Configuration` classes that Spring provides (see the {spring-boot-code}/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories[`META-INF/spring.factories`] file).



[[boot-features-locating-auto-configuration-candidates]]
=== Locating Auto-configuration Candidates
Spring Boot checks for the presence of a `META-INF/spring.factories` file within your published jar.
The file should list your configuration classes under the `EnableAutoConfiguration` key, as shown in the following example:

[indent=0]
----
	org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
	com.mycorp.libx.autoconfigure.LibXAutoConfiguration,\
	com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration
----

NOTE: Auto-configurations must be loaded that way _only_.
Make sure that they are defined in a specific package space and that they are never the target of component scanning.
Furthermore, auto-configuration classes should not enable component scanning to find additional components.
Specific ``@Import``s should be used instead.

You can use the {spring-boot-autoconfigure-module-code}/AutoConfigureAfter.java[`@AutoConfigureAfter`] or {spring-boot-autoconfigure-module-code}/AutoConfigureBefore.java[`@AutoConfigureBefore`] annotations if your configuration needs to be applied in a specific order.
For example, if you provide web-specific configuration, your class may need to be applied after `WebMvcAutoConfiguration`.

If you want to order certain auto-configurations that should not have any direct knowledge of each other, you can also use `@AutoConfigureOrder`.
That annotation has the same semantic as the regular `@Order` annotation but provides a dedicated order for auto-configuration classes.



[[boot-features-condition-annotations]]
=== Condition Annotations
You almost always want to include one or more `@Conditional` annotations on your auto-configuration class.
The `@ConditionalOnMissingBean` annotation is one common example that is used to allow developers to override auto-configuration if they are not happy with your defaults.

Spring Boot includes a number of `@Conditional` annotations that you can reuse in your own code by annotating `@Configuration` classes or individual `@Bean` methods.
These annotations include:

* <<boot-features-class-conditions>>
* <<boot-features-bean-conditions>>
* <<boot-features-property-conditions>>
* <<boot-features-resource-conditions>>
* <<boot-features-web-application-conditions>>
* <<boot-features-spel-conditions>>



[[boot-features-class-conditions]]
==== Class Conditions
The `@ConditionalOnClass` and `@ConditionalOnMissingClass` annotations let `@Configuration` classes be included based on the presence or absence of specific classes.
Due to the fact that annotation metadata is parsed by using https://asm.ow2.org/[ASM], you can use the `value` attribute to refer to the real class, even though that class might not actually appear on the running application classpath.
You can also use the `name` attribute if you prefer to specify the class name by using a `String` value.

This mechanism does not apply the same way to `@Bean` methods where typically the return type is the target of the condition: before the condition on the method applies, the JVM will have loaded the class and potentially processed method references which will fail if the class is not present.

To handle this scenario, a separate `@Configuration` class can be used to isolate the condition, as shown in the following example:

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	// Some conditions
	public class MyAutoConfiguration {

		// Auto-configured beans

		@Configuration(proxyBeanMethods = false)
		@ConditionalOnClass(EmbeddedAcmeService.class)
		static class EmbeddedConfiguration {

			@Bean
			@ConditionalOnMissingBean
			public EmbeddedAcmeService embeddedAcmeService() { ... }

		}

	}
----

TIP: If you use `@ConditionalOnClass` or `@ConditionalOnMissingClass` as a part of a meta-annotation to compose your own composed annotations, you must use `name` as referring to the class in such a case is not handled.



[[boot-features-bean-conditions]]
==== Bean Conditions
The `@ConditionalOnBean` and `@ConditionalOnMissingBean` annotations let a bean be included based on the presence or absence of specific beans.
You can use the `value` attribute to specify beans by type or `name` to specify beans by name.
The `search` attribute lets you limit the `ApplicationContext` hierarchy that should be considered when searching for beans.

When placed on a `@Bean` method, the target type defaults to the return type of the method, as shown in the following example:

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	public class MyAutoConfiguration {

		@Bean
		@ConditionalOnMissingBean
		public MyService myService() { ... }

	}
----

In the preceding example, the `myService` bean is going to be created if no bean of type `MyService` is already contained in the `ApplicationContext`.

TIP: You need to be very careful about the order in which bean definitions are added, as these conditions are evaluated based on what has been processed so far.
For this reason, we recommend using only `@ConditionalOnBean` and `@ConditionalOnMissingBean` annotations on auto-configuration classes (since these are guaranteed to load after any user-defined bean definitions have been added).

NOTE: `@ConditionalOnBean` and `@ConditionalOnMissingBean` do not prevent `@Configuration` classes from being created.
The only difference between using these conditions at the class level and marking each contained `@Bean` method with the annotation is that the former prevents registration of the `@Configuration` class as a bean if the condition does not match.



[[boot-features-property-conditions]]
==== Property Conditions
The `@ConditionalOnProperty` annotation lets configuration be included based on a Spring Environment property.
Use the `prefix` and `name` attributes to specify the property that should be checked.
By default, any property that exists and is not equal to `false` is matched.
You can also create more advanced checks by using the `havingValue` and `matchIfMissing` attributes.



[[boot-features-resource-conditions]]
==== Resource Conditions
The `@ConditionalOnResource` annotation lets configuration be included only when a specific resource is present.
Resources can be specified by using the usual Spring conventions, as shown in the following example: `file:/home/user/test.dat`.



[[boot-features-web-application-conditions]]
==== Web Application Conditions
The `@ConditionalOnWebApplication` and `@ConditionalOnNotWebApplication` annotations let configuration be included depending on whether the application is a "`web application`".
A servlet-based web application is any application that uses a Spring `WebApplicationContext`, defines a `session` scope, or has a `ConfigurableWebEnvironment`.
A reactive web application is any application that uses a `ReactiveWebApplicationContext`, or has a `ConfigurableReactiveWebEnvironment`.



[[boot-features-spel-conditions]]
==== SpEL Expression Conditions
The `@ConditionalOnExpression` annotation lets configuration be included based on the result of a {spring-framework-docs}core.html#expressions[SpEL expression].



[[boot-features-test-autoconfig]]
=== Testing your Auto-configuration
An auto-configuration can be affected by many factors: user configuration (`@Bean` definition and `Environment` customization), condition evaluation (presence of a particular library), and others.
Concretely, each test should create a well defined `ApplicationContext` that represents a combination of those customizations.
`ApplicationContextRunner` provides a great way to achieve that.

`ApplicationContextRunner` is usually defined as a field of the test class to gather the base, common configuration.
The following example makes sure that `UserServiceAutoConfiguration` is always invoked:

[source,java,indent=0]
----
include::{test-examples}/autoconfigure/UserServiceAutoConfigurationTests.java[tag=runner]
----

TIP: If multiple auto-configurations have to be defined, there is no need to order their declarations as they are invoked in the exact same order as when running the application.

Each test can use the runner to represent a particular use case.
For instance, the sample below invokes a user configuration (`UserConfiguration`) and checks that the auto-configuration backs off properly.
Invoking `run` provides a callback context that can be used with `Assert4J`.

[source,java,indent=0]
----
include::{test-examples}/autoconfigure/UserServiceAutoConfigurationTests.java[tag=test-user-config]
----

It is also possible to easily customize the `Environment`, as shown in the following example:

[source,java,indent=0]
----
include::{test-examples}/autoconfigure/UserServiceAutoConfigurationTests.java[tag=test-env]
----

The runner can also be used to display the `ConditionEvaluationReport`.
The report can be printed at `INFO` or `DEBUG` level.
The following example shows how to use the `ConditionEvaluationReportLoggingListener` to print the report in auto-configuration tests.

[source,java,indent=0]
----
	@Test
	public void autoConfigTest {
		ConditionEvaluationReportLoggingListener initializer = new ConditionEvaluationReportLoggingListener(
				LogLevel.INFO);
		ApplicationContextRunner contextRunner = new ApplicationContextRunner()
				.withInitializer(initializer).run((context) -> {
						// Do something...
				});
	}
----



==== Simulating a Web Context
If you need to test an auto-configuration that only operates in a Servlet or Reactive web application context, use the `WebApplicationContextRunner` or `ReactiveWebApplicationContextRunner` respectively.



==== Overriding the Classpath
It is also possible to test what happens when a particular class and/or package is not present at runtime.
Spring Boot ships with a `FilteredClassLoader` that can easily be used by the runner.
In the following example, we assert that if `UserService` is not present, the auto-configuration is properly disabled:

[source,java,indent=0]
----
include::{test-examples}/autoconfigure/UserServiceAutoConfigurationTests.java[tag=test-classloader]
----



[[boot-features-custom-starter]]
=== Creating Your Own Starter
A full Spring Boot starter for a library may contain the following components:

* The `autoconfigure` module that contains the auto-configuration code.
* The `starter` module that provides a dependency to the `autoconfigure` module as well as the library and any additional dependencies that are typically useful.
In a nutshell, adding the starter should provide everything needed to start using that library.

TIP: You may combine the auto-configuration code and the dependency management in a single module if you do not need to separate those two concerns.



[[boot-features-custom-starter-naming]]
==== Naming
You should make sure to provide a proper namespace for your starter.
Do not start your module names with `spring-boot`, even if you use a different Maven `groupId`.
We may offer official support for the thing you auto-configure in the future.

As a rule of thumb, you should name a combined module after the starter.
For example, assume that you are creating a starter for "acme" and that you name the auto-configure module `acme-spring-boot-autoconfigure` and the starter `acme-spring-boot-starter`.
If you only have one module that combines the two, name it `acme-spring-boot-starter`.



[[boot-features-custom-starter-configuration-keys]]
==== Configuration keys
If your starter provides configuration keys, use a unique namespace for them.
In particular, do not include your keys in the namespaces that Spring Boot uses (such as `server`, `management`, `spring`, and so on).
If you use the same namespace, we may modify these namespaces in the future in ways that break your modules.
As a rule of thumb, prefix all your keys with a namespace that you own (e.g. `acme`).

Make sure that configuration keys are documented by adding field javadoc for each property, as shown in the following example:

[source,java,indent=0]
----
	@ConfigurationProperties("acme")
	public class AcmeProperties {

		/**
		 * Whether to check the location of acme resources.
		 */
		private boolean checkLocation = true;

		/**
		 * Timeout for establishing a connection to the acme server.
		 */
		private Duration loginTimeout = Duration.ofSeconds(3);

		// getters & setters

	}
----

NOTE: You should only use simple text with `@ConfigurationProperties` field Javadoc, since they are not processed before being added to the JSON.

Here are some rules we follow internally to make sure descriptions are consistent:

* Do not start the description by "The" or "A".
* For `boolean` types, start the description with "Whether" or "Enable".
* For collection-based types, start the description with "Comma-separated list"
* Use `java.time.Duration` rather than `long` and describe the default unit if it differs from milliseconds, e.g. "If a duration suffix is not specified, seconds will be used".
* Do not provide the default value in the description unless it has to be determined at runtime.

Make sure to <<appendix-configuration-metadata.adoc#configuration-metadata-annotation-processor,trigger meta-data generation>> so that IDE assistance is available for your keys as well.
You may want to review the generated metadata (`META-INF/spring-configuration-metadata.json`) to make sure your keys are properly documented.
Using your own starter in a compatible IDE is also a good idea to validate that quality of the metadata.



[[boot-features-custom-starter-module-autoconfigure]]
==== `autoconfigure` Module
The `autoconfigure` module contains everything that is necessary to get started with the library.
It may also contain configuration key definitions (such as `@ConfigurationProperties`) and any callback interface that can be used to further customize how the components are initialized.

TIP: You should mark the dependencies to the library as optional so that you can include the `autoconfigure` module in your projects more easily.
If you do it that way, the library is not provided and, by default, Spring Boot backs off.

Spring Boot uses an annotation processor to collect the conditions on auto-configurations in a metadata file (`META-INF/spring-autoconfigure-metadata.properties`).
If that file is present, it is used to eagerly filter auto-configurations that do not match, which will improve startup time.
It is recommended to add the following dependency in a module that contains auto-configurations:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-autoconfigure-processor</artifactId>
		<optional>true</optional>
	</dependency>
----

With Gradle 4.5 and earlier, the dependency should be declared in the `compileOnly` configuration, as shown in the following example:

[source,groovy,indent=0,subs="verbatim,quotes,attributes"]
----
	dependencies {
		compileOnly "org.springframework.boot:spring-boot-autoconfigure-processor"
	}
----

With Gradle 4.6 and later, the dependency should be declared in the `annotationProcessor` configuration, as shown in the following example:

[source,groovy,indent=0,subs="verbatim,quotes,attributes"]
----
	dependencies {
		annotationProcessor "org.springframework.boot:spring-boot-autoconfigure-processor"
	}
----



[[boot-features-custom-starter-module-starter]]
==== Starter Module
The starter is really an empty jar.
Its only purpose is to provide the necessary dependencies to work with the library.
You can think of it as an opinionated view of what is required to get started.

Do not make assumptions about the project in which your starter is added.
If the library you are auto-configuring typically requires other starters, mention them as well.
Providing a proper set of _default_ dependencies may be hard if the number of optional dependencies is high, as you should avoid including dependencies that are unnecessary for a typical usage of the library.
In other words, you should not include optional dependencies.

NOTE: Either way, your starter must reference the core Spring Boot starter (`spring-boot-starter`) directly or indirectly (i.e. no need to add it if your starter relies on another starter).
If a project is created with only your custom starter, Spring Boot's core features will be honoured by the presence of the core starter.



[[boot-features-kotlin]]
== Kotlin support
https://kotlinlang.org[Kotlin] is a statically-typed language targeting the JVM (and other platforms) which allows writing concise and elegant code while providing {kotlin-docs}java-interop.html[interoperability] with existing libraries written in Java.

Spring Boot provides Kotlin support by leveraging the support in other Spring projects such as Spring Framework, Spring Data, and Reactor.
See the {spring-framework-docs}languages.html#kotlin[Spring Framework Kotlin support documentation] for more information.

The easiest way to start with Spring Boot and Kotlin is to follow https://spring.io/guides/tutorials/spring-boot-kotlin/[this comprehensive tutorial].
You can create new Kotlin projects via https://start.spring.io/#!language=kotlin[start.spring.io].
Feel free to join the #spring channel of https://slack.kotlinlang.org/[Kotlin Slack] or ask a question with the `spring` and `kotlin` tags on https://stackoverflow.com/questions/tagged/spring+kotlin[Stack Overflow] if you need support.



[[boot-features-kotlin-requirements]]
=== Requirements
Spring Boot supports Kotlin 1.3.x.
To use Kotlin, `org.jetbrains.kotlin:kotlin-stdlib` and `org.jetbrains.kotlin:kotlin-reflect` must be present on the classpath.
The `kotlin-stdlib` variants `kotlin-stdlib-jdk7` and `kotlin-stdlib-jdk8` can also be used.

Since https://discuss.kotlinlang.org/t/classes-final-by-default/166[Kotlin classes are final by default], you are likely to want to configure {kotlin-docs}compiler-plugins.html#spring-support[kotlin-spring] plugin in order to automatically open Spring-annotated classes so that they can be proxied.

https://github.com/FasterXML/jackson-module-kotlin[Jackson's Kotlin module] is required for serializing / deserializing JSON data in Kotlin.
It is automatically registered when found on the classpath.
A warning message is logged if Jackson and Kotlin are present but the Jackson Kotlin module is not.

TIP: These dependencies and plugins are provided by default if one bootstraps a Kotlin project on https://start.spring.io/#!language=kotlin[start.spring.io].



[[boot-features-kotlin-null-safety]]
=== Null-safety
One of Kotlin's key features is {kotlin-docs}null-safety.html[null-safety].
It deals with `null` values at compile time rather than deferring the problem to runtime and encountering a `NullPointerException`.
This helps to eliminate a common source of bugs without paying the cost of wrappers like `Optional`.
Kotlin also allows using functional constructs with nullable values as described in this https://www.baeldung.com/kotlin-null-safety[comprehensive guide to null-safety in Kotlin].

Although Java does not allow one to express null-safety in its type system, Spring Framework, Spring Data, and Reactor now provide null-safety of their API via tooling-friendly annotations.
By default, types from Java APIs used in Kotlin are recognized as {kotlin-docs}java-interop.html#null-safety-and-platform-types[platform types] for which null-checks are relaxed.
{kotlin-docs}java-interop.html#jsr-305-support[Kotlin's support for JSR 305 annotations] combined with nullability annotations provide null-safety for the related Spring API in Kotlin.

The JSR 305 checks can be configured by adding the `-Xjsr305` compiler flag with the following options: `-Xjsr305={strict|warn|ignore}`.
The default behavior is the same as `-Xjsr305=warn`.
The `strict` value is required to have null-safety taken in account in Kotlin types inferred from Spring API but should be used with the knowledge that Spring API nullability declaration could evolve even between minor releases and more checks may be added in the future).

WARNING: Generic type arguments, varargs and array elements nullability are not yet supported.
See https://jira.spring.io/browse/SPR-15942[SPR-15942] for up-to-date information.
Also be aware that Spring Boot's own API is {github-issues}10712[not yet annotated].



[[boot-features-kotlin-api]]
=== Kotlin API



[[boot-features-kotlin-api-runapplication]]
==== runApplication
Spring Boot provides an idiomatic way to run an application with `runApplication<MyApplication>(*args)` as shown in the following example:

[source,kotlin,indent=0]
----
	import org.springframework.boot.autoconfigure.SpringBootApplication
	import org.springframework.boot.runApplication

	@SpringBootApplication
	class MyApplication

	fun main(args: Array<String>) {
		runApplication<MyApplication>(*args)
	}
----

This is a drop-in replacement for `SpringApplication.run(MyApplication::class.java, *args)`.
It also allows customization of the application as shown in the following example:

[source,kotlin,indent=0]
----
	runApplication<MyApplication>(*args) {
		setBannerMode(OFF)
	}
----



[[boot-features-kotlin-api-extensions]]
==== Extensions
Kotlin {kotlin-docs}extensions.html[extensions] provide the ability to extend existing classes with additional functionality.
The Spring Boot Kotlin API makes use of these extensions to add new Kotlin specific conveniences to existing APIs.

`TestRestTemplate` extensions, similar to those provided by Spring Framework for `RestOperations` in Spring Framework, are provided.
Among other things, the extensions make it possible to take advantage of Kotlin reified type parameters.



[[boot-features-kotlin-dependency-management]]
=== Dependency management
In order to avoid mixing different versions of Kotlin dependencies on the classpath, Spring Boot imports the Kotlin BOM.

With Maven, the Kotlin version can be customized via the `kotlin.version` property and plugin management is provided for `kotlin-maven-plugin`.
With Gradle, the Spring Boot plugin automatically aligns the `kotlin.version` with the version of the Kotlin plugin.

Spring Boot also manages the version of Coroutines dependencies by importing the Kotlin Coroutines BOM.
The version can be customized via the `kotlin-coroutines.version` property.

TIP: `org.jetbrains.kotlinx:kotlinx-coroutines-reactor` dependency is provided by default if one bootstraps a Kotlin project with at least one reactive dependency on https://start.spring.io/#!language=kotlin[start.spring.io].


[[boot-features-kotlin-configuration-properties]]
=== `@ConfigurationProperties`
`@ConfigurationProperties` when used in combination with <<boot-features-external-config-constructor-binding,`@ConstructorBinding`>> supports classes with immutable `val` properties as shown in the following example:

[source,kotlin,indent=0]
----
@ConstructorBinding
@ConfigurationProperties("example.kotlin")
data class KotlinExampleProperties(
		val name: String,
		val description: String,
		val myService: MyService) {

	data class MyService(
			val apiToken: String,
			val uri: URI
	)
}
----

TIP: To generate <<appendix-configuration-metadata.adoc#configuration-metadata-annotation-processor,your own metadata>> using the annotation processor, {kotlin-docs}kapt.html[`kapt` should be configured] with the `spring-boot-configuration-processor` dependency.
Note that some features (such as detecting the default value or deprecated items) are not working due to limitations in the model kapt provides.



[[boot-features-kotlin-testing]]
=== Testing
While it is possible to use JUnit 4 to test Kotlin code, JUnit 5 is provided by default and is recommended.
JUnit 5 enables a test class to be instantiated once and reused for all of the class's tests.
This makes it possible to use `@BeforeClass` and `@AfterClass` annotations on non-static methods, which is a good fit for Kotlin.

JUnit 5 is the default and the vintage engine is provided for backward compatibility with JUnit 4.
If you don't use it, exclude `org.junit.vintange:junit-vintage-engine`.
You also need to {junit5-docs}/#writing-tests-test-instance-lifecycle-changing-default[switch test instance lifecycle to "per-class"].

To mock Kotlin classes, https://mockk.io/[MockK] is recommended.
If you need the `Mockk` equivalent of the Mockito specific <<boot-features-testing-spring-boot-applications-mocking-beans,`@MockBean` and `@SpyBean` annotations>>, you can use https://github.com/Ninja-Squad/springmockk[SpringMockK] which provides similar `@MockkBean` and `@SpykBean` annotations.



[[boot-features-kotlin-resources]]
=== Resources



[[boot-features-kotlin-resources-further-reading]]
==== Further reading
* {kotlin-docs}[Kotlin language reference]
* https://slack.kotlinlang.org/[Kotlin Slack] (with a dedicated #spring channel)
* https://stackoverflow.com/questions/tagged/spring+kotlin[Stackoverflow with `spring` and `kotlin` tags]
* https://try.kotlinlang.org/[Try Kotlin in your browser]
* https://blog.jetbrains.com/kotlin/[Kotlin blog]
* https://kotlin.link/[Awesome Kotlin]
* https://spring.io/guides/tutorials/spring-boot-kotlin/[Tutorial: building web applications with Spring Boot and Kotlin]
* https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin[Developing Spring Boot applications with Kotlin]
* https://spring.io/blog/2016/03/20/a-geospatial-messenger-with-kotlin-spring-boot-and-postgresql[A Geospatial Messenger with Kotlin, Spring Boot and PostgreSQL]
* https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0[Introducing Kotlin support in Spring Framework 5.0]
* https://spring.io/blog/2017/08/01/spring-framework-5-kotlin-apis-the-functional-way[Spring Framework 5 Kotlin APIs, the functional way]



[[boot-features-kotlin-resources-examples]]
==== Examples
* https://github.com/sdeleuze/spring-boot-kotlin-demo[spring-boot-kotlin-demo]: regular Spring Boot + Spring Data JPA project
* https://github.com/mixitconf/mixit[mixit]: Spring Boot 2 + WebFlux + Reactive Spring Data MongoDB
* https://github.com/sdeleuze/spring-kotlin-fullstack[spring-kotlin-fullstack]: WebFlux Kotlin fullstack example with Kotlin2js for frontend instead of JavaScript or TypeScript
* https://github.com/spring-petclinic/spring-petclinic-kotlin[spring-petclinic-kotlin]: Kotlin version of the Spring PetClinic Sample Application
* https://github.com/sdeleuze/spring-kotlin-deepdive[spring-kotlin-deepdive]: a step by step migration for Boot 1.0 + Java to Boot 2.0 + Kotlin
* https://github.com/sdeleuze/spring-boot-coroutines-demo[spring-boot-coroutines-demo]: Coroutines sample project



[[boot-features-whats-next]]
== What to Read Next
If you want to learn more about any of the classes discussed in this section, you can check out the {spring-boot-api}[Spring Boot API documentation] or you can browse the {spring-boot-code}[source code directly].
If you have specific questions, take a look at the <<howto.adoc#howto, how-to>> section.

If you are comfortable with Spring Boot's core features, you can continue on and read about <<production-ready-features.adoc#production-ready, production-ready features>>.
