
[[test-mockmvc]]
== Spring MVC 集成测试

Spring Security提供与 https://docs.spring.io/spring/docs/current/spring-framework-reference/html/testing.html#spring-mvc-test-framework[Spring MVC Test]的全面集成

[[test-mockmvc-setup]]
=== 设置MockMvc和Spring Security

为了将Spring Security与Spring MVC Test一起使用，有必要添加Spring Security `FilterChainProxy` 作为过滤器。 还必须添加Spring Security的 `TestSecurityContextHolderPostProcessor` 以支持在<<Running as a User in Spring MVC Test with Annotations,带有注解的Spring MVC测试中以用户身份运行>>。 可以使用Spring Security的 `SecurityMockMvcConfigurers.springSecurity()` 来完成。 例如：


NOTE: Spring Security的测试支持需要spring-test-4.1.3.RELEASE或更高版本。

[source,java]
----

import static org.springframework.security.test.web.servlet.setup.SecurityMockMvcConfigurers.*;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration
@WebAppConfiguration
public class CsrfShowcaseTests {

	@Autowired
	private WebApplicationContext context;

	private MockMvc mvc;

	@Before
	public void setup() {
		mvc = MockMvcBuilders
				.webAppContextSetup(context)
				.apply(springSecurity()) // <1>
				.build();
	}

...
----

<1> `SecurityMockMvcConfigurers.springSecurity()` 将执行我们将Spring Security与Spring MVC Test集成在一起所需的所有初始设置

[[test-mockmvc-smmrpp]]
=== SecurityMockMvcRequestPostProcessors

Spring MVC Test提供了一个方便的接口，称为 `RequestPostProcessor`，可用于修改请求。 Spring Security提供了许多 `RequestPostProcessor` 实现，这些实现使测试更加容易。 为了使用Spring Security的 `RequestPostProcessor` 实现，请确保使用以下静态导入：

[source,java]
----
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.*;
----

[[test-mockmvc-csrf]]
==== 使用CSRF保护进行测试

在测试任何非安全的HTTP方法并使用Spring Security的CSRF保护时，必须确保在请求中包括有效的CSRF令牌。使用以下命令将有效的CSRF令牌指定为请求参数：

[source,java]
----
mvc
	.perform(post("/").with(csrf()))
----

如果愿意，可以在标题中包含CSRF令牌：

[source,java]
----
mvc
	.perform(post("/").with(csrf().asHeader()))
----

您还可以使用以下方法测试提供的CSRF令牌无效：

[source,java]
----
mvc
	.perform(post("/").with(csrf().useInvalidToken()))
----

[[test-mockmvc-securitycontextholder]]
==== 在Spring MVC测试中以用户身份运行测试

通常需要以特定用户身份运行测试。 填充用户有两种简单的方法：

* <<Running as a User in Spring MVC Test with RequestPostProcessor,在Spring MVC Test中使用RequestPostProcessor以用户身份运行 >>
* <<Running as a User in Spring MVC Test with Annotations,在带有注解的Spring MVC测试中以用户身份运行>>

[[test-mockmvc-securitycontextholder-rpp]]
==== 在Spring MVC Test中使用RequestPostProcessor以用户身份运行

有许多选项可用于将用户与当前 `HttpServletRequest` 关联。例如，以下将以用户名 "user"，密码 "password" 和角色 "ROLE_USER" 的用户身份（不需要存在）运行：

[NOTE]
====
该支持通过将用户与 `HttpServletRequest` 关联而起作用。 要将请求关联到 `SecurityContextHolder`，您需要确保 `SecurityContextPersistenceFilter` 与 `MockMvc` 实例关联。 实现此目的的几种方法是：

* 调用 <<test-mockmvc-setup,apply(springSecurity())>>
* 将Spring Security的 `FilterChainProxy` 添加到 `MockMvc`
* 使用 `MockMvcBuilders.standaloneSetup` 时，将 `SecurityContextPersistenceFilter` 手动添加到 `MockMvc` 实例可能很有意义。
====

[source,java]
----
mvc
	.perform(get("/").with(user("user")))
----

您可以轻松进行自定义。例如，以下用户名（管理员），用户名 "admin", 密码 "pass" 以及角色 "ROLE_USER 和 "ROLE_ADMIN" 将作为用户（不需要存在）运行。

[source,java]
----
mvc
	.perform(get("/admin").with(user("admin").password("pass").roles("USER","ADMIN")))
----

如果您有要使用的自定义 `UserDetails`，则也可以轻松指定它。 例如，下面的代码将使用指定的 `UserDetails`（不需要存在）来运行具有指定 `UserDetails` 主体的 `UsernamePasswordAuthenticationToken`：

[source,java]
----
mvc
	.perform(get("/").with(user(userDetails)))
----

您可以使用以下身份以匿名用户身份运行：

[source,java]
----
mvc
	.perform(get("/").with(anonymous()))
----

如果您使用默认用户运行，并希望以匿名用户身份执行一些请求，则此功能特别有用。

如果需要自定义身份验证（不需要存在），可以使用以下方法：

[source,java]
----
mvc
	.perform(get("/").with(authentication(authentication)))
----

您甚至可以使用以下方法自定义 `SecurityContext`：

[source,java]
----
mvc
	.perform(get("/").with(securityContext(securityContext)))
----

通过使用 ``MockMvcBuilders`` 的默认请求，我们还可以确保针对每个请求以特定用户身份运行。 例如，以下用户名（管理员），用户名 "admin",密码 "password", 和角色 "ROLE_ADMIN" 将作为用户（不需要存在）运行：

[source,java]
----
mvc = MockMvcBuilders
		.webAppContextSetup(context)
		.defaultRequest(get("/").with(user("user").roles("ADMIN")))
		.apply(springSecurity())
		.build();
----

如果发现您在许多测试中使用的是同一用户，建议将用户移至某个方法。例如，您可以在自己的名为 `CustomSecurityMockMvcRequestPostProcessors` 的类中指定以下内容：

[source,java]
----
public static RequestPostProcessor rob() {
	return user("rob").roles("ADMIN");
}
----

现在，您可以在 `SecurityMockMvcRequestPostProcessors` 上执行静态导入，并在测试中使用它：

[source,java]
----
import static sample.CustomSecurityMockMvcRequestPostProcessors.*;

...

mvc
	.perform(get("/").with(rob()))
----

===== 在带有注解的Spring MVC测试中以用户身份运行

除了使用 `RequestPostProcessor` 创建用户之外，还可以使用<<Testing Method Security,测试方法安全性>>所述的注解。 例如，以下将对具有用户名 "user"，密码 "password" 和角色 "ROLE_USER" 的用户运行测试：

[source,java]
----
@Test
@WithMockUser
public void requestProtectedUrlWithUser() throws Exception {
mvc
		.perform(get("/"))
		...
}
----

或者，以下将使用用户名 "user"，密码 "password" 和角色 "ROLE_ADMIN" 的用户运行测试：

[source,java]
----
@Test
@WithMockUser(roles="ADMIN")
public void requestProtectedUrlWithUser() throws Exception {
mvc
		.perform(get("/"))
		...
}
----

==== 测试HTTP基本身份验证

虽然始终可以使用HTTP Basic进行身份验证，但是记住标头名称，格式和对值进行编码有点繁琐。 现在，可以使用Spring Security的 `httpBasic` `RequestPostProcessor` 完成此操作。 例如，以下代码段：

[source,java]
----
mvc
	.perform(get("/").with(httpBasic("user","password")))
----

将通过确保在HTTP请求上填充以下标头，尝试使用HTTP Basic对用户名 "user" 和密码 "password" 进行身份验证：

[source,text]
----
Authorization: Basic dXNlcjpwYXNzd29yZA==
----

=== SecurityMockMvcRequestBuilders

Spring MVC Test还提供了一个 `RequestBuilder` 接口，该接口可用于创建测试中使用的 `MockHttpServletRequest`。 Spring Security提供了一些 `RequestBuilder` 实现，可用来简化测试。 为了使用Spring Security的 `RequestBuilder` 实现，请确保使用以下静态导入：

[source,java]
----
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestBuilders.*;
----

==== Testing Form Based Authentication

您可以使用Spring Security的测试支持轻松地创建一个请求，以测试基于表单的身份验证。例如，以下代码将使用用户名 "user" ，密码 "password" 和有效的CSRF令牌向 "/login" 提交POST：

[source,java]
----
mvc
	.perform(formLogin())
----

定制请求很容易。例如，以下代码将使用用户名 "admin"，密码 "pass" 和有效的CSRF令牌向 "/auth" 提交POST：

[source,java]
----
mvc
	.perform(formLogin("/auth").user("admin").password("pass"))
----

我们还可以自定义包含用户名和密码的参数名称。 例如，这是上面的请求，已修改为包括HTTP参数  "u" 上的用户名和HTTP参数 "p" 上的密码。

[source,java]
----
mvc
	.perform(formLogin("/auth").user("u","admin").password("p","pass"))
----

[[testing-oidc-login]]
==== Testing OIDC Login

为了在OAuth 2.0客户端上发出经过身份验证的请求，您需要使用授权服务器模拟某种授权流程。
但是，Spring Security的OAuth 2.0 Client测试支持可以帮助删除大部分样板。

如果您的客户端使用OIDC进行身份验证，则可以使用  `oidcLogin()` `RequestPostProcessor`  来配置通过身份验证的用户的 `MockMvc` 请求。
其中最简单的如下所示：

[source,java]
----
mvc.perform(get("/endpoint").with(oidcLogin()));
----

要做的是创建一个模拟 `OidcUser`，并将其正确地通过任何身份验证API传递，以便它可用于您的控制器等等。
它包含一个模拟的 OidcUserInfo，一个模拟的 `OidcIdToken` 和一个模拟的 授权集合。
另外，与用户相关联的  <<testing-oauth2-client,a mock `OAuth2AuthorizedClient`>> 被注册到 `HttpSessionOAuth2AuthorizedClientRepository`。

默认情况下，用户信息没有声明，而id令牌具有 `sub` 声明，如下所示：

[source,json]
----
{
    "sub" : "user"
}
----

经过测试的结果 `OidcUser` 将通过以下方式通过：

[source,java]
----
assertThat(user.getIdToken().getTokenValue()).isEqualTo("id-token");
assertThat(user.getIdToken().getClaim("sub")).isEqualTo("user");
assertThat(user.getUserInfo().getClaims()).isEmpty();
GrantedAuthority authority = user.getAuthorities().iterator().next();
assertThat(authority.getAuthority()).isEqualTo("SCOPE_read");
----

当然可以配置这些值。

任何声明都可以使用其相应的方法进行配置：

[source,java]
----
mvc.perform(get("/endpoint")
        .with(oidcLogin()
                .idToken(idToken -> idToken.subject("my-subject"))
                .userInfo(info -> info.firstName("Rob"))));
----

[source,java]
----
mvc.perform(get("/endpoint")
        .with(oidcLogin().idToken(idToken -> idToken.claims(claims -> claims.remove("scope")))));
----


默认情况下， `oidcLogin()` 会添加  `SCOPE_read` `GrantedAuthority`。
但是，可以通过提供测试所需的 `GrantedAuthority` 实例列表来覆盖它：

[source,java]
----
mvc
    .perform(get("/endpoint")
        .with(oidcLogin().authorities(new SimpleGrantedAuthority("SCOPE_messages"))));
----

或者，您可以通过 `OidcUser` 的实例提供所有详细信息，如下所示：

[source,java]
----
mvc.perform(get("/endpoint")
        .with(oidcLogin().oidcUser(new MyOidcUser())));
----

[[testing-oauth2-login]]
==== Testing OAuth 2.0 Login

或者，如果您的客户端使用OAuth 2.0进行身份验证，但不使用OIDC进行身份验证，则可以使用  `oauth2Login()` `RequestPostProcessor`  与经过身份验证的用户一起配置 `MockMvc` 请求。 其中最简单的如下所示：

[source,java]
----
mvc.perform(get("/endpoint").with(oauth2Login()));
----

要做的就是创建一个模拟 `OAuth2User`，将其正确地通过任何身份验证API传递，以便控制器可以使用它，依此类推。 它包含一组模拟的属性和一组模拟的授权机构。 另外，与用户关联的模拟 <<testing-oauth2-client,a mock `OAuth2AuthorizedClient`>>  被注册到 `HttpSessionOAuth2AuthorizedClientRepository`。

默认情况下，属性集仅包含 `sub`：

[source,json]
----
{
  "sub" : "user"
}
----

经过测试的结果 `OAuth2User` 将通过以下方式通过：

[source,java]
----
assertThat(user.getClaim("sub")).isEqualTo("user");
GrantedAuthority authority = user.getAuthorities().iterator().next();
assertThat(authority.getAuthority()).isEqualTo("SCOPE_read");
----

当然可以配置这些值。

可以通过基础 `Map` 配置任何声明：

[source,java]
----
mvc.perform(get("/endpoint")
        .with(oauth2Login()
                .attributes(attrs -> attrs.put("sub", "my-subject"))));
----

[source,java]
----
mvc.perform(get("/endpoint")
        .with(oauth2Login()
                .attributes(attrs -> attrs.remove("some_claim"))));
----

默认情况下， `oauth2User()`  添加一个 `SCOPE_read` `GrantedAuthority`。 但是，可以通过提供测试所需的 `GrantedAuthority` 实例列表来覆盖此方法：

[source,java]
----
mvc
    .perform(get("/endpoint")
        .with(oauth2Login().authorities(new SimpleGrantedAuthority("SCOPE_messages"))));
----

或者，您可以通过 `OAuth2User` 实例提供所有详细信息，如下所示：

[source,java]
----
mvc.perform(get("/endpoint")
        .with(oauth2Login().oauth2User(new MyOAuth2User())));
----

[[testing-oauth2-client]]
==== Testing OAuth 2.0 Clients

Independent of how your user authenticates, there may be other OAuth 2.0 tokens that the request will need in order to communicate with resource servers, say in an integration test.

If you need to express an OAuth 2.0 client in your test, then you can use the `oauth2Client()` `RequestPostProcessor` to configure a `MockMvc` request with an authorized client.
The simplest of these would look something like this:

[source,java]
----
mvc.perform(get("/endpoint").with(oauth2Client()));
----

What this will do is create a mock `OAuth2AuthorizedClient`, passing it correctly through any authentication APIs.
It contains a mock `ClientRegistration` and associated access token.
It will register this `ClientRegistration` and access token in an `HttpSessionOAuth2AuthorizedClientRepository`.

By default, the access token contains only the `scope` attribute:

[source,json]
----
{
  "scope" : "read"
}
----

And the resulting `OAuth2AuthorizedClient`, were it tested, would pass in the following way:

[source,java]
----
assertThat(client.getClientRegistration().getRegistrationId()).isEqualTo("test");
assertThat(client.getAccessToken().getTokenValue()).isEqualTo("access-token");
assertThat(client.getPrincipalName()).isEqualTo("user");
----

These values can, of course, be configured.

Any client details can be configured via the `ClientRegistration.Builder` like so:

[source,java]
----
mvc.perform(get("/endpoint")
        .with(oauth2Client()
                .clientRegistration(client -> client.clientId("client-id"));
----

To supply the corresponding token, invoke `accessToken()` like this:

[source,java]
----
mvc.perform(get("/endpoint")
        .with(oauth2Client()
                .accessToken(new OAuth2AccessToken(BEARER, "my-value", issuedAt, expiresAt, scopes))));
----

===== `ClientRegistrationRepository` and `OAuth2AuthorizedClientRepository`

Under many circumstances, you will need to supply a registration id so that it can be looked up by exchange filter functions or `@RegisteredOAuth2AuthorizedClient` annotations.
For this reason, `oauth2Client()` ships with a convenience method:

[source,java]
----
mvc.perform(get("/endpoint").with(oauth2Client("facebook"));
----

This, however, doesn't know about your application's `ClientRegistrationRepository`, so calling this does not look up your "facebook" client registration for you.

To configure a test with an actual `ClientRegistration` from your `ClientRegistrationRepository` you can do:

[source,java]
----
@Autowired
ClientRegistrationRepository clientRegistrationRepository;

// ...

mvc.perform(get("/endpoint")
        .with(oauth2Client()
                .clientRegistration(this.clientRegistrationRepository.findByRegistrationId("facebook"))));
----

Also, `oauth2Client()` doesn't know about your application's `OAuth2AuthorizedClientRepository`, which is what Spring Security uses to resolve `@RegisteredOAuth2AuthorizedClient` annotations.
To make it available in your controllers, your app will need to be using an `HttpSessionOAuth2AuthorizedClientRepository` so that the token can be retrieved in a thread-safe way.

You can isolate this configuration to your test via a test configuration like the following:

[source,java]
----
@TestConfiguration
static class TestAuthorizedClientRepositoryConfig {
    @Bean
    OAuth2AuthorizedClientRepository authorizedClientRepository() {
        return new HttpSessionOAuth2AuthorizedClientRepository();
    }
}
----

[[testing-jwt]]
==== Testing JWT Authentication

In order to make an authorized request on a resource server, you need a bearer token.

If your resource server is configured for JWTs, then this would mean that the bearer token needs to be signed and then encoded according to the JWT specification.
All of this can be quite daunting, especially when this isn't the focus of your test.

Fortunately, there are a number of simple ways that you can overcome this difficulty and allow your tests to focus on authorization and not on representing bearer tokens.
We'll look at two of them now:

===== `jwt() RequestPostProcessor`

The first way is via a `RequestPostProcessor`.
The simplest of these would look something like this:

[source,java]
----
mvc
    .perform(get("/endpoint").with(jwt()));
----

What this will do is create a mock `Jwt`, passing it correctly through any authentication APIs so that it's available for your authorization mechanisms to verify.

By default, the `JWT` that it creates has the following characteristics:

[source,json]
----
{
  "headers" : { "alg" : "none" },
  "claims" : {
    "sub" : "user",
    "scope" : "read"
  }
}
----

And the resulting `Jwt`, were it tested, would pass in the following way:

[source,java]
----
assertThat(jwt.getTokenValue()).isEqualTo("token");
assertThat(jwt.getHeaders().get("alg")).isEqualTo("none");
assertThat(jwt.getSubject()).isEqualTo("sub");
GrantedAuthority authority = jwt.getAuthorities().iterator().next();
assertThat(authority.getAuthority()).isEqualTo("read");
----

These values can, of course be configured.

Any headers or claims can be configured with their corresponding methods:

[source,java]
----
mvc
    .perform(get("/endpoint")
        .with(jwt().jwt(jwt -> jwt.header("kid", "one").claim("iss", "https://idp.example.org"))));
----

[source,java]
----
mvc
    .perform(get("/endpoint")
        .with(jwt().jwt(jwt -> jwt.claims(claims -> claims.remove("scope")))));
----

The `scope` and `scp` claims are processed the same way here as they are in a normal bearer token request.
However, this can be overridden simply by providing the list of `GrantedAuthority` instances that you need for your test:

[source,java]
----
mvc
    .perform(get("/endpoint")
        .with(jwt().authorities(new SimpleGrantedAuthority("SCOPE_messages"))));
----

Or, if you have a custom `Jwt` to `Collection<GrantedAuthority>` converter, you can also use that to derive the authorities:

[source,java]
----
mvc
    .perform(get("/endpoint")
        .with(jwt().authorities(new MyConverter())));
----

You can also specify a complete `Jwt`, for which `{security-api-url}org/springframework/security/oauth2/jwt/Jwt.Builder.html[Jwt.Builder]` comes quite handy:

[source,java]
----
Jwt jwt = Jwt.withTokenValue("token")
    .header("alg", "none")
    .claim("sub", "user")
    .claim("scope", "read");

mvc
    .perform(get("/endpoint")
        .with(jwt().jwt(jwt)));
----

===== `authentication()` `RequestPostProcessor`

The second way is by using the `authentication()` `RequestPostProcessor`.
Essentially, you can instantiate your own `JwtAuthenticationToken` and provide it in your test, like so:

[source,java]
----
Jwt jwt = Jwt.withTokenValue("token")
    .header("alg", "none")
    .claim("sub", "user")
    .build();
Collection<GrantedAuthority> authorities = AuthorityUtils.createAuthorityList("SCOPE_read");
JwtAuthenticationToken token = new JwtAuthenticationToken(jwt, authorities);

mvc
    .perform(get("/endpoint")
        .with(authentication(token)));
----

Note that as an alternative to these, you can also mock the `JwtDecoder` bean itself with a `@MockBean` annotation.

[[testing-opaque-token]]
==== Testing Opaque Token Authentication

Or, if your resource server is configured for opaque tokens, then this would mean that the bearer token needs to be registered with and verified against an authorization server.
This can be just as distracting as creating a signed JWT.

There are two simple ways that you can overcome this difficulty and allow your tests to focus on authorization and not on representing bearer tokens.
Let's take a look:

===== `opaqueToken()` `RequestPostProcessor`

The first way is via a `RequestPostProcessor`.
The simplest of these would look something like this:

[source,java]
----
mvc.perform(get("/endpoint").with(opaqueToken()));
----

What this will do is create a mock `OAuth2AuthenticatedPrincipal`, passing it correctly through any authentication APIs so that it's available for your authorization mechanisms to verify.

By default, the set of attributes that it creates is like this:

[source,json]
----
{
  "sub" : "user",
  "scope" : "read"
}
----

And the resulting `OAuth2AuthenticatedPrincipal`, were it tested, would pass in the following way:

[source,java]
----
assertThat(principal.getAttribute("sub")).isEqualTo("user");
GrantedAuthority authority = principal.getAuthorities().iterator().next();
assertThat(authority.getAuthority()).isEqualTo("SCOPE_read");
----

These values can, of course be configured.

Any attributes can be configured via an underlying `Map`:

[source,java]
----
mvc.perform(get("/endpoint")
        .with(opaqueToken().attributes(attrs -> attrs
                .put("sub", "my-subject")
                .put("my-claim", "my-value"))));
----

[source,java]
----
mvc.perform(get("/endpoint")
        .with(opaqueToken().attributes(attrs -> attrs
                .remove("scope"))));
----

The `scope` attribute is processed the same way here as it is in a normal bearer token request.
However, this can be overridden simply by providing the list of `GrantedAuthority` instances that you need for your test:

[source,java]
----
mvc.perform(get("/endpoint")
        .with(opaqueToken().authorities(new SimpleGrantedAuthority("SCOPE_messages"))));
----

Or, you can supply all detail via an instance of `OAuth2AuthenticatedPrincipal` like so:

[source,java]
----
mvc.perform(get("/endpoint")
        .with(opaqueToken().principal(new MyAuthenticatedPrincipal())));
----

===== `authentication()` `RequestPostProcessor`

The second way is by using the `authentication()` `RequestPostProcessor`.
Essentially, you can instantiate your own `BearerTokenAuthentication` and provide it in your test, like so:

[source,java]
----
Map<String, Object> attributes = Collections.singletonMap("sub", "user");
OAuth2AccessToken accessToken = new OAuth2AccessToken(BEARER, "token", null, null);
Collection<GrantedAuthority> authorities = AuthorityUtils.createAuthorityList("SCOPE_read");
OAuth2AuthenticatedPrincipal principal = new DefaultOAuth2AuthenticatedPrincipal(attributes, authorities);

BearerTokenAuthentication token = new BearerTokenAuthentication(attributes, accessToken, authorities);

mvc.perform(get("/endpoint")
        .with(authentication(token)));
----

Note that as an alternative to these, you can also mock the `OpaqueTokenIntrospector` bean itself with a `@MockBean` annotation.

[[test-logout]]
==== Testing Logout

While fairly trivial using standard Spring MVC Test, you can use Spring Security's testing support to make testing log out easier.
For example, the following will submit a POST to "/logout" with a valid CSRF token:

[source,java]
----
mvc
	.perform(logout())
----

You can also customize the URL to post to.
For example, the snippet below will submit a POST to "/signout" with a valid CSRF token:

[source,java]
----
mvc
	.perform(logout("/signout"))
----

=== SecurityMockMvcResultMatchers

At times it is desirable to make various security related assertions about a request.
To accommodate this need, Spring Security Test support implements Spring MVC Test's `ResultMatcher` interface.
In order to use Spring Security's `ResultMatcher` implementations ensure the following static import is used:

[source,java]
----
import static org.springframework.security.test.web.servlet.response.SecurityMockMvcResultMatchers.*;
----

==== Unauthenticated Assertion

At times it may be valuable to assert that there is no authenticated user associated with the result of a `MockMvc` invocation.
For example, you might want to test submitting an invalid username and password and verify that no user is authenticated.
You can easily do this with Spring Security's testing support using something like the following:

[source,java]
----
mvc
	.perform(formLogin().password("invalid"))
	.andExpect(unauthenticated());
----

==== Authenticated Assertion

It is often times that we must assert that an authenticated user exists.
For example, we may want to verify that we authenticated successfully.
We could verify that a form based login was successful with the following snippet of code:

[source,java]
----
mvc
	.perform(formLogin())
	.andExpect(authenticated());
----

If we wanted to assert the roles of the user, we could refine our previous code as shown below:

[source,java]
----
mvc
	.perform(formLogin().user("admin"))
	.andExpect(authenticated().withRoles("USER","ADMIN"));
----

Alternatively, we could verify the username:

[source,java]
----
mvc
	.perform(formLogin().user("admin"))
	.andExpect(authenticated().withUsername("admin"));
----

We can also combine the assertions:

[source,java]
----
mvc
	.perform(formLogin().user("admin").roles("USER","ADMIN"))
	.andExpect(authenticated().withUsername("admin"));
----

We can also make arbitrary assertions on the authentication

[source,java]
----
mvc
	.perform(formLogin())
	.andExpect(authenticated().withAuthentication(auth ->
		assertThat(auth).isInstanceOf(UsernamePasswordAuthenticationToken.class)));
----
