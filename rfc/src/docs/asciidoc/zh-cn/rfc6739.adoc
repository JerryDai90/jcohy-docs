= rfc6749 - OAuth 2.0 授权框架

原文链接: https://tools.ietf.org/html/rfc6749[https://tools.ietf.org/html/rfc6749]

[NOTE]
====
摘要

OAuth 2.0 授权框架允许第三方应用程序通过如下任意一种方式获取有限制的访问：

* 第三方应用代表资源拥有者发起在资源拥有者和HTTP服务之间的互动。
* 第三方应用通过其身份来获取访问权限。

本文取代并淘汰了在 {ietf-rfc}/rfc5849[RFC 5849] 中所描述的的 OAuth 1.0 协议。
====

[NOTE]
====
本备忘录的状态：
这是 Internet 标准跟踪文档。

本文档是 Internet 工程任务组（IETF）的产品。它代表了 IETF 社区的共识。它获得了公众审查，并已获得互联网工程指导小组（IESG）批准发布。有关 Internet 标准的更多信息，请参见 {ietf-rfc}/rfc5741#section-2[RFC 5741的第2节]。
有关本文档当前状态，任何勘误以及如何提供反馈的信息，请访问 http://www.rfc-editor.org/info/rfc6749。
====

[NOTE]
====
版权声明

IETF Trust 及标识为本文档的作者的个人版权所有（c）2012。保留所有权利。

本文档受 https://tools.ietf.org/html/bcp78[BCP 78] 和 IETF Trust 文档的法律条款 (http://trustee.ietf.org/license-info[http://trustee.ietf.org/license-info]) 的约束，自本文档发布之日起生效。请仔细查阅这些文件，因为它们描述了与本文档有关的权利和限制。

从本文档中提取的代码组件必须按 Trust 的法律条款 4.e 节所述包括简化 BSD 许可证文本；并且按简化BSD许可证中所述不附带质量保证。
====

[[introduction]]
== 介绍

在传统的 C/S 身份验证模型中，客户端通过使用资源所有者的凭据向服务器进行身份验证来请求服务器上的访问受限资源（受保护资源）。 为了向第三方应用程序能够访问受限资源，资源所有者需要与第三方共享其凭据。 这会产生一些问题和局限：

* 为了将来的需要，第三方程序需要存储资源拥有者的凭据（通常为明文密码）
* 即使密码验证存在安全漏洞，服务器仍然需要支持它
* 第三方程序对资源拥有者的受保护资源拥有过于宽泛的权限，同时资源拥有者也没有能力对第三方程序进行限制（如限制第三方程序仅访问部分资源，或限制第三方程序的访问时间等）
* 资源拥有者必须通过更改密码来撤销第三方应用的权限。并且不能对单个第三方应用撤权（一旦更改密码，所有之前授予权限的第三方应用程序都要重新授权）
* 任意第三方应用的泄密都会导致终端用户的密码和受该密码保护的所有数据泄密。

OAuth 通过引入授权层并将客户端的角色与资源所有者的角色分开来解决这些问题。在 OAuth 中，客户端请求访问由资源所有者拥有并由资源服务器托管的资源，并向其颁发与资源所有者不同的凭据集。

客户端通过获取访问令牌而不是使用资源拥有者的凭据来访问受限资源。访问令牌是一个表示特定范围，生命周期和其他访问属性的字符串。授权服务器在资源所有者的批准下才会向第三方客户端颁发访问令牌。客户端使用访问令牌来访问资源服务器托管的受保护资源。

例如，一个终端用户（资源拥有者）可以授权打印服务（客户端）访问存储在照片共享服务（资源服务器）中的受保护照片，而无需与打印服务共享其用户名和密码。相反，她直接使用照片共享服务信任的服务器（授权服务器）进行身份验证，该服务器向打印服务发放特定凭证（访问令牌）。

此规范旨在与 HTTP（{ietf-rfc}/rfc2616[RFC2616]）一起使用。在 HTTP 之外的任何协议上使用 OAuth 都超出了本规范的范围。

作为信息文档发布的 OAuth 1.0 协议（{ietf-rfc}/rfc5849}[RFC5849]）是一个小型临时社区工作的结果。此标准跟踪规范建立在 OAuth 1.0 部署经验的基础上，以及从更广泛的 IETF 社区收集的其他用例和可扩展性要求。OAuth 2.0 协议与 OAuth 1.0 不向后兼容。
这两个版本可以在网络上共存，并且实现可以选择支持两者。但是，本规范的目的是所有的新系统均采用 OAuth2.0，OAuth1.0 仅用于支持已经部署的系统。OAuth 2.0 协议与 OAuth 1.0 协议共享的实现细节很少，所以熟悉 OAuth 1.0 的实施者不应该对本规范的结构和细节进行臆测。

[[introduction-roles]]
=== 角色

OAuth定义了四个角色：

资源所有者(resource owner)::
能够对受保护资源授予访问权限的实体。当资源所有者是一个人时，它被称为终端用户。
资源服务器（resource server）::
托管受保护资源的服务器，能够接受和响应通过令牌对受保护的资源的请求。
客户端（client）::
代表资源所有者及其授权进行受保护资源请求的应用程序。术语“客户端”并不暗示任何特定的实现特征（例如，应用程序是在服务器，台式机还是其他设备上执行）。
授权服务器（authorization server）::
成功后，服务器向客户端发出访问令牌验证资源所有者并获得授权。

授权服务器和资源服务器之间的交互超出了本规范的范围。授权服务器可以是与资源服务器相同的服务器或单独的实体。单个授权服务器可以发出可以被多个资源服务器接受的访问令牌。

[[introduction-protocol-flow]]
=== 协议流程

[source,text]
====
     +--------+                               +---------------+
     |        |--(A)- Authorization Request ->|   Resource    |
     |        |                               |     Owner     |
     |        |<-(B)-- Authorization Grant ---|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(C)-- Authorization Grant -->| Authorization |
     | Client |                               |     Server    |
     |        |<-(D)----- Access Token -------|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(E)----- Access Token ------>|    Resource   |
     |        |                               |     Server    |
     |        |<-(F)--- Protected Resource ---|               |
     +--------+                               +---------------+

                     图 1: Abstract Protocol Flow
====

Figure 1中所示的抽象 OAuth 2.0 流程描述了四个角色之间的交互。包括以下步骤：

[upperalpha]
. 客户端请求资源所有者授权。该授权请求可以直接直接呈现给资源拥有者，也可间接地通过授权服务器进行（例如跳转到授权服务器）。
. 客户端收到授权许可，即表示资源所有者授权的凭证，使用本规范中定义的四种授权类型之一或使用扩展授权类型表示。授权许可类型取决于客户端使用何种方法请求授权服务器，以及授权服务器支持哪些授权类型。
. 客户端通过向授权服务器进行认证并呈现用户赋予的权限来请求 access token。
. 授权服务器验证客户端并验证用户赋予的权限，如果有效，则颁发 access token。
. 客户端从资源服务器请求受保护资源，并通过呈现 access token 进行身份验证。
. 资源服务器验证 access token，如果有效，则为该请求提供服务。

客户端从资源所有者获得授权授权的首选方法（如步骤（A）和（B）所示）是使用授权服务器作为中介，如第 <<obtaining-authorization-authorization-code-grant,4.1 节中的图 3>>所示。

[[introduction-authorization-grant]]
=== 权限授予

权限授予（ Authorization Grant）是资源拥有者同意授权请求（访问受保护资源）的凭据，客户端可以用它来获取 access token。 本规范定义了四种授权(grant)类型 - 授权码模式(authorization code)，简化模式（implicit），密码模式（resource owner password credentials）和客户端模式（client credentials） ，以及用于定义其他类型的可扩展性机制。

[[introduction-authorization-grant-code]]
==== 授权码模式（Authorization Code）

授权码是通过授权服务器来获得的，授权服务器是客户端和资源拥有者之间的媒介。与客户端直接向资源拥有者申请权限不同，客户端通过将资源拥有者引向授权服务器(通过 {ietf-rfc}/rfc2616[RFC 2616]  中定义的 user-agent )，然后授权服务器反过来将资源拥有者 redirect 到 client（附带上 authorization code）。

在将资源拥有者 redirect 到 client（附带 authorization code）之前，授权服务器验证资源拥有者并获取授权。因为资源拥有者仅与授权服务器进行身份验证，所以资源拥有者的凭据（用户名、密码等）永远不会泄露给客户端（尤其是第三方客户端）。

授权码有一些重要的安全优势，比如验证 client 的能力，比如直接将 access token 传送给 client 而不是通过资源拥有者的 user-agent（可能会将token泄露给第三方）。

[[introduction-authorization-grant-implicit]]
==== 简化模式（implicit）

简化模式是为在浏览器中使用诸如 JavaScript 之类的脚本语言而优化的一种简化的授权码流程。在简化模式中，直接将 access token 而不是 authorization code 颁发给 client（通过资源拥有者的授权）。grant 类型为 implicit，所以没有中间环节（比如用来在稍后获取 access token 的 authorization code）

在简化模式中颁发 access token 时，授权服务器没有对 client 进行验证。在某些情况下，可以通过用来获取 access token 的重定向 URI 来验证 client。access token 可以通过访问资源拥有者的 user-agent 暴露给资源拥有者或者其他的应用。

由于简化模式减少了获取 access token 的往返次数，所以可以提高某些客户端的响应能力和效率（比如一个运行在浏览器中的应用）。但是，应该权衡使用简化模式所带来的便捷性与其带来的安全隐患之间的利害关系（在 <<access-tokens,10.3>> 和 <<implic-access-tokens,10.16>> 中有描述），尤其是授权码模式可用时。

[[introduction-authorization-grant-password]]
==== 密码模式（resource owner password credentials）

资源拥有者密码凭据（如用户名和密码）可以用来直接用来当做一种获取 access token 的权限授予方式。凭据仅应当在资源拥有者高度信任 client 时使用（比如，应用是设备操作系统的一部分，或有较高权限的应用），并且其他授权模式（比如授权码模式）不可用时。

尽管这种授权类型需要 client 直接接触资源拥有者的凭据，资源拥有者的凭据仅被用于单次的获取 access token 的请求。通过使用用户凭据来交换具有较长寿命的 access token 或者 refresh token，这种授权模式可消除 client 在将来需要授权时对资源拥有者凭据的需求（就是说，这次通过用户凭据获取了 access token，以后就可以直接通过 access token 而不是用户凭据来访问受限资源了）。

[[introduction-authorization-grant-client]]
==== 客户端模式（client credentials）

当授权范围限于客户端控制下的受保护资源或先前与授权服务器一起安排的受保护资源时，client 凭据（或其他形式的客户端身份验证）可用作权限授予。客户端凭证通常是在客户端代表自己（客户端也是资源所有者）或基于先前与授权服务器一起安排的授权请求访问受保护资源时用作权限授予。

[[introduction-access-token]]
=== 访问令牌（Access Token）

access token是用来访问受限资源的凭据。access token 是一个代表授予 client 的权限的字符串。该字符串通常对 client 不透明。token 表示特定范围和持续时间的访问权限，由资源所有者授予，由资源服务器和授权服务器执行。

令牌可以表示用于检索授权信息的标识符，或者可以以可验证的方式自包含授权信息（即，由一些数据和签名组成的令牌串）。client 可能需要额外的身份验证凭据（超出本规范的范围）来使用令牌。

访问令牌提供一个使用单个的资源服务器可以理解的令牌来替换其他不同的身份验证方式（如用户名+密码方式）的抽象层。这种抽象使得颁发访问令牌比用于获取它们的权限授予更具限制性，并且消除了资源服务器理解各种不同身份验证方法的需要。

访问令牌可以具有基于资源服务器安全性要求的不同格式，结构和使用方法（例如，加密属性）。访问令牌属性和用于访问受保护资源的方法超出了本规范的范围，并由协同规范（如 {ietf-rfc}/rfc6750[RFC6750]）定义。

[[introduction-refresh-token]]
=== 刷新令牌（Refresh Token）

refresh token 是用于获取 access token 的凭据。refresh token 由授权服务器颁发给 client，用于在当前访问令牌变为无效或过期时获取新的访问令牌，或者获取具有相同或更窄范围的其他访问令牌（访问令牌可能具有更短的生命周期和权限少于资源所有者授权的权限。根据授权服务器的判断，发出刷新令牌是可选的。如果授权服务器发出刷新令牌，则在发出访问令牌时包括它（即图1中的步骤（D））。

刷新令牌是表示资源所有者授予客户端的权限的字符串。该字符串通常对客户端不透明。令牌表示用于检索 授权信息的标识符。与访问令牌不同，刷新令牌仅用于授权服务器，不会发送到资源服务器。

[source,text]
====
  +--------+                                           +---------------+
  |        |--(A)------- Authorization Grant --------->|               |
  |        |                                           |               |
  |        |<-(B)----------- Access Token -------------|               |
  |        |               & Refresh Token             |               |
  |        |                                           |               |
  |        |                            +----------+   |               |
  |        |--(C)---- Access Token ---->|          |   |               |
  |        |                            |          |   |               |
  |        |<-(D)- Protected Resource --| Resource |   | Authorization |
  | Client |                            |  Server  |   |     Server    |
  |        |--(E)---- Access Token ---->|          |   |               |
  |        |                            |          |   |               |
  |        |<-(F)- Invalid Token Error -|          |   |               |
  |        |                            +----------+   |               |
  |        |                                           |               |
  |        |--(G)----------- Refresh Token ----------->|               |
  |        |                                           |               |
  |        |<-(H)----------- Access Token -------------|               |
  +--------+           & Optional Refresh Token        +---------------+

               图 2: Refreshing an Expired Access Token
====

图2所示的流程包括以下步骤：

[upperalpha]
. 客户端通过向授权服务器进行认证、发起权限授予来获取 access token。
. 授权服务器验证客户端并验证权限授予授权，如果有效，则颁发访问令牌和刷新令牌。
. 客户端通过呈现访问令牌向资源服务器发出受保护的资源请求。
. 资源服务器验证访问令牌，如果有效，则为请求提供服务。
. 重复步骤（C）和（D）直到访问令牌到期。如果客户端知道访问令牌已过期，则跳到步骤（G）;否则，它会生成另一个受保护的资源请求
. 由于访问令牌无效，资源服务器返回无效的令牌错误。
. 客户端通过向授权服务器进行身份验证并显示刷新令牌来请求新的访问令牌。该客户端身份验证的要求是基于客户端类型和授权服务器策略。
. 授权服务器验证客户端并验证刷新令牌，如果有效，则发出新的访问令牌（以及可选的新刷新令牌）。

步骤（C），（D），（E）和（F）不属于规范的范围，如 <<accessing-protected-resources,第7节所述>>。

[[introduction-tls-version]]
=== TLS 版本

由于广泛的部署和已知的安全性漏洞，当本规范使用安全传输层协议（TLS）时可能存在不同的适用版本。在本协议发表时，TLS v1.2 {ietf-rfc}/rfc5246[RFC5246] 是最新版本，但是部署基础非常有限，可能无法实现。TLS v1.0 {ietf-rfc}/rfc2246[RFC2246]是最广泛的部署版本并将提供最广泛的互操作性。
实现还可以支持满足其安全要求的其他传输层安全机制。

[[introduction-http-redirections]]
=== HTTP 重定向

在 client 话说授权服务器将 user-agent 导向另一个目的地时，本规范广泛地使用了 HTTP 重定向。虽然本规范中的示例使用 HTTP 302 状态代码进行重定向，但是允许其他的实现通过其他方法实现重定向，这也被认为是实现细节的一部分。

[[introduction-interoperability]]
=== 互通性

OAuth 2.0 提供了一个具有明确定义的具有丰富的安全属性的授权框架。但是，作为一个具有许多可选组件的丰富且高度可扩展的框架，该规范本身可能会产生各种不可互操作的实现。

此外，对于一些组件，本规范仅有部分定义或完全未定义（例如，客户端注册，授权服务器功能，endpoint 发现）。如果没有这些组件，客户端必须专门手动地针对特定授权服务器和资源服务器进行配置以进行互操作。

该框架的设计明确期望未来的工作将定义实现完整的Web级互操作性所必需的规范性配置文件和扩展。

[[introduction-notational-conventions]]
=== 符号约定(Notational Conventions)

本规范中的关键字 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", 和 "OPTIONAL" 应按 {ietf-rfc}/rfc2119[RFC2119] 中所述进行解释。

[[client-registration]]
== 客户端注册

在启动协议之前，client 向授权服务器注册。client 注册的方式使用授权服务器超出了本规范的范围，但通常涉及终端用户与 HTML 注册表单的交互。

客户端注册不需要客户端和授权服务器之间的直接交互。当授权服务器支持时，注册可以依赖于其他方式来建立信任并获得所需的客户端属性（例如，重定向 URI，客户端类型）。例如，可以使用自发布或第三方发布的断言来完成注册，或者通过使用 可信通道执行客户端发现的授权服务器来完成注册。

注册客户端时，客户端开发人员应该：

* 指定 <<client-registration-client-types,如第2.1节所述的客户端类型>>
* 提供如 <<protocol-endpoints-authorization-endpoint-redirection-endpoint,第3.1.2节所述>>的 client 重定向 URI， 以及
* 包含授权服务器所需的任何其他信息（例如，应用程序名称，网站，描述，徽标图像，所接受的法律条款）。

[[client-registration-client-types]]
=== 客户端类型（Client Types）

OAuth 根据其与授权服务器进行安全身份验证的能力定义了两种客户端类型（即，保证其客户凭证的机密性的能力）：

机密::
客户端能够维护其凭证的机密性（例如，在具有对客户端凭证具有受限访问的安全服务器上实现的客户端），或能够使用其他方式进行安全的客户端认证。

公开::
客户端无法维护其凭据的机密性（例如，在资源所有者使用的设备上执行的客户端，例如已安装的本机应用程序或基于Web 浏览器的应用程序），并且无法通过任何其他方式进行安全的客户端身份验证。

客户端类型标识基于授权服务器的安全身份验证定义及其可接受的客户端凭据暴露级别。授权服务器不应该对客户端类型做出假设。

客户端可以被实现为分布式组件集，每个组件具有不同的客户端类型和安全性上下文（例如，具有基于机密服务器的组件和基于公共浏览器的组件的分布式客户端）。如果授权服务器不提供对此类客户端的支持或不提供有关其注册的指导，则客户端应该将每个组件注册为单独的客户端。

此规范是围绕以下客户端配置设计的：

Web应用程序::
Web应用程序是在Web 服务器上运行的机密客户端。资源所有者通过在资源所有者使用的设备上的用户代理中呈现的HTML用户界面来访问客户端。客户端凭据以及发布到客户端的任何访问令牌都存储在Web服务器上，不会向资源所有者公开或访问。

基于用户代理的应用程序::
基于用户代理的应用程序是公共客户端，其中客户端代码从web服务器下载并在资源所有者使用的设备上的用户代理（例如，web浏览器）内执行。协议数据和凭证可以轻松访问（并且通常可见）资源所有者。由于此类应用程序驻留在用户代理中，因此它们可以在请求授权时无缝使用用户代理功能。

本机应用程序::
本机应用程序是在资源所有者使用的设备上安装和执行的公共客户端。资源所有者可以访问协议数据和凭证。这是假设的可以提取应用程序中包含的任何客户端身份验证凭据。另一方面，动态发布的凭证（例如访问令牌或刷新令牌）可以获得可接受的保护级别。至少，这些凭据受到保护，从而免受应用程序可能与之交互的恶意服务器的影响。在某些平台上，可能会保护这些凭据免受驻留在同一设备上的其他应用程序的影响。

[[client-registration-client-identifier]]
=== 客户端标识（Client Identifier）

授权服务器向已注册的 client 颁发 client identifier – 一个代表该 client 注册信息的唯一字符串。client identifier 不需要保密，它被暴露给资源拥有者并且禁止单独用于 client 认证。客户端标识符对于授权服务器是唯一的。
本规范未定义 client identifier 字符串的大小。客户端应避免对标识符大小进行假设。授权服务器应该记录它发出的任何标识符的大小。

[[client-registration-client-authentication]]
=== 客户端认证（Client Authentication）

如果客户端类型是机密的，则客户端和授权服务器建立适合授权服务器的安全性要求的客户端认证方法。授权服务器可以接受满足其安全要求的任何形式的客户端身份验证。

机密客户端通常被颁发（或建立）用于与授权服务器进行认证的一组客户机凭证（例如，密码，公钥/私钥对）。

授权服务器可以与公共客户端建立客户端身份验证方法。但是，授权服务器不得依赖公共客户端身份验证来识别客户端。

客户端在每个请求中最多使用一种身份验证方法。

[[client-registration-client-authentication-password]]
==== 客户端密码（Client Password）

拥有客户端密码的客户端可以使用 {ietf-rfc}/rfc2617[RFC2617] 中定义的 HTTP Basic 身份验证方案向授权服务器进行身份验证。使用 <<appendix-B>> 编码算法对客户端标识符进行编码，
并将编码 value 用作 username;客户端密码使用相同的算法进行编码并用作 password。授权服务器必须支持HTTP基本身份验证方案，以便对发出客户端密码的客户端进行身份验证。

例如（额外换行符仅用于排版目的）：

[source,text]
====
Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3
====

或者，授权服务器可以选择支持在请求体中包含如下参数的客户端凭据：

client_id::
REQUIRED.在 <<client-registration-client-identifier,2.2节>>描述的注册过程中发给客户端的客户端标识符。

client_secret::
REQUIRED. The client secret. 如果客户端密钥是空字符串，则客户端可以省略该参数。

使用这两个参数在请求体中包含客户端凭证是不推荐的，并且应该仅限于无法直接使用 HTTP 基本身份验证方案（或其他基于密码的 HTTP 身份验证方案）的客户端。参数只能在请求体中传输，绝不能包含在请求 URI 中。

例如，使用 body 参数刷新访问令牌（<<refreshing-an-access-token,第6节>>）的 HTTP 请求（额外换行符仅用于排版目的）：

[source,text]
====
     POST /token HTTP/1.1
     Host: server.example.com
     Content-Type: application/x-www-form-urlencoded

     grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
     &client_id=s6BhdRkqt3&client_secret=7Fjfp0ZBr1KtDRbnfVdmIw
====

当使用密码验证发送请求时，授权服务器必须要求使用 <<introduction-tls-version,如1.6节所述的TLS>>。

由于此客户端身份验证方法涉及密码，因此授权服务器必须保护使用它的任何 endpoint 免受穷举攻击。

[[client-registration-client-authentication-other]]
==== 其他认证方法
授权服务器可以支持符合其安全要求的任何合适的HTTP认证方案。使用其他身份验证方法时，授权服务器必须定义客户端标识符（注册记录）和身份验证方案之间的映射。

[[client-registration-unregistered-clients]]
=== 未注册的客户端

此规范不排除使用未注册的客户端。但是，此类客户端的使用超出了本规范的范围，需要进行额外的安全性分析并检查其互操作性影响。

[[protocol-endpoints]]
== 协议端点（Protocol Endpoints）

授权过程使用两个授权服务器端点（HTTP资源）：

Authorization endpoint::
客户端使用该端点通过用户代理重定向从资源所有者获取授权。

Token endpoint::
客户端用于通过 user-agent redirection 从资源所有者获取授权。

以及一个客户端端点：

Redirection endpoint::
授权服务器用于通过资源所有者 user-agent将包含授权凭据的响应返回给客户端。

并非每种授权授权类型都使用两个端点。扩展授权类型可以根据需要定义其他端点。

[[protocol-endpoints-authorization-endpoint]]
=== 授权端点（Authorization endpoint）

授权端点用于与资源所有者交互并获得权限授予。 授权服务器必须首先验证资源所有者的身份。 授权服务器验证资源所有者的方式（例如，用户名和密码登录，会话 cookie）超出了本规范的范围。

客户端获取授权端点位置的方法超出了本规范的范围，因为这个位置通常由服务文档提供。

端点 URI 可以包括 `application/x-www-form-urlencoded` 格式（根据 <<appendix-B,附录B>>）的查询组件（{ietf-rfc}/rfc3986#section-3.4[RFC3986第3.4节]），并且在添加其他查询参数时该组件必须保留。端点 URI 绝不能包含片段组件。

由于对授权端点的请求导致用户身份验证和凭据的明文传输（在HTTP响应中），在向授权端点发送请求时，授权服务器必须使用 <<introduction-tls-version,第1.6节中所述的 TLS>>。对于没有值的参数，必须当作在请求中省略了该参数。授权服务器必须忽略无法识别的请求参数。请求和响应参数不得被包含多次。

授权服务器必须支持对授权端点使用 HTTP "GET" 方法 {ietf-rfc}/rfc2616[RFC2616]，并且也可以支持使用 "POST" 方法。

如果请求参数没有携带任何值，则必须忽略。授权服务器必须忽略 无法识别的请求参数。请求和响应参数 不得超过一次。

[[protocol-endpoints-authorization-endpoint-response-type]]
==== 响应类型

授权终端由授权代码模式和简化授权模式的工作流中使用。客户端使用以下参数通知授权服务器所需的授权类型：

response_type::
REQUIRED. 值必须是用于请求如 <<code-authorization-request,如第4.1.1节所述>>授权码的 "code" 或者 <<implicit-authorization-request,如4.2.1节所述>>用于请求访问令牌（简化授权）的 "token" ，或者注册的扩展值，如 <<new-response-type,第8.4节>>。

扩展响应类型可以包含空格 (%x20) 分隔的值列表，其中值的顺序无关紧要（例如，响应类型 "a b" 与 "b a" 相同）。这种复合响应类型的含义由它们各自的规范定义。

如果授权请求缺少“response_type”参数，或者不理解响应类型，授权服务器必须返回 <<error-response,如第4.1.2.1节>>所述的错误响应。

[[protocol-endpoints-authorization-endpoint-redirection-endpoint]]
==== 重定向端点(Redirection Endpoint)

完成与资源所有者的交互后，授权服务器将资源所有者的用户代理指向客户端。在用户注册过程中或在发出授权请求时，授权服务器将 user-agent 重定向到先前与授权服务器建立的客户端重定向端点。
重定向端点URI必须是 {ietf-rfc}/rfc3986#section-4.3[RFC3986第4.3节] 定义的绝对 URI。端点URI可以包括 `application/x-www-form-urlencoded` 格式的（<<appendix-B,附录B>>）查询组件（{ietf-rfc}/rfc3986#section-3.4[RFC3986第3.4节]），并且在添加其他查询参数时必须保留该组件。端点 URI 绝不能包含片段组件。


[[code-authorization-request]]
==== 授权请求（Authorization Request）

[[error-response]]
===== 错误响应

[[implicit-authorization-request]]
==== 授权请求（Authorization Request）

[[protocol-endpoints-token-endpoint]]
=== Token Endpoint

[[protocol-endpoints-token-endpoint-client-authentication]]
==== 客户端认证

[[protocol-endpoints-access-token-scope]]
=== 访问令牌范围

[[obtaining-authorization]]
== 获取授权


[[obtaining-authorization-authorization-code-grant]]
=== 授权码模式（Authorization Code Grant）


[source,text]
====
     +----------+
     | Resource |
     |   Owner  |
     |          |
     +----------+
          ^
          |
         (B)
     +----|-----+          Client Identifier      +---------------+
     |         -+----(A)-- & Redirection URI ---->|               |
     |  User-   |                                 | Authorization |
     |  Agent  -+----(B)-- User authenticates --->|     Server    |
     |          |                                 |               |
     |         -+----(C)-- Authorization Code ---<|               |
     +-|----|---+                                 +---------------+
       |    |                                         ^      v
      (A)  (C)                                        |      |
       |    |                                         |      |
       ^    v                                         |      |
     +---------+                                      |      |
     |         |>---(D)-- Authorization Code ---------'      |
     |  Client |          & Redirection URI                  |
     |         |                                             |
     |         |<---(E)----- Access Token -------------------'
     +---------+       (w/ Optional Refresh Token)

   Note: The lines illustrating steps (A), (B), and (C) are broken into
   two parts as they pass through the user-agent.

                     图 3: Authorization Code Flow
====

[[obtaining-authorization-implicit-grant]]
=== 简化模式（Implicit Grant）

[[obtaining-authorization-password]]
=== 密码模式（Resource Owner Password Credentials Grant ）

[[obtaining-authorization-client]]
=== 客户端模式（Client Credentials Grant）



[[new-response-type]]
== 定义新的授权端点响应类型



[[access-tokens]]
=== 访问令牌（Access Tokens）

[[implic-access-tokens]]
=== 在简化模式中滥用访问令牌来模拟资源所有者

[[accessing-protected-resources]]
== 访问受保护的资源

[[refreshing-an-access-token]]
== 刷新访问令牌


[[appendix-B]]
== 附录B:使用 application/x-www-form-urlencoded 媒体类型