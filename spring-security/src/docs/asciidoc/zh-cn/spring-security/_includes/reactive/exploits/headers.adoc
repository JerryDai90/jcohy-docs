[[webflux-headers]]
= 安全HTTP响应头
本节讨论Spring Security对在WebFlux响应中添加各种安全头的支持。

== 默认安全头
Spring Security允​​许用户轻松注入默认的安全标头，以帮助保护其应用程序。 Spring Security的默认值为包含以下标头：

[source,http]
----
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Content-Type-Options: nosniff
Strict-Transport-Security: max-age=31536000 ; includeSubDomains
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
----

NOTE: 仅在HTTPS请求上添加严格传输安全性

有关这些标题中的每个标题的更多详细信息，请参阅相应的部分：

* <<webflux-headers-cache-control,Cache Control>>
* <<webflux-headers-content-type-options,Content Type Options>>
* <<webflux-headers-hsts,HTTP Strict Transport Security>>
* <<webflux-headers-frame-options,X-Frame-Options>>
* <<webflux-headers-xss-protection,X-XSS-Protection>>

虽然这些标头中的每一个均被视为最佳实践，但应注意，并非所有客户端都使用标头，因此鼓励进行其他测试。

您可以自定义特定的标题。例如，假设希望您的HTTP响应标头如下所示：

[source,http]
----
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Content-Type-Options: nosniff
X-Frame-Options: SAMEORIGIN
X-XSS-Protection: 1; mode=block
----

具体来说，您希望所有默认标头都具有以下自定义设置：

* <<webflux-headers-frame-options,X-Frame-Options>> 允许来自相同域的任何请求
* <<webflux-headers-hsts,HTTP Strict Transport Security (HSTS)>> 不会添加到响应中

您可以使用以下Java配置轻松完成此操作：

[source,java]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers ->
			headers
				.hsts(hsts ->
					hsts
						.disable()
				)
				.frameOptions(frameOptions ->
					frameOptions
						.mode(Mode.SAMEORIGIN)
				)
		);
	return http.build();
}
----


如果您不想添加默认值，并且希望对应使用的内容进行明确控制，则可以禁用默认值。 下面提供了基于Java和XML的配置示例

I如有必要，可以使用以下Java配置禁用所有HTTP安全响应标头：

[source,java]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers ->
			headers
				.disable()
		);
	return http.build();
}
----

[[webflux-headers-cache-control]]
== Cache Control
过去，Spring Security要求您为Web应用程序提供自己的缓存控件。 当时看来这是合理的，但是浏览器缓存已经演变为包括用于安全连接的缓存。 这意味着用户可以查看经过身份验证的页面，然后注销，然后恶意用户可以使用浏览器历史记录来查看缓存的页面。 为了缓解这种情况，Spring Security添加了缓存控制支持，默认情况下会将以下标头插入响应中。

[source]
----
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
----


如果您确实想缓存特定的响应，则您的应用程序可以有选择地设置缓存控制标头以覆盖Spring Security设置的标头。 这对于确保正确缓存CSS，JavaScript和图像之类的内容很有用。

您还可以使用以下Java配置禁用缓存控制：

[source,java]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers ->
			headers
				.cache(cache -> cache.disable())
		);
	return http.build();
}
----

[[webflux-headers-content-type-options]]
== Content Type 选项
历史上，包括Internet Explorer在内的浏览器都会尝试使用 https://en.wikipedia.org/wiki/Content_sniffing[content sniffing] 来猜测请求的内容类型。 这允许浏览器通过猜测未指定内容类型的资源上的内容类型来改善用户体验。 例如，如果浏览器遇到一个未指定内容类型的JavaScript文件，它将能够猜测该内容类型然后执行。

[NOTE]
允许上传内容时，还有许多其他事情（即，仅在不同的域中显示文档，确保设置了Content-Type标头，清理文档等）。 但是，这些措施不在Spring Security提供的范围之内。 指出禁用内容嗅探时也很重要，您必须指定内容类型才能使内容正常工作

内容嗅探的问题在于，这允许恶意用户使用多义词（即，可以作为多种内容类型有效的文件）执行XSS攻击。 例如，某些网站可能允许用户向网站提交有效的附言文档并进行查看。 恶意用户可能会创建一个也是 http://webblaze.cs.berkeley.edu/papers/barth-caballero-song.pdf[有效JavaScript文件的Postscript文档] a，并对其执行XSS攻击。


可以通过在响应中添加以下标头来禁用内容嗅探：

[source]
----
X-Content-Type-Options: nosniff
----

与缓存控制元素一样，默认情况下会添加nosniff指令。但是，如果需要禁用标题，则可以使用以下内容：

[source,java]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers ->
			headers
				.contentTypeOptions(contentTypeOptions -> contentTypeOptions.disable())
		);
	return http.build();
}
----

[[webflux-headers-hsts]]
== HTTP Strict Transport Security (HSTS)
当您输入您的银行的网站，您进入 mybank.example.com 或进入 https://mybank.example.com[] 如果您忽略了 https 协议，您可能会受到 https://en.wikipedia.org/wiki/Man-in-the-middle_attack[中间人攻击]。
即使网站执行重定向到 https://mybank.example.com， 恶意用户也可以截获初始HTTP请求并操纵响应(即重定向到  https://mibank.example.com  并窃取他们的凭证)。

许多用户忽略了https协议，这就是创建HTTP https://tools.ietf.org/html/rfc6797[严格传输安全性（HSTS）]的原因。 将 mybank.example.com 添加为 https://tools.ietf.org/html/rfc6797#section-5.1[HSTS主机] 后，浏览器可以提前知道对 mybank.example.com 的任何请求都应解释为https://mybank.example.com。 这大大降低了发生中间人攻击的可能性。


[NOTE]
==
根据 https://tools.ietf.org/html/rfc6797#section-7.2[RFC6797]，HSTS头仅注入到HTTPS响应中。 为了使浏览器能够确认标头，浏览器必须首先信任对用于建立连接的SSL证书（不仅仅是SSL证书）进行签名的CA。
==

将站点标记为HSTS主机的一种方法是将主机预加载到浏览器中。 另一方法是将“ Strict-Transport-Security”标头添加到响应中。 例如，以下内容将指示浏览器将域视为一年的HSTS主机（一年大约31536000秒）：


[source]
----
Strict-Transport-Security: max-age=31536000 ; includeSubDomains ; preload
----

可选的includeSubDomains指令指示Spring Security子域（即secure.mybank.example.com）也应被视为HSTS域。

可选的preload指令指示Spring Security该域应在浏览器中预加载为HSTS域。 有关HSTS预加载的更多详细信息，请参见 https://hstspreload.org。

与其他头文件一样，Spring Security默认添加HSTS。 您可以使用 <<nsa-hsts,<hsts>>> 元素来自定义HSTS标头，如下所示：

[source,java]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers ->
			headers
				.hsts(hsts ->
					hsts
						.includeSubdomains(true)
						.preload(true)
						.maxAge(Duration.ofDays(365))
				)
		);
	return http.build();
}
----


[[webflux-headers-frame-options]]
== X-Frame-Options
允许将您的网站添加到框架可能是一个安全问题。 例如，使用聪明的CSS样式用户可能会被诱骗点击他们不想要的内容（https://www.youtube.com/watch?v=3mk0RySeNsU[视频演示]）。 例如，登录到其银行的用户可以单击将按钮授予其他用户访问权限。 这种攻击称为 https://en.wikipedia.org/wiki/Clickjacking[Clickjacking]。


[NOTE]
处理点击劫持的另一种现代方法是使用<<headers-csp,第14.2.8节“内容安全策略（CSP）” >>.


有许多方法可以缓解点击劫持攻击。 例如，要保护旧版浏览器免遭点击劫持攻击，可以使用分帧代码。 虽然不完美，但是对于传统浏览器而言， https://www.owasp.org/index.php/Clickjacking_Defense_Cheat_Sheet#Best-for-now_Legacy_Browser_Frame_Breaking_Script[frame breaking code] 是最好的选择。

解决点击劫持的更现代方法是使用 https://developer.mozilla.org/en-US/docs/HTTP/X-Frame-Options[X-Frame-Options]  头：

[source]
----
X-Frame-Options: DENY
----

X-Frame-Options响应标头指示浏览器阻止响应中带有此标头的任何网站呈现在框架中。 默认情况下，Spring Security禁用iframe中的呈现。

您可以使用 <<nsa-frame-options,frame-options>> 元素来自定义X-Frame-Options。

[source,java]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers ->
			headers
				.frameOptions(frameOptions ->
					frameOptions
						.mode(SAMEORIGIN)
				)
		);
	return http.build();
}
----

[[webflux-headers-xss-protection]]
== X-XSS-Protection
一些浏览器内置了对过滤掉 https://www.owasp.org/index.php/Testing_for_Reflected_Cross_site_scripting_(OWASP-DV-001)[reflected XSS attacks]的支持。 这绝非万无一失，但确实有助于XSS保护。

通常默认情况下会启用过滤，因此添加标头通常只会确保标头已启用，并指示浏览器在检测到XSS攻击时应采取的措施。
例如，过滤器可能会尝试以最小侵入性的方式更改内容以仍然呈现所有内容。 有时，这种替换本身可能会成为 https://hackademix.net/2009/11/21/ies-xss-filter-creates-xss-vulnerabilities/[XSS漏洞本身]。 相反，最好是阻止内容，而不要尝试对其进行修复。 为此，我们可以添加以下标头：


[source]
----
X-XSS-Protection: 1; mode=block
----


默认情况下包含此标头。但是，我们可以根据需要自定义它。例如：

[source,java]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers ->
			headers
				.xssProtection(xssProtection -> xssProtection.disable())
		);
	return http.build();
}
----

[[webflux-headers-csp]]
== Content Security Policy (CSP)

https://www.w3.org/TR/CSP2/[Content Security Policy (CSP)] 是Web应用程序可以利用的一种机制，可以缓解诸如跨站点脚本（XSS）之类的内容注入漏洞。 CSP是一种声明性策略，为Web应用程序作者提供了一种工具，可以声明该Web应用程序希望从中加载资源的来源，并最终将这些信息通知客户端（用户代理）。

[NOTE]
==
内容安全策略并非旨在解决所有内容注入漏洞。 取而代之的是，可以利用CSP帮助减少内容注入攻击所造成的危害。 作为第一道防线，Web应用程序作者应验证其输入并对其输出进行编码。
==

Web应用程序可以通过在响应中包括以下HTTP标头之一来使用CSP：

* *_Content-Security-Policy_*
* *_Content-Security-Policy-Report-Only_*

这些标头中的每一个都用作将 *_安全策略传递_* 给客户端的机制。 安全策略包含一组 *_安全策略指令_*（例如 _script-src_ 和 _object-src_ ），每个指令负责声明对特定资源表示形式的限制。

例如，Web应用程序可以通过在响应中包含以下标头来声明它希望从特定的受信任源中加载脚本：

[source]
----
Content-Security-Policy: script-src https://trustedscripts.example.com
----

用户代理会阻止尝试从另一个源（而不是 _script-src_ 指令中声明的内容）加载脚本。 此外，如果在安全策略中声明了  https://www.w3.org/TR/CSP2/#directive-report-uri[*_report-uri_*]  指令，则用户代理会将违反行为报告给声明的URL。

例如，如果Web应用程序违反了已声明的安全策略，则以下响应标头将指示用户代理将违规报告发送到策略的  _report-uri_  指令中指定的URL。

[source]
----
Content-Security-Policy: script-src https://trustedscripts.example.com; report-uri /csp-report-endpoint/
----

https://www.w3.org/TR/CSP2/#violation-reports[*_Violation reports_*] 是标准的JSON结构，可以由Web应用程序自己的API或公共托管的CSP违规报告服务（例如 https://report-uri.io/[*_REPORT-URI_*]）捕获。

Content-Security-Policy-Report-Only标头为Web应用程序作者和管理员提供了监视安全策略而不是强制执行这些策略的功能。 该标题通常在试验和/或开发站点的安全策略时使用。 当某个策略被认为有效时，可以通过使用  _Content-Security-Policy_  标头字段来强制实施。

给定以下响应头，该策略声明可以从两个可能的来源之一加载脚本。

[source]
----
Content-Security-Policy-Report-Only: script-src 'self' https://trustedscripts.example.com; report-uri /csp-report-endpoint/
----

如果站点违反了此策略，则通过尝试从  _evil.com_ 加载脚本，用户代理会将违规报告发送到  _report-uri_  指令指定的声明URL，但是仍然允许违规资源加载。

[[webflux-headers-csp-configure]]
=== 配置内容安全策略

请注意，Spring Security默认不会添加内容安全策略。 Web应用程序作者必须声明安全策略以强制执行和/或监视受保护的资源。

例如，给定以下安全策略：
[source]
----
script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/
----

您可以使用Java配置启用CSP标头，如下所示：

[source,java]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers ->
			headers
				.contentSecurityPolicy(contentSecurityPolicy ->
					contentSecurityPolicy
						.policyDirectives("script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/")
				)
		);
	return http.build();
}
----

要启用CSP _'report-only'_ 标头，请提供以下Java配置：

[source,java]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers ->
			headers
				.contentSecurityPolicy(contentSecurityPolicy ->
					contentSecurityPolicy
						.policyDirectives("script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/")
						.reportOnly()
				)
		);
	return http.build();
}
----

[[webflux-headers-csp-links]]
=== 其他资源

将内容安全策略应用于Web应用程序通常是一项艰巨的任务。 以下资源可以为您的站点制定有效的安全策略提供进一步的帮助。

https://www.html5rocks.com/en/tutorials/security/content-security-policy/[内容安全策略简介]

https://developer.mozilla.org/en-US/docs/Web/Security/CSP[CSP指南-Mozilla开发人员网络]

https://www.w3.org/TR/CSP2/[W3C候选人推荐]

[[webflux-headers-referrer]]
== 推荐人策略

https://www.w3.org/TR/referrer-policy[Referrer Policy] 是一种机制，Web应用程序可以利用该机制来管理引荐来源网址字段，该字段包含用户所在的最后一页。 Spring Security的方法是使用 https://www.w3.org/TR/referrer-policy/[Referrer Policy] 头，该标头提供了不同的 https://www.w3.org/TR/referrer-policy/#referrer-policies[策略]：


[source]
----
Referrer-Policy: same-origin
----

Referrer-Policy响应头指示浏览器让目的地知道用户先前所在的源。

[[webflux-headers-referrer-configure]]
=== 配置推荐人策略

Spring Security默认情况下不添加Referrer Policy标头。
您可以使用Java配置启用Referrer-Policy标头，如下所示：

[source,java]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers ->
			headers
				.referrerPolicy(referrerPolicy ->
					referrerPolicy
						.policy(ReferrerPolicy.SAME_ORIGIN)
				)
		);
	return http.build();
}
----


[[webflux-headers-feature]]
== Feature Policy （功能策略）

https://wicg.github.io/feature-policy/[Feature Policy] 功能策略是一种机制，允许Web开发人员在浏览器中选择性地启用，禁用和修改某些API和Web功能的行为。

[source]
----
Feature-Policy: geolocation 'self'
----

借助功能策略，开发人员可以为浏览器选择一套“策略”，以实施整个站点中使用的特定功能。 这些政策限制了网站可以访问或修改某些功能的浏览器默认行为的API。


[[webflux-headers-feature-configure]]
=== 配置功能策略

Spring Security默认不添加功能策略标头。
您可以使用Java配置启用Feature-Policy标头，如下所示：

[source,java]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers ->
			headers
				.featurePolicy("geolocation 'self'")
		);
	return http.build();
}
----


[[webflux-headers-clearsitedata]]
== 清除站点数据

https://www.w3.org/TR/clear-site-data/[Clear Site Data] 清除站点数据是一种机制，通过该机制，当HTTP响应包含以下标头时，可以删除所有浏览器端数据（Cookie，本地存储等）：

[source]
----
Clear-Site-Data: "cache", "cookies", "storage", "executionContexts"
----

这是注销时执行的不错的清理操作。

[[webflux-headers-clearsitedata-configure]]
=== 配置清除站点数据

Spring Security默认不会添加“清除站点数据”标头。

您可以将应用程序配置为在注销时发送此标头，如下所示：

[source,java]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	ServerLogoutHandler securityContext = new SecurityContextServerLogoutHandler();
	ServerLogoutHandler clearSiteData = new HeaderWriterServerLogoutHandler(new ClearSiteDataServerHttpHeadersWriter());
	DelegatingServerLogoutHandler logoutHandler = new DelegatingServerLogoutHandler(securityContext, clearSiteData);

	http
		// ...
		.logout()
		    .logoutHandler(logoutHandler);
	return http.build();
}
----

[NOTE]
不建议您通过 `headers()` 指令配置此标题编写器。这样做的原因是，将删除任何会话状态（例如  `JSESSIONID` cookie），从而有效地注销用户。
