[[core-services]]
== 核心服务
现在，我们对Spring Security的架构和核心类进行高级别的概述，让我们在一个或两个核心接口及其实现的仔细看看，尤其是 `AuthenticationManager`，`UserDetailsService` 和 `AccessDecisionManager` 这些东西的信息都在这个文档的里面，所以这一点很重要，你要知道他们是如何配置如何操作的。


[[core-services-authentication-manager]]
=== AuthenticationManager, ProviderManager 和 AuthenticationProvider
`AuthenticationManager` 只是一个接口，这样的实现可以是我们选择的任何东西，但它是如何在实践中运作的?如果我们需要检查多个授权数据库或者将不同的授权服务结合起来，类似数据库和LDAP服务器?
Spring Security的默认实现被称为 `ProviderManager` 而非处理身份验证请求本身，它委托给一个列表去配置 `AuthenticationProvider`，其中每个查询反过来，看它是否能进行认证。
每个提供程序都将抛出一个异常或返回一个完全填充的身份验证对象。还记得我们的好朋友，`UserDetails` 和 `UserDetailsService` 吗?如果没有，回到前面的章节刷新你的记忆。
到验证的认证请求的最常见的方法是加载相应 `UserDetails` 并针对已经由用户输入所述一个检查加载密码。这是由 `DaoAuthenticationProvider` 所使用的方法（见下文）。
加载的 `UserDetails` 对象-尤其是 `GrantedAuthority` 的IT包含-建设是返回一个成功验证，并存储在 `SecurityContext` 完全填充 `Authentication` 对象时，将被使用。

如果你使用的命名空间，创建并在内部进行维护 `ProviderManager` 的一个实例，您可以通过使用命名空间身份验证提供元素添加提供商。(<<ns-auth-manager,命名空间章节>>)。在这种情况下，你不应该声明在应用程序上下文中的 `ProviderManager` bean。但是，如果你没有使用命名空间，那么你会这样声明:

[source,xml]
----

<bean id="authenticationManager"
		class="org.springframework.security.authentication.ProviderManager">
	<constructor-arg>
		<list>
			<ref local="daoAuthenticationProvider"/>
			<ref local="anonymousAuthenticationProvider"/>
			<ref local="ldapAuthenticationProvider"/>
		</list>
	</constructor-arg>
</bean>
----
在上面的例子中，我们有三个提供者。它们试图在顺序显示(它是通过使用一个 `List` 的暗示)，每个提供者都能尝试验证，或者通过简单的返回 `null` 跳过认证。如果所有的实现都返回 `null`，则 `ProviderManager` 将抛出一个 `ProviderNotFoundException`。
如果你有兴趣了解更多的有关提供者，请参考 `ProviderManager` 的JavaDocs。

身份验证机，如Web表单登录处理过滤器被注入到 `ProviderManager` 的引用，将调用它来处理自己的身份验证请求。你需要的供应商有时可以与认证机制互换，而在其他时间，他们将依赖于特定的认证机制。
例如，`DaoAuthenticationProvider` 和 `LdapAuthenticationProvider` 给它提交一个简单的用户名/密码验证请求，并因此将与基于表单登录或HTTP基本验证工作的机制兼容。
另一方面，一些认证机制创建只能由单一类型 `AuthenticationProvider` 解释的认证请求对象。这一方面的一个例子是JA-SIG CAS，它使用一个服务票据的概念，因此可以仅通过一个 `CasAuthenticationProvider` 进行认证。
你不必太在意这一点，因为如果你忘记注册一个合适的供应商，你会简单地收到一个 `ProviderNotFoundException` 不进行认证的尝试。

[[core-services-erasing-credentials]]
==== 清除成功认证的凭据
默认情况下(从Spring Security 3.1开始)的 `ProviderManager` 将试图清除它返回一个成功的认证请求的 `Authentication` 对象的任何敏感的身份验证信息。这可以防止密码等个人资料超过保留时间。

当使用用户对象的高速缓存时，例如，改善在无状态情况下应用程序的性能，这可能导致问题。如果 `Authentication` 包含在高速缓存（诸如 `UserDetails` 实例）的对象的引用中，将其凭证移除，则它将不再能够进行对缓存的值进行验证。
你需要考虑到这一点，如果你使用的是高速缓存。一个显而易见的解决方案是让一个对象的副本，无论是在高速缓存中执行或在 `AuthenticationProvider` 它创建返回 `Authentication` 对象。
另外，你可以在 `ProviderManager` 中禁用 `eraseCredentialsAfterAuthentication`。查看Javadoc了解更多信息。

[[core-services-dao-provider]]
==== DaoAuthenticationProvider
Spring Security中实现最简单的 `AuthenticationProvider` 是 `DaoAuthenticationProvider`，也是最早支持的框架。它利用了 `UserDetailsService`（作为DAO）去查找用户名和密码。它的用户进行身份验证通过 `UserDetailsService` 加载 `UsernamePasswordAuthenticationToken` 提交密码进行一对一的比较。配置提供程序是非常简单的:

[source,xml]
----

<bean id="daoAuthenticationProvider"
	class="org.springframework.security.authentication.dao.DaoAuthenticationProvider">
<property name="userDetailsService" ref="inMemoryDaoImpl"/>
<property name="passwordEncoder" ref="passwordEncoder"/>
</bean>
----

这个 `PasswordEncoder` 是可选的。一个 `PasswordEncoder` 提供编码以及 `UserDetails` 对象提出的密码是从配置 `UserDetailsService` 返回的解码。 详细<<core-services-password-encoding,如下>> 。

=== UserDetailsService Implementations
本参考指南早些时候提到的，大多数的认证供应商利用的 `UserDetails` 和 `UserDetailsService`  接口。回想一下，`UserDetailsService` 是一个方法:

[source,java]
----
UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
----

返回的 `UserDetails` 是提供给 `getters` 的一个接口，以保证非空的认证信息，例如，用户名，密码，授权和用户帐户是否被启用或禁用。
大多数认证供应商将使用 `UserDetailsService`，即使用户名和密码不作为认证决定的一部分。他们可以使用返回的 `UserDetails` 对象为其 `GrantedAuthority` 信息对象，因为其他的一些系统（如LDAP或X.509或CAS等）承担了实际验证凭证的的责任。
鉴于 `UserDetailsService` 就是这么简单实现的，它应该便于用户检索使用自己选择的持久化策略的认证信息。话虽如此，Spring Security确实包括了许多有用的基本实现，我们将在下面看到。

[[core-services-in-memory-service]]
==== 在内存认证
简单的使用去创建一个自定义的 `UserDetailsService` 实现选择从一个持久性引擎中提取信息，但许多应用程序不需要这么复杂。
尤其是如果你正在建设一个原型应用或刚刚开始结合Spring Security当你真的不想花时间配置数据库或写作  `UserDetailsService`  实现。对于这种情况，一个简单的选项是使用安全性<<ns-minimal,命名空间>>的 `user-service` 元素:

[source,xml]
----
<user-service id="userDetailsService">
<!-- Password is prefixed with {noop} to indicate to DelegatingPasswordEncoder that
NoOpPasswordEncoder should be used. This is not safe for production, but makes reading
in samples easier. Normally passwords should be hashed using BCrypt -->
<user name="jimi" password="{noop}jimispassword" authorities="ROLE_USER, ROLE_ADMIN" />
<user name="bob" password="{noop}bobspassword" authorities="ROLE_USER" />
</user-service>
----


这也支持一个外部属性文件的使用:

[source,xml]
----
<user-service id="userDetailsService" properties="users.properties"/>
----

属性文件应包含在表单条目

[source,txt]
----
username=password,grantedAuthority[,grantedAuthority][,enabled|disabled]
----

例如

[source,txt]
----
jimi=jimispassword,ROLE_USER,ROLE_ADMIN,enabled
bob=bobspassword,ROLE_USER,enabled
----

[[core-services-jdbc-user-service]]
==== JdbcDaoImpl
Spring Security还包括 `UserDetailsService`，它可以从一个JDBC数据源获得认证信息。
内部Spring JDBC的使用，避免了一个全功能对象关系映射（ORM）的复杂性来存储用户信息。如果你的应用程序不使用ORM工具，你可以写一个自定义 `UserDetailsService` 重用在你可能已经创建好的映射文件上。回到 `JdbcDaoImpl`，实例的配置如下：:

[source,xml]
----
<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
<property name="driverClassName" value="org.hsqldb.jdbcDriver"/>
<property name="url" value="jdbc:hsqldb:hsql://localhost:9001"/>
<property name="username" value="sa"/>
<property name="password" value=""/>
</bean>

<bean id="userDetailsService"
	class="org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl">
<property name="dataSource" ref="dataSource"/>
</bean>
----

您可以通过修改上面的 `DriverManagerDataSource` 使用不同的关系型数据库管理系统。你也可以从JNDI获得，与任何其他的Spring配置使用一个全球性的数据源。

===== Authority Groups
默认情况下，`JdbcDaoImpl` 加载权限直接映射到用户的角色(见 数据库架构附录)。另一种方法是将权限分成组并分配组给用户。有些人喜欢这种方式作为管理用户权限的一种手段。见 `JdbcDaoImpl` Javadoc获得如何能够使用权限组的更多信息。该组架构也包括在<<appendix-schema,附录>>中。

