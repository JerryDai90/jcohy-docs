[[servlet-authentication-form]]
= Form Login

Spring Security提供对通过html表单提供的用户名和密码的支持。 本节详细介绍了基于表单的身份验证在Spring Security中的工作方式。

让我们看看基于表单的登录在Spring Security中如何工作。 首先，我们了解如何将用户重定向到登录表单。
// FIXME: describe authenticationentrypoint, authenticationfailurehandler, authenticationsuccesshandler
.Redirecting to the Log In Page
image::{figures}/loginurlauthenticationentrypoint.png[]

该图基于我们的  <<servlet-securityfilterchain,`SecurityFilterChain`>> 图。

image:{icondir}/number_1.png[] 首先，用户向未经授权的资源 ``/private` 请求未经身份验证的请求。

image:{icondir}/number_2.png[] Spring Security的 <<servlet-authorization-filtersecurityinterceptor,`FilterSecurityInterceptor`>> 通过抛出 `AccessDeniedException` 来指示未经身份验证的请求被拒绝。

image:{icondir}/number_3.png[] 由于未对用户进行身份验证，因此 <<servlet-exceptiontranslationfilter,`ExceptionTranslationFilter`>>  会启动“开始身份验证”，并使用配置的  <<servlet-authentication-authenticationentrypoint,`AuthenticationEntryPoint`>> 将重定向发送到登录页面。 在大多数情况下，  `AuthenticationEntryPoint` 是 {security-api-url}org/springframework/security/web/authentication/LoginUrlAuthenticationEntryPoint.html[`LoginUrlAuthenticationEntryPoint`] 的实例。

image:{icondir}/number_4.png[] 然后，浏览器将请求将其重定向到的登录页面。

image:{icondir}/number_5.png[] 应用程序中的某些内容必须<<servlet-authentication-form-custom,呈现登录页面>>。 .

[[servlet-authentication-usernamepasswordauthenticationfilter]]
提交用户名和密码后，`UsernamePasswordAuthenticationFilter` 会对用户名和密码进行身份验证。 `UsernamePasswordAuthenticationFilter` 扩展了 <<servlet-authentication-abstractprocessingfilter,AbstractAuthenticationProcessingFilter>>，因此此图看起来应该非常相似。

.Authenticating Username and Password
image::{figures}/usernamepasswordauthenticationfilter.png[]

该图基于我们的 <<servlet-securityfilterchain,`SecurityFilterChain`>>  图。

image:{icondir}/number_1.png[] 当用户提交其用户名和密码时，`UsernamePasswordAuthenticationFilter` 通过从 `HttpServletRequest` 中提取用户名和密码来创建 `UsernamePasswordAuthenticationToken`，这是一种 <<servlet-authentication-authentication,`Authentication`>>。

image:{icondir}/number_2.png[] 接下来，将 `UsernamePasswordAuthenticationToken` 传递到 `AuthenticationManager` 进行身份验证。 `AuthenticationManager` 外观的详细信息取决于 <<servlet-authentication-unpwd-storage,用户信息的存储方式>>。

image:{icondir}/number_3.png[] 如果身份验证失败，则失败

* 已清除 <<servlet-authentication-securitycontextholder,SecurityContextHolder>>。
* `RememberMeServices.loginFail` 被调用。 如果记住我未配置，则为空。
// FIXME: link to rememberme
* `AuthenticationFailureHandler` 被调用。
// FIXME: link to AuthenticationFailureHandler

image:{icondir}/number_4.png[] 如果身份验证成功，则为成功。

* 新的登录通知 `SessionAuthenticationStrategy`。
// FIXME: Add link to SessionAuthenticationStrategy
* <<servlet-authentication-authentication,Authentication >> 是在 <<servlet-authentication-securitycontextholder,SecurityContextHolder>> 上设置的。 之后，`SecurityContextPersistenceFilter` 将 `SecurityContext` 保存到 `HttpSession` 中。
// FIXME: link securitycontextpersistencefilter
* `RememberMeServices.loginSuccess` 被调用。 如果记住我未配置，则为空。
// FIXME: link to rememberme
* `ApplicationEventPublisher` 发布一个 `InteractiveAuthenticationSuccessEvent`.
* `AuthenticationSuccessHandler` 被调用。 通常，这是一个 `SimpleUrlAuthenticationSuccessHandler`，当我们重定向到登录页面时，它将重定向到  <<servlet-exceptiontranslationfilter,`ExceptionTranslationFilter`>>  保存的请求。

[[servlet-authentication-form-min]]
默认情况下，Spring Security表单登录处于启用状态。 但是，一旦提供了任何基于servlet的配置，就必须显式提供基于表单的登录。 可以在下面找到最小的显式Java配置：

.Form Log In
====
.Java
[source,java,role="primary"]
----
protected void configure(HttpSecurity http) {
	http
		// ...
		.formLogin(withDefaults());
}
----

.XML
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->
	<form-login />
</http>
----

.Kotlin
[source,kotlin,role="secondary"]
----
fun configure(http: HttpSecurity) {
	http {
		// ...
		formLogin { }
	}
}
----
====

在这种配置中，Spring Security将呈现一个默认的登录页面。 大多数生产应用程序将需要自定义登录表单。

下面的配置演示了如何提供自定义登录表单。

[[servlet-authentication-form-custom]]
The configuration below demonstrates how to provide a custom log in form.

.Custom Log In Form Configuration
====
.Java
[source,java,role="primary"]
----
protected void configure(HttpSecurity http) throws Exception {
	http
		// ...
		.formLogin(form -> form
			.loginPage("/login")
			.permitAll()
		);
}
----

.XML
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->
	<intercept-url pattern="/login" access="permitAll" />
	<form-login login-page="/login" />
</http>
----

.Kotlin
[source,kotlin,role="secondary"]
----
fun configure(http: HttpSecurity) {
	http {
		// ...
		formLogin {
			loginPage = "/login"
			permitAll()
		}
	}
}
----
====

[[servlet-authentication-form-custom-html]]
在Spring Security配置中指定登录页面后，您将负责呈现该页面。 以下是 https://www.thymeleaf.org/[Thymeleaf]  模板，该模板生成符合 `/login` 登录页面的HTML登录表单。

.Log In Form
====
.src/main/resources/templates/login.html
[source,xml]
----
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="https://www.thymeleaf.org">
	<head>
		<title>Please Log In</title>
	</head>
	<body>
		<h1>Please Log In</h1>
		<div th:if="${param.error}">
			Invalid username and password.</div>
		<div th:if="${param.logout}">
			You have been logged out.</div>
		<form th:action="@{/login}" method="post">
			<div>
			<input type="text" name="username" placeholder="Username"/>
			</div>
			<div>
			<input type="password" name="password" placeholder="Password"/>
			</div>
			<input type="submit" value="Log in" />
		</form>
	</body>
</html>
----
====

关于默认HTML表单，有一些关键点：

* 	一个POST请求到 `/login` 用来验证用户
* 该表格将需要包含一个由Thymeleaf  <<servlet-csrf-include-form-auto,自动包含>>的 <<servlet-csrf,CSRF Token>>。
* 该表单 `username` 参数为 username
* 该表单 `password` 参数为 password
* 如果HTTP参数错误，则表明用户未能提供有效的 username/password
* 如果HTTP参数存在 logout 参数，则表明用户已成功注销

除了自定义登录页面外，许多用户将不需要更多。 但是，如果需要，可以使用其他配置自定义以上所有内容。

[[servlet-authentication-form-custom-controller]]
如果您使用的是Spring MVC，则需要一个将  `GET /login`   映射到我们创建的登录模板的控制器。 下面是最小的LoginController示例：

.LoginController
====
.src/main/java/example/LoginController.java
[source,java]
----
@Controller
class LoginController {
	@GetMapping("/login")
	String login() {
		return "login";
	}
}
----
====
